WEBVTT

00:00:02.982 --> 00:00:06.461
[MÚSICA, TOCANDO]

00:01:12.600 --> 00:01:13.590
DAVID MALAN: Tudo bem.

00:01:13.590 --> 00:01:17.130
Este é o CS50, e esta é a semana 2 em que estamos

00:01:17.130 --> 00:01:20.610
vamos dar uma olhada em um nível inferior de como as coisas funcionam,

00:01:20.610 --> 00:01:24.120
e, de fato, entre os objetivos do curso está esse entendimento de baixo para cima

00:01:24.120 --> 00:01:26.670
para que dentro de algumas semanas, até mesmo alguns anos,

00:01:26.670 --> 00:01:29.920
quando você encontrar alguma nova tecnologia, você será capaz de pensar no passado com esperança

00:01:29.920 --> 00:01:33.180
em alguns dos desta semana e isso é blocos de construção básicos e primitivos

00:01:33.180 --> 00:01:36.060
e realmente apenas deduza como as tecnologias de amanhã funcionarão.

00:01:36.060 --> 00:01:37.685
Mas ao longo do caminho, vai parecer...

00:01:37.685 --> 00:01:40.727
vai ser um pouco difícil, talvez, ver a floresta pelas árvores,

00:01:40.727 --> 00:01:41.380
por assim dizer.

00:01:41.380 --> 00:01:44.783
E assim o objetivo no final do dia ainda será a solução de problemas.

00:01:44.783 --> 00:01:47.700
Então pensamos em começar hoje com uma olhada em alguns dos problemas

00:01:47.700 --> 00:01:50.405
falaremos ou resolveremos na próxima semana,

00:01:50.405 --> 00:01:53.280
e para isso contamos com alguns corajosos voluntários que já se apresentaram.

00:01:53.280 --> 00:01:58.320
Se pudéssemos acender alguma iluminação dramática e conhecer os voluntários de hoje.

00:01:58.320 --> 00:02:00.430
À minha esquerda aqui, temos...

00:02:00.430 --> 00:02:00.930
ALEX: Oi.

00:02:00.930 --> 00:02:01.960
Meu nome é Alex.

00:02:01.960 --> 00:02:05.340
Estou no primeiro ano da faculdade e sou de Chapel Hill, Carolina do Norte.

00:02:05.340 --> 00:02:07.080
DAVID MALAN: Bem-vindo ao Alex.

00:02:07.080 --> 00:02:09.180
E à direita de Alex.

00:02:09.180 --> 00:02:10.050
SARAH: Eu sou a Sara.

00:02:10.050 --> 00:02:13.230
Sou de Toronto, Canadá, e também sou aluno do primeiro ano da faculdade.

00:02:13.230 --> 00:02:14.188
DAVID MALAN: Maravilhoso.

00:02:14.188 --> 00:02:15.869
Bem, bem-vindos a Alex e Sarah.

00:02:15.869 --> 00:02:18.577
Então, um dos problemas que você talvez resolva esta semana para o problema

00:02:18.577 --> 00:02:22.442
o conjunto 2 é analisar o nível de leitura de um corpo de texto,

00:02:22.442 --> 00:02:25.650
se alguém lê no nível da primeira série, nível da segunda série, nível da terceira série

00:02:25.650 --> 00:02:28.570
nível, até 12 ou 13 ou além.

00:02:28.570 --> 00:02:32.250
O que você talvez nunca tenha pensado, certamente em termos de código,

00:02:32.250 --> 00:02:35.310
como você analisaria algum texto, algum livro e figura

00:02:35.310 --> 00:02:36.750
em que nível de leitura ele está.

00:02:36.750 --> 00:02:40.330
E, no entanto, certamente nossos professores que cresceram sabiam ou tinham um senso intuitivo disso.

00:02:40.330 --> 00:02:42.450
Então, vamos considerar alguns exemplos de texto.

00:02:42.450 --> 00:02:45.960
Por exemplo, Alex, o que você tem lido ultimamente?

00:02:45.960 --> 00:02:52.502
ALEX: Um peixe, dois peixes, peixe vermelho, peixe azul.

00:02:52.502 --> 00:02:53.460
DAVID MALAN: Maravilhoso.

00:02:53.460 --> 00:02:58.890
Considerando isso, em que série você diria que Alex está lendo atualmente?

00:02:58.890 --> 00:03:01.500
Sinta-se à vontade para apenas gritar.

00:03:01.500 --> 00:03:02.730
Primeiro, primeiro?

00:03:02.730 --> 00:03:07.200
Então, de fato, você verá esta semana, se executar seu código no texto de Alex,

00:03:07.200 --> 00:03:10.410
na verdade, ele lê abaixo do nível de leitura da primeira série.

00:03:10.410 --> 00:03:12.400
Mas por que isso pode acontecer?

00:03:12.400 --> 00:03:16.410
Qual pode ser a sua intuição para o motivo de termos

00:03:16.410 --> 00:03:19.020
acusou Alex de ler neste nível?

00:03:19.020 --> 00:03:20.990
Sinta-se livre para gritar.

00:03:20.990 --> 00:03:21.490
Sim.

00:03:21.490 --> 00:03:24.520
Poucas sílabas, palavras curtas, frases curtas.

00:03:24.520 --> 00:03:27.828
E então há algumas heurísticas, talvez, podemos inferir desse pequeno texto,

00:03:27.828 --> 00:03:30.370
isso provavelmente significa que é melhor para crianças mais novas.

00:03:30.370 --> 00:03:33.370
Agora Sarah, ao contrário, o que você tem lido?

00:03:33.370 --> 00:03:35.470
SARAH: Sr. e Sra. Dursley de Number.

00:03:35.470 --> 00:03:38.890
Four Privet Drive tiveram o orgulho de dizer que foram

00:03:38.890 --> 00:03:41.050
perfeitamente normal, muito obrigado.

00:03:41.050 --> 00:03:43.480
Eles eram as últimas pessoas que você esperaria que estivessem envolvidas

00:03:43.480 --> 00:03:46.390
em qualquer coisa estranha ou misteriosa porque eles simplesmente

00:03:46.390 --> 00:03:47.952
não se prendia com muita bobagem.

00:03:47.952 --> 00:03:48.910
DAVID MALAN: Tudo bem.

00:03:48.910 --> 00:03:50.950
Agora, independentemente da série em que você estava quando

00:03:50.950 --> 00:03:53.283
você deve ter lido esse texto, qual o nível de escolaridade para Sarah

00:03:53.283 --> 00:03:55.230
parecia estar lendo?

00:03:55.230 --> 00:03:57.570
Então oitava série, segunda série.

00:03:57.570 --> 00:03:58.080
OK.

00:03:58.080 --> 00:04:01.125
Então ouvindo um pouco de tudo, então com isso, pelo menos de acordo com o código,

00:04:01.125 --> 00:04:03.240
seria na verdade a sétima série.

00:04:03.240 --> 00:04:05.130
E qual poderia ser a intuição?

00:04:05.130 --> 00:04:07.620
Por que esse é um nível de ensino superior, embora possamos

00:04:07.620 --> 00:04:09.917
discorda exatamente de qual série é?

00:04:09.917 --> 00:04:11.250
AUDIÊNCIA: Frases complicadas.

00:04:11.250 --> 00:04:12.000
DAVID MALAN: Sim.

00:04:12.000 --> 00:04:14.218
Frases tão complicadas, frases mais longas.

00:04:14.218 --> 00:04:17.010
Então, de fato, muito mais palavras foram ditas por Sarah porque havia

00:04:17.010 --> 00:04:18.519
foi muito mais lá na página.

00:04:18.519 --> 00:04:22.079
Vamos traduzir essas ideias na próxima semana no conjunto de problemas 2,

00:04:22.079 --> 00:04:25.170
se você enfrentar este, por meio do código para que possa, finalmente,

00:04:25.170 --> 00:04:26.910
inferir coisas destes quantitativamente.

00:04:26.910 --> 00:04:29.190
Mas para fazer isso, vamos ter que entender o texto.

00:04:29.190 --> 00:04:32.610
Então, vamos primeiro agradecer aos nossos voluntários e depois mergulhar nesse nível inferior.

00:04:32.610 --> 00:04:35.337
[APLAUSOS]

00:04:39.910 --> 00:04:40.600
Desculpe.

00:04:40.600 --> 00:04:41.490
Você pode ficar com eles.

00:04:41.490 --> 00:04:42.222
SARA: Ah, tudo bem.

00:04:42.222 --> 00:04:43.180
DAVID MALAN: Tudo bem.

00:04:43.180 --> 00:04:45.970
Além disso, vamos considerar outro corpo de texto

00:04:45.970 --> 00:04:48.010
talvez que você possa ver esta semana, que

00:04:48.010 --> 00:04:50.210
é um pouco algo assim.

00:04:50.210 --> 00:04:53.860
O que tenho aqui na tela é o que passaremos a chamar hoje de texto cifrado.

00:04:53.860 --> 00:04:56.530
É o resultado da criptografia de alguma informação.

00:04:56.530 --> 00:05:00.190
E criptografia, ou mais geralmente, a arte e a ciência da criptografia

00:05:00.190 --> 00:05:00.908
está ao nosso redor.

00:05:00.908 --> 00:05:03.700
É o que você está usando na web, em seus telefones, com seus bancos.

00:05:03.700 --> 00:05:07.000
E qualquer coisa que tente manter os dados seguros está usando criptografia.

00:05:07.000 --> 00:05:10.390
Mas haverá diferentes níveis de criptografia-- criptografia forte,

00:05:10.390 --> 00:05:11.140
criptografia fraca.

00:05:11.140 --> 00:05:14.590
E o que você vê aqui na tela não é tão forte,

00:05:14.590 --> 00:05:18.190
mas veremos mais tarde como podemos descriptografar isso e realmente revelar

00:05:18.190 --> 00:05:22.030
qual é o texto simples que corresponde a esse texto cifrado.

00:05:22.030 --> 00:05:25.670
Mas, para isso, temos que começar a tirar algumas rodinhas,

00:05:25.670 --> 00:05:26.197
por assim dizer.

00:05:26.197 --> 00:05:28.030
E acredite ou não, mesmo que seu tempo

00:05:28.030 --> 00:05:30.100
veria na semana passada pela primeira vez,

00:05:30.100 --> 00:05:32.230
provavelmente, poderia ter sido um pouco no mato.

00:05:32.230 --> 00:05:36.072
E muito mais complicado aparentemente do que C, acontece que ao longo do caminho,

00:05:36.072 --> 00:05:37.780
temos fornecido e continuaremos

00:05:37.780 --> 00:05:39.760
para fornecer certas rodas de treinamento.

00:05:39.760 --> 00:05:42.190
Por exemplo, a Biblioteca CS50 é uma delas,

00:05:42.190 --> 00:05:46.240
e até mesmo algumas das explicações que damos de tópicos por enquanto

00:05:46.240 --> 00:05:49.120
nestas primeiras semanas será um tanto simplificado - abstraído,

00:05:49.120 --> 00:05:49.730
Se você for.

00:05:49.730 --> 00:05:51.730
Mas o objetivo final é que você entenda

00:05:51.730 --> 00:05:55.060
cada um desses detalhes para que, depois do CS50, você realmente

00:05:55.060 --> 00:05:58.210
pode ficar por conta própria e entender e envolver sua mente

00:05:58.210 --> 00:06:01.040
em torno de quaisquer tecnologias futuras também.

00:06:01.040 --> 00:06:05.318
Vamos considerar primeiro o primeiro programa com o qual começamos na semana passada,

00:06:05.318 --> 00:06:06.110
qual foi este.

00:06:06.110 --> 00:06:09.215
Então, "olá, mundo" em C. No final das contas, foi realmente o printf

00:06:09.215 --> 00:06:11.590
função que estava fazendo a parte interessante do trabalho,

00:06:11.590 --> 00:06:14.890
mas havia muitas coisas técnicas acima e abaixo dele.

00:06:14.890 --> 00:06:19.900
As chaves, os parênteses, palavras como void e include, e então

00:06:19.900 --> 00:06:21.730
claro, os colchetes angulares e muito mais.

00:06:21.730 --> 00:06:25.870
Mas, no final das contas, precisávamos converter esse código-fonte em C

00:06:25.870 --> 00:06:30.190
para código de máquina, os 0's e 1's em binário que o computador entendeu.

00:06:30.190 --> 00:06:32.500
E para fazer isso, é claro, nós corremos...

00:06:32.500 --> 00:06:33.700
nós compilamos o código.

00:06:33.700 --> 00:06:37.400
Executamos o make e, em seguida, conseguimos executar esse código lá.

00:06:37.400 --> 00:06:39.370
Então deixe-me ir aqui para o VS Code

00:06:39.370 --> 00:06:44.510
e recriar rapidamente esse hello.c praticamente transcrevendo o mesmo.

00:06:44.510 --> 00:06:51.970
Então eu poderia incluir aqui stdio.h, int main void.

00:06:51.970 --> 00:06:54.460
E então aqui, eu tinha simplesmente, olá,

00:06:54.460 --> 00:06:57.430
vírgula, mundo com minha barra invertida, aspas finais e muito mais.

00:06:57.430 --> 00:07:01.693
Agora, da última vez, para compilar isso, eu realmente executei make hello, seguido de Enter.

00:07:01.693 --> 00:07:03.860
Espero que você não veja erros e isso é bom.

00:07:03.860 --> 00:07:05.980
E se você fizer ponto, barra, olá, você vê,

00:07:05.980 --> 00:07:07.840
na verdade, os resultados desse programa.

00:07:07.840 --> 00:07:11.470
Mas acontece que make não é realmente um compilador

00:07:11.470 --> 00:07:12.950
como aludi na semana passada.

00:07:12.950 --> 00:07:15.520
É um programa que claramente torna seu programa,

00:07:15.520 --> 00:07:19.030
mas ele próprio apenas automatiza o processo de uso de um compilador real.

00:07:19.030 --> 00:07:21.290
E há muitos compiladores diferentes por aí,

00:07:21.290 --> 00:07:24.190
e aquele que está realmente usando sob o capô

00:07:24.190 --> 00:07:27.640
é uma coisinha chamada Clang for C Language.

00:07:27.640 --> 00:07:30.190
E o Clang é um compilador bastante popular hoje em dia.

00:07:30.190 --> 00:07:33.520
Há outro que existe há anos chamado GCC,

00:07:33.520 --> 00:07:36.330
mas estes são apenas nomes específicos para tipos de compiladores

00:07:36.330 --> 00:07:38.830
que pessoas diferentes, empresas diferentes, grupos diferentes

00:07:38.830 --> 00:07:40.310
realmente criaram.

00:07:40.310 --> 00:07:44.800
Mas se você usar manualmente um compilador na semana 1,

00:07:44.800 --> 00:07:47.170
você tem que entender um pouco mais sobre o que é

00:07:47.170 --> 00:07:50.703
acontecendo porque é ainda mais enigmático do que apenas fazer sozinho.

00:07:50.703 --> 00:07:53.620
Na verdade, deixe-me voltar para a janela do meu terminal aqui, deixe-me prosseguir

00:07:53.620 --> 00:07:58.690
e limpe a tela um pouco e execute realmente o compilador bruto

00:07:58.690 --> 00:07:59.360
comando.

00:07:59.360 --> 00:08:01.450
Então, o que fazer é automatizar para mim, deixe-me,

00:08:01.450 --> 00:08:03.620
na verdade, faça isso manualmente por apenas um momento.

00:08:03.620 --> 00:08:10.450
Então, se eu quiser compilar o hello.c em um programa executável que eu possa executar,

00:08:10.450 --> 00:08:12.220
Eu posso fazer isso.

00:08:12.220 --> 00:08:17.110
clang, espaço, hello.c e, em seguida, Enter.

00:08:17.110 --> 00:08:20.980
E agora não há saída, o que é bom neste caso, sem erros,

00:08:20.980 --> 00:08:22.010
mas observe isso.

00:08:22.010 --> 00:08:25.450
Se eu for em frente e digitar ls, descobri que há

00:08:25.450 --> 00:08:32.140
um arquivo que foi criado repentinamente na minha pasta atual estranhamente chamado a.out.

00:08:32.140 --> 00:08:33.580
Isso significa Saída do Assembler.

00:08:33.580 --> 00:08:35.980
Resumindo, esse é o nome padrão

00:08:35.980 --> 00:08:39.440
de um programa criado quando você executa o Clang sozinho.

00:08:39.440 --> 00:08:41.830
Agora esse é um nome muito ruim para um programa

00:08:41.830 --> 00:08:44.000
porque não descreve o que faz.

00:08:44.000 --> 00:08:49.870
Então seria melhor aqui fazer, bem, em vez de a.out, que, sim,

00:08:49.870 --> 00:08:53.950
ainda imprime hello.world, mas não é realmente um programa com nome claro,

00:08:53.950 --> 00:08:55.420
seria bom nomear este olá.

00:08:55.420 --> 00:08:56.240
Então o que eu poderia fazer?

00:08:56.240 --> 00:08:59.740
Eu poderia fazer como aprendemos na semana passada-- bem, eu poderia renomear a.out para hello

00:08:59.740 --> 00:09:01.820
usando o comando mv do Linux.

00:09:01.820 --> 00:09:04.480
Então, vou me mudar para fora para me tornar olá.

00:09:04.480 --> 00:09:06.370
Mas isso também parece meio tedioso.

00:09:06.370 --> 00:09:07.720
Agora eu tenho três passos.

00:09:07.720 --> 00:09:10.750
Como escrever meu código, compilar meu código e renomeá-lo

00:09:10.750 --> 00:09:12.190
antes que eu possa executá-lo.

00:09:12.190 --> 00:09:13.580
Nós podemos fazer melhor do que isso.

00:09:13.580 --> 00:09:15.580
E assim acontece que certos comandos

00:09:15.580 --> 00:09:18.220
like clang apoie o que vamos começar hoje

00:09:18.220 --> 00:09:20.380
chamando argumentos de linha de comando.

00:09:20.380 --> 00:09:24.010
Um argumento de linha de comando, ao contrário de um argumento para uma função,

00:09:24.010 --> 00:09:27.040
é apenas uma palavra adicional ou frase-chave que você

00:09:27.040 --> 00:09:30.400
digite após um comando no seu prompt no seu terminal

00:09:30.400 --> 00:09:33.440
janela que apenas modifica o comportamento desse comando.

00:09:33.440 --> 00:09:35.600
Ele o configura um pouco mais especificamente.

00:09:35.600 --> 00:09:39.220
Então, o que você está vendo aqui na tela é um comando melhor com o qual

00:09:39.220 --> 00:09:45.220
para executar clang para que agora eu possa especificar a saída deste comando por este o.

00:09:45.220 --> 00:09:46.610
Então, faça o que quero dizer com isso?

00:09:46.610 --> 00:09:48.943
Bem, deixe-me ir em frente e limpar a janela do meu terminal novamente

00:09:48.943 --> 00:09:54.955
e, mais explicitamente, digite clang -o hello hello.c e, em seguida, Enter.

00:09:54.955 --> 00:09:57.580
Novamente, nada parece acontecer, mas isso é bom quando

00:09:57.580 --> 00:10:02.860
você não vê nenhum erro e agora o programa que acabei de criar se chama Hello.

00:10:02.860 --> 00:10:07.280
Portanto, ele atinge exatamente o mesmo efeito que o make, mas o que.

00:10:07.280 --> 00:10:09.820
não tenho nada a ver com make é digitar e lembrar de algo

00:10:09.820 --> 00:10:11.075
desde que este comando.

00:10:11.075 --> 00:10:12.700
E isso também é uma mentira inocente.

00:10:12.700 --> 00:10:16.420
Acontece que pré-configuramos o VS Code na nuvem para você

00:10:16.420 --> 00:10:21.310
para também usar alguns outros recursos do Clang que seriam ainda mais

00:10:21.310 --> 00:10:22.840
tedioso para vocês mesmos escreverem.

00:10:22.840 --> 00:10:28.130
E realmente, é por isso que destilamos isso como, em última análise, apenas execução.

00:10:28.130 --> 00:10:31.900
Deixe-me fazer uma pausa aqui para ver primeiro se há alguma dúvida sobre o que eu

00:10:31.900 --> 00:10:34.540
feito pegando meu primeiro programa em C

00:10:34.540 --> 00:10:37.720
e só agora compilando primeiro com make, mas depois recomeçando

00:10:37.720 --> 00:10:40.780
e agora compilando manualmente com clang com o que

00:10:40.780 --> 00:10:44.500
chamaremos argumentos de linha de comando. -o, espaço, olá,

00:10:44.500 --> 00:10:46.820
e depois o nome do arquivo.

00:10:46.820 --> 00:10:47.320
Sim?

00:10:47.320 --> 00:10:48.780
AUDIÊNCIA: O que é a.out?

00:10:48.780 --> 00:10:49.530
DAVID MALAN: Sim.

00:10:49.530 --> 00:10:51.870
Então a.out é um nome histórico.

00:10:51.870 --> 00:10:55.240
Refere-se à saída do montador-- mais sobre isso em breve.

00:10:55.240 --> 00:10:58.080
E é apenas o nome de arquivo padrão que você obtém automaticamente

00:10:58.080 --> 00:11:01.350
se você apenas executar o compilador em qualquer arquivo para que você

00:11:01.350 --> 00:11:02.970
tem apenas um nome padrão para ele.

00:11:02.970 --> 00:11:05.213
Mas não é um programa muito bem nomeado.

00:11:05.213 --> 00:11:07.380
Em vez de executar o Microsoft Word no seu Mac ou PC,

00:11:07.380 --> 00:11:09.880
seria como clicar duas vezes em a.out.

00:11:09.880 --> 00:11:11.880
Em vez disso, com esses argumentos de linha de comando,

00:11:11.880 --> 00:11:17.370
você pode personalizar a saída do Clang e chamá-lo de olá ou o que quiser.

00:11:17.370 --> 00:11:23.020
Outras dúvidas sobre o que fiz aqui com o próprio Clang, o compilador?

00:11:23.020 --> 00:11:23.520
Sim?

00:11:23.520 --> 00:11:25.510
AUDIÊNCIA: O que é -o?

00:11:25.510 --> 00:11:26.565
DAVID MALAN: Então...

00:11:26.565 --> 00:11:29.440
e você só saberia disso lendo o manual, fazendo uma aula,

00:11:29.440 --> 00:11:30.500
significa saída.

00:11:30.500 --> 00:11:35.890
Então -o significa alterar a saída do Clang para um arquivo chamado hello

00:11:35.890 --> 00:11:38.680
em vez do padrão, que é a.out.

00:11:38.680 --> 00:11:42.400
E isso também é, novamente, um detalhe que você teria que procurar em uma página da web,

00:11:42.400 --> 00:11:44.810
leia o manual, ouça alguém como eu falar sobre isso.

00:11:44.810 --> 00:11:46.893
E, na verdade, há muito mais do que essas opções,

00:11:46.893 --> 00:11:48.890
mas vamos apenas arranhar a superfície aqui.

00:11:48.890 --> 00:11:49.390
Tudo bem.

00:11:49.390 --> 00:11:53.530
Então, se agora sabemos disso, o que mais está realmente acontecendo sob o capô?

00:11:53.530 --> 00:11:57.250
Bem, vamos dar uma olhada não apenas nesta versão do meu código,

00:11:57.250 --> 00:12:01.190
mas minha versão um pouco mais complicada na semana passada,

00:12:01.190 --> 00:12:03.430
que se parecia um pouco com isto, em que

00:12:03.430 --> 00:12:07.330
Eu adicionei alguma entrada dinâmica do usuário para que eu pudesse dizer não olá, mundo

00:12:07.330 --> 00:12:11.810
para todos, mas olá, David ou olá para quem realmente executa este programa.

00:12:11.810 --> 00:12:15.880
Então, na verdade, deixe-me ir em frente e mudar meu código aqui no VS Code apenas

00:12:15.880 --> 00:12:17.770
para corresponder ao mesmo código da semana passada.

00:12:17.770 --> 00:12:19.190
Portanto, nenhum novo código ainda.

00:12:19.190 --> 00:12:22.820
Vou apenas, em um momento, compilá-lo de uma maneira um pouco diferente.

00:12:22.820 --> 00:12:29.020
Então eu fiz a string da semana passada, eu acho, resposta igual a string, entre aspas,

00:12:29.020 --> 00:12:30.100
"Qual o seu nome?"

00:12:30.100 --> 00:12:31.540
Assim como no Scratch.

00:12:31.540 --> 00:12:35.920
E então aqui embaixo, em vez de fazer mundo, inicialmente escrevi resposta,

00:12:35.920 --> 00:12:37.450
mas isso não foi bem.

00:12:37.450 --> 00:12:41.530
O que eu fiz em vez de imprimir olá, David ou olá,

00:12:41.530 --> 00:12:42.940
fulano de tal?

00:12:42.940 --> 00:12:44.722
Sim?

00:12:44.722 --> 00:12:45.680
Desculpe, um pouco mais alto?

00:12:45.680 --> 00:12:46.430
AUDIÊNCIA: %s?

00:12:46.430 --> 00:12:50.478
DAVID MALAN: Sim, então %s, o chamado código de formato que printf sabe como

00:12:50.478 --> 00:12:51.020
lidar com.

00:12:51.020 --> 00:12:52.470
E eu tive que acrescentar uma outra coisa.

00:12:52.470 --> 00:12:54.350
Alguém além de %s--

00:12:54.350 --> 00:12:54.850
sim?

00:12:54.850 --> 00:12:56.050
AUDIÊNCIA: O nome da variável.

00:12:56.050 --> 00:12:58.870
DAVID MALAN: O nome da variável que eu quero conectar nesse

00:12:58.870 --> 00:13:00.190
espaço reservado %s.

00:13:00.190 --> 00:13:01.630
E neste caso, é resposta.

00:13:01.630 --> 00:13:04.363
Agora deixe-me fazer um refinamento apenas porque agora estamos na semana 2

00:13:04.363 --> 00:13:06.530
e vamos começar a escrever mais linhas de código,

00:13:06.530 --> 00:13:10.360
mesmo que o Scratch tenha chamado o valor de retorno da peça do quebra-cabeça ask,

00:13:10.360 --> 00:13:11.560
responda sempre.

00:13:11.560 --> 00:13:14.480
E veja, temos controle total sobre como nossas variáveis ​​são chamadas.

00:13:14.480 --> 00:13:17.410
E agora provavelmente é bom não chamar sempre genericamente

00:13:17.410 --> 00:13:19.870
minha resposta variável se eu estiver usando get_string.

00:13:19.870 --> 00:13:21.050
Vamos chamá-lo do que é.

00:13:21.050 --> 00:13:23.680
Portanto, agora é apenas uma questão de estilo, se você quiser.

00:13:23.680 --> 00:13:26.620
Deixe-me mudar a variável para ser nome só assim

00:13:26.620 --> 00:13:29.980
que é um pouco mais claro para mim, para você, para um TF ou TA

00:13:29.980 --> 00:13:34.000
exatamente o que essa variável representa em vez de responder de forma mais genérica.

00:13:34.000 --> 00:13:37.030
Tudo bem, dito isso, deixe-me ir até a janela do meu terminal,

00:13:37.030 --> 00:13:41.050
e na semana passada novamente, executei make para compilar exatamente o mesmo programa.

00:13:41.050 --> 00:13:43.270
Agora, porém, deixe-me ir em frente e apenas usar o clang.

00:13:43.270 --> 00:13:45.490
Então clang -o--

00:13:45.490 --> 00:13:47.500
Eu ainda chamarei esta versão de olá--

00:13:47.500 --> 00:13:49.330
espaço, olá.c.

00:13:49.330 --> 00:13:51.080
Portanto, exatamente o mesmo comando de antes.

00:13:51.080 --> 00:13:54.640
A única diferença é que adicionei mais algumas linhas de código

00:13:54.640 --> 00:13:56.330
para obter a entrada do usuário.

00:13:56.330 --> 00:13:59.960
Deixe-me apertar Enter, e agora, caramba, nosso primeiro erro.

00:13:59.960 --> 00:14:02.750
Portanto, a saída de clang e make não é uma coisa boa,

00:14:02.750 --> 00:14:05.420
e aqui, estamos vendo algo particularmente enigmático.

00:14:05.420 --> 00:14:09.010
Então, algo na função 'main--' referência indefinida

00:14:09.010 --> 00:14:13.480
para 'get_string', string e, em seguida, o comando do vinculador falhou com o código de saída 1.

00:14:13.480 --> 00:14:16.540
Então, na verdade, há muito jargão aqui que vai separar hoje,

00:14:16.540 --> 00:14:20.338
mas minha dica é que claramente meu problema está no main, embora isso não seja surpreendente

00:14:20.338 --> 00:14:22.130
porque não há mais nada acontecendo aqui.

00:14:22.130 --> 00:14:26.830
get_string é um problema, e o problema é que é uma referência indefinida.

00:14:26.830 --> 00:14:28.990
E, no entanto, observe, eu era muito bom.

00:14:28.990 --> 00:14:32.920
Adicionei o arquivo de cabeçalho CS50 e disse na semana passada que é

00:14:32.920 --> 00:14:35.920
o suficiente para ensinar ao compilador que existem funções,

00:14:35.920 --> 00:14:39.070
mas o problema é que mesmo que isso, de fato,

00:14:39.070 --> 00:14:43.090
ensine ao Clang que get_string existe, não é

00:14:43.090 --> 00:14:47.530
informações suficientes para o Clang procurar no disco rígido do computador

00:14:47.530 --> 00:14:51.860
os 0's e 1's que realmente implementam o próprio get_string.

00:14:51.860 --> 00:14:54.250
Então, em outras palavras, isso inclui linha, por semana passada,

00:14:54.250 --> 00:14:55.333
é um pouco de uma dica.

00:14:55.333 --> 00:14:59.560
É um teaser do Clang que você está prestes a ver e usar esta função em algum lugar.

00:14:59.560 --> 00:15:05.710
Mas se você realmente quiser usar os 0's e 1's que o CS50 escreveu há algum tempo

00:15:05.710 --> 00:15:08.740
e coloque-os em seu programa para que ele realmente

00:15:08.740 --> 00:15:11.470
sabe como obter entrada do usuário, bem, então,

00:15:11.470 --> 00:15:15.440
Vou ter que ir em frente e executar um comando ligeiramente diferente.

00:15:15.440 --> 00:15:16.250
Então deixe-me fazer isso.

00:15:16.250 --> 00:15:18.917
Deixe-me limpar a janela do meu terminal, apenas me livre dessa distração

00:15:18.917 --> 00:15:23.020
e deixe-me propor agora que executemos este comando.

00:15:23.020 --> 00:15:28.510
Quase como antes, clang -o, space, hello, then hello.c,

00:15:28.510 --> 00:15:34.210
mas com um argumento de linha de comando adicional no final, e este é um -l--

00:15:34.210 --> 00:15:35.050
não é o número 1.

00:15:35.050 --> 00:15:39.370
Então -lcs sem espaço entre os dois.

00:15:39.370 --> 00:15:43.540
Agora o l vai resultar em todos aqueles 0s e 1s que na verdade

00:15:43.540 --> 00:15:48.350
estavam no CS50 sendo vinculados ao seu código, às suas poucas linhas de código ou às minhas

00:15:48.350 --> 00:15:48.850
aqui.

00:15:48.850 --> 00:15:53.530
Mas esse é o segundo passo que o compilador requer para saber como

00:15:53.530 --> 00:15:58.537
para realmente executar e compilar seu código e CS50.

00:15:58.537 --> 00:16:00.370
E o CS50 não é o único que faz isso.

00:16:00.370 --> 00:16:04.750
Se você usar qualquer biblioteca de terceiros em C que não vem com o idioma,

00:16:04.750 --> 00:16:08.333
você faria -l tal e tal onde quem quer que seja -

00:16:08.333 --> 00:16:10.000
no entanto, eles nomearam sua própria biblioteca.

00:16:10.000 --> 00:16:14.298
Mas você não precisa fazer isso para coisas embutidas como temos usado até agora.

00:16:14.298 --> 00:16:16.090
Tudo bem, então deixe-me ir em frente e tentar isso.

00:16:16.090 --> 00:16:19.000
Voltarei ao VS Code aqui e deixe-me prosseguir agora

00:16:19.000 --> 00:16:23.620
e execute clang -o hello, depois hello.c.

00:16:23.620 --> 00:16:26.560
E agora, em vez de apenas pressionar Enter, -lcs50

00:16:26.560 --> 00:16:29.590
sem espaço entre l e cs50, Enter.

00:16:29.590 --> 00:16:33.310
Agora nada de ruim acontece e agora posso fazer ./hello.

00:16:33.310 --> 00:16:34.180
Qual o seu nome?

00:16:34.180 --> 00:16:37.633
Vou digitar David, Enter, e agora vemos olá, David.

00:16:37.633 --> 00:16:40.300
Agora, honestamente, é aqui que estamos realmente entrando nas ervas daninhas,

00:16:40.300 --> 00:16:42.130
e agora isso está levando--

00:16:42.130 --> 00:16:45.730
isso é realmente apenas adicionando incômodo ao processo de compilação e execução

00:16:45.730 --> 00:16:46.460
seu código.

00:16:46.460 --> 00:16:49.960
E então a realidade é, mesmo que isso seja realmente o que está acontecendo,

00:16:49.960 --> 00:16:51.880
é por isso que usamos na semana passada e vamos

00:16:51.880 --> 00:16:55.240
para continuar usando esta semana em diante make porque apenas

00:16:55.240 --> 00:16:57.130
automatiza todo esse processo para você.

00:16:57.130 --> 00:17:00.130
Mas o ideal é entender o que está dando errado porque qualquer um dos erros

00:17:00.130 --> 00:17:02.770
mensagens que você viu para o conjunto de problemas 1, qualquer uma das mensagens de erro

00:17:02.770 --> 00:17:05.859
você vê nas próximas semanas provavelmente não estão vindo de make,

00:17:05.859 --> 00:17:08.560
eles estão vindo de Clang debaixo do capô

00:17:08.560 --> 00:17:10.780
porque make é apenas automatizar o processo.

00:17:10.780 --> 00:17:14.060
Mas com make, você literalmente apenas escreve make e então o nome do programa,

00:17:14.060 --> 00:17:17.560
você não precisa se preocupar com nenhum desses argumentos de linha de comando.

00:17:17.560 --> 00:17:22.240
Perguntas, então, sobre como compilar com traço -lcs50 ou qualquer outra coisa?

00:17:22.240 --> 00:17:23.043
Sim?

00:17:23.043 --> 00:17:24.960
AUDIÊNCIA: Qual é o benefício de [INAUDÍVEL]??

00:17:24.960 --> 00:17:26.220
DAVID MALAN: Desculpe, qual é o benefício de--

00:17:26.220 --> 00:17:27.512
AUDIÊNCIA: Usando o Clang manualmente.

00:17:27.512 --> 00:17:30.000
DAVID MALAN: Qual é a vantagem de usar o Clang manualmente?

00:17:30.000 --> 00:17:30.870
Nenhum, realmente.

00:17:30.870 --> 00:17:33.450
Na verdade, tudo o que main está fazendo é apenas dizer-- make está fazendo

00:17:33.450 --> 00:17:35.055
está nos poupando algumas teclas.

00:17:35.055 --> 00:17:37.680
Se você preferir, porém, e apenas gosta de estar mais no controle,

00:17:37.680 --> 00:17:41.130
você pode executar totalmente o Clang manualmente se você se lembrar das várias linhas de comando

00:17:41.130 --> 00:17:42.090
argumentos.

00:17:42.090 --> 00:17:42.660
Sim?

00:17:42.660 --> 00:17:47.335
AUDIÊNCIA: Então por que você teve que explicar [INAUDÍVEL]

00:17:47.335 --> 00:17:48.210
DAVID MALAN: Exatamente.

00:17:48.210 --> 00:17:49.560
Por que eu tive que explicar--

00:17:49.560 --> 00:17:53.220
ou seja, forneça uma dica para o CS50 com o arquivo de cabeçalho cs50.h,

00:17:53.220 --> 00:17:55.470
mas não precisei fazer isso com standardio.h?

00:17:55.470 --> 00:17:56.400
Só porque.

00:17:56.400 --> 00:18:00.990
standardio.h vem com C, assim como algumas outras bibliotecas vêm

00:18:00.990 --> 00:18:03.060
com C que começaremos a ver hoje.

00:18:03.060 --> 00:18:05.410
O CS50, no entanto, não está embutido em C em todos os lugares,

00:18:05.410 --> 00:18:07.890
e então você tem que adicionar explicitamente aquele ali.

00:18:07.890 --> 00:18:08.767
Sim?

00:18:08.767 --> 00:18:11.970
AUDIÊNCIA: Você pode definir qual argumento de linha de comando [INAUDÍVEL]??

00:18:11.970 --> 00:18:15.210
DAVID MALAN: Um argumento de linha de comando é uma palavra ou frase

00:18:15.210 --> 00:18:17.740
que você digita na linha de comando--

00:18:17.740 --> 00:18:22.200
também conhecido como seu terminal-- para influenciar o comportamento de um programa.

00:18:22.200 --> 00:18:22.742
AUDIÊNCIA: OK.

00:18:22.742 --> 00:18:24.430
Portanto, é um termo para o que você está dando.

00:18:24.430 --> 00:18:24.565
DAVID MALAN: Sim.

00:18:24.565 --> 00:18:25.660
Ele altera os padrões.

00:18:25.660 --> 00:18:27.790
Em nosso mundo GUI, Interface Gráfica do Usuário,

00:18:27.790 --> 00:18:29.680
você e eu provavelmente clicaríamos em algumas caixas,

00:18:29.680 --> 00:18:32.350
selecionaríamos algumas opções de menu para configurar um programa

00:18:32.350 --> 00:18:33.460
comportar-se da mesma maneira.

00:18:33.460 --> 00:18:36.850
Em uma interface de linha de comando, você só precisa dizer tudo de uma vez,

00:18:36.850 --> 00:18:39.600
e é por isso que temos argumentos de linha de comando.

00:18:39.600 --> 00:18:40.605
Sim?

00:18:40.605 --> 00:18:43.243
AUDIÊNCIA: É fazer [INAUDÍVEL]

00:18:43.243 --> 00:18:43.910
DAVID MALAN: Não.

00:18:43.910 --> 00:18:45.470
Make não é só para CS50.

00:18:45.470 --> 00:18:50.480
É usado globalmente em qualquer projeto hoje em dia usando C, C++,

00:18:50.480 --> 00:18:52.020
mesmo outras línguas também.

00:18:52.020 --> 00:18:54.140
Na verdade, quase todos os comandos que você vê nesta classe,

00:18:54.140 --> 00:18:57.530
a menos que tenha 5-0 no final, é usado globalmente.

00:18:57.530 --> 00:19:00.758
Apenas aqueles - um sufixo com 50 são, de fato, específicos do curso.

00:19:00.758 --> 00:19:03.050
E mesmo aqueles vamos gradualmente tirar as rodinhas

00:19:03.050 --> 00:19:06.890
de modo que exatamente o que esses comandos estão fazendo também.

00:19:06.890 --> 00:19:09.053
Tudo bem, então o que foi que acabamos de fazer?

00:19:09.053 --> 00:19:11.720
Tudo o que acabamos de fazer, é claro, continuo chamando de compilação,

00:19:11.720 --> 00:19:13.580
mas vamos descer por uma toca de coelho então

00:19:13.580 --> 00:19:15.967
que você entenda que quando você compila o código,

00:19:15.967 --> 00:19:18.050
na verdade, há um monte de etapas, acontecendo

00:19:18.050 --> 00:19:21.800
e isso vai permitir muitos recursos, como as empresas podem

00:19:21.800 --> 00:19:26.060
escrever código e, em seguida, convertê-lo para executá-lo em Macs e PCs

00:19:26.060 --> 00:19:27.240
ou telefones ou similares.

00:19:27.240 --> 00:19:30.320
Portanto, não é apenas uma questão de converter o código-fonte em código de máquina,

00:19:30.320 --> 00:19:34.610
na verdade, há quatro etapas envolvidas no que você e eu, desde a semana passada,

00:19:34.610 --> 00:19:35.840
conhecido como compilação.

00:19:35.840 --> 00:19:39.033
E esses não são termos que você deve ter em mente constantemente

00:19:39.033 --> 00:19:41.450
porque, novamente, vamos abstrair muito disso.

00:19:41.450 --> 00:19:43.492
Mas só para descermos pela toca do coelho uma vez,

00:19:43.492 --> 00:19:45.890
vamos considerar cada uma dessas quatro etapas que

00:19:45.890 --> 00:19:49.850
estão acontecendo para você há uma semana automaticamente, a primeira das quais

00:19:49.850 --> 00:19:51.080
é chamado de pré-processamento.

00:19:51.080 --> 00:19:52.260
Então o que isso quer dizer?

00:19:52.260 --> 00:19:54.450
Bem, vamos considerar o mesmo programa de antes.

00:19:54.450 --> 00:19:57.830
Portanto, observe que duas das linhas de código começam com uma marca de hash.

00:19:57.830 --> 00:20:02.338
Esse é um símbolo especial em C e é a chamada diretiva de pré-processador.

00:20:02.338 --> 00:20:04.130
Você não precisa memorizar termos como esse,

00:20:04.130 --> 00:20:07.005
mas significa apenas que é um pouco diferente de todas as outras linhas.

00:20:07.005 --> 00:20:08.960
E qualquer coisa com um símbolo de hash aqui deve

00:20:08.960 --> 00:20:13.315
ser pré-processado - isto é, analisado inicialmente antes que qualquer outra coisa aconteça.

00:20:13.315 --> 00:20:17.100
Vamos considerar essas duas linhas acima, o que exatamente está acontecendo.

00:20:17.100 --> 00:20:19.220
Bem, acontece que com essas duas linhas, você

00:20:19.220 --> 00:20:23.390
tem dois arquivos de cabeçalho, é claro, cs50.he stdio.h.

00:20:23.390 --> 00:20:27.980
Onde estão esses arquivos, porque eles nunca estiveram no VS Code para você,

00:20:27.980 --> 00:20:28.550
aparentemente.

00:20:28.550 --> 00:20:31.940
Se você digitar LS-- se abrir o File Explorer na GUI,

00:20:31.940 --> 00:20:35.900
você nunca viu, provavelmente, cs50.h ou stdio.h.

00:20:35.900 --> 00:20:39.620
Eles simplesmente funcionam, mas é porque há uma pasta em algum lugar

00:20:39.620 --> 00:20:43.340
no disco rígido que você está usando no seu Mac ou PC

00:20:43.340 --> 00:20:45.690
ou em algum lugar na nuvem, como no nosso caso.

00:20:45.690 --> 00:20:50.210
E dentro desta pasta, tradicionalmente chamada de /usr/include.

00:20:50.210 --> 00:20:51.857
E o usuário está deliberadamente com erros ortográficos.

00:20:51.857 --> 00:20:54.440
É apenas um pouco mais sucinto, embora seja um pouco estranho

00:20:54.440 --> 00:20:55.760
por que descartamos aquela letra.

00:20:55.760 --> 00:21:01.760
Mas usr/include é apenas uma pasta no servidor que contém cs50.h, stdio.h,

00:21:01.760 --> 00:21:03.990
e um monte de outras coisas também.

00:21:03.990 --> 00:21:08.030
Na verdade, se você digitar VS Code, na janela do seu terminal,

00:21:08.030 --> 00:21:13.310
quando estiver usando espaços de código na nuvem e digite LS space /usr/include,

00:21:13.310 --> 00:21:15.470
você pode ver todos os arquivos nessa pasta.

00:21:15.470 --> 00:21:17.580
Mas pré-instalamos tudo isso para você.

00:21:17.580 --> 00:21:20.390
Então, vamos considerar o que realmente está nesses arquivos aqui.

00:21:20.390 --> 00:21:25.370
Se eu destacar essas duas linhas no topo que começam com hash incluem, bem,

00:21:25.370 --> 00:21:30.530
Eu meio que insinuei na semana passada que o que está naquele primeiro arquivo é uma dica sobre o que

00:21:30.530 --> 00:21:32.660
funções CS50 escreveu para você.

00:21:32.660 --> 00:21:35.540
Então você pode pensar nessas linhas de inclusão

00:21:35.540 --> 00:21:38.300
como espaços reservados temporários para o que é

00:21:38.300 --> 00:21:41.000
vai se tornar como um achado global e substituir.

00:21:41.000 --> 00:21:44.270
Essa é a primeira coisa que o clang vai fazer é pré-processar este arquivo.

00:21:44.270 --> 00:21:47.300
Ele vai procurar por qualquer linha que comece com hash include.

00:21:47.300 --> 00:21:50.960
E se ele vir isso, vai essencialmente para esse arquivo,

00:21:50.960 --> 00:21:55.190
como cs50.h, e depois é só copiar e colar o conteúdo desse arquivo

00:21:55.190 --> 00:21:56.443
magicamente lá para você.

00:21:56.443 --> 00:21:58.110
Você não o vê visualmente na tela.

00:21:58.110 --> 00:22:00.060
Mas está acontecendo nos bastidores.

00:22:00.060 --> 00:22:03.230
E realmente, o que está acontecendo com esta primeira linha

00:22:03.230 --> 00:22:09.380
é que em algum lugar em cs50.h está a declaração de getString

00:22:09.380 --> 00:22:11.690
como conversamos na semana passada, e provavelmente

00:22:11.690 --> 00:22:13.215
parece um pouco com isto.

00:22:13.215 --> 00:22:15.590
E não gastamos muito tempo com isso ainda na semana passada,

00:22:15.590 --> 00:22:17.030
mas vamos com o tempo mais.

00:22:17.030 --> 00:22:21.470
Observe que é assim que uma função é declarada.

00:22:21.470 --> 00:22:23.677
Ou seja, é decretado existir.

00:22:23.677 --> 00:22:25.760
O nome da função, é claro, é getString.

00:22:25.760 --> 00:22:28.310
Dentro dos parênteses estão seus argumentos.

00:22:28.310 --> 00:22:31.580
Neste caso, há um argumento para getString, eu afirmo hoje,

00:22:31.580 --> 00:22:33.080
mas você sabe disso implicitamente.

00:22:33.080 --> 00:22:34.160
E é uma indicação.

00:22:34.160 --> 00:22:36.860
É o prompt que o humano vê quando você usa getString.

00:22:36.860 --> 00:22:37.790
O que é isso?

00:22:37.790 --> 00:22:41.060
Bem, é uma sequência de texto, como entre aspas, "qual é o seu nome?"

00:22:41.060 --> 00:22:43.080
ou qualquer outra coisa que eu perguntei na semana passada.

00:22:43.080 --> 00:22:46.610
Enquanto isso, getString, como sabemos na semana passada, tem um valor de retorno.

00:22:46.610 --> 00:22:48.140
Ele retorna algo para você.

00:22:48.140 --> 00:22:49.610
E isso também é uma corda.

00:22:49.610 --> 00:22:52.120
Então, novamente, isso também é chamado de protótipo de funções.

00:22:52.120 --> 00:22:53.870
É a coisa no final da semana passada

00:22:53.870 --> 00:22:57.560
que acabei de copiar e colar da parte inferior do meu arquivo para o topo,

00:22:57.560 --> 00:23:02.030
apenas para que fosse como este teaser para clang sobre o que existiria mais tarde.

00:23:02.030 --> 00:23:07.670
Então você pode pensar nessas linhas de inclusão como uma espécie de combinação de todos

00:23:07.670 --> 00:23:11.360
dessas declarações de função em algum arquivo separado chamado cs50.h,

00:23:11.360 --> 00:23:14.780
para que você mesmo não precise digitá-los toda vez que usar a biblioteca--

00:23:14.780 --> 00:23:18.470
ou pior, para que você mesmo não precise copiar e colar essas linhas.

00:23:18.470 --> 00:23:22.520
Isso é o que o clang está fazendo por você em sua primeira etapa de pré-processamento.

00:23:22.520 --> 00:23:27.470
Segundo, e último neste exemplo, o que acontece quando o clang pré-processa

00:23:27.470 --> 00:23:29.175
esta segunda linha de inclusão?

00:23:29.175 --> 00:23:31.550
Bem, a única outra função que nos interessa nesta história

00:23:31.550 --> 00:23:33.650
é printf, é claro, que vem com C.

00:23:33.650 --> 00:23:39.440
Então, basicamente, você pode pensar no protótipo ou declaração de printf

00:23:39.440 --> 00:23:40.820
como apenas sendo isso.

00:23:40.820 --> 00:23:42.870
Printf é o nome da função.

00:23:42.870 --> 00:23:47.370
É preciso uma string que você deseja formatar como, Olá, mundo da vírgula,

00:23:47.370 --> 00:23:49.110
ou Olá vírgula %s.

00:23:49.110 --> 00:23:52.120
E então com ponto, ponto, ponto, isso realmente tem um significado técnico.

00:23:52.120 --> 00:23:55.770
Isso significa, é claro, que você pode inserir 0 variáveis, 1 variável, 2

00:23:55.770 --> 00:23:56.340
ou 10.

00:23:56.340 --> 00:23:58.530
Então ponto, ponto, ponto significa algum número de variáveis.

00:23:58.530 --> 00:24:00.072
Agora ainda não falamos sobre isso.

00:24:00.072 --> 00:24:01.410
E não vamos realmente, em geral.

00:24:01.410 --> 00:24:05.490
printf realmente retorna um valor, um número, que é um inteiro.

00:24:05.490 --> 00:24:07.420
Mas mais sobre isso talvez outra hora.

00:24:07.420 --> 00:24:10.920
Geralmente não é algo que o programador tende a olhar.

00:24:10.920 --> 00:24:14.250
Mas isso é tudo o que queremos dizer com pré-processamento, de modo que, ao final desse processo,

00:24:14.250 --> 00:24:18.030
mesmo que haja mais linhas de código em cs50.h e stdio.h,

00:24:18.030 --> 00:24:21.330
o que realmente está acontecendo é aquele estrondo, no pré-processamento

00:24:21.330 --> 00:24:25.380
o arquivo, copia e cola o conteúdo desses arquivos em seu código

00:24:25.380 --> 00:24:29.160
para que agora seu código saiba tudo-- getString, printf,

00:24:29.160 --> 00:24:31.060
e qualquer outra coisa.

00:24:31.060 --> 00:24:35.230
Alguma dúvida, então, nessa primeira etapa, o pré-processamento?

00:24:35.230 --> 00:24:35.920
Sim?

00:24:35.920 --> 00:24:49.195
AUDIÊNCIA: [INAUDÍVEL]

00:24:49.195 --> 00:24:50.320
DAVID MALAN: Boa pergunta.

00:24:50.320 --> 00:24:52.720
Quando você inclui um arquivo, ele inclui apenas o que

00:24:52.720 --> 00:24:54.880
você precisa ou inclui tudo?

00:24:54.880 --> 00:24:56.420
Pense nisso como incluindo tudo.

00:24:56.420 --> 00:24:59.020
Portanto, se for um arquivo grande, haverá muito código no início.

00:24:59.020 --> 00:25:01.880
E é por isso que, se você pensar em todos os zeros e uns

00:25:01.880 --> 00:25:03.880
Mostrei há pouco, assim como na semana passada,

00:25:03.880 --> 00:25:06.130
há muitos zeros e uns que acabam

00:25:06.130 --> 00:25:08.892
na tela como resultado de apenas escrever Olá, mundo.

00:25:08.892 --> 00:25:10.600
Muitos desses zeros e uns são talvez

00:25:10.600 --> 00:25:13.390
vindo de um código que você não precisa necessariamente.

00:25:13.390 --> 00:25:15.340
Mas parte disso talvez esteja lá, mas há

00:25:15.340 --> 00:25:17.740
são maneiras de otimizar isso também.

00:25:17.740 --> 00:25:22.395
Tudo bem, então a etapa dois da compilação é, confusamente, chamada de compilação.

00:25:22.395 --> 00:25:24.520
É só que esse é o termo que quase todo mundo usa

00:25:24.520 --> 00:25:27.940
para descrever todo o processo, em vez de apenas esta etapa.

00:25:27.940 --> 00:25:32.140
Mas uma vez que um programa foi pré-processado nos bastidores

00:25:32.140 --> 00:25:35.865
pelo compilador para você, agora parece algo assim.

00:25:35.865 --> 00:25:38.740
E eu coloquei ponto, ponto, ponto apenas para sugerir que, sim, para sua pergunta,

00:25:38.740 --> 00:25:39.820
há mais coisas acima dele.

00:25:39.820 --> 00:25:40.987
Há mais coisas abaixo dele.

00:25:40.987 --> 00:25:43.070
Não é interessante agora para nós.

00:25:43.070 --> 00:25:44.860
Então agora temos apenas código C.

00:25:44.860 --> 00:25:46.960
Não há mais diretivas de pré-processador.

00:25:46.960 --> 00:25:49.840
Neste ponto, todos os símbolos hash e essas linhas de código

00:25:49.840 --> 00:25:52.670
foram pré-processados ​​e convertidos em outra coisa.

00:25:52.670 --> 00:25:56.380
E agora - e é aqui que as coisas ficam um pouco assustadoras.

00:25:56.380 --> 00:26:00.370
Aqui agora está o que acontece quando clang, ou qualquer compilador,

00:26:00.370 --> 00:26:03.310
literalmente compila código como este.

00:26:03.310 --> 00:26:08.720
Ele o converte disso em C para isso em código assembly.

00:26:08.720 --> 00:26:10.720
Portanto, esta é uma das línguas mais assustadoras.

00:26:10.720 --> 00:26:12.580
Eu, pessoalmente, realmente não tenho boas lembranças.

00:26:12.580 --> 00:26:14.805
Esta não é uma linguagem na qual muitas pessoas programam.

00:26:14.805 --> 00:26:16.930
Se você fizer uma aula subsequente em ciência da computação,

00:26:16.930 --> 00:26:19.600
em sistemas, uma classe de nível superior, você pode realmente

00:26:19.600 --> 00:26:21.430
aprender isso ou alguma variante dele.

00:26:21.430 --> 00:26:23.232
Mas há pelo menos algumas pessoas lá fora

00:26:23.232 --> 00:26:24.940
que precisam saber essas coisas porque isso

00:26:24.940 --> 00:26:29.320
está mais próximo do que os próprios computadores, hoje em dia, entendem.

00:26:29.320 --> 00:26:34.600
As CPUs Intel ou as CPUs AMD, os cérebros dos computadores e telefones de hoje

00:26:34.600 --> 00:26:37.960
entender coisas que se parecem mais com isso e menos com C.

00:26:37.960 --> 00:26:42.430
Agora é completamente esotérico, mas deixe-me apenas destacar algumas frases.

00:26:42.430 --> 00:26:44.630
Há algumas coisas que são um pouco familiares.

00:26:44.630 --> 00:26:47.620
Há menção de principal no topo lá em amarelo.

00:26:47.620 --> 00:26:49.750
Há menção de getString na parte inferior.

00:26:49.750 --> 00:26:52.070
Há menção de printf abaixo.

00:26:52.070 --> 00:26:55.600
Portanto, esta é apenas outra linguagem de programação chamada linguagem assembly,

00:26:55.600 --> 00:26:57.010
que décadas atrás, os humanos -

00:26:57.010 --> 00:26:58.450
eu mesmo incluído na escola--

00:26:58.450 --> 00:27:00.130
escreveu o código.

00:27:00.130 --> 00:27:02.630
E com certeza, algumas pessoas ainda escrevem esse código,

00:27:02.630 --> 00:27:06.070
especialmente porque você pode escrever um código muito, muito eficiente.

00:27:06.070 --> 00:27:08.590
Mas é muito mais misterioso.

00:27:08.590 --> 00:27:11.380
É muito menos amigável.

00:27:11.380 --> 00:27:14.650
Então você verá em amarelo agora, essas são as chamadas instruções

00:27:14.650 --> 00:27:18.460
que o cérebro de um computador ou CPU entende, empurrando valores

00:27:18.460 --> 00:27:23.630
ao redor, movendo-os, subtraindo valores, chamando funções e mover, mover,

00:27:23.630 --> 00:27:24.130
mover.

00:27:24.130 --> 00:27:27.400
Realmente, as operações de baixo nível que os computadores entendem

00:27:27.400 --> 00:27:31.030
tendem a ser operações aritméticas - subtração, adição,

00:27:31.030 --> 00:27:34.120
e coisas do gênero-- movendo coisas dentro e fora da memória.

00:27:34.120 --> 00:27:37.510
É muito mais tedioso para pessoas como nós escrever códigos como este.

00:27:37.510 --> 00:27:40.450
É por isso que você e eu tendemos a escrever coisas assim.

00:27:40.450 --> 00:27:44.080
E ainda assim, idealmente, pessoas como você e eu tendemos a arrastar e soltar peças de quebra-cabeças

00:27:44.080 --> 00:27:46.520
esse tipo de resumo de tudo isso ainda mais longe.

00:27:46.520 --> 00:27:49.420
Mas, por enquanto, isso é, novamente, chamado de linguagem assembly.

00:27:49.420 --> 00:27:54.310
É o que acontece quando o compilador literalmente compila seu código.

00:27:54.310 --> 00:27:57.010
Mas claro, isso ainda não é zeros e uns.

00:27:57.010 --> 00:27:58.580
Então, temos dois passos a percorrer.

00:27:58.580 --> 00:28:02.270
Então, quando um compilador avança para a etapa três,

00:28:02.270 --> 00:28:05.530
é aqui que as coisas são convertidas em código de máquina.

00:28:05.530 --> 00:28:08.500
E quando um compilador monta seu código para você,

00:28:08.500 --> 00:28:14.260
ele converte o que acabamos de ver na tela aqui em zeros e uns reais -

00:28:14.260 --> 00:28:18.550
o chamado código de máquina que seu telefone ou computador entende.

00:28:18.550 --> 00:28:22.120
Mas vale a pena notar que estes não são necessariamente todos

00:28:22.120 --> 00:28:24.280
dos zeros e uns do seu programa.

00:28:24.280 --> 00:28:29.980
Sim, são os zeros e uns que correspondem ao seu programa Hello

00:28:29.980 --> 00:28:33.250
ou printf e getString e similares, mas observe

00:28:33.250 --> 00:28:36.940
que aqui, precisamos de um passo final.

00:28:36.940 --> 00:28:40.100
Nesses zeros e uns estão apenas suas linhas de código.

00:28:40.100 --> 00:28:43.540
Mas e as linhas de código do CS50 que escrevemos para implementar getString?

00:28:43.540 --> 00:28:46.990
E as linhas de código que os humanos escreveram décadas atrás para implementar o printf?

00:28:46.990 --> 00:28:50.020
Eles estão em algum lugar neste disco rígido, como no meu Mac, meu PC,

00:28:50.020 --> 00:28:54.460
ou em algum lugar na nuvem, mas precisamos combinar todos esses zeros e uns

00:28:54.460 --> 00:29:01.390
juntos e vincular meu código com o código do CS50 com o código do I/O padrão,

00:29:01.390 --> 00:29:02.420
todos juntos.

00:29:02.420 --> 00:29:05.110
E então o que acontece na última etapa, em última análise,

00:29:05.110 --> 00:29:07.960
é que se tivermos meu código aqui em amarelo,

00:29:07.960 --> 00:29:11.440
e então o código que CS50 escreveu, e o código que os autores de C

00:29:11.440 --> 00:29:15.940
ele mesmo escreveu, o que realmente está acontecendo é que em algum lugar, nós não apenas

00:29:15.940 --> 00:29:19.960
hello.c, que, obviamente, eu escrevi, e escrevi conosco ao vivo aqui,

00:29:19.960 --> 00:29:24.550
também há, vamos supor, em algum lugar no computador, um arquivo cs50.c

00:29:24.550 --> 00:29:28.210
que, coincidentemente, eu e a equipe do CS50 escrevemos anos atrás.

00:29:28.210 --> 00:29:30.790
E também, em algum lugar do computador, há outro arquivo.

00:29:30.790 --> 00:29:34.120
Deixe-me simplificar demais chamando-o apenas de stdio.c.

00:29:34.120 --> 00:29:36.850
Na prática, provavelmente é chamado especificamente de printf.c.

00:29:36.850 --> 00:29:39.460
Mas eles estão em algum lugar, esses dois outros arquivos.

00:29:39.460 --> 00:29:44.110
E então esta última etapa chamada vinculação leva meus zeros e uns

00:29:44.110 --> 00:29:48.100
do código que acabei de escrever, ou seja, este código na tela aqui.

00:29:48.100 --> 00:29:50.810
Em seguida, ele pega os zeros e uns que o CS50 escreveu.

00:29:50.810 --> 00:29:53.480
E pega os zeros e uns que os autores de C escreveram,

00:29:53.480 --> 00:29:56.240
para implementar a biblioteca de E/S padrão.

00:29:56.240 --> 00:30:00.750
E por último, voilá, liga todos eles.

00:30:00.750 --> 00:30:03.980
E esta é a mesma bolha de zeros e uns que vimos anteriormente.

00:30:03.980 --> 00:30:08.090
Agora é o resultado do pré-processamento do seu código,

00:30:08.090 --> 00:30:12.620
compilando seu código, montando seu código, vinculando seu código e meu Deus,

00:30:12.620 --> 00:30:15.830
neste ponto, como se ainda houvesse alguma diversão em programar para você,

00:30:15.830 --> 00:30:19.620
acabamos de retirar tudo, chamamos todo esse processo de compilação.

00:30:19.620 --> 00:30:20.120
Por que?

00:30:20.120 --> 00:30:22.490
Porque agora que sabemos que essas etapas existem...

00:30:22.490 --> 00:30:25.370
e pessoas inteligentes resolvem esse problema para nós--

00:30:25.370 --> 00:30:27.890
você e eu podemos operar nesse nível de abstração

00:30:27.890 --> 00:30:32.420
e apenas suponha que a compilação converte o código-fonte em código de máquina.

00:30:32.420 --> 00:30:36.350
Dúvidas, porém, em qualquer uma dessas etapas intermediárias?

00:30:36.350 --> 00:30:37.360
Sim?

00:30:37.360 --> 00:30:41.958
AUDIÊNCIA: Para vincular, há partes diferentes, como [INAUDÍVEL]??

00:30:50.072 --> 00:30:51.280
DAVID MALAN: Uma boa pergunta.

00:30:51.280 --> 00:30:53.238
Então, onde estão todos esses zeros e um armazenados?

00:30:53.238 --> 00:30:56.400
Porque você e eu usamos um navegador, certo? code.cs50.io,

00:30:56.400 --> 00:30:58.330
claro, é esta interface de usuário baseada na web.

00:30:58.330 --> 00:31:00.497
Mas, novamente, lembre-se da semana passada, mesmo que você esteja

00:31:00.497 --> 00:31:05.640
usando um navegador da web para acessar o VS Code, essa versão baseada na web do código VS

00:31:05.640 --> 00:31:09.000
está conectado a um servidor real em algum lugar na nuvem.

00:31:09.000 --> 00:31:13.170
E nesse servidor, você tem sua própria conta e seus próprios arquivos, e realmente,

00:31:13.170 --> 00:31:15.360
seu próprio disco rígido, virtualmente na nuvem.

00:31:15.360 --> 00:31:18.872
Pense nisso um pouco como Dropbox ou Box ou Google Drive ou OneDrive

00:31:18.872 --> 00:31:19.830
ou algo assim.

00:31:19.830 --> 00:31:23.310
Portanto, você tem um disco rígido em algum lugar que provisionamos para você.

00:31:23.310 --> 00:31:27.930
E é nesse disco rígido que você tem o código que acabou de escrever,

00:31:27.930 --> 00:31:32.700
ou eu apenas escrevi cs50.c, stdio.c e todos os outros códigos

00:31:32.700 --> 00:31:36.967
que implementa as funções matemáticas e tudo mais que o C suporta.

00:31:36.967 --> 00:31:37.550
Boa pergunta.

00:31:37.550 --> 00:31:38.964
Sim?

00:31:38.964 --> 00:31:45.425
AUDIÊNCIA: Então, digamos na biblioteca CS50, a linha [INAUDÍVEL]

00:31:45.425 --> 00:31:49.401
fazemos exatamente a mesma coisa [INAUDÍVEL]

00:31:49.401 --> 00:31:51.935
copiá-los e colá-los todo o caminho?

00:31:51.935 --> 00:31:53.060
DAVID MALAN: Boa pergunta.

00:31:53.060 --> 00:31:57.110
Esse hash inclui a linha cs50.h na parte superior do meu código.

00:31:57.110 --> 00:32:01.310
Se eu substituir isso pelo conteúdo de cs50.c, isso funcionaria?

00:32:01.310 --> 00:32:03.590
Resposta curta, sim, isso funcionaria.

00:32:03.590 --> 00:32:05.400
Você pode copiar todo o código lá.

00:32:05.400 --> 00:32:08.577
No entanto, há alguma ordem de operações que podem entrar em jogo.

00:32:08.577 --> 00:32:10.910
E provavelmente não é tão simples quanto copiar e colar.

00:32:10.910 --> 00:32:13.190
Mas conceitualmente, sim, é isso que está acontecendo.

00:32:13.190 --> 00:32:19.370
Agora dito isso, em cs50.h, estão apenas os protótipos das funções,

00:32:19.370 --> 00:32:23.628
as dicas sobre a aparência das funções, qual é o tipo de retorno,

00:32:23.628 --> 00:32:25.670
qual é o nome deles e quais são seus argumentos.

00:32:25.670 --> 00:32:29.867
É no arquivo dot c que o código real tende a ser escrito.

00:32:29.867 --> 00:32:32.450
E isso é um pouco confuso agora porque você e eu temos apenas

00:32:32.450 --> 00:32:33.920
código escrito em arquivos ponto c.

00:32:33.920 --> 00:32:35.690
Mas nas próximas semanas, você realmente

00:32:35.690 --> 00:32:37.940
comece a escrever alguns de seus próprios arquivos dot h

00:32:37.940 --> 00:32:40.460
também, assim como CS50, assim como E/S padrão.

00:32:40.460 --> 00:32:44.150
Mas, em essência, essa linha de código apenas facilita o uso e a reutilização

00:32:44.150 --> 00:32:46.020
código que já foi escrito.

00:32:46.020 --> 00:32:47.750
E esse é o objetivo de uma biblioteca.

00:32:47.750 --> 00:32:50.327
AUDIÊNCIA: Vinculá-los [INAUDÍVEL]?

00:32:50.327 --> 00:32:51.910
DAVID MALAN: Diga isso um pouco mais alto.

00:32:51.910 --> 00:32:54.472
AUDIÊNCIA: A vinculação acontece quando você usa o compilador?

00:32:54.472 --> 00:32:55.180
DAVID MALAN: Sim.

00:32:55.180 --> 00:32:56.980
A vinculação acontece quando você compila seu código?

00:32:56.980 --> 00:32:57.480
Sim.

00:32:57.480 --> 00:33:02.320
Quando você executa o make, como fizemos na semana passada,

00:33:02.320 --> 00:33:04.570
todas essas quatro etapas estão acontecendo.

00:33:04.570 --> 00:33:07.780
O pré-processamento converte as linhas de inclusão de hash em outra coisa.

00:33:07.780 --> 00:33:10.600
Compilar tecnicamente o converte em assembly

00:33:10.600 --> 00:33:14.290
código, que o Mac, o PC, o servidor entende mais de perto.

00:33:14.290 --> 00:33:18.850
Assembly converte essa linguagem em código de máquina binário que este computador

00:33:18.850 --> 00:33:20.080
realmente entende.

00:33:20.080 --> 00:33:22.540
E então a ligação combina tudo junto.

00:33:22.540 --> 00:33:27.550
E, de fato, se você pensar em alguns minutos atrás, quando eu fiz isso -lcs50,

00:33:27.550 --> 00:33:30.070
a razão pela qual eu tinha que adicionar isso, e a razão

00:33:30.070 --> 00:33:32.860
meu código não compilou no começo, foi porque eu

00:33:32.860 --> 00:33:38.650
esqueci de dizer ao clang para vincular os zeros e uns do CS50 por essa última etapa.

00:33:38.650 --> 00:33:42.147
Não preciso fazer -lstdio porque vem com C,

00:33:42.147 --> 00:33:44.480
então isso seria entediante para todos no mundo.

00:33:44.480 --> 00:33:47.140
Mas o CS50 não vem com C, então ligamos isso.

00:33:47.140 --> 00:33:49.780
E, para ser claro, nem sempre usaremos a biblioteca do CS50.

00:33:49.780 --> 00:33:53.072
Esse será mais um par de rodinhas que tiraremos nas próximas semanas.

00:33:53.072 --> 00:33:55.000
Mas, por enquanto, simplifica algumas coisas.

00:33:55.000 --> 00:33:57.284
Sim?

00:33:57.284 --> 00:33:59.750
AUDIÊNCIA: O que é [INAUDÍVEL]?

00:34:08.878 --> 00:34:10.170
DAVID MALAN: Resposta curta, sim.

00:34:10.170 --> 00:34:12.870
Então, a que se traduzem os zeros e uns, o código da máquina?

00:34:12.870 --> 00:34:15.690
Sim, existe uma relação um-para-um entre a máquina

00:34:15.690 --> 00:34:17.340
código e o código assembly.

00:34:17.340 --> 00:34:21.510
Código de montagem, não é realmente inglês, mas pelo menos são símbolos que eu reconheço.

00:34:21.510 --> 00:34:22.800
Não são zeros e uns.

00:34:22.800 --> 00:34:24.810
O código de máquina, é claro, é apenas zeros e uns.

00:34:24.810 --> 00:34:27.960
Antigamente, antes de C existir, as pessoas

00:34:27.960 --> 00:34:30.630
estavam programando apenas em código assembly.

00:34:30.630 --> 00:34:34.469
Antes da existência do código assembly, as pessoas codificavam em zeros e uns.

00:34:34.469 --> 00:34:36.719
E você pode imaginar o quão doloroso foi,

00:34:36.719 --> 00:34:39.027
e assim cada uma dessas linguagens faz a vida, para nós,

00:34:39.027 --> 00:34:40.110
tipo de mais fácil e mais fácil.

00:34:40.110 --> 00:34:42.330
Em algumas semanas, faremos a transição para o Python, que

00:34:42.330 --> 00:34:45.300
irá, por sua vez, tornar C ainda mais simples -

00:34:45.300 --> 00:34:48.090
ou codificação, em geral, mais simples de fazer também.

00:34:48.090 --> 00:34:53.346
Tudo bem, então com isso dito, o que podemos agora--

00:34:53.346 --> 00:34:55.060
o que poderia dar errado com isso?

00:34:55.060 --> 00:34:58.140
Bem, acontece que além de compilar, tecnicamente falando,

00:34:58.140 --> 00:34:59.233
há descompilação.

00:34:59.233 --> 00:35:01.150
E não fizemos isso e não faremos isso.

00:35:01.150 --> 00:35:04.080
Mas vale a pena considerar por um momento.

00:35:04.080 --> 00:35:07.560
Se você não compilasse seu código, mas descompilasse--

00:35:07.560 --> 00:35:11.340
como a palavra sugere, isso significa apenas inverter o processo, convertê-lo,

00:35:11.340 --> 00:35:14.580
idealmente, do código de máquina-- zeros e uns--

00:35:14.580 --> 00:35:19.870
talvez de volta para C. Agora isso seria legal, talvez, se tudo que você tem é um programa,

00:35:19.870 --> 00:35:22.080
você pode convertê-lo e ver o código-fonte real.

00:35:22.080 --> 00:35:25.320
O que poderia ser uma desvantagem, se alguém na internet

00:35:25.320 --> 00:35:28.650
é capaz de descompilar o código em sua máquina?

00:35:28.650 --> 00:35:29.160
Sim?

00:35:29.160 --> 00:35:30.270
AUDIÊNCIA: [INAUDÍVEL]

00:35:30.270 --> 00:35:34.130
DAVID MALAN: OK, então é mais fácil encontrar bugs no código que--

00:35:34.130 --> 00:35:35.430
oh, para explorar.

00:35:35.430 --> 00:35:38.417
Portanto, pode ser mais fácil invadir o software

00:35:38.417 --> 00:35:41.000
encontrando erros que você e eu cometemos porque, literalmente, eles são

00:35:41.000 --> 00:35:43.370
olhando para você em código, enquanto os zeros e uns fazem

00:35:43.370 --> 00:35:45.080
é bem menos óbvio.

00:35:45.080 --> 00:35:48.140
Outras desvantagens do que chamei de descompilação?

00:35:48.140 --> 00:35:49.970
Sim?

00:35:49.970 --> 00:35:53.690
AUDIÊNCIA: Se o material é protegido por direitos autorais ou você nem sabe como obtê-lo--

00:35:53.690 --> 00:35:54.440
DAVID MALAN: Sim.

00:35:54.440 --> 00:35:55.948
AUDIÊNCIA: [INAUDÍVEL]

00:35:55.948 --> 00:35:57.740
DAVID MALAN: Sim, se seu código, seu trabalho,

00:35:57.740 --> 00:36:00.950
é sua propriedade intelectual, protegida por direitos autorais ou não, isso é

00:36:00.950 --> 00:36:03.660
meio desagradável que alguém pode apenas executar um comando, e bum,

00:36:03.660 --> 00:36:05.577
eles podem ver o código original que você escreveu.

00:36:05.577 --> 00:36:08.490
Agora, acontece que não é tão simples assim.

00:36:08.490 --> 00:36:11.720
E mesmo assim, sim, você poderia pegar um programa como Hello,

00:36:11.720 --> 00:36:15.080
ou até mesmo o Microsoft Word e convertê-lo de zeros e uns

00:36:15.080 --> 00:36:19.400
de volta a alguma forma de código-fonte - seja em C ou Java

00:36:19.400 --> 00:36:22.820
ou Python ou qualquer outra coisa, o que quer que tenha sido originalmente escrito em-- odds

00:36:22.820 --> 00:36:25.800
vai ser uma bagunça total de se olhar.

00:36:25.800 --> 00:36:26.300
Por que?

00:36:26.300 --> 00:36:30.390
Como os nomes das variáveis ​​de coisas não são retidos nos zeros e uns,

00:36:30.390 --> 00:36:30.890
tipicamente.

00:36:30.890 --> 00:36:33.980
Os nomes das funções podem não ser retidos nos zeros e uns.

00:36:33.980 --> 00:36:36.350
O código é, a lógica é, mas o computador

00:36:36.350 --> 00:36:38.510
não importa quais variáveis ​​bonitas você escolheu

00:36:38.510 --> 00:36:41.060
e como suas funções foram bem nomeadas, apenas

00:36:41.060 --> 00:36:42.890
precisa conhecê-los como zeros e uns.

00:36:42.890 --> 00:36:46.370
Além disso, se você pensar na semana passada, introduzimos coisas como loops em C.

00:36:46.370 --> 00:36:49.745
E além dos loops for, existe que outro tipo de loop, por exemplo?

00:36:49.745 --> 00:36:50.620
AUDIÊNCIA: [INAUDÍVEL]

00:36:50.620 --> 00:36:53.412
DAVID MALAN: Então, um loop while-- e mesmo que pareçam diferentes

00:36:53.412 --> 00:36:55.920
e você tem que escrever um código diferente, eles alcançam exatamente

00:36:55.920 --> 00:36:59.910
a mesma funcionalidade, ou seja, quando você compila um loop for

00:36:59.910 --> 00:37:04.140
ou você compila um loop while, se eles fizerem logicamente a mesma coisa,

00:37:04.140 --> 00:37:07.420
eles podem acabar parecendo idênticos a zeros e uns.

00:37:07.420 --> 00:37:09.780
E assim, portanto, não é necessariamente previsível

00:37:09.780 --> 00:37:11.820
que você receberá de volta o código original, por quê?

00:37:11.820 --> 00:37:15.110
Porque os zeros e uns podem não saber, por assim dizer,

00:37:15.110 --> 00:37:16.860
se era um loop for ou um loop while,

00:37:16.860 --> 00:37:19.350
então talvez a compilação mostre um ou outro.

00:37:19.350 --> 00:37:21.870
E honestamente, descompilando, enquanto possível - e é

00:37:21.870 --> 00:37:24.570
uma forma de fazer engenharia reversa do produto de alguém.

00:37:24.570 --> 00:37:28.662
As probabilidades são, se você for bom o suficiente para começar a ler o código que foi descompilado

00:37:28.662 --> 00:37:30.870
e lendo a confusão disso, é provável que você

00:37:30.870 --> 00:37:34.020
provavelmente tem talento para escrever o mesmo programa do zero

00:37:34.020 --> 00:37:34.650
você mesmo.

00:37:34.650 --> 00:37:36.870
Agora, isso é um exagero, talvez, mas não é

00:37:36.870 --> 00:37:40.410
tão fácil ou ameaçador quanto você pode pensar.

00:37:40.410 --> 00:37:43.290
Então, em geral, uma vez que o código é compilado, é

00:37:43.290 --> 00:37:48.290
bastante desafiador, demorado, caro para fazer engenharia reversa, muito

00:37:48.290 --> 00:37:50.040
como seria no mundo real, certo?

00:37:50.040 --> 00:37:52.860
Como se todos nós tivéssemos algum tipo de telefone, provavelmente, hoje em dia no bolso.

00:37:52.860 --> 00:37:55.193
Não há nada que o impeça de abri-lo de alguma forma,

00:37:55.193 --> 00:37:57.060
bisbilhotando, recriando o que está lá.

00:37:57.060 --> 00:37:59.130
Isso é uma quantidade enorme de esforço, provavelmente.

00:37:59.130 --> 00:38:01.880
E nesse ponto, talvez você devesse apenas inventar o telefone, em vez

00:38:01.880 --> 00:38:03.310
de tentar fazer engenharia reversa.

00:38:03.310 --> 00:38:06.330
Então, o mesmo tipo de ideia no mundo físico.

00:38:06.330 --> 00:38:13.050
Alguma dúvida, então, sobre compilar, ou mesmo descompilar nessas formas?

00:38:13.050 --> 00:38:17.160
Tudo bem, então as probabilidades são, neste ponto, não apenas eu, mas você cometeu erros.

00:38:17.160 --> 00:38:19.050
E você escreveu um código com bugs--

00:38:19.050 --> 00:38:22.350
um bug em um código é apenas um erro, um erro lógico

00:38:22.350 --> 00:38:26.490
ou de outra forma, onde o código simplesmente não se comporta corretamente como você pretende.

00:38:26.490 --> 00:38:29.880
E até agora, provavelmente, suas técnicas de depuração

00:38:29.880 --> 00:38:32.910
estive para talvez olhar para trás para o que eu fiz na aula, talvez

00:38:32.910 --> 00:38:35.320
faça uma pergunta online ou pessoalmente.

00:38:35.320 --> 00:38:38.190
Mas, em última análise, seria bom se você tivesse algumas ferramentas próprias

00:38:38.190 --> 00:38:39.570
com o qual depurar o código.

00:38:39.570 --> 00:38:41.587
E isso, honestamente, é uma habilidade para toda a vida.

00:38:41.587 --> 00:38:43.170
Você não vai sair do CS50--

00:38:43.170 --> 00:38:44.490
e mesmo daqui a 20 anos, você não vai

00:38:44.490 --> 00:38:47.910
estar escrevendo-- se você estiver escrevendo código-- corrija o código o tempo todo.

00:38:47.910 --> 00:38:50.820
Tipo, todos nós da equipe continuamos a escrever bugs.

00:38:50.820 --> 00:38:54.120
Esperançosamente, eles ficam um pouco mais sofisticados, e não tipo,

00:38:54.120 --> 00:38:55.540
opa, perdi um ponto e vírgula.

00:38:55.540 --> 00:38:57.660
Mas mesmo esses tipos de erros, nós também cometemos.

00:38:57.660 --> 00:39:00.150
Mas existem ferramentas e técnicas por aí

00:39:00.150 --> 00:39:03.550
que podem facilitar sua vida na hora de resolver esses problemas.

00:39:03.550 --> 00:39:06.360
Agora, o termo bug existe há décadas.

00:39:06.360 --> 00:39:11.790
Mas uma história divertida para contar é que o primeiro bug real documentado foi

00:39:11.790 --> 00:39:13.650
na verdade, de alguma forma conectado a Harvard.

00:39:13.650 --> 00:39:18.870
Na verdade, este é o diário de bordo relacionado ao computador Harvard Mark II

00:39:18.870 --> 00:39:22.890
de 1947, onde se você ler as notas aqui-- e eu aumentar o zoom-- isso

00:39:22.890 --> 00:39:27.630
foi uma mariposa real descoberta dentro deste grande computador mainframe que

00:39:27.630 --> 00:39:29.160
estava causando algum tipo de problema.

00:39:29.160 --> 00:39:30.450
E os engenheiros lá na época, na verdade

00:39:30.450 --> 00:39:33.610
achei engraçado que, uau, o bug físico realmente explica o problema.

00:39:33.610 --> 00:39:36.450
E está para sempre colado nesta folha de papel, que eu acredito

00:39:36.450 --> 00:39:39.090
agora está em exibição no Smithsonian.

00:39:39.090 --> 00:39:43.260
Com isso dito, isso também é apenas representativo de um bug lógico.

00:39:43.260 --> 00:39:45.390
E essa história é na verdade--

00:39:45.390 --> 00:39:49.170
essa história foi muitas vezes recontada por um matemático famoso, então cientista da computação

00:39:49.170 --> 00:39:53.640
realmente, Dra. Grace Hopper, que realmente trabalhou não apenas no Harvard Mark II

00:39:53.640 --> 00:39:57.210
computador, mas seu antecessor, o Harvard Mark I.

00:39:57.210 --> 00:40:01.020
E se você já passou algum tempo no prédio de engenharia do outro lado do rio

00:40:01.020 --> 00:40:04.103
aqui, você pode realmente ver muito deste computador, que

00:40:04.103 --> 00:40:07.020
está ao longo da parede quando você entra pela primeira vez no Science and Engineering

00:40:07.020 --> 00:40:07.530
Complexo.

00:40:07.530 --> 00:40:09.530
E, de fato, como você provavelmente já ouviu enquanto crescia,

00:40:09.530 --> 00:40:11.070
este é um computador mainframe.

00:40:11.070 --> 00:40:15.210
Era assim que os Macs e PCs, por assim dizer, eram antigamente,

00:40:15.210 --> 00:40:18.240
com coisas muito físicas que essencialmente implementavam os zeros

00:40:18.240 --> 00:40:21.900
e aqueles que você e eu tomamos como garantidos agora sendo miniaturizados em nossos laptops

00:40:21.900 --> 00:40:22.410
e telefones.

00:40:22.410 --> 00:40:23.910
Então tem um pedaço da história aí.

00:40:23.910 --> 00:40:27.390
Se você visitar esse lado do campus em algum momento, dê uma olhada.

00:40:27.390 --> 00:40:30.480
Mas vamos considerar, então, como resolvemos não, é claro, bugs físicos,

00:40:30.480 --> 00:40:31.350
mas erros lógicos.

00:40:31.350 --> 00:40:33.600
E vamos considerar algo assim da semana passada,

00:40:33.600 --> 00:40:38.820
por meio do qual, estávamos tentando muito simplesmente imprimir como esta coluna de três tijolos

00:40:38.820 --> 00:40:40.320
usando hashtags de tipos.

00:40:40.320 --> 00:40:44.400
Então, deixe-me passar aqui em apenas um momento para o VS Code.

00:40:44.400 --> 00:40:47.080
E vou seguir em frente e abrir um programa que escrevi com antecedência.

00:40:47.080 --> 00:40:49.455
E estou trazendo para a aula porque há um bug nele,

00:40:49.455 --> 00:40:51.510
e gostaria de descobrir como resolver esse bug.

00:40:51.510 --> 00:40:56.160
Deixe-me abrir um buggy0.c, que é a versão 0 do meu código.

00:40:56.160 --> 00:40:58.200
E vamos dar uma olhada rápida no que está aqui.

00:40:58.200 --> 00:40:58.950
É bem curto.

00:40:58.950 --> 00:41:03.750
Inclui apenas stdio.h, usa printf, usa um loop for,

00:41:03.750 --> 00:41:07.797
e o objetivo, simplesmente, é imprimir aquela coluna de três tijolos.

00:41:07.797 --> 00:41:11.130
Agora, é curto o suficiente para que alguns de vocês, se já estiverem se sentindo confortáveis ​​com C,

00:41:11.130 --> 00:41:13.360
você já pode ver o bug lógico.

00:41:13.360 --> 00:41:16.200
Não é um erro de sintaxe, como se fosse compilar e executar.

00:41:16.200 --> 00:41:17.280
Mas tem um bug aí.

00:41:17.280 --> 00:41:22.320
E suponha que eu seja muito novo em C, estou muito desconfortável com C, são 2:00 da manhã

00:41:22.320 --> 00:41:26.130
e eu simplesmente não consigo ver o bug, quais são meus recursos aqui para realmente

00:41:26.130 --> 00:41:27.745
encontrar um erro como este?

00:41:27.745 --> 00:41:29.370
Bem, primeiro, vamos olhar para o sintoma.

00:41:29.370 --> 00:41:31.740
Deixe-me ir até a janela do meu terminal.

00:41:31.740 --> 00:41:36.120
Vou usar make buggy0 porque, novamente, o arquivo é chamado buggyo.c.

00:41:36.120 --> 00:41:37.260
Eu não vou usar clang.

00:41:37.260 --> 00:41:39.880
Na verdade, nunca vou usar o clang manualmente daqui em diante.

00:41:39.880 --> 00:41:42.430
Só vou usar make porque facilita a nossa vida.

00:41:42.430 --> 00:41:43.560
Ele compila.

00:41:43.560 --> 00:41:45.390
Sem erros, então não é sintaxe.

00:41:45.390 --> 00:41:47.670
Não é algo bobo como faltar um ponto e vírgula.

00:41:47.670 --> 00:41:53.190
Mas quando executo ./buggy0, é claro que vejo um, dois, três, quatro...

00:41:53.190 --> 00:41:57.990
e isso, é claro, não corresponde aos um, dois, três tijolos que eu realmente

00:41:57.990 --> 00:41:59.610
destinado a essa coluna.

00:41:59.610 --> 00:42:02.970
E, no entanto, estou começando a contar em 0, como costumo fazer.

00:42:02.970 --> 00:42:03.930
Eu tenho três.

00:42:03.930 --> 00:42:05.280
Eu vou até três.

00:42:05.280 --> 00:42:06.780
Então, onde está meu erro lógico?

00:42:06.780 --> 00:42:10.150
Se obviamente ainda não saltou para você, bem, como posso resolver isso?

00:42:10.150 --> 00:42:13.080
Bem, em primeiro lugar, talvez a melhor técnica

00:42:13.080 --> 00:42:16.080
para resolver bugs, pelo menos no início, é só usar printf.

00:42:16.080 --> 00:42:20.020
Como até agora, usamos sprint, digamos, Olá e outras coisas na tela.

00:42:20.020 --> 00:42:22.530
Mas printf é apenas uma função para imprimir qualquer coisa.

00:42:22.530 --> 00:42:24.570
E não há razão para que você não possa temporariamente

00:42:24.570 --> 00:42:27.900
use printf para imprimir o conteúdo das variáveis,

00:42:27.900 --> 00:42:29.850
o que está acontecendo dentro do seu programa, apenas

00:42:29.850 --> 00:42:31.350
para descobrir onde está o seu erro.

00:42:31.350 --> 00:42:32.940
E então você pode excluir essa linha de código mais tarde.

00:42:32.940 --> 00:42:34.600
Não precisa ficar lá para sempre.

00:42:34.600 --> 00:42:35.740
Então deixe-me fazer isso.

00:42:35.740 --> 00:42:39.450
Em vez de apenas imprimir no VS Code o símbolo de hash,

00:42:39.450 --> 00:42:45.690
deixe-me fazer uma pequena verificação de segurança aqui e imprimir o valor de i.

00:42:45.690 --> 00:42:49.170
Então deixe-me ir em frente e dizer algo como, eu sou--

00:42:49.170 --> 00:42:51.610
agora eu quero dizer que eu sou isso.

00:42:51.610 --> 00:42:54.540
Mas, é claro, não é assim que imprimo o valor de i.

00:42:54.540 --> 00:42:58.930
Se eu quiser imprimir o valor de i, o que devo colocar aqui?

00:42:58.930 --> 00:43:02.160
Portanto, %i para inteiro, em vez de %s para string.

00:43:02.160 --> 00:43:03.410
Portanto, eles ainda são espaços reservados.

00:43:03.410 --> 00:43:04.930
Mas usamos %s para números inteiros.

00:43:04.930 --> 00:43:08.450
E agora, se eu quiser imprimir i, só preciso da vírgula como segundo argumento,

00:43:08.450 --> 00:43:09.250
e então eu.

00:43:09.250 --> 00:43:13.000
Tudo bem, deixe-me ir em frente e voltar para a janela do meu terminal.

00:43:13.000 --> 00:43:15.760
Deixe-me recompilar o programa porque eu o mudei.

00:43:15.760 --> 00:43:18.880
Isso ainda funciona bem, ./buggy0.

00:43:18.880 --> 00:43:22.540
E agora, deixe-me aumentar o tamanho da janela do meu terminal aqui.

00:43:22.540 --> 00:43:25.510
Você apenas vê algumas informações de diagnóstico, se quiser.

00:43:25.510 --> 00:43:26.560
Este não é o objetivo.

00:43:26.560 --> 00:43:29.393
Isso não é o que você deveria enviar para este problema de lição de casa,

00:43:29.393 --> 00:43:30.070
fosse um.

00:43:30.070 --> 00:43:33.730
Mas está nos ajudando diagnosticamente a saber que, OK, quando i é zero,

00:43:33.730 --> 00:43:34.450
aqui está um hash.

00:43:34.450 --> 00:43:36.182
Quando i é 1, aqui está um hash.

00:43:36.182 --> 00:43:37.390
Quando eu tiver dois anos, aqui está um hash.

00:43:37.390 --> 00:43:39.017
Quando eu tiver 3 anos, aqui está um hash.

00:43:39.017 --> 00:43:39.850
Bem, espere um minuto.

00:43:39.850 --> 00:43:41.530
Isso é um, dois, três, quatro.

00:43:41.530 --> 00:43:44.360
Então, claramente, estou imprimindo muitas vezes.

00:43:44.360 --> 00:43:48.130
Então, deixe-me olhar para o código aqui, encolhendo minha janela de terminal.

00:43:48.130 --> 00:43:53.080
E deixe-me perguntar ao grupo, onde está, de fato, o erro?

00:43:53.080 --> 00:43:56.080
Ou qual seria, equivalentemente, a solução?

00:43:56.080 --> 00:43:57.561
Sim, no meio.

00:43:57.561 --> 00:44:00.020
AUDIÊNCIA: [INAUDÍVEL]

00:44:00.020 --> 00:44:03.550
DAVID MALAN: Sim, em vez de menor ou igual a, use apenas menor que.

00:44:03.550 --> 00:44:05.300
Então você tem que escolher uma pista aqui.

00:44:05.300 --> 00:44:08.630
Se você vai começar a contar a partir de 0, geralmente usa menos que,

00:44:08.630 --> 00:44:10.880
e ir até, mas não através do valor.

00:44:10.880 --> 00:44:13.970
Ou se preferir, como no mundo humano, contando de 1 em diante,

00:44:13.970 --> 00:44:17.300
você pode usar less than ou equal to, mas precisa ser consistente.

00:44:17.300 --> 00:44:19.790
E, em geral, como programador, sempre comece

00:44:19.790 --> 00:44:22.610
contando de 0 se você estiver fazendo algo canônico como este.

00:44:22.610 --> 00:44:25.160
Mas a solução é, sim, apenas mudar isso

00:44:25.160 --> 00:44:27.860
alterando o maior menor que ou igual ao menor.

00:44:27.860 --> 00:44:34.340
Se eu recompilar este programa com make buggy0, e então fazer .buggy0 novamente--

00:44:34.340 --> 00:44:36.500
e deixe-me aumentar o tamanho da janela do meu terminal.

00:44:36.500 --> 00:44:39.050
Agora, você vê, OK, quase a mesma saída.

00:44:39.050 --> 00:44:44.330
Mas, de fato, i começa em 0 e vai até, mas não passa, três.

00:44:44.330 --> 00:44:48.920
Tudo bem, então printf, resumindo, pode ser sua primeira ferramenta de diagnóstico.

00:44:48.920 --> 00:44:51.500
Em vez de apenas olhar para a tela ou levantar a mão...

00:44:51.500 --> 00:44:55.490
Quero dizer, use printf para ver, literalmente, o que está acontecendo dentro do seu programa

00:44:55.490 --> 00:44:57.287
apenas imprimindo coisas de interesse.

00:44:57.287 --> 00:44:59.120
E depois de resolver o problema, você

00:44:59.120 --> 00:45:02.840
pode voltar ao seu código, como farei aqui, diminuindo a janela do meu terminal.

00:45:02.840 --> 00:45:04.610
Vou deletar a linha printf.

00:45:04.610 --> 00:45:07.100
E agora estou pronto para compartilhar este programa com o mundo

00:45:07.100 --> 00:45:08.870
ou enviá-lo como dever de casa ou algo semelhante.

00:45:08.870 --> 00:45:11.390
É apenas para ser temporário.

00:45:11.390 --> 00:45:15.440
Alguma dúvida sobre printf como uma ferramenta de depuração?

00:45:18.010 --> 00:45:18.510
Não?

00:45:18.510 --> 00:45:20.970
Tudo bem, bem, isso só nos leva até certo ponto.

00:45:20.970 --> 00:45:23.430
E honestamente, à medida que seus programas crescem e crescem e crescem,

00:45:23.430 --> 00:45:25.180
vai realmente ficar muito chato

00:45:25.180 --> 00:45:28.860
para começar a adicionar printf's, removê-los e descobrir,

00:45:28.860 --> 00:45:31.860
se você tiver vários printfs, bem, qual deles imprimiu o quê?

00:45:31.860 --> 00:45:34.560
Acaba ficando confuso, eventualmente, confiar apenas em printf.

00:45:34.560 --> 00:45:37.740
Sendo um cientista da computação, cientistas da computação

00:45:37.740 --> 00:45:41.040
escreveram software para facilitar a depuração do código.

00:45:41.040 --> 00:45:44.040
Esse software é o que normalmente chamaríamos de depurador, que

00:45:44.040 --> 00:45:47.040
seria a segunda ferramenta do comércio que você pode usar para realmente resolver

00:45:47.040 --> 00:45:48.610
problemas em seu código.

00:45:48.610 --> 00:45:52.690
Agora, no mundo do código VS, existe um depurador integrado.

00:45:52.690 --> 00:45:54.840
Portanto, a interface gráfica do usuário que você verá

00:45:54.840 --> 00:45:58.260
no VS Code não é específico do CS50, na verdade vem com o VS Code.

00:45:58.260 --> 00:46:01.230
E suporta C, C++, Java e Python,

00:46:01.230 --> 00:46:03.030
e muitos outros idiomas também.

00:46:03.030 --> 00:46:05.640
Mas é, reconhecidamente, um pouco complicado

00:46:05.640 --> 00:46:07.650
para começar a usar o depurador.

00:46:07.650 --> 00:46:10.200
Você tem que criar um arquivo de configuração e fazer

00:46:10.200 --> 00:46:13.480
algumas etapas irritantes que apenas atrapalham a resolução de problemas reais.

00:46:13.480 --> 00:46:17.070
Portanto, automatizamos o processo para você apenas iniciar o depurador.

00:46:17.070 --> 00:46:19.680
E depois disso, é uma espécie de padrão da indústria como você o usa.

00:46:19.680 --> 00:46:23.380
Mas evitamos a dor de cabeça de ter que criar esses arquivos de configuração.

00:46:23.380 --> 00:46:25.330
Então, suponha que eu queira fazer isso.

00:46:25.330 --> 00:46:27.600
Suponha que eu queira tentar depurar este programa

00:46:27.600 --> 00:46:30.330
passo a passo usando um software especial.

00:46:30.330 --> 00:46:31.810
Bem, como posso fazer isso?

00:46:31.810 --> 00:46:36.240
Bem, deixe-me propor que, se eu voltar para a versão original

00:46:36.240 --> 00:46:40.530
onde eu era menor ou igual a 3, tenho certeza de que

00:46:40.530 --> 00:46:41.790
estava imprimindo muitos hashes.

00:46:41.790 --> 00:46:43.350
Então eu vou fazer isso-- e você pode ter feito isso

00:46:43.350 --> 00:46:45.160
acidentalmente ou nunca.

00:46:45.160 --> 00:46:49.500
Mas observe se você passar o mouse sobre a sarjeta, por assim dizer, no VS Code, a parte dela

00:46:49.500 --> 00:46:52.590
à esquerda do editor, você vê esse tipo de cinza

00:46:52.590 --> 00:46:54.390
para fora ponto vermelho.

00:46:54.390 --> 00:46:57.240
Se você clicar ali, ele se tornará um ponto vermelho mais brilhante.

00:46:57.240 --> 00:46:59.670
E isso representa o que chamaremos de ponto de interrupção.

00:46:59.670 --> 00:47:03.090
E este é apenas um indicador visual que você colocou como um sinal de parada equivalente

00:47:03.090 --> 00:47:06.270
lá, e você está dizendo ao depurador em um momento, pare

00:47:06.270 --> 00:47:07.350
executando meu código lá.

00:47:07.350 --> 00:47:07.920
Por que?

00:47:07.920 --> 00:47:11.610
Como prefiro percorrer meu código em uma espécie de velocidade humana,

00:47:11.610 --> 00:47:14.380
e não como a velocidade do computador onde ele roda tudo de uma vez.

00:47:14.380 --> 00:47:16.750
Então, defini meu ponto de interrupção, que é o primeiro passo.

00:47:16.750 --> 00:47:18.580
E então o passo dois é simplesmente isso.

00:47:18.580 --> 00:47:23.190
Em vez de executar o programa em si, execute o comando chamado debug50,

00:47:23.190 --> 00:47:26.010
e então ./buggy0.

00:47:26.010 --> 00:47:29.220
E agora isso iniciará seu programa, mas por dentro

00:47:29.220 --> 00:47:31.200
do depurador, que é um programa especial

00:47:31.200 --> 00:47:33.060
que pessoas inteligentes escreveram que irão capacitar

00:47:33.060 --> 00:47:38.190
você agora percorre seu código linha por linha e, novamente, em seu próprio conforto

00:47:38.190 --> 00:47:38.970
ritmo.

00:47:38.970 --> 00:47:43.080
Vou apertar Enter, algumas coisas vão acontecer na tela-- uau.

00:47:43.080 --> 00:47:45.767
Observe, este é um erro comum que cometi acidentalmente aqui.

00:47:45.767 --> 00:47:47.100
Parece que mudei meu código.

00:47:47.100 --> 00:47:49.892
Eu fiz porque entrei e mudei o sinal de menor ou igual.

00:47:49.892 --> 00:47:52.860
Então deixe-me ir em frente e reexecutar make buggy0--

00:47:52.860 --> 00:47:53.520
Digitar.

00:47:53.520 --> 00:47:55.590
Bom, agora deixe-me executar novamente o debug50--

00:47:55.590 --> 00:47:57.810
Digitar.

00:47:57.810 --> 00:47:59.760
E agora algumas coisas aconteceram na tela

00:47:59.760 --> 00:48:03.270
e leva um momento para começar, mas assim que começar, você

00:48:03.270 --> 00:48:06.010
veja isso, você ainda verá seu código.

00:48:06.010 --> 00:48:09.410
Mas você verá esse destaque amarelo, que provavelmente nunca viu antes.

00:48:09.410 --> 00:48:11.910
E observe que está destacando especificamente a mesma linha

00:48:11.910 --> 00:48:13.440
que eu estabeleci um ponto de interrupção.

00:48:13.440 --> 00:48:13.950
Por que?

00:48:13.950 --> 00:48:18.870
Isso significa apenas que o depurador executou todas essas linhas,

00:48:18.870 --> 00:48:20.670
exceto a linha 7.

00:48:20.670 --> 00:48:23.340
Ele quebrou em - não de um jeito ruim.

00:48:23.340 --> 00:48:27.580
Mas ele pausou a execução na linha 7, então ainda não imprimiu nenhum hashe.

00:48:27.580 --> 00:48:30.450
E você pode ver isso-- sem hashes na janela do terminal ainda.

00:48:30.450 --> 00:48:31.980
É uma execução pausada.

00:48:31.980 --> 00:48:35.190
Mas o que é interessante com o depurador é o material

00:48:35.190 --> 00:48:37.410
aqui do lado esquerdo.

00:48:37.410 --> 00:48:39.960
No depurador aqui, você verá, em variáveis,

00:48:39.960 --> 00:48:41.910
todas as suas assim chamadas variáveis ​​locais.

00:48:41.910 --> 00:48:44.160
E realmente não fizemos uma distinção entre local

00:48:44.160 --> 00:48:45.327
e algo chamado global.

00:48:45.327 --> 00:48:48.000
Mas, por enquanto, variáveis ​​locais significam apenas todas as variáveis

00:48:48.000 --> 00:48:49.390
que existem em sua função.

00:48:49.390 --> 00:48:52.110
Então i atualmente tem um valor de 0.

00:48:52.110 --> 00:48:53.410
OK, e isso faz sentido.

00:48:53.410 --> 00:48:57.360
Então agora, como passo pelo meu código e vejo o que está fazendo?

00:48:57.360 --> 00:48:59.610
Bem, aqui na parte superior da tela, você

00:48:59.610 --> 00:49:02.250
veja alguns ícones de reprodução, como um reprodutor de vídeo,

00:49:02.250 --> 00:49:03.630
mas têm um significado especial.

00:49:03.630 --> 00:49:07.892
Este primeiro reproduzirá apenas o resto do seu programa até o fim.

00:49:07.892 --> 00:49:10.350
Então você só clica nele se tiver resolvido o problema

00:49:10.350 --> 00:49:13.110
e você só quer executá-lo até a conclusão como antes.

00:49:13.110 --> 00:49:14.370
Mas os próximos três--

00:49:14.370 --> 00:49:16.920
ou os próximos dois, realmente, são realmente os mais suculentos.

00:49:16.920 --> 00:49:19.710
O segundo aqui, se você passar o mouse sobre ele, eventualmente,

00:49:19.710 --> 00:49:21.930
você verá que se chama Step Over.

00:49:21.930 --> 00:49:25.170
Step Over significa que o depurador será executado

00:49:25.170 --> 00:49:28.630
esta linha de código atualmente destacada, mas não vai se aprofundar nela.

00:49:28.630 --> 00:49:30.660
Então, se é uma função como printf, não é

00:49:30.660 --> 00:49:32.827
vai começar a percorrer printf linha por linha.

00:49:32.827 --> 00:49:33.327
Por que?

00:49:33.327 --> 00:49:36.420
Porque posso presumir que printf, escrito décadas atrás, está correto.

00:49:36.420 --> 00:49:38.050
O problema provavelmente está comigo.

00:49:38.050 --> 00:49:42.690
Mas na próxima linha, se eu realmente quiser entrar no código printf

00:49:42.690 --> 00:49:46.110
para descobrir como funciona ou encontrar algum problema depois de tantos anos,

00:49:46.110 --> 00:49:48.810
você pode entrar em printf e, em seguida, a tela mudaria,

00:49:48.810 --> 00:49:50.910
e você veria cada uma das linhas para printf,

00:49:50.910 --> 00:49:54.250
linha por linha - pelo menos se você tiver o código-fonte do printf instalado.

00:49:54.250 --> 00:49:56.490
Tudo bem, vou usar o primeiro, Step Over.

00:49:56.490 --> 00:49:59.130
E observe como o destaque amarelo se move.

00:49:59.130 --> 00:50:03.060
E observe como, na janela do terminal, há um símbolo de hash.

00:50:03.060 --> 00:50:03.780
Aqui vamos nós.

00:50:03.780 --> 00:50:05.130
Há um hash.

00:50:05.130 --> 00:50:07.230
Agora, observe a linha 5 destacada.

00:50:07.230 --> 00:50:09.480
Isso significa que ele parou na linha 5.

00:50:09.480 --> 00:50:11.350
A linha 5 ainda não foi executada.

00:50:11.350 --> 00:50:12.600
Então, o que isso significa?

00:50:12.600 --> 00:50:16.320
O valor de i, no canto superior esquerdo, ainda é 0.

00:50:16.320 --> 00:50:18.920
Mas assim que eu clicar em Step Over novamente, assista

00:50:18.920 --> 00:50:24.470
o que acontece no canto superior esquerdo, onde i é uma variável na tela.

00:50:24.470 --> 00:50:26.420
Agora eu-- e piscou brevemente--

00:50:26.420 --> 00:50:27.920
tem valor 1.

00:50:27.920 --> 00:50:30.650
E agora, se eu passar de novo, observe a janela do terminal.

00:50:30.650 --> 00:50:32.120
Aqui está o meu segundo hash.

00:50:32.120 --> 00:50:36.380
Agora, deixe-me clicar em Step Over no loop for, observe a variável no canto superior esquerdo.

00:50:36.380 --> 00:50:38.567
Agora 1 vai para 2.

00:50:38.567 --> 00:50:39.650
Agora deixe-me clicar novamente.

00:50:39.650 --> 00:50:43.220
Terceiro hash - e aqui é onde o erro lógico talvez seja revelado.

00:50:43.220 --> 00:50:45.210
Deixe-me ir em frente e passar por cima do loop.

00:50:45.210 --> 00:50:46.520
Agora eu tenho 3.

00:50:46.520 --> 00:50:49.280
Espere um minuto, ainda vou imprimir um hash.

00:50:49.280 --> 00:50:49.810
Aí está.

00:50:49.810 --> 00:50:50.810
Aqui está o quarto hash.

00:50:50.810 --> 00:50:53.852
E neste ponto, esperançosamente, a lâmpada, proverbialmente, se apagou.

00:50:53.852 --> 00:50:55.020
Eu percebo, oh, eu estraguei tudo.

00:50:55.020 --> 00:50:58.580
Eu posso parar o programa completamente com o quadrado vermelho,

00:50:58.580 --> 00:51:01.100
ou posso simplesmente deixá-lo correr até o fim, o que

00:51:01.100 --> 00:51:02.493
simplesmente encerra tudo.

00:51:02.493 --> 00:51:05.660
Neste ponto, só quero voltar ao meu código e começar a consertar as coisas.

00:51:05.660 --> 00:51:07.700
E você pode fechar, por exemplo, como farei aqui,

00:51:07.700 --> 00:51:10.670
o File Explorer, apenas para ocultar o painel que se abriu.

00:51:10.670 --> 00:51:12.320
Então isso é debug50.

00:51:12.320 --> 00:51:15.920
Mas não é uma coisa do CS50, apenas inicia o depurador para você, que

00:51:15.920 --> 00:51:19.520
é algo que você encontraria em quase todos os ambientes de programação hoje em dia.

00:51:19.520 --> 00:51:23.670
Dúvidas sobre depuração?

00:51:23.670 --> 00:51:24.170
Questões?

00:51:24.170 --> 00:51:24.670
Sim?

00:51:24.670 --> 00:51:27.295
AUDIÊNCIA: Onde ele diz onde deu errado?

00:51:27.295 --> 00:51:28.420
DAVID MALAN: Boa pergunta.

00:51:28.420 --> 00:51:30.310
Onde ele diz onde deu errado?

00:51:30.310 --> 00:51:33.190
Então, infelizmente, ele não diz nada disso.

00:51:33.190 --> 00:51:37.570
A responsabilidade ainda está em você, o ser humano, para usar esta ferramenta de forma produtiva para caminhar

00:51:37.570 --> 00:51:39.580
através do seu código em um ritmo mais são.

00:51:39.580 --> 00:51:42.070
Mas seu cérebro é quem ainda precisa resolvê-lo.

00:51:42.070 --> 00:51:45.190
E não duvido, no futuro, com inteligência artificial e muito mais,

00:51:45.190 --> 00:51:47.350
programas como este serão ainda mais úteis,

00:51:47.350 --> 00:51:49.160
e comece a responder a perguntas como essa para nós.

00:51:49.160 --> 00:51:51.340
E há outras ferramentas que apresentaremos neste semestre

00:51:51.340 --> 00:51:52.990
que são ainda mais poderosos do que isso.

00:51:52.990 --> 00:51:56.770
Mas, por enquanto, é apenas uma ferramenta, na verdade, para desacelerar as coisas e não

00:51:56.770 --> 00:51:57.820
tem que mudar seu código.

00:51:57.820 --> 00:52:01.420
O fato de eu ter aquele painel à esquerda que apenas me mostrava que eu estava mudando

00:52:01.420 --> 00:52:04.150
value é apenas uma alternativa para printf, e eu posso

00:52:04.150 --> 00:52:06.820
atravesse-o um pouco mais devagar.

00:52:06.820 --> 00:52:10.580
Outras perguntas sobre depuração?

00:52:10.580 --> 00:52:11.080
Não?

00:52:11.080 --> 00:52:14.950
Deixe-me mostrar um exemplo final com este depurador aqui.

00:52:14.950 --> 00:52:16.750
E este também escrevi com antecedência.

00:52:16.750 --> 00:52:18.730
Deixe-me fechar buggy0.c.

00:52:18.730 --> 00:52:22.327
E deixe-me abrir buggy1.c, minha segunda versão.

00:52:22.327 --> 00:52:24.160
Deixe-me fechar a janela do meu terminal por um segundo

00:52:24.160 --> 00:52:26.350
e dar-lhe uma rápida visita a este programa, que

00:52:26.350 --> 00:52:28.030
da mesma forma, tem um erro.

00:52:28.030 --> 00:52:32.830
Agora, no início deste programa, algumas inclusões familiares, cs50.he stdio.h.

00:52:32.830 --> 00:52:34.730
Isso não é algo que vimos antes.

00:52:34.730 --> 00:52:36.190
É específico para este exemplo--

00:52:36.190 --> 00:52:38.830
uma função chamada getNegativeInt.

00:52:38.830 --> 00:52:41.043
Não recebe argumentos e retorna um número inteiro.

00:52:41.043 --> 00:52:41.710
O que isso faz?

00:52:41.710 --> 00:52:45.040
Ele literalmente obtém um número inteiro negativo, idealmente, do usuário.

00:52:45.040 --> 00:52:47.200
Curiosidade, porém, não funciona corretamente.

00:52:47.200 --> 00:52:50.090
Esse é o problema. getNegativeInt está quebrado no momento.

00:52:50.090 --> 00:52:51.470
Então, o que o main faz?

00:52:51.470 --> 00:52:54.130
Bem, main apenas chama essa função, não passando nada

00:52:54.130 --> 00:52:55.690
entre parênteses, sem entradas.

00:52:55.690 --> 00:52:58.240
E armazena o valor de retorno em i.

00:52:58.240 --> 00:53:00.260
E então ele apenas imprime i na tela.

00:53:00.260 --> 00:53:03.910
Então, honestamente, só de olhar para isso, me sinto confortável o suficiente

00:53:03.910 --> 00:53:06.365
com programação em C, acho que main está correto.

00:53:06.365 --> 00:53:07.990
Deixe-me apenas estipular, main está correto.

00:53:07.990 --> 00:53:09.698
Mas vai ter um bug aqui embaixo.

00:53:09.698 --> 00:53:11.210
Agora, qual é o bug aqui embaixo?

00:53:11.210 --> 00:53:14.830
Bem, deixe-me ver a implementação de getNegativeInt.

00:53:14.830 --> 00:53:18.970
Observe, esta primeira linha, 12, é idêntica ao protótipo aqui.

00:53:18.970 --> 00:53:22.690
O protótipo é meio estupidamente necessário aqui

00:53:22.690 --> 00:53:25.300
porque C lê as coisas de cima para baixo, da esquerda para a direita -

00:53:25.300 --> 00:53:26.690
o compilador tecnicamente faz.

00:53:26.690 --> 00:53:29.680
Então, se você fizer referência a getNegativeInt aqui, mas você

00:53:29.680 --> 00:53:33.490
não o implemente até aqui, e você não disse a C com antecedência

00:53:33.490 --> 00:53:36.820
que existirá, novamente, você obtém o erro que vimos na semana passada.

00:53:36.820 --> 00:53:39.010
Tudo bem, então como getNegativeInt funciona?

00:53:39.010 --> 00:53:40.960
Declaramos uma variável chamada n.

00:53:40.960 --> 00:53:43.540
Temos que fazer um loop while que faz o quê?

00:53:43.540 --> 00:53:47.110
Ele usa getInt, que vem com a biblioteca cs50, por semana.

00:53:47.110 --> 00:53:49.480
Ele solicita ao usuário um número inteiro negativo, entre aspas,

00:53:49.480 --> 00:53:51.670
e armazena o valor em n.

00:53:51.670 --> 00:53:56.800
Eu então faço tudo isso enquanto n é menor que 0, certo?

00:53:56.800 --> 00:54:00.400
Lembre-se, costumávamos fazer loop while na semana passada para garantir que o humano cooperasse

00:54:00.400 --> 00:54:03.970
e não nos dá o tipo errado de valor, seja positivo ou negativo

00:54:03.970 --> 00:54:04.970
ou alguma outra coisa.

00:54:04.970 --> 00:54:06.400
E então retornamos n.

00:54:06.400 --> 00:54:07.570
E há algumas sutilezas.

00:54:07.570 --> 00:54:12.970
Alguém se lembra-- ou tem uma intuição de por que declarei n na linha 14,

00:54:12.970 --> 00:54:15.790
em vez da linha 17?

00:54:15.790 --> 00:54:17.620
Isso é uma coisa específica do C.

00:54:17.620 --> 00:54:23.465
AUDIÊNCIA: [INAUDÍVEL]

00:54:23.465 --> 00:54:24.340
DAVID MALAN: Exatamente.

00:54:24.340 --> 00:54:27.610
Existe essa noção de escopo em C. E continuaremos a ver isso ao longo do tempo,

00:54:27.610 --> 00:54:32.590
por meio do qual, uma variável só existe dentro das chaves mais recentes

00:54:32.590 --> 00:54:33.560
que você abriu.

00:54:33.560 --> 00:54:36.910
Então, se eu declarei n aqui na linha 14, posso usá-lo

00:54:36.910 --> 00:54:40.900
em qualquer lugar entre as linhas 13 e 21 porque essas são as chaves mais próximas.

00:54:40.900 --> 00:54:43.540
Se, por outro lado, como você notou, se eu dissesse isso,

00:54:43.540 --> 00:54:49.180
int n é igual a getInt e assim por diante, e não tinha a linha atual 14,

00:54:49.180 --> 00:54:53.470
bem, n existiria dentro dessas chaves, mas não aqui, que

00:54:53.470 --> 00:54:55.340
é tarde demais e definitivamente não está aqui.

00:54:55.340 --> 00:54:59.480
Portanto, você só precisa declará-lo primeiro e depois usá-lo e reutilizá-lo como tal.

00:54:59.480 --> 00:55:01.545
Agora, deixe-me mostrar como posso depurar isso.

00:55:01.545 --> 00:55:03.170
Mas deixe-me mostrar-lhe os sintomas primeiro.

00:55:03.170 --> 00:55:04.930
Deixe-me abrir a janela do meu terminal.

00:55:04.930 --> 00:55:06.970
Deixe-me executar make buggy1.

00:55:06.970 --> 00:55:11.710
Compila OK, então não é algo bobo como um ponto e vírgula. ./buggy1,

00:55:11.710 --> 00:55:13.660
e me pedem um número inteiro negativo.

00:55:13.660 --> 00:55:15.280
Tudo bem, deixe-me dar menos 1 -

00:55:15.280 --> 00:55:16.710
Digitar.

00:55:16.710 --> 00:55:19.920
Bem, a função principal deve imprimir o que eu digitei,

00:55:19.920 --> 00:55:20.880
mas claramente não.

00:55:20.880 --> 00:55:21.880
Está me alertando novamente.

00:55:21.880 --> 00:55:23.830
Tudo bem, então talvez seja menos 2.

00:55:23.830 --> 00:55:24.330
Não?

00:55:24.330 --> 00:55:26.380
Talvez negativo 3.

00:55:26.380 --> 00:55:27.570
50?

00:55:27.570 --> 00:55:29.160
OK, então definitivamente está quebrado, certo?

00:55:29.160 --> 00:55:31.528
Parece logicamente estar fazendo o oposto.

00:55:31.528 --> 00:55:33.820
Agora, talvez você possa ver por que isso já está acontecendo.

00:55:33.820 --> 00:55:37.170
Estes são programas deliberadamente simples para fins de demonstração.

00:55:37.170 --> 00:55:38.470
Mas vamos fazer isso.

00:55:38.470 --> 00:55:41.037
Deixe-me ir em frente e definir um ponto de interrupção em main,

00:55:41.037 --> 00:55:42.870
mesmo que eu tenha certeza de que main está correto.

00:55:42.870 --> 00:55:45.810
Mas isso me ajuda a iniciar meu processo de pensamento-- começar com principal,

00:55:45.810 --> 00:55:47.010
e, em seguida, levá-lo de lá.

00:55:47.010 --> 00:55:51.840
Deixe-me executar agora, debug50 ./buggy1--

00:55:51.840 --> 00:55:52.920
Digitar.

00:55:52.920 --> 00:55:53.700
E vamos ver.

00:55:53.700 --> 00:55:56.880
Com esse ponto de interrupção agora, a GUI irá se reconfigurar.

00:55:56.880 --> 00:56:00.360
Vai pausar na linha 8 porque essa é a primeira linha interessante

00:56:00.360 --> 00:56:01.260
dentro do principal.

00:56:01.260 --> 00:56:03.780
Então eu poderia apenas colocar o ponto de interrupção na linha 8 também.

00:56:03.780 --> 00:56:06.480
É inteligente o suficiente para saber que se eu configurá-lo em 6,

00:56:06.480 --> 00:56:09.570
você realmente quer dizer a linha 8 porque essa é a primeira linha real do código.

00:56:09.570 --> 00:56:11.280
E observe, agora, o que acontece.

00:56:11.280 --> 00:56:15.780
Se eu passar por cima desta linha, observe que i, que no momento

00:56:15.780 --> 00:56:18.090
parece ter um valor padrão de 0--

00:56:18.090 --> 00:56:19.470
Mais sobre isso em outro momento.

00:56:19.470 --> 00:56:24.750
Mas se eu clicar em Step Over como antes, será solicitado um número inteiro negativo.

00:56:24.750 --> 00:56:25.750
Deixe-me digitar menos 1--

00:56:25.750 --> 00:56:27.300
Digitar.

00:56:27.300 --> 00:56:32.470
E agora, observe, não há destaque amarelo adicional.

00:56:32.470 --> 00:56:32.970
Por que?

00:56:32.970 --> 00:56:35.160
Onde estou atualmente preso, logicamente?

00:56:35.160 --> 00:56:37.937
AUDIÊNCIA: [INAUDÍVEL]

00:56:37.937 --> 00:56:40.770
DAVID MALAN: Sim, apenas logicamente, devo estar nesse loop do, while.

00:56:40.770 --> 00:56:43.560
E mesmo que você não entenda, como se essa fosse a única explicação.

00:56:43.560 --> 00:56:46.143
Se você continuar sendo solicitado, certamente há um loop acontecendo.

00:56:46.143 --> 00:56:49.270
Há apenas um loop no meu código, então provavelmente há um problema aí.

00:56:49.270 --> 00:56:52.900
Portanto, não posso simplesmente definir um ponto de interrupção no main e esperar que isso funcione.

00:56:52.900 --> 00:56:53.610
Então deixe-me apenas--

00:56:53.610 --> 00:56:56.280
deixe-me parar com o quadrado vermelho.

00:56:56.280 --> 00:56:58.860
E deixe-me pensar, tudo bem, em vez de...

00:56:58.860 --> 00:57:02.770
Ainda posso definir meu ponto de interrupção em main, mas deixe-me executar novamente o depurador.

00:57:02.770 --> 00:57:05.470
E desta vez, não ultrapasse essa linha de código,

00:57:05.470 --> 00:57:07.930
deixe-me entrar nessa linha de código.

00:57:07.930 --> 00:57:09.270
Então observe o que acontece agora.

00:57:09.270 --> 00:57:11.430
Em vez de clicar no segundo ícone aqui,

00:57:11.430 --> 00:57:14.610
deixe-me clicar no terceiro, cujo nome é, de fato, Step Into.

00:57:14.610 --> 00:57:17.880
E observe como o destaque amarelo não se move para a linha 9.

00:57:17.880 --> 00:57:21.930
Ele mergulha na linha 8-- a função na linha 8,

00:57:21.930 --> 00:57:25.170
assim, trazendo-me para a linha 17.

00:57:25.170 --> 00:57:28.270
É como ir para a próxima função.

00:57:28.270 --> 00:57:31.422
Agora, não se incomodou em fazer uma pausa na linha 12 ou 13 ou 14

00:57:31.422 --> 00:57:34.380
porque ainda não há nada intelectualmente interessante acontecendo.

00:57:34.380 --> 00:57:37.080
A parte suculenta realmente começa, ao que parece, na linha 17.

00:57:37.080 --> 00:57:40.980
Então, agora observe, n é minha variável no canto superior esquerdo.

00:57:40.980 --> 00:57:42.270
Se eu clicar--

00:57:42.270 --> 00:57:45.420
Eu não quero clicar em Step Into agora, no entanto.

00:57:45.420 --> 00:57:48.090
O que poderia dar errado se eu clicar em Step Into--

00:57:48.090 --> 00:57:52.480
ou o que isso faria que eu acho que não quero fazer?

00:57:52.480 --> 00:57:52.990
Sim?

00:57:52.990 --> 00:57:54.755
AUDIÊNCIA: [INAUDÍVEL]

00:57:54.755 --> 00:57:56.630
DAVID MALAN: Sim, entraria em getInt.

00:57:56.630 --> 00:57:59.620
Mas eu gostaria de pensar que a versão do getInt da equipe está correta,

00:57:59.620 --> 00:58:02.120
e esse não é o nosso problema hoje, então eu quero passar por cima disso.

00:58:02.120 --> 00:58:06.710
E observe agora no canto superior esquerdo que nada acontece ainda com o valor de n

00:58:06.710 --> 00:58:09.530
até que eu vá para a janela do terminal agora e digite algo

00:58:09.530 --> 00:58:10.670
como 1 negativo.

00:58:10.670 --> 00:58:14.600
Agora observe, ele pula para a linha 19, que é a próxima linha interessante.

00:58:14.600 --> 00:58:17.240
No canto superior esquerdo, n, de fato, é menos 1.

00:58:17.240 --> 00:58:19.160
E aqui é onde agora posso fazer uma pausa como humano

00:58:19.160 --> 00:58:22.760
e pense, tudo bem, enquanto n é menor que 0.

00:58:22.760 --> 00:58:25.280
Tudo bem, n, no canto superior esquerdo, é menos 1.

00:58:25.280 --> 00:58:27.830
Então tudo bem, enquanto menos 1 é menor que 0,

00:58:27.830 --> 00:58:29.780
bem, obviamente isso é verdade matematicamente.

00:58:29.780 --> 00:58:30.930
Então o que vai acontecer?

00:58:30.930 --> 00:58:32.130
É um loop do while.

00:58:32.130 --> 00:58:37.285
Então, quando eu clicar em Step Over novamente, ele irá para esta linha

00:58:37.285 --> 00:58:39.410
porque está no final do interior desse loop.

00:58:39.410 --> 00:58:42.710
E agora aqui, está passando de novo e de novo.

00:58:42.710 --> 00:58:44.240
Tudo bem, deixe-me fazer isso mais uma vez.

00:58:44.240 --> 00:58:45.980
Vou passar por cima, está bem?

00:58:45.980 --> 00:58:48.777
Vou digitar menos 2, e é exatamente a mesma coisa.

00:58:48.777 --> 00:58:50.360
Agora é minha chance, na linha amarela--

00:58:50.360 --> 00:58:51.260
OK, espere um minuto.

00:58:51.260 --> 00:58:53.450
2 negativo é obviamente menor que 0.

00:58:53.450 --> 00:58:56.080
Deixe-me tentar mais uma vez.

00:58:56.080 --> 00:58:57.570
Clique uma vez aqui.

00:58:57.570 --> 00:58:59.040
Tudo bem, deixe-me dar 50.

00:58:59.040 --> 00:59:05.020
E agora, OK, enquanto 50 é menor que 0, isso não é verdade,

00:59:05.020 --> 00:59:08.970
então o loop acabou porque não vai fazer isso enquanto 50 for menor que 0.

00:59:08.970 --> 00:59:09.730
Isso não é verdade.

00:59:09.730 --> 00:59:12.240
Agora observe, quando clico em Step Over mais uma vez,

00:59:12.240 --> 00:59:15.810
ele então termina o loop, mesmo que não haja mais nada a fazer.

00:59:15.810 --> 00:59:17.610
Agora está prestes a retornar n.

00:59:17.610 --> 00:59:21.360
Ele pula de volta para main, onde parei na linha 9.

00:59:21.360 --> 00:59:23.778
Agora imprime, na janela do meu terminal, o número 50.

00:59:23.778 --> 00:59:26.070
E espero que, neste ponto, para sua pergunta anterior,

00:59:26.070 --> 00:59:30.700
meu cérebro humano percebeu, oh, eu sou um idiota, como se eu tivesse virado minha placa lá.

00:59:30.700 --> 00:59:32.460
Então eu provavelmente-- deixe-me parar com isso.

00:59:32.460 --> 00:59:34.780
Eu provavelmente quero fazer algo assim.

00:59:34.780 --> 00:59:38.860
Se o objetivo é obter um número inteiro negativo, provavelmente quero dizer,

00:59:38.860 --> 00:59:45.070
enquanto n é, por exemplo, maior ou igual a 0 funcionaria.

00:59:45.070 --> 00:59:48.630
Então, enquanto n for maior ou igual a 0, continue fazendo isso.

00:59:48.630 --> 00:59:50.430
E essa é a lógica que eu queria expressar.

00:59:50.430 --> 00:59:53.733
Assim, o depurador evita que eu fique olhando para a tela, levantando a mão,

00:59:53.733 --> 00:59:54.900
tipo de perguntar a outra pessoa.

00:59:54.900 --> 00:59:58.650
Pelo menos neste caso, permite-me passar por isso a um ritmo mais saudável.

00:59:58.650 --> 01:00:03.000
Perguntas agora sobre debug50, que deve ser seu novo amigo, mesmo que não seja

01:00:03.000 --> 01:00:04.940
seu primeiro instinto após printf?

01:00:07.690 --> 01:00:09.190
Alguma pergunta sobre debug50?

01:00:09.190 --> 01:00:09.730
Não?

01:00:09.730 --> 01:00:13.960
Tudo bem, bem, há uma última técnica com a qual podemos equipá-lo aqui.

01:00:13.960 --> 01:00:17.470
E isso é, além de printf e um depurador, sem brincadeira,

01:00:17.470 --> 01:00:21.400
um pato de borracha é na verdade uma solução razoavelmente recomendada

01:00:21.400 --> 01:00:22.720
para encontrar bugs em seu código.

01:00:22.720 --> 01:00:24.640
À sua pergunta anterior, o pato dois não é

01:00:24.640 --> 01:00:26.390
vai resolver o problema para você.

01:00:26.390 --> 01:00:29.710
Mas se você já se perguntou por que esse carinha está aqui há tanto tempo,

01:00:29.710 --> 01:00:32.080
existe essa técnica, tem seu próprio artigo da Wikipédia

01:00:32.080 --> 01:00:33.760
da chamada depuração de pato de borracha.

01:00:33.760 --> 01:00:37.390
A ideia é que, se você estiver em seu dormitório,

01:00:37.390 --> 01:00:39.520
lutando com algum bug em seu código, printf

01:00:39.520 --> 01:00:42.820
não revelou a fonte para você, o depurador não está ajudando muito,

01:00:42.820 --> 01:00:46.960
honestamente, talvez ajudasse apenas sondar qual problema você está tendo.

01:00:46.960 --> 01:00:50.260
Semelhante a ir para o horário de expediente, conversar com um TA ou um professor,

01:00:50.260 --> 01:00:52.030
apenas passando por seus problemas porque

01:00:52.030 --> 01:00:54.730
em uma espécie de conversa com o pato sobre o fato

01:00:54.730 --> 01:01:00.550
que você está fazendo isso enquanto n é menor que 0, e então se for -

01:01:00.550 --> 01:01:01.180
espere um minuto.

01:01:01.180 --> 01:01:03.820
Eu sou um idiota, não só por falar com o pato de borracha.

01:01:03.820 --> 01:01:05.980
Você percebe, esperançosamente, ao se expressar,

01:01:05.980 --> 01:01:09.910
literalmente verbalmente, você provavelmente ouvirá com probabilidade diferente de zero,

01:01:09.910 --> 01:01:11.860
como algum ilógico em sua declaração.

01:01:11.860 --> 01:01:16.430
E apenas ouvindo as coisas, você perceberá como, oh, esse é o meu problema.

01:01:16.430 --> 01:01:19.720
E então, francamente, se você tem colegas de quarto, também pode usar um colega de quarto para isso.

01:01:19.720 --> 01:01:21.700
Mas o pato de borracha é apenas uma espécie de go-to

01:01:21.700 --> 01:01:24.700
quando seus colegas de quarto não têm interesse em seu conjunto de problemas C,

01:01:24.700 --> 01:01:28.150
falando algo através disso como tal.

01:01:28.150 --> 01:01:29.933
E esta é uma técnica inestimável.

01:01:29.933 --> 01:01:32.350
Reconheço que não costumo fazer isso tanto com um pato de borracha,

01:01:32.350 --> 01:01:34.510
mas idealmente com colegas, colegas humanos.

01:01:34.510 --> 01:01:38.260
Mas apenas falar sobre as coisas com frequência ajudará você a perceber,

01:01:38.260 --> 01:01:40.360
oh, eu disse algo ilógico.

01:01:40.360 --> 01:01:41.860
Agora posso voltar ao código.

01:01:41.860 --> 01:01:44.650
Portanto, não resolva problemas olhando para a tela

01:01:44.650 --> 01:01:46.240
infinitamente por minutos, por horas.

01:01:46.240 --> 01:01:48.100
Nesse ponto, é hora de uma pausa, hora

01:01:48.100 --> 01:01:50.475
ir embora, hora de falar com o pato, se você já

01:01:50.475 --> 01:01:52.900
esgotou algumas dessas outras ferramentas.

01:01:52.900 --> 01:01:55.330
Como um aparte, ao sair hoje no final da aula,

01:01:55.330 --> 01:01:59.020
temos, claramente, muitos patos de borracha para você.

01:01:59.020 --> 01:02:01.600
E tornou-se uma coisa ao longo dos anos, pelo menos

01:02:01.600 --> 01:02:05.770
entre outros, levar o pato com eles quando viajam e nos enviar fotos.

01:02:05.770 --> 01:02:10.480
Aqui, por exemplo, está o depurador de pato de borracha do CS50, também conhecido como DDB,

01:02:10.480 --> 01:02:15.940
para Duck Debugger, que é um trocadilho com um programa geek chamado GDB, o GNU

01:02:15.940 --> 01:02:18.740
Debugger, que é um software real para depuração.

01:02:18.740 --> 01:02:25.270
Este é o depurador do CS50 nas colinas de Porto Rico, também, aqui no mar.

01:02:25.270 --> 01:02:28.310
Ele fez o seu caminho para San Francisco aqui.

01:02:28.310 --> 01:02:30.640
Além disso, no Fisherman's Wharf pelos leões marinhos.

01:02:30.640 --> 01:02:31.660
Familiar?

01:02:31.660 --> 01:02:34.570
Aqui em Stanford, onde há um William Gates Computer Science

01:02:34.570 --> 01:02:38.950
edifício para ciência da computação, na estrada em SF no Google.

01:02:38.950 --> 01:02:41.650
E esta é a Fontana di Trevi em Roma.

01:02:41.650 --> 01:02:43.810
E por último, o Coliseu.

01:02:43.810 --> 01:02:46.990
Portanto, estaremos curiosos para ver nos próximos anos para onde seu pato dois viajará.

01:02:46.990 --> 01:02:49.120
Então isso foi um pouco.

01:02:49.120 --> 01:02:51.850
Por que não avançamos aqui e fazemos uma pequena pausa de 5 minutos?

01:02:51.850 --> 01:02:52.760
Ainda não há lanches.

01:02:52.760 --> 01:02:54.400
Você é bem-vindo para se levantar ou sentar.

01:02:54.400 --> 01:02:56.620
Voltaremos em cerca de cinco.

01:02:56.620 --> 01:03:00.020
Tudo bem, então estamos de volta.

01:03:00.020 --> 01:03:04.000
E se o objetivo, em última instância, hoje é entender melhor as coisas

01:03:04.000 --> 01:03:06.940
como strings para que possamos resolver problemas com texto,

01:03:06.940 --> 01:03:09.190
vamos considerar alguns tipos de dados mais simples

01:03:09.190 --> 01:03:11.290
primeiro, como podemos representá-los e, em seguida,

01:03:11.290 --> 01:03:14.290
veja se isso não nos leva a uma descoberta de como strings,

01:03:14.290 --> 01:03:17.330
e apenas o software moderno de hoje está usando coisas assim.

01:03:17.330 --> 01:03:21.850
Então, quando falamos na semana zero sobre representação de dados,

01:03:21.850 --> 01:03:25.930
tínhamos maneiras diferentes de fazer isso, em termos de binário e decimal,

01:03:25.930 --> 01:03:27.640
e unário par.

01:03:27.640 --> 01:03:30.520
Quando começamos a falar sobre o mesmo na semana passada em código,

01:03:30.520 --> 01:03:33.980
em vez disso, começamos a falar sobre tipos de dados.

01:03:33.980 --> 01:03:36.820
E esses tipos de dados eram uma maneira de dizer

01:03:36.820 --> 01:03:40.000
o computador, como você quer um número inteiro, você quer um caractere,

01:03:40.000 --> 01:03:44.260
você quer um valor de ponto flutuante, como um número real, ou mesmo uma string,

01:03:44.260 --> 01:03:45.070
como vimos?

01:03:45.070 --> 01:03:47.350
Mas acontece que os computadores, é claro,

01:03:47.350 --> 01:03:49.930
têm apenas quantidades finitas de recursos.

01:03:49.930 --> 01:03:53.740
Seu computador possui apenas uma quantidade fixa de memória ou RAM.

01:03:53.740 --> 01:03:55.910
E isso realmente tem implicações no mundo real.

01:03:55.910 --> 01:03:59.630
Por exemplo, aqui estão alguns dos tipos de dados que vimos até agora.

01:03:59.630 --> 01:04:04.090
E acontece que cada um deles em C tem um número específico

01:04:04.090 --> 01:04:05.650
de bits alocados a ele.

01:04:05.650 --> 01:04:08.350
Agora, reconhecidamente, isso pode variar de acordo com o sistema.

01:04:08.350 --> 01:04:10.850
Não é tanto o caso hoje em dia, mas por muitos anos,

01:04:10.850 --> 01:04:13.100
por décadas, os computadores foram ficando cada vez melhores.

01:04:13.100 --> 01:04:15.392
Os primeiros computadores podem ter usado menos bits

01:04:15.392 --> 01:04:16.600
para alguns desses tipos de dados.

01:04:16.600 --> 01:04:18.663
Computadores mais modernos podem usar mais bits.

01:04:18.663 --> 01:04:21.830
Portanto, os números que você está prestes a ver são exatamente onde estamos hoje.

01:04:21.830 --> 01:04:25.030
Portanto, quando se trata desses tipos de dados, um bool,

01:04:25.030 --> 01:04:29.020
que é verdadeiro ou falso, curiosamente, usa um byte inteiro,

01:04:29.020 --> 01:04:32.380
mesmo que isso seja um exagero porque para um bool, true ou false,

01:04:32.380 --> 01:04:33.940
você, é claro, só precisa de um bit.

01:04:33.940 --> 01:04:36.520
Mas acontece que, embora seja um desperdício usar

01:04:36.520 --> 01:04:39.938
oito bits, ou um byte, apenas para representar verdadeiro ou falso,

01:04:39.938 --> 01:04:41.230
é apenas mais fácil para computadores.

01:04:41.230 --> 01:04:42.820
Portanto, um bool tende a ser um byte.

01:04:42.820 --> 01:04:47.590
Um int, que temos usado muito, usa 4 bytes, normalmente, ou 32 bits.

01:04:47.590 --> 01:04:50.590
E se eu fizer algumas contas rápidas da semana zero, com 32 bits,

01:04:50.590 --> 01:04:54.040
você tem aproximadamente 4 bilhões de valores possíveis.

01:04:54.040 --> 01:04:56.290
Mas se você quiser representar positivo e negativo,

01:04:56.290 --> 01:04:59.710
isso significa que você pode representar cerca de 2 bilhões negativos, todo o caminho

01:04:59.710 --> 01:05:01.020
para 2 bilhões positivos.

01:05:01.020 --> 01:05:02.770
Então esse é o intervalo, normalmente, com ints.

01:05:02.770 --> 01:05:06.820
Se são poucos números para você, acontece que existem coisas chamadas longs.

01:05:06.820 --> 01:05:10.120
E longs usam 64 bits, o que permite que você tenha

01:05:10.120 --> 01:05:13.220
como um quintilhão de possibilidades,

01:05:13.220 --> 01:05:15.730
que é muito, certamente, muito mais do que 4 bilhões.

01:05:15.730 --> 01:05:17.410
Então, às vezes, você pode usar um longo.

01:05:17.410 --> 01:05:18.670
Mas mesmo isso é finito.

01:05:18.670 --> 01:05:21.640
E assim como discutimos no final da semana passada,

01:05:21.640 --> 01:05:23.980
coisas ruins podem acontecer se você fizer certas suposições

01:05:23.980 --> 01:05:27.220
quanto aos dados por causa de coisas como estouro de número inteiro ou algo semelhante,

01:05:27.220 --> 01:05:28.330
onde as coisas acontecem.

01:05:28.330 --> 01:05:31.538
Então há um float, que é um número real, algo com um ponto decimal.

01:05:31.538 --> 01:05:36.040
Por convenção, são 4 bytes ou 32 bits, o que lhe dá, em resumo,

01:05:36.040 --> 01:05:37.810
apenas uma quantidade específica de precisão.

01:05:37.810 --> 01:05:41.620
Não dita necessariamente quantos números à esquerda ou à direita.

01:05:41.620 --> 01:05:45.250
No agregado, em última análise, você tem,

01:05:45.250 --> 01:05:47.650
4 bilhões de permutações possíveis ainda.

01:05:47.650 --> 01:05:50.110
Se você precisa de mais precisão para fins científicos, médicos,

01:05:50.110 --> 01:05:54.790
para aplicativos financeiros, você pode usar 8 bytes, também conhecido como duplo,

01:05:54.790 --> 01:05:57.700
que apenas lhe dá mais dígitos de precisão.

01:05:57.700 --> 01:06:01.360
Eles acabam ficando imprecisos de acordo com o exemplo que vimos na semana passada,

01:06:01.360 --> 01:06:03.610
mas pelo menos leva você mais adiante.

01:06:03.610 --> 01:06:07.930
Como um aparte, em aplicações realmente importantes, em finanças,

01:06:07.930 --> 01:06:10.030
na medicina, nas operações militares e na

01:06:10.030 --> 01:06:12.640
como onde você realmente não pode ter erros de arredondamento--

01:06:12.640 --> 01:06:17.470
Para encurtar a história, os humanos desenvolveram bibliotecas em C e outras linguagens

01:06:17.470 --> 01:06:19.317
que usam mais, inclusive, de 8 bytes.

01:06:19.317 --> 01:06:22.150
Portanto, existem soluções para esses problemas, mas são sempre finitas.

01:06:22.150 --> 01:06:24.070
Você tem que escolher um limite superior.

01:06:24.070 --> 01:06:27.070
Depois, há char, que vimos brevemente na semana passada quando perguntei

01:06:27.070 --> 01:06:29.470
o usuário para y ou n, para sim ou não.

01:06:29.470 --> 01:06:32.470
E então há uma string, que vou propor como um ponto de interrogação

01:06:32.470 --> 01:06:34.360
porque uma string depende totalmente.

01:06:34.360 --> 01:06:35.380
Tipo, Oi!

01:06:35.380 --> 01:06:38.890
HI, ponto de exclamação, parece ser três bytes.

01:06:38.890 --> 01:06:41.140
DAVID, parece ser cinco.

01:06:41.140 --> 01:06:45.400
Portanto, as strings, claramente, são variáveis ​​com base no que você ou o tipo humano.

01:06:45.400 --> 01:06:48.140
Portanto, veremos o que isso significa daqui a pouco.

01:06:48.140 --> 01:06:51.580
Isso, porém, é o que está dentro do seu Mac, seu PC, seu telefone.

01:06:51.580 --> 01:06:53.680
Pode não parecer exatamente assim, mas é

01:06:53.680 --> 01:06:56.187
um módulo de memória para um computador moderno.

01:06:56.187 --> 01:06:57.520
E vamos em frente e usar isso.

01:06:57.520 --> 01:06:59.920
Realmente, é apenas representativo da quantidade finita de memória

01:06:59.920 --> 01:07:01.360
que qualquer computador, de fato, tem.

01:07:01.360 --> 01:07:06.160
Vamos ampliar um desses pequenos chips pretos na placa de circuito aqui.

01:07:06.160 --> 01:07:10.180
Aumente o zoom e deixe-me propor que este retângulo realmente representa

01:07:10.180 --> 01:07:14.380
algum número de bytes, como escondido dentro deste pequeno circuito preto

01:07:14.380 --> 01:07:16.750
na placa é talvez, eu não sei, um gigabyte,

01:07:16.750 --> 01:07:19.300
um bilhão de bytes, talvez 100 bytes-- algum número de bytes.

01:07:19.300 --> 01:07:21.258
Depende totalmente do computador e de quanto

01:07:21.258 --> 01:07:22.700
você pagou pelo stick de memória.

01:07:22.700 --> 01:07:27.850
Mas se houver um número finito de bytes implementados fisicamente de alguma forma

01:07:27.850 --> 01:07:30.327
digitalmente dentro deste hardware, bem, então

01:07:30.327 --> 01:07:32.410
é lógico que poderíamos numerar esses bytes.

01:07:32.410 --> 01:07:36.940
Podemos decidir arbitrariamente que o canto superior esquerdo é o número do byte

01:07:36.940 --> 01:07:38.800
um, ou realmente byte número zero.

01:07:38.800 --> 01:07:41.170
O próximo a ele é o número um, depois o número dois,

01:07:41.170 --> 01:07:43.450
número 3, ponto, ponto, ponto, número 2 bilhões

01:07:43.450 --> 01:07:46.090
ou o que quer que seja, por maior que seja essa memória.

01:07:46.090 --> 01:07:50.530
Portanto, se você usar uma variável em um programa C, será apenas um byte.

01:07:50.530 --> 01:07:54.190
Como um char, pode ser literalmente armazenado no canto superior esquerdo

01:07:54.190 --> 01:07:55.120
da memória.

01:07:55.120 --> 01:07:57.760
Na prática, você não se importa onde, fisicamente, está.

01:07:57.760 --> 01:07:59.830
Mas, na verdade, a interpretação do artista seria

01:07:59.830 --> 01:08:02.872
isso-- um char pode usar um desses bytes únicos

01:08:02.872 --> 01:08:04.330
algures na memória do computador.

01:08:04.330 --> 01:08:07.450
Se você usar um int, que é de 4 bytes, isso lhe daria

01:08:07.450 --> 01:08:10.840
4 bytes, contíguos-- da esquerda para a direita, de cima para baixo.

01:08:10.840 --> 01:08:13.274
Mas todos os 32 bits estariam próximos um do outro

01:08:13.274 --> 01:08:16.149
então o computador sabe que aqueles, de fato, todos pertencem ao mesmo int.

01:08:16.149 --> 01:08:18.680
Se você precisar de um longo, ou um duplo para esse assunto,

01:08:18.680 --> 01:08:21.140
então você pode usar 8 bytes completos neste caso.

01:08:21.140 --> 01:08:23.439
E você continua usando e usando essa memória,

01:08:23.439 --> 01:08:26.170
como uma tela, quase no Photoshop

01:08:26.170 --> 01:08:29.845
ou uma planilha onde você pode apenas mover pixels ou mover dados,

01:08:29.845 --> 01:08:31.720
isso é realmente o que a memória do seu computador é,

01:08:31.720 --> 01:08:36.702
uma tela para armazenar informações em unidades de bytes ou 8 bits.

01:08:36.702 --> 01:08:39.160
Agora, não precisamos ficar olhando para essas placas de circuito.

01:08:39.160 --> 01:08:41.287
Podemos abstraí-lo, como costumamos fazer.

01:08:41.287 --> 01:08:43.120
E vamos em frente e ampliar esta grade,

01:08:43.120 --> 01:08:45.740
apenas para considerar algumas variáveis ​​muito específicas.

01:08:45.740 --> 01:08:49.180
Deixe-me aumentar o zoom e agora vejo menos, mas caixas maiores

01:08:49.180 --> 01:08:51.580
na tela, cada um dos quais, novamente, representa um byte.

01:08:51.580 --> 01:08:55.130
E agora deixe-me propor que brinquemos com algum código real.

01:08:55.130 --> 01:08:58.029
Então aqui em C, embora sem um programa completo,

01:08:58.029 --> 01:09:01.060
são três ints-- score1, score2, score3.

01:09:01.060 --> 01:09:07.359
Eu, coincidentemente, dei a mim mesmo duas pontuações em torno de 72 e 73,

01:09:07.359 --> 01:09:09.040
e, em seguida, uma pontuação muito baixa em 33.

01:09:09.040 --> 01:09:12.048
Claro, na semana passada ou duas semanas atrás, isso teria sido alto.

01:09:12.048 --> 01:09:13.840
Mas agora estamos lidando com inteiros reais.

01:09:13.840 --> 01:09:17.750
Portanto, essas são três pontuações mais ou menos em meus questionários ou testes ou similares.

01:09:17.750 --> 01:09:19.250
Então deixe-me ir para o VS Code aqui.

01:09:19.250 --> 01:09:22.210
E vamos fazer um programa chamado scores.c.

01:09:22.210 --> 01:09:24.399
Vou escrever, code scores.c.

01:09:24.399 --> 01:09:26.149
Isso vai me dar o meu novo arquivo.

01:09:26.149 --> 01:09:28.420
E deixe-me ir em frente e implementar algo assim.

01:09:28.420 --> 01:09:34.149
Incluir stdio.h, int main(void) e, em seguida, aqui dentro,

01:09:34.149 --> 01:09:37.689
deixe-me fazer int score1 será 72.

01:09:37.689 --> 01:09:40.029
A pontuação interna2 será 73.

01:09:40.029 --> 01:09:43.149
E int score3 será 33.

01:09:43.149 --> 01:09:45.460
E então deixe-me fazer algo como escrever um programa

01:09:45.460 --> 01:09:48.043
para tirar a média das notas dos meus três testes juntos, algo assim.

01:09:48.043 --> 01:09:52.240
Deixe-me fazer printf, entre aspas, minha média é--

01:09:52.240 --> 01:09:56.470
e eu vou seguir em frente e fazer, digamos, %i, /n.

01:09:56.470 --> 01:09:58.290
E agora, deixe-me inserir os resultados.

01:09:58.290 --> 01:10:00.040
E isso é uma espécie de matemática do ensino fundamental agora.

01:10:00.040 --> 01:10:02.210
Como faço para calcular a média de três valores?

01:10:02.210 --> 01:10:09.110
Bem, assim como no papel, posso fazer score1 mais score2 mais score3

01:10:09.110 --> 01:10:12.830
entre parênteses, por ordem das operações, dividido por 3,

01:10:12.830 --> 01:10:14.457
já que há três pontuações totais.

01:10:14.457 --> 01:10:16.040
Tudo bem, então eu acho que isso dá certo.

01:10:16.040 --> 01:10:19.040
E, de fato, você pode usar parênteses e operadores como mais em seu código

01:10:19.040 --> 01:10:23.180
assim em C. Deixe-me ir em frente agora e fazer pontuações.

01:10:23.180 --> 01:10:24.327
Nenhum erro de sintaxe.

01:10:24.327 --> 01:10:25.910
Então está bom, não falta nada aí.

01:10:25.910 --> 01:10:28.850
E agora deixe-me fazer ./scores e ver qual é a minha média de teste.

01:10:28.850 --> 01:10:32.270
Tudo bem, não é ótimo, mas acho que ainda assim passei.

01:10:32.270 --> 01:10:36.050
E, de fato, minha média aqui é 59.

01:10:36.050 --> 01:10:38.360
É precisamente 59 embora?

01:10:38.360 --> 01:10:39.140
Bem vamos ver.

01:10:39.140 --> 01:10:42.110
Vamos, na verdade, em vez de usar um int, que tal irmos em frente

01:10:42.110 --> 01:10:44.870
e usar algo como um valor de ponto flutuante aqui?

01:10:44.870 --> 01:10:46.250
E deixe-me ir em frente e fazer isso.

01:10:46.250 --> 01:10:48.710
Então deixe-me recompilar meu código, fazer pontuações.

01:10:48.710 --> 01:10:50.600
Huh, tudo bem, eu tenho um problema.

01:10:50.600 --> 01:10:52.340
Deixe-me ampliar a janela do meu terminal.

01:10:52.340 --> 01:10:54.710
Nós não vimos este, necessariamente, antes.

01:10:54.710 --> 01:10:56.510
Mas erro na linha 9.

01:10:56.510 --> 01:11:00.410
Format especifica o tipo double, que é bastante preciso,

01:11:00.410 --> 01:11:02.180
mas o argumento tem tipo int.

01:11:02.180 --> 01:11:03.300
Então o que isso quer dizer?

01:11:03.300 --> 01:11:06.508
Bem, está me mostrando com esses rabiscos verdes que algo está errado entre

01:11:06.508 --> 01:11:09.060
o %f e essa coisa aqui.

01:11:09.060 --> 01:11:13.020
Bem, à esquerda, estou sugerindo um flutuador, ou um duplo.

01:11:13.020 --> 01:11:16.835
À direita, porém, que tipo de dados são score1, score2, score3?

01:11:16.835 --> 01:11:17.960
Tudo bem, então eles são ints.

01:11:17.960 --> 01:11:19.583
Então clang não gosta disso.

01:11:19.583 --> 01:11:22.250
O compilador simplesmente não gosta que eu esteja usando ints à direita,

01:11:22.250 --> 01:11:24.170
mas eu quero carros alegóricos à esquerda.

01:11:24.170 --> 01:11:26.670
Portanto, haverá diferentes maneiras de resolver isso.

01:11:26.670 --> 01:11:29.870
Uma maneira seria simplesmente ignorar o problema como fiz originalmente,

01:11:29.870 --> 01:11:32.450
e apenas volte para %i.

01:11:32.450 --> 01:11:38.330
Ou, como um aparte, %d geralmente é uma alternativa a %i para um número decimal.

01:11:38.330 --> 01:11:42.358
Mas usamos %i porque soa como int, então %i está bem aqui também.

01:11:42.358 --> 01:11:44.150
Mas não quero apenas evitar o problema.

01:11:44.150 --> 01:11:46.500
Eu quero realmente exibir um valor de ponto flutuante.

01:11:46.500 --> 01:11:47.730
Então, como posso consertar isso?

01:11:47.730 --> 01:11:50.272
Bem, acontece que posso resolver isso de algumas maneiras diferentes.

01:11:50.272 --> 01:11:53.990
O mais simples é apenas garantir que pelo menos um número à direita

01:11:53.990 --> 01:11:59.330
é um valor de ponto flutuante, como 3,0 em vez de apenas 3.

01:11:59.330 --> 01:12:01.700
Agora acho que o clang ficará mais feliz.

01:12:01.700 --> 01:12:03.320
Deixe-me fazer pontuações--

01:12:03.320 --> 01:12:04.400
Digitar.

01:12:04.400 --> 01:12:05.330
E, de fato, está tudo bem.

01:12:05.330 --> 01:12:05.930
Por que?

01:12:05.930 --> 01:12:10.050
Assim que você tiver pelo menos mais um tipo de dados preciso à direita,

01:12:10.050 --> 01:12:13.170
apenas trata tudo, nesse ponto, como valor de ponto flutuante

01:12:13.170 --> 01:12:14.330
para que a matemática funcione.

01:12:14.330 --> 01:12:17.720
Então ./scores, Enter-- e agora, lá vamos nós, certo?

01:12:17.720 --> 01:12:20.390
Alguns de nós podem realmente querer esse 1/3 de ponto.

01:12:20.390 --> 01:12:21.980
Nossa média não foi de 59.

01:12:21.980 --> 01:12:25.010
É 59 1/3, como neste caso aqui.

01:12:25.010 --> 01:12:26.750
Tudo bem, então nós resolvemos isso lá.

01:12:26.750 --> 01:12:30.890
Como um aparte, porém, há uma outra técnica para mostrar aqui.

01:12:30.890 --> 01:12:33.320
Se você não queria mudar para 3.0 porque é

01:12:33.320 --> 01:12:36.410
um pouco estranho, porque havia literalmente três pontuações,

01:12:36.410 --> 01:12:38.760
não é como se precisasse ter um ponto decimal,

01:12:38.760 --> 01:12:43.970
você também pode converter explicitamente o 3 em um float

01:12:43.970 --> 01:12:46.230
dizendo, entre parênteses, float.

01:12:46.230 --> 01:12:48.050
Isso é o que se chama typecasting.

01:12:48.050 --> 01:12:51.840
E isso apenas converterá a coisa logo depois para esse tipo de dados,

01:12:51.840 --> 01:12:52.560
Se for possível.

01:12:52.560 --> 01:12:56.970
Então, se eu fizer isso de novo, faça pontuações, sem erros agora. ./scores, e eu recebo,

01:12:56.970 --> 01:12:59.960
na verdade, o mesmo resultado. Há um problema de arredondamento aqui,

01:12:59.960 --> 01:13:03.650
mas sabemos que o arredondamento está relacionado com a imprecisão da semana passada.

01:13:03.650 --> 01:13:06.980
Por enquanto, deixe-me ficar feliz com meus 59,3 algo.

01:13:06.980 --> 01:13:08.360
Eu vou levar isso por agora.

01:13:08.360 --> 01:13:14.660
Mas isso é o mais próximo de uma resposta correta boa o suficiente para mim agora.

01:13:14.660 --> 01:13:15.942
Mas como eu...

01:13:15.942 --> 01:13:18.650
pense agora, o que está acontecendo dentro da memória do computador?

01:13:18.650 --> 01:13:19.310
Bem, vamos considerar.

01:13:19.310 --> 01:13:20.643
Aqui está a mesma grade de memória.

01:13:20.643 --> 01:13:22.490
Cada caixa representa um byte.

01:13:22.490 --> 01:13:25.790
Onde estão score1, score2 e score3 em minha memória?

01:13:25.790 --> 01:13:28.790
Bem, score1, deixe-me propor, está no canto superior esquerdo.

01:13:28.790 --> 01:13:32.060
Mas está ocupando quatro caixas de 4 bytes.

01:13:32.060 --> 01:13:34.842
Score2 provavelmente termina ao lado dele na memória,

01:13:34.842 --> 01:13:36.800
no entanto, nem sempre será esse o caso,

01:13:36.800 --> 01:13:38.180
mas escolhi exemplos simples.

01:13:38.180 --> 01:13:40.910
73 está próximo a ele, também ocupando 4 bytes.

01:13:40.910 --> 01:13:45.320
E, finalmente, 33 está no score3, lá embaixo.

01:13:45.320 --> 01:13:48.343
Agora, se realmente olharmos para a memória do computador,

01:13:48.343 --> 01:13:50.510
olhe para ele com algum tipo de microscópio ou similar,

01:13:50.510 --> 01:13:54.110
na verdade há 32 bits, 32 bits, 32 bits

01:13:54.110 --> 01:13:59.308
em cada um desses quatro grupos de quatro bytes que representam esses valores.

01:13:59.308 --> 01:14:01.100
Mas, novamente, para os propósitos de hoje em diante, nós

01:14:01.100 --> 01:14:03.308
realmente não precisa pensar repetidamente em binário.

01:14:03.308 --> 01:14:05.940
É apenas, de fato, esses números decimais sendo armazenados lá.

01:14:05.940 --> 01:14:08.240
Mas eu afirmo agora, este não é o melhor design.

01:14:08.240 --> 01:14:11.300
Mesmo que você nunca tenha programado antes do CS50,

01:14:11.300 --> 01:14:13.220
o que você está vendo aqui na tela,

01:14:13.220 --> 01:14:16.970
como um trecho, em que sentido esse design talvez seja ruim, mesmo que seja

01:14:16.970 --> 01:14:19.960
uma maneira correta de armazenar três pontuações de teste?

01:14:19.960 --> 01:14:20.960
O que há de ruim aqui?

01:14:20.960 --> 01:14:21.882
Sim?

01:14:21.882 --> 01:14:26.220
AUDIÊNCIA: Quanto mais pontuações você tiver, mais você [INAUDÍVEL]..

01:14:26.220 --> 01:14:28.950
DAVID MALAN: Sim, sempre faça exatamente o que você fez - extrapole

01:14:28.950 --> 01:14:31.740
a 4 pontuações, 5 pontuações 50 pontuações.

01:14:31.740 --> 01:14:34.020
Isso não pode ser tão bem projetado porque agora você está

01:14:34.020 --> 01:14:36.300
vai ter 4 linhas de código, 5 linhas de código,

01:14:36.300 --> 01:14:38.550
50 linhas de código quase idênticas,

01:14:38.550 --> 01:14:40.770
exceto por esse número arbitrário que estamos

01:14:40.770 --> 01:14:42.430
atualização no final da variável.

01:14:42.430 --> 01:14:44.940
Então, de fato, provavelmente haverá uma melhor

01:14:44.940 --> 01:14:48.690
maneira, embora, pelo menos em C, ainda não tenhamos visto essa técnica.

01:14:48.690 --> 01:14:52.440
Mas a solução, de hoje em diante, será algo chamado array.

01:14:52.440 --> 01:14:57.180
Uma matriz é uma maneira de armazenar seus dados de volta

01:14:57.180 --> 01:15:00.630
para trás para trás na memória do computador de tal forma

01:15:00.630 --> 01:15:03.960
que você pode acessar cada membro individual facilmente.

01:15:03.960 --> 01:15:08.530
Em outras palavras, com uma matriz, você pode fazer algo assim.

01:15:08.530 --> 01:15:12.300
Em vez de dizer int score1, int score2, int score3,

01:15:12.300 --> 01:15:15.790
dando a cada um um valor, você pode primeiro dizer ao computador,

01:15:15.790 --> 01:15:18.330
por favor me dê uma variável chamada pontuações--

01:15:18.330 --> 01:15:20.700
plural, embora você possa chamá-lo do que quiser--

01:15:20.700 --> 01:15:24.090
de tamanho três, cada um dos quais será um número inteiro.

01:15:24.090 --> 01:15:28.680
Ou seja, é assim que você declara um array em C que terá

01:15:28.680 --> 01:15:30.930
espaço suficiente para armazenar três números inteiros.

01:15:30.930 --> 01:15:34.540
Dito de outra forma, esta é a maneira técnica de dizer ao computador,

01:15:34.540 --> 01:15:38.880
por favor me dê 12 bytes no total--

01:15:38.880 --> 01:15:42.660
3 vezes 4 cada para um int, então me dê 12 bytes no total.

01:15:42.660 --> 01:15:44.640
E o que o computador vai fazer é garantir

01:15:44.640 --> 01:15:47.350
que eles estão lado a lado na memória do computador.

01:15:47.350 --> 01:15:49.360
E isso será útil em apenas um momento.

01:15:49.360 --> 01:15:51.820
Então deixe-me ir em frente e fazer algo útil com isso.

01:15:51.820 --> 01:15:53.640
Deixe-me armazenar três pontuações reais.

01:15:53.640 --> 01:15:58.500
Aqui está como eu poderia armazenar essas mesmas pontuações numéricas nesta matriz.

01:15:58.500 --> 01:16:03.040
A sintaxe é um pouco diferente, mas há uma variável chamada pontuações.

01:16:03.040 --> 01:16:05.010
Mas se você quiser ir para o primeiro local,

01:16:05.010 --> 01:16:08.520
a partir de hoje, você usa colchetes e vai para o local 0

01:16:08.520 --> 01:16:13.080
primeiro, porque as coisas em C são indexadas em 0, por assim dizer,

01:16:13.080 --> 01:16:14.280
você começa a contar em 0.

01:16:14.280 --> 01:16:16.410
O primeiro int está em [0].

01:16:16.410 --> 01:16:18.030
O segundo int está em [1].

01:16:18.030 --> 01:16:19.530
O terceiro int está em [2].

01:16:19.530 --> 01:16:20.730
Então não é um, dois, três.

01:16:20.730 --> 01:16:22.090
É literalmente 0, 1, 2.

01:16:22.090 --> 01:16:24.090
E isso não é algo sobre o qual você tem controle.

01:16:24.090 --> 01:16:26.250
Você deve começar em 0.

01:16:26.250 --> 01:16:29.940
Portanto, essas linhas agora criam uma matriz de tamanho três,

01:16:29.940 --> 01:16:33.510
e então insira um, dois, três valores nesse array.

01:16:33.510 --> 01:16:37.770
Mas a vantagem agora é que você só tem um nome de variável para lembrar.

01:16:37.770 --> 01:16:39.240
É chamado apenas de pontuações.

01:16:39.240 --> 01:16:43.380
Sim, você precisa entrar no array para obter valores individuais.

01:16:43.380 --> 01:16:46.618
Você precisa indexá-lo usando esses colchetes.

01:16:46.618 --> 01:16:48.660
Mas pelo menos você não tem essa abordagem hackeada

01:16:48.660 --> 01:16:53.050
de declarar uma variável separada para cada um desses valores.

01:16:53.050 --> 01:16:56.070
Então deixe-me voltar para scores.c aqui.

01:16:56.070 --> 01:16:57.580
E deixe-me propor que eu faça isso.

01:16:57.580 --> 01:17:00.580
Deixe-me usar a mesma ideia para fazer o seguinte.

01:17:00.580 --> 01:17:02.580
Deixe-me me livrar desses três números inteiros separados.

01:17:02.580 --> 01:17:06.210
Deixe-me dar a mim mesmo uma matriz de pontuações int de tamanho 3.

01:17:06.210 --> 01:17:10.470
E então a pontuação [0] será, como antes, 72.

01:17:10.470 --> 01:17:14.070
A pontuação[1] será 73.

01:17:14.070 --> 01:17:16.830
E a pontuação[2] será 33.

01:17:16.830 --> 01:17:18.780
E deixa eu me livrar do pontinho aí.

01:17:18.780 --> 01:17:23.490
Tudo bem, então agora, se eu for em frente e executar isso novamente com pontuações feitas -

01:17:23.490 --> 01:17:24.642
Digitar.

01:17:24.642 --> 01:17:29.060
Huh, o que eu fiz de errado aqui?

01:17:29.060 --> 01:17:31.680
Acho que me precipitei um pouco demais.

01:17:31.680 --> 01:17:36.100
Deixe-me aumentar minha janela de terminal.

01:17:36.100 --> 01:17:38.830
Vamos nos concentrar na linha 10 aqui, primeiro.

01:17:38.830 --> 01:17:42.310
Erro, uso de identificador não declarado, score1.

01:17:42.310 --> 01:17:44.170
O que eu fiz aqui que foi idiota?

01:17:44.170 --> 01:17:45.430
Sim?

01:17:45.430 --> 01:17:47.440
AUDIÊNCIA: Você não declarou uma variável.

01:17:47.440 --> 01:17:49.420
DAVID MALAN: Certo, então não declarei score1.

01:17:49.420 --> 01:17:50.530
Eu tenho um código antigo.

01:17:50.530 --> 01:17:53.798
Então eu meio que, honestamente, me adiantei aqui, nem mesmo intencionalmente.

01:17:53.798 --> 01:17:56.090
Então deixe-me ir em frente e encolher minha janela de terminal novamente.

01:17:56.090 --> 01:17:57.740
Eu preciso terminar meu pensamento aqui.

01:17:57.740 --> 01:17:58.960
Então deixe-me limpar meu terminal.

01:17:58.960 --> 01:18:04.960
E deixe-me mudar isso agora para pontuações[0] mais pontuações[1] mais

01:18:04.960 --> 01:18:05.610
pontuações[2].

01:18:05.610 --> 01:18:07.360
Portanto, é um pouco mais detalhado porque eu

01:18:07.360 --> 01:18:10.040
tem esses colchetes, por assim dizer.

01:18:10.040 --> 01:18:12.220
Mas acho que agora meu código é consistente.

01:18:12.220 --> 01:18:13.870
Então deixe-me fazer pontuações agora.

01:18:13.870 --> 01:18:14.950
Agora compila.

01:18:14.950 --> 01:18:19.870
./scores me dá, de fato, a mesma média aproximada com esses mesmos valores.

01:18:19.870 --> 01:18:24.280
Tudo bem, então deixe-me ir em frente e talvez melhorar isso um pouco.

01:18:24.280 --> 01:18:26.920
É um pouco bobo ter que escrever um programa especial apenas

01:18:26.920 --> 01:18:31.610
para verificar sua média de três pontuações de teste como 72, 73, 33.

01:18:31.610 --> 01:18:33.550
Por que eu realmente não faço o programa dinâmico

01:18:33.550 --> 01:18:37.250
e pedir ao humano essas pontuações?

01:18:37.250 --> 01:18:39.140
Então, em vez disso, deixe-me fazer isso.

01:18:39.140 --> 01:18:43.480
Que tal nos livrarmos do 72 e mudarmos isso para getInt.

01:18:43.480 --> 01:18:46.300
E vou apenas solicitar ao usuário uma pontuação.

01:18:46.300 --> 01:18:52.510
Deixe-me me livrar do 73 e fazer com que seja uma pontuação getInt, entre aspas.

01:18:52.510 --> 01:18:56.560
E, finalmente, livre-se do 33 e substitua-o por getInt, entre aspas,

01:18:56.560 --> 01:18:57.670
pontuação.

01:18:57.670 --> 01:19:03.680
getInt é uma coisa CS50 por enquanto, então eu preciso incluir cs50.h, como sempre.

01:19:03.680 --> 01:19:05.650
Mas acho que agora é um programa melhor

01:19:05.650 --> 01:19:08.680
porque agora posso compilar uma vez, posso até compartilhar com meus amigos.

01:19:08.680 --> 01:19:12.490
E agora qualquer um de nós pode obter uma média de três notas em algum teste de classe.

01:19:12.490 --> 01:19:15.190
Eles não precisam saber o código ou reescrever o código apenas

01:19:15.190 --> 01:19:16.910
para digitar suas pontuações.

01:19:16.910 --> 01:19:19.150
Portanto, faça pontuações trabalhadas.

01:19:19.150 --> 01:19:25.120
./scores, agora posso digitar o que quiser-- talvez seja 72, 73, 33,

01:19:25.120 --> 01:19:26.320
ainda obter a mesma resposta.

01:19:26.320 --> 01:19:31.210
Ou talvez eu esteja tendo um semestre melhor, 100, 100, talvez 99,

01:19:31.210 --> 01:19:33.520
e agora ainda temos uma pontuação bastante alta lá.

01:19:33.520 --> 01:19:34.600
Mas agora é dinâmico.

01:19:34.600 --> 01:19:36.080
Agora você não precisa do código-fonte.

01:19:36.080 --> 01:19:37.747
Você não precisa recompilar o programa.

01:19:37.747 --> 01:19:39.670
Só vai funcionar de novo e de novo.

01:19:39.670 --> 01:19:41.090
Mas isso também.

01:19:41.090 --> 01:19:43.660
Deixe-me propor que este código está correto se eu

01:19:43.660 --> 01:19:45.910
deseja obter três pontuações do usuário.

01:19:45.910 --> 01:19:50.950
Mas essas linhas destacadas agora, de 6 a 9, são bem desenhadas,

01:19:50.950 --> 01:19:53.170
Você diria?

01:19:53.170 --> 01:19:53.680
Sim?

01:19:53.680 --> 01:19:54.898
AUDIÊNCIA: Você pode fazer um loop?

01:19:54.898 --> 01:19:55.940
DAVID MALAN: Sim, certo?

01:19:55.940 --> 01:19:58.220
Isso é-- podemos usar um loop, é o spoiler aqui.

01:19:58.220 --> 01:19:58.820
Por que?

01:19:58.820 --> 01:20:01.590
Quero dizer, meu Deus, é como o mesmo código de novo e de novo e de novo.

01:20:01.590 --> 01:20:03.465
A única coisa que muda é o número.

01:20:03.465 --> 01:20:06.170
E isso deveria ter algum cheiro de código novamente,

01:20:06.170 --> 01:20:09.080
porque se eu continuar digitando a mesma coisa de novo e de novo,

01:20:09.080 --> 01:20:11.810
isso é claramente uma oportunidade de projetar algo melhor.

01:20:11.810 --> 01:20:13.650
Então deixe-me fazer isso.

01:20:13.650 --> 01:20:18.590
Deixe-me seguir em frente e ainda criar minha matriz de tamanho três.

01:20:18.590 --> 01:20:23.270
Mas deixe-me usar nosso velho amigo, o loop for, for int i equals 0,

01:20:23.270 --> 01:20:26.610
i menor que 3, i++.

01:20:26.610 --> 01:20:29.510
E então aqui, deixe-me fazer o colchete de pontuação--

01:20:29.510 --> 01:20:32.920
não vimos isso antes, mas alguma intuição?

01:20:32.920 --> 01:20:34.220
Faixa de pontuação--

01:20:34.220 --> 01:20:34.720
AUDIÊNCIA: i.

01:20:34.720 --> 01:20:39.730
DAVID MALAN: i, porque isso usará o que i for, seja 0 ou 1 ou 2

01:20:39.730 --> 01:20:40.720
em iteração.

01:20:40.720 --> 01:20:43.780
E então eu posso obter um int, pedindo pontuação ao usuário,

01:20:43.780 --> 01:20:47.000
sem ter que me repetir de novo e de novo.

01:20:47.000 --> 01:20:50.560
Espero que, se não cometi nenhum erro de digitação, faça pontuações, tudo bem.

01:20:50.560 --> 01:20:54.665
./scores, 72, 73, 33, e estamos de volta aos negócios.

01:20:54.665 --> 01:20:56.540
Mas o código agora é indiscutivelmente melhor projetado,

01:20:56.540 --> 01:21:01.240
porque agora, eu não codifiquei as pontuações,

01:21:01.240 --> 01:21:04.940
e na verdade não copiei e colei nada desse código.

01:21:04.940 --> 01:21:08.230
Bem, se considerarmos agora o que está acontecendo dentro da memória do computador,

01:21:08.230 --> 01:21:10.510
é praticamente o mesmo em termos de valores.

01:21:10.510 --> 01:21:15.490
Mas ao invés das variáveis ​​serem, literalmente, score1, score2, score3,

01:21:15.490 --> 01:21:17.210
há apenas uma variável.

01:21:17.210 --> 01:21:19.030
É uma matriz chamada pontuações.

01:21:19.030 --> 01:21:24.550
Mas você pode indexar em seus três locais usando scores[0] para obter

01:21:24.550 --> 01:21:28.810
o primeiro, pontua [1] para obter o segundo, pontua [2] para obter o terceiro.

01:21:28.810 --> 01:21:29.990
Mas isso é fundamental.

01:21:29.990 --> 01:21:33.040
A memória é contígua.

01:21:33.040 --> 01:21:35.380
A tela é tão grande que envolve.

01:21:35.380 --> 01:21:38.950
Mas fisicamente, digitalmente, a memória é contígua-- topo

01:21:38.950 --> 01:21:40.270
para baixo, da esquerda para a direita.

01:21:40.270 --> 01:21:41.530
E isso é importante, por quê?

01:21:41.530 --> 01:21:46.060
Como os colchetes indicam 0, 1, 2, cada um desses inteiros

01:21:46.060 --> 01:21:48.790
está a apenas um inteiro de distância do próximo.

01:21:48.790 --> 01:21:51.220
Não pode ser aleatoriamente aqui de repente.

01:21:51.220 --> 01:21:54.070
Tem que ser costas com costas.

01:21:54.070 --> 01:21:57.130
Tudo bem, agora equipado com esse paradigma,

01:21:57.130 --> 01:22:00.710
o que mais poderíamos realmente fazer aqui?

01:22:00.710 --> 01:22:04.270
Bem, vale a pena saber que é possível no código

01:22:04.270 --> 01:22:06.850
até mesmo passar arrays como argumentos.

01:22:06.850 --> 01:22:09.100
E deixe-me apenas preparar este programa rapidamente,

01:22:09.100 --> 01:22:11.320
apenas para que você tenha visto antes.

01:22:11.320 --> 01:22:13.190
Mas deixe-me ir em frente e fazer isso.

01:22:13.190 --> 01:22:18.130
Deixe-me propor que eu crie uma função que faça essa média para mim.

01:22:18.130 --> 01:22:22.510
Vou criar uma função chamada average que retorna um float.

01:22:22.510 --> 01:22:26.860
E os argumentos que essa coisa vai levar--

01:22:26.860 --> 01:22:28.640
vamos ver, vai ser o array.

01:22:28.640 --> 01:22:31.480
Acontece que, se você quiser obter uma matriz de números -

01:22:31.480 --> 01:22:33.050
você pode chamá-lo do que quiser.

01:22:33.050 --> 01:22:36.970
É assim que você diz a C que uma função leva, não

01:22:36.970 --> 01:22:39.790
um inteiro, mas uma matriz de inteiros.

01:22:39.790 --> 01:22:41.290
E você não precisa chamá-lo de array.

01:22:41.290 --> 01:22:42.790
Estou fazendo isso apenas para fins de discussão.

01:22:42.790 --> 01:22:43.660
Pode ser chamado de x.

01:22:43.660 --> 01:22:44.490
Pode ser números.

01:22:44.490 --> 01:22:45.490
Pode ser qualquer outra coisa.

01:22:45.490 --> 01:22:49.060
Estou apenas chamando um array para ser super explícito quanto ao que está lá.

01:22:49.060 --> 01:22:51.730
Agora, como altero meu código aqui embaixo?

01:22:51.730 --> 01:22:55.130
O que eu acho que vou fazer no momento é apenas isso.

01:22:55.130 --> 01:22:59.110
Vou me livrar desse código aqui, onde calculei manualmente a média.

01:22:59.110 --> 01:23:01.480
E deixe-me chamar a função média aqui

01:23:01.480 --> 01:23:05.000
passando em toda a matriz de pontuações.

01:23:05.000 --> 01:23:07.030
Portanto, este é apenas um exemplo de abstração,

01:23:07.030 --> 01:23:08.890
como agora eu tenho uma função chamada average.

01:23:08.890 --> 01:23:09.670
Eu não ligo.

01:23:09.670 --> 01:23:12.490
Não preciso me lembrar de como funciona depois de implementá-lo.

01:23:12.490 --> 01:23:15.010
Isso meio que aperta um pouco meu código principal.

01:23:15.010 --> 01:23:17.030
Mas ainda tenho que implementar isso.

01:23:17.030 --> 01:23:19.360
Então, mais tarde no meu arquivo-- deixe-me repetir antes,

01:23:19.360 --> 01:23:22.270
a única vez que está certo em C se repetir de novo e de novo,

01:23:22.270 --> 01:23:27.010
digitando novamente, average, e então int array open colchete--

01:23:27.010 --> 01:23:28.580
mas agora não um ponto e vírgula.

01:23:28.580 --> 01:23:30.250
Agora eu tenho que implementar isso.

01:23:30.250 --> 01:23:33.400
E posso implementar isso de várias maneiras diferentes,

01:23:33.400 --> 01:23:37.630
mas eu não sei com antecedência--

01:23:37.630 --> 01:23:39.040
Eu não posso simplesmente fazer isso.

01:23:39.040 --> 01:23:48.400
Não posso simplesmente fazer array[0] mais array[1] mais array[2],

01:23:48.400 --> 01:23:52.130
a menos que este programa só funcione com três números.

01:23:52.130 --> 01:23:55.460
Então deixe-me ir em frente e fazer isso.

01:23:55.460 --> 01:23:58.570
Deixe-me primeiro propor que há um design ruim aqui.

01:23:58.570 --> 01:24:01.930
Na minha função principal, que valor repeti duas vezes?

01:24:05.050 --> 01:24:07.550
Entre as linhas destacadas, o que salta para você duas vezes?

01:24:07.550 --> 01:24:09.020
AUDIÊNCIA: O comprimento da matriz?

01:24:09.020 --> 01:24:11.520
DAVID MALAN: Sim, o comprimento da matriz, é apenas três.

01:24:11.520 --> 01:24:14.720
Agora não é grande coisa que eu digitei o número três na linha 8 e na linha 9,

01:24:14.720 --> 01:24:17.120
mas este é exatamente o tipo de atalho

01:24:17.120 --> 01:24:18.440
isso vai te colocar em apuros eventualmente.

01:24:18.440 --> 01:24:18.860
Por que?

01:24:18.860 --> 01:24:20.240
Porque, eventualmente, você ou outra pessoa está

01:24:20.240 --> 01:24:22.407
vai entrar e tornar a matriz maior ou menor,

01:24:22.407 --> 01:24:24.410
e você não vai perceber isso magicamente,

01:24:24.410 --> 01:24:26.270
esse mesmo número está em dois lugares.

01:24:26.270 --> 01:24:29.270
E, de fato, é isso que um programador costuma chamar de número mágico.

01:24:29.270 --> 01:24:31.940
Um número mágico é aquele que aparece magicamente.

01:24:31.940 --> 01:24:35.210
E você está no sistema de honra para mudar aqui, se você mudar aqui,

01:24:35.210 --> 01:24:36.688
e então você muda isso aqui.

01:24:36.688 --> 01:24:39.230
Isso não vai acabar bem se o ônus for do programador

01:24:39.230 --> 01:24:43.190
para lembrar onde eles codificaram - ou seja, escreveram três explicitamente.

01:24:43.190 --> 01:24:46.250
Portanto, sempre que você reutilizar um valor como esse, sabe de uma coisa?

01:24:46.250 --> 01:24:50.690
Provavelmente deveríamos fazer o que fizemos na semana passada, que foi declarar uma variável,

01:24:50.690 --> 01:24:53.510
talvez no topo do meu programa, então é super óbvio

01:24:53.510 --> 01:24:56.990
o que é, chamado, talvez n, e iguale a 3.

01:24:56.990 --> 01:24:59.030
Melhor ainda, o que eu fiz na semana passada para ter certeza

01:24:59.030 --> 01:25:02.390
que eu não posso estragar e acidentalmente mudar esse valor?

01:25:02.390 --> 01:25:03.440
Sim, constante.

01:25:03.440 --> 01:25:05.810
E a palavra-chave era apenas const para abreviar.

01:25:05.810 --> 01:25:09.110
E agora eu tenho uma variável global-- global no sentido que eu posso

01:25:09.110 --> 01:25:11.870
acessá-lo em qualquer lugar-- isso é chamado n.

01:25:11.870 --> 01:25:12.680
É um int.

01:25:12.680 --> 01:25:14.450
E sempre vai ser 3.

01:25:14.450 --> 01:25:18.500
E agora posso melhorar um pouco minha função principal apenas mudando

01:25:18.500 --> 01:25:22.662
os 3 para n, então agora se eu, se um colega percebeu, oh, espere um minuto,

01:25:22.662 --> 01:25:23.870
há quatro testes este ano.

01:25:23.870 --> 01:25:25.610
Você muda n para quatro, recompila o código,

01:25:25.610 --> 01:25:31.190
e funciona em qualquer outro lugar, exceto na minha função média.

01:25:31.190 --> 01:25:33.830
Deixe-me mudar de volta para 3, apenas para consistência.

01:25:33.830 --> 01:25:39.770
Isso não vai voar agora, apenas para resumir coisas como esta, por exemplo,

01:25:39.770 --> 01:25:43.610
e então retorne isso dividido por 3.

01:25:43.610 --> 01:25:51.130
Por que isso não funcionará agora como eu defini?

01:25:51.130 --> 01:25:52.159
Sim?

01:25:52.159 --> 01:25:58.030
AUDIÊNCIA: [INAUDÍVEL]

01:25:58.030 --> 01:26:00.980
DAVID MALAN: OK, posso estar retornando um valor inteiro quando

01:26:00.980 --> 01:26:02.870
Pretendo devolver um float por isso.

01:26:02.870 --> 01:26:05.870
Mas acho que estou bem porque usei aquele pequeno truque em que me certifiquei

01:26:05.870 --> 01:26:08.810
que pelo menos um dos números em minha expressão aritmética

01:26:08.810 --> 01:26:11.010
é, de fato, um valor de ponto flutuante.

01:26:11.010 --> 01:26:14.180
E apenas adicionando o ponto 0, certifique-se de que tudo

01:26:14.180 --> 01:26:15.650
é tratado como um flutuador.

01:26:15.650 --> 01:26:17.864
Então eu acho que está tudo bem.

01:26:17.864 --> 01:26:19.034
AUDIÊNCIA: [INAUDÍVEL]

01:26:19.034 --> 01:26:20.701
DAVID MALAN: Desculpe, um pouco mais alto.

01:26:20.701 --> 01:26:24.385
AUDIÊNCIA: Parece que você é [INAUDÍVEL]..

01:26:24.385 --> 01:26:25.260
DAVID MALAN: Exatamente.

01:26:25.260 --> 01:26:27.093
Então a mão esquerda não está falando com a mão direita

01:26:27.093 --> 01:26:30.210
aqui, em que minha implementação atual de média

01:26:30.210 --> 01:26:33.510
ainda está assumindo que haverá apenas três testes ou algo assim.

01:26:33.510 --> 01:26:35.670
Mas espere um minuto, acabei de passar pelo problema

01:26:35.670 --> 01:26:39.480
de modificar isso para ser n, genericamente.

01:26:39.480 --> 01:26:43.205
E se eu mudar isso para 4, não vou ficar feliz, talvez,

01:26:43.205 --> 01:26:46.080
com a minha média porque agora vou ignorar uma das minhas pontuações de teste

01:26:46.080 --> 01:26:46.690
completamente.

01:26:46.690 --> 01:26:48.450
Então deixe-me mudar isso de volta para 3.

01:26:48.450 --> 01:26:51.180
E, infelizmente, se for uma variável agora,

01:26:51.180 --> 01:26:55.500
n e, portanto, tenho literalmente um número variável de pontuações,

01:26:55.500 --> 01:27:00.920
como faço para tirar a média de um número variável de coisas?

01:27:00.920 --> 01:27:02.630
Quero dizer, qual é o meu bloco de construção aqui?

01:27:02.630 --> 01:27:03.170
Sim?

01:27:03.170 --> 01:27:10.100
AUDIÊNCIA: [INAUDÍVEL]

01:27:10.100 --> 01:27:10.850
DAVID MALAN: Sim.

01:27:10.850 --> 01:27:14.880
Por que não uso um loop que percorre a matriz e adiciona coisas à medida que você avança?

01:27:14.880 --> 01:27:17.360
Quero dizer, como na escola primária, quando você faz a média na sua calculadora

01:27:17.360 --> 01:27:19.730
ou papel e lápis, você continua somando os números,

01:27:19.730 --> 01:27:22.380
e então você divide no final pelo número total de coisas.

01:27:22.380 --> 01:27:23.520
Então, como posso fazer isso?

01:27:23.520 --> 01:27:25.730
Bem, deixe-me mudar minha implementação de average

01:27:25.730 --> 01:27:30.515
para primeiro declarar uma variável chamada sum, ou qualquer outra, defina-a igual a 0.

01:27:30.515 --> 01:27:33.140
Isso é como eu no meu pedaço de papel me preparando para contar,

01:27:33.140 --> 01:27:36.590
ou minha calculadora, é claro, quando você a liga, normalmente o padrão é zero.

01:27:36.590 --> 01:27:41.570
E agora, deixe-me fazer para, int i é igual a 0. i é menor que a--

01:27:41.570 --> 01:27:43.700
bem, não, eu não fiz isso.

01:27:43.700 --> 01:27:46.730
i é menor que n, i++.

01:27:46.730 --> 01:27:52.640
E agora aqui, deixe-me ir em frente e adicionar à soma atual, o que for

01:27:52.640 --> 01:27:55.910
está na localização do array, i.

01:27:55.910 --> 01:28:00.740
E então aqui embaixo, acho que posso apenas retornar alguns divididos por 3,0 -

01:28:00.740 --> 01:28:04.560
não 3.0, n, talvez aqui.

01:28:04.560 --> 01:28:08.492
E, na verdade, acho que vou conseguir... vamos garantir que seja um carro alegórico.

01:28:08.492 --> 01:28:11.450
Vamos usar o truque de seleção de tipos apenas para garantir que eu não

01:28:11.450 --> 01:28:15.540
enganar alguém e jogar fora tudo depois da vírgula.

01:28:15.540 --> 01:28:17.300
Então, aumentou rapidamente, certo?

01:28:17.300 --> 01:28:18.990
A média ficou muito mais envolvida.

01:28:18.990 --> 01:28:22.130
Não é apenas uma única linha de código, mas agora é dinâmico.

01:28:22.130 --> 01:28:25.070
Eu inicializo uma variável chamada sum como 0.

01:28:25.070 --> 01:28:30.920
Nesse loop, continuo adicionando a soma, que inicialmente é 0,

01:28:30.920 --> 01:28:33.200
o que quer que esteja no array[i]--

01:28:33.200 --> 01:28:36.740
ou especificamente array[0], array[1], array[2].

01:28:36.740 --> 01:28:40.970
Isso me dá uma soma total que devolvo, dividida pelo número total de coisas.

01:28:40.970 --> 01:28:42.560
Agora, isso eu posso apertar um pouco.

01:28:42.560 --> 01:28:45.650
Lembre-se de que este é um açúcar sintático para apenas adicionar coisas.

01:28:45.650 --> 01:28:48.620
Não posso usar plus plus porque isso apenas adiciona literalmente um.

01:28:48.620 --> 01:28:52.630
Mas posso usar aqui, mais igual a.

01:28:52.630 --> 01:28:54.880
Dúvidas sobre esta implementação aqui?

01:28:54.880 --> 01:28:58.000
Realmente o único takeaway-- ou o takeaway mais importante

01:28:58.000 --> 01:29:00.730
é que esta é a sintaxe de como você diz

01:29:00.730 --> 01:29:04.210
uma função que espera uma matriz inteira, não

01:29:04.210 --> 01:29:06.450
uma única variável como um int ou algo semelhante.

01:29:06.450 --> 01:29:08.200
Você literalmente usa colchetes, mas você

01:29:08.200 --> 01:29:11.530
não especifique o comprimento lá dentro.

01:29:11.530 --> 01:29:12.748
Sim?

01:29:12.748 --> 01:29:16.410
AUDIÊNCIA: Qual variável [INAUDÍVEL] no topo?

01:29:16.410 --> 01:29:18.410
DAVID MALAN: E a variável no topo?

01:29:18.410 --> 01:29:22.205
AUDIÊNCIA: [INAUDÍVEL]

01:29:22.205 --> 01:29:23.330
DAVID MALAN: Boa pergunta.

01:29:23.330 --> 01:29:25.220
O que eu tenho definido como no topo?

01:29:25.220 --> 01:29:31.280
Essa variável, N, deve ser um número inteiro se você for usar dentro

01:29:31.280 --> 01:29:33.840
de uma matriz de colchetes aqui.

01:29:33.840 --> 01:29:38.360
Portanto, esta linha 10, observe, não diz mais 3, diz N.

01:29:38.360 --> 01:29:42.350
E então qualquer N é 3 ou 4 ou qualquer outra coisa, isso é quantos

01:29:42.350 --> 01:29:43.970
inteiros que obterei nesse array.

01:29:43.970 --> 01:29:47.070
E deve ser, por definição de array, um inteiro que

01:29:47.070 --> 01:29:48.320
vai nesses colchetes.

01:29:48.320 --> 01:29:50.000
E aqui está uma fonte comum de confusão.

01:29:50.000 --> 01:29:52.350
Quando você cria a matriz, ou seja, declara-a,

01:29:52.350 --> 01:29:54.350
você usa colchetes assim, onde você coloca

01:29:54.350 --> 01:29:56.210
o número total de elementos que você deseja.

01:29:56.210 --> 01:29:59.820
Quando você subsequentemente usar o array, como estou fazendo aqui,

01:29:59.820 --> 01:30:02.690
você não menciona int novamente - assim como você não menciona int

01:30:02.690 --> 01:30:04.610
uma e outra vez uma vez que uma variável existe.

01:30:04.610 --> 01:30:10.220
Você ainda usa os colchetes, mas não usa N. Você usa 0 ou 1 ou 2

01:30:10.220 --> 01:30:11.990
ou, genericamente aqui, i.

01:30:11.990 --> 01:30:14.810
Então, quando C foi projetado, eles às vezes usavam a mesma sintaxe

01:30:14.810 --> 01:30:17.060
para duas ideias ou contextos diferentes.

01:30:17.060 --> 01:30:17.984
Sim?

01:30:17.984 --> 01:30:22.645
AUDIÊNCIA: Você tem que incluir a linha 6 [INAUDÍVEL]??

01:30:22.645 --> 01:30:23.770
DAVID MALAN: Boa pergunta.

01:30:23.770 --> 01:30:25.900
Devo incluir a linha 6?

01:30:25.900 --> 01:30:29.290
Resposta curta, sim, por causa do motivo que encontramos na semana passada.

01:30:29.290 --> 01:30:32.750
C, ou clang realmente, lê seu código de cima para baixo, da esquerda para a direita.

01:30:32.750 --> 01:30:38.890
E assim, se o compilador vir alguma menção a esta função average na linha 16,

01:30:38.890 --> 01:30:41.800
mas você não disse ao compilador que a média existe,

01:30:41.800 --> 01:30:43.610
você receberá um erro na tela.

01:30:43.610 --> 01:30:45.490
Então, a maneira convencional de fazer isso é você

01:30:45.490 --> 01:30:48.670
apenas copie e cole a primeira linha de código da função,

01:30:48.670 --> 01:30:51.260
é o chamado protótipo ou declaração.

01:30:51.260 --> 01:30:51.760
Sim?

01:30:51.760 --> 01:30:55.662
AUDIÊNCIA: Existe uma biblioteca se você não souber o tamanho do array?

01:30:55.662 --> 01:30:58.120
DAVID MALAN: Realmente uma boa pergunta e uma forma de seguir perfeita.

01:30:58.120 --> 01:31:01.078
Existe uma biblioteca que você pode usar se não souber o tamanho da matriz?

01:31:01.078 --> 01:31:01.720
Não.

01:31:01.720 --> 01:31:07.660
E então, se algum de vocês programou em Java ou Python ou outras linguagens,

01:31:07.660 --> 01:31:11.020
você pode simplesmente perguntar ao array, qual é o tamanho dele?

01:31:11.020 --> 01:31:13.778
Em C, você e eu, os programadores, temos que nos lembrar disso.

01:31:13.778 --> 01:31:15.820
E resposta curta, não, não há função que

01:31:15.820 --> 01:31:17.445
fará isso automaticamente para nós.

01:31:17.445 --> 01:31:20.230
E, de fato, deixe-me fazer uma afirmação mais sutil

01:31:20.230 --> 01:31:23.950
que não há problema em usar variáveis ​​globais como esta se forem realmente

01:31:23.950 --> 01:31:25.160
para opções de configuração.

01:31:25.160 --> 01:31:25.660
Por que?

01:31:25.660 --> 01:31:28.160
É conveniente colocá-los no início do arquivo

01:31:28.160 --> 01:31:30.565
porque todos, você, seus colegas, seus TAs

01:31:30.565 --> 01:31:32.440
vão vê-los na parte superior do código.

01:31:32.440 --> 01:31:36.130
Mas você realmente não deveria usá-los em todo o seu código.

01:31:36.130 --> 01:31:38.380
Seria melhor se a função média, em si, fosse

01:31:38.380 --> 01:31:40.610
independente dessa variável especial.

01:31:40.610 --> 01:31:42.025
Então, com isso, quero dizer isso.

01:31:42.025 --> 01:31:46.240
Você sabe o que eu realmente devo fazer, se eu realmente quiser ser bem desenhado?

01:31:46.240 --> 01:31:51.400
Devo passar o comprimento da matriz para a função média.

01:31:51.400 --> 01:31:54.310
Eu deveria dar à função média um segundo argumento -

01:31:54.310 --> 01:31:57.800
Vou chamá-lo de comprimento, por exemplo, mas posso chamá-lo do que quiser.

01:31:57.800 --> 01:32:02.500
E então, em vez de colocar N aqui embaixo no final do meu arquivo,

01:32:02.500 --> 01:32:05.745
deixe-me apenas dizer comprimento dinamicamente.

01:32:05.745 --> 01:32:08.620
E isso é uma sutileza - e não há necessidade de ficar muito confuso sobre isso.

01:32:08.620 --> 01:32:11.830
Mas isso, agora, é apenas um exemplo de como a mesma função pode

01:32:11.830 --> 01:32:13.690
tome não um, mas dois argumentos.

01:32:13.690 --> 01:32:19.400
Mas, de fato, em C, você mesmo deve se lembrar qual é o comprimento de um array

01:32:19.400 --> 01:32:19.900
é.

01:32:19.900 --> 01:32:22.810
Você não pode simplesmente perguntar ao array por meio de alguma sintaxe

01:32:22.810 --> 01:32:26.560
como você pode, aqueles de vocês que já programaram em Java ou Python.

01:32:26.560 --> 01:32:27.070
Sim?

01:32:27.070 --> 01:32:35.115
AUDIÊNCIA: [INAUDÍVEL]

01:32:35.115 --> 01:32:36.240
DAVID MALAN: Boa pergunta.

01:32:36.240 --> 01:32:39.198
Seria melhor projetado para escrever uma função que calcula o tamanho?

01:32:39.198 --> 01:32:42.570
Resposta curta, não pode fazer isso em C. Assim que você passar um array

01:32:42.570 --> 01:32:47.263
em uma função em C, você não consegue descobrir seu tamanho se for um array genérico

01:32:47.263 --> 01:32:48.180
como os inteiros.

01:32:48.180 --> 01:32:51.040
Existem casos especiais em que você pode fazer isso.

01:32:51.040 --> 01:32:53.283
Mas, em geral, não, simplesmente não é possível em C.

01:32:53.283 --> 01:32:55.200
E se isso é alguma frustração, honestamente, isso

01:32:55.200 --> 01:32:57.180
é por isso que idiomas mais modernos adicionam esse recurso.

01:32:57.180 --> 01:32:57.680
Por que?

01:32:57.680 --> 01:32:59.910
Porque foi muito chato, como estou aludindo aqui

01:32:59.910 --> 01:33:01.560
para não ter essa informação.

01:33:01.560 --> 01:33:03.643
Agora, só para ter certeza de que não estraguei nada,

01:33:03.643 --> 01:33:07.540
deixe-me compilar esta versão final das partituras.

01:33:07.540 --> 01:33:08.620
Suspense.

01:33:08.620 --> 01:33:14.030
Tudo certo. ./scores, 72, 73, 33, e ainda estamos de volta aos negócios.

01:33:14.030 --> 01:33:15.530
Portanto, esta versão é mais complicada.

01:33:15.530 --> 01:33:18.738
E como sempre, teremos esta versão no site do curso para referência.

01:33:18.738 --> 01:33:20.740
Mas o ponto, na verdade, é que os arrays, não apenas

01:33:20.740 --> 01:33:23.290
podem ser usados ​​como contêineres para armazenar vários valores--

01:33:23.290 --> 01:33:25.490
três ou mais neste caso--

01:33:25.490 --> 01:33:30.440
você também pode passá-los como argumentos, como tal.

01:33:30.440 --> 01:33:34.300
Tudo bem, além disso, vamos simplificar por um momento,

01:33:34.300 --> 01:33:36.100
e considere agora o mundo dos chars.

01:33:36.100 --> 01:33:39.200
Se tivermos apenas bytes únicos, aonde isso nos leva?

01:33:39.200 --> 01:33:41.200
E como isso nos leva, em última análise, às cordas

01:33:41.200 --> 01:33:44.170
para resolver problemas como legibilidade e criptografia e afins?

01:33:44.170 --> 01:33:46.390
Bem, aqui, por exemplo, estão três linhas de código,

01:33:46.390 --> 01:33:48.967
fora do contexto, que simplesmente armazenam três caracteres.

01:33:48.967 --> 01:33:50.800
E você já pode ver onde isso vai dar.

01:33:50.800 --> 01:33:53.920
Ter três variáveis ​​chamadas c1, c2, c3 é claramente

01:33:53.920 --> 01:33:57.470
vai acabar sendo um design ruim por causa de toda a redundância boba aqui.

01:33:57.470 --> 01:33:59.650
Mas observe, estou usando aspas simples como na semana passada

01:33:59.650 --> 01:34:01.330
porque estes são caracteres únicos.

01:34:01.330 --> 01:34:03.647
O que isso parece na memória do computador?

01:34:03.647 --> 01:34:05.480
Bem, parece um pouco com isto.

01:34:05.480 --> 01:34:09.730
Se limparmos a memória antiga, c1, c2, c3 provavelmente

01:34:09.730 --> 01:34:12.562
terminará aqui, talvez não literalmente no canto superior esquerdo.

01:34:12.562 --> 01:34:14.020
Esta é apenas a interpretação de um artista.

01:34:14.020 --> 01:34:18.440
Mas c1, c2, c3 provavelmente terminarão assim.

01:34:18.440 --> 01:34:20.020
Agora, o que há realmente lá?

01:34:20.020 --> 01:34:21.730
São realmente esses mesmos três números--

01:34:21.730 --> 01:34:23.350
72, 73, 33.

01:34:23.350 --> 01:34:27.920
Mas quantos bits tem um byte?

01:34:27.920 --> 01:34:28.880
Apenas oito.

01:34:28.880 --> 01:34:33.830
Então, se olharmos para a representação binária desses caracteres,

01:34:33.830 --> 01:34:35.330
seriam apenas oito bits cada.

01:34:35.330 --> 01:34:39.140
Isso é suficiente para armazenar pequenos números como 72, 73, 33.

01:34:39.140 --> 01:34:41.580
Não estamos lidando com Unicode, emoji e coisas do gênero.

01:34:41.580 --> 01:34:42.837
Mas o ponto é o mesmo.

01:34:42.837 --> 01:34:45.170
Você não precisa usar quatro bytes para armazenar esses números.

01:34:45.170 --> 01:34:48.087
Você pode usar um tipo de dados diferente, como chars, e sob o capô,

01:34:48.087 --> 01:34:51.420
na verdade, usará apenas bytes únicos para cada um.

01:34:51.420 --> 01:34:55.850
Mas isso é meio que -- não é assim que implementamos strings, certo?

01:34:55.850 --> 01:34:59.270
Quando você queria dizer oi, semana passada ou esta, usamos aspas duplas.

01:34:59.270 --> 01:35:02.400
E escrevemos todas as coisas juntas e usamos uma variável, não três,

01:35:02.400 --> 01:35:02.900
certo?

01:35:02.900 --> 01:35:06.260
Quando digitei David, não havia uma variável para DAVID.

01:35:06.260 --> 01:35:09.750
Eu tinha uma variável chamada name que armazenava tudo.

01:35:09.750 --> 01:35:13.310
Então, em C, continuamos falando sobre essas coisas chamadas strings.

01:35:13.310 --> 01:35:17.427
Veremos, eventualmente, que as cordas não são necessariamente o que parecem ser.

01:35:17.427 --> 01:35:19.760
Mas, por enquanto, o principal sobre strings é que elas são

01:35:19.760 --> 01:35:22.070
comprimento variável, por assim dizer, certo?

01:35:22.070 --> 01:35:25.250
Eles podem ser três caracteres, Hi, ou cinco caracteres, David,

01:35:25.250 --> 01:35:28.250
ou qualquer coisa menor ou maior.

01:35:28.250 --> 01:35:30.980
Então, como vamos implementar strings,

01:35:30.980 --> 01:35:33.110
se tudo o que temos no final do dia é a minha memória?

01:35:33.110 --> 01:35:36.290
Bem, aqui está um exemplo de apenas criar, declarar,

01:35:36.290 --> 01:35:39.650
e definindo uma string chamada s. s porque é apenas uma string simples,

01:35:39.650 --> 01:35:41.900
e entre aspas, HI!, entre aspas duplas.

01:35:41.900 --> 01:35:44.090
O que isso parece na memória do computador?

01:35:44.090 --> 01:35:45.230
Bem, vamos limpá-lo novamente.

01:35:45.230 --> 01:35:48.110
E aqui, agora, porque é tecnicamente armazenado em uma variável,

01:35:48.110 --> 01:35:50.960
s, aqui está como eu poderia desenhá-lo como artista.

01:35:50.960 --> 01:35:52.520
São três bytes no total--

01:35:52.520 --> 01:35:53.990
Oi ponto de exclamação.

01:35:53.990 --> 01:35:59.630
Mas não tem c1, c2, c3, é só, a coisa toda é s.

01:35:59.630 --> 01:36:03.800
Mas acontece que uma corda, fato divertido,

01:36:03.800 --> 01:36:06.990
é realmente apenas o que debaixo do capô?

01:36:06.990 --> 01:36:09.610
Meio que levando a isso--

01:36:09.610 --> 01:36:12.090
o que é uma string, se é assim que está disposta na memória?

01:36:12.090 --> 01:36:13.190
AUDIÊNCIA: Uma matriz.

01:36:13.190 --> 01:36:15.830
DAVID MALAN: Literalmente, é apenas uma série de personagens.

01:36:15.830 --> 01:36:18.590
E não precisávamos saber sobre arrays na semana passada para usar strings.

01:36:18.590 --> 01:36:21.382
É aqui que, novamente, as rodinhas estão começando a cair.

01:36:21.382 --> 01:36:23.730
Mas uma string é apenas uma matriz de caracteres.

01:36:23.730 --> 01:36:26.040
Oi ponto de exclamação, por exemplo.

01:36:26.040 --> 01:36:28.370
Então, tecnicamente, um array--

01:36:28.370 --> 01:36:33.890
ou uma string chamada s é realmente uma variável chamada s que permite

01:36:33.890 --> 01:36:38.150
para obter o primeiro caractere com s[0], se você quiser-- s[1], s[2].

01:36:38.150 --> 01:36:40.340
Você pode literalmente obter caracteres individuais

01:36:40.340 --> 01:36:43.820
apenas tratando s como se fosse um array, o que realmente

01:36:43.820 --> 01:36:47.000
está debaixo do capô, neste caso.

01:36:47.000 --> 01:36:48.560
Mas há um porém.

01:36:48.560 --> 01:36:51.500
Como você sabe onde as cordas terminam?

01:36:51.500 --> 01:36:54.560
Antigamente, quando eu desenhava alguns números inteiros na tela,

01:36:54.560 --> 01:36:57.080
Eu sei, afirmo que eles sempre ocupam 4 bytes.

01:36:57.080 --> 01:37:00.200
Se eu tivesse desenhado um long, ele sempre ocuparia 8 bytes.

01:37:00.200 --> 01:37:03.530
Se eu tivesse desenhado um caractere, ele sempre ocuparia 1 byte.

01:37:03.530 --> 01:37:06.533
Mas quantos bytes uma string ocupa?

01:37:06.533 --> 01:37:08.450
Sim, quero dizer, essa é a resposta certa.

01:37:08.450 --> 01:37:10.490
Neste caso, três, ao que parece.

01:37:10.490 --> 01:37:13.490
Mas se for David, são uns bons cinco personagens.

01:37:13.490 --> 01:37:16.173
Mas onde colocamos o número três?

01:37:16.173 --> 01:37:17.840
Onde você coloca o número cinco, certo?

01:37:17.840 --> 01:37:20.190
Isso é literalmente tudo o que está dentro do seu computador.

01:37:20.190 --> 01:37:23.430
Estes são todos os nossos blocos de construção à nossa frente.

01:37:23.430 --> 01:37:25.490
Então, como podemos... para onde vão os três?

01:37:25.490 --> 01:37:26.540
Para onde vão os cinco?

01:37:26.540 --> 01:37:29.420
Bem, acontece que você pode resolver isso de duas maneiras diferentes.

01:37:29.420 --> 01:37:34.160
Mas a maneira como os humanos decidiram implementar strings anos atrás é, de fato, uma matriz,

01:37:34.160 --> 01:37:38.960
mas eles adicionaram um byte extra no final de cada array de strings,

01:37:38.960 --> 01:37:41.840
só para deixar claro, com um chamado valor sentinela,

01:37:41.840 --> 01:37:44.480
que a string termina aqui.

01:37:44.480 --> 01:37:45.050
Por que?

01:37:45.050 --> 01:37:47.930
Portanto, se você tiver duas strings na memória do computador, como, HI!

01:37:47.930 --> 01:37:52.760
e tchau, você sabe onde está a barreira entre o ponto de exclamação de um

01:37:52.760 --> 01:37:54.590
e a letra B no próximo, certo?

01:37:54.590 --> 01:37:56.000
Você precisa de algum tipo de delimitador.

01:37:56.000 --> 01:38:00.110
E então o que realmente está por baixo do capô é isso.

01:38:00.110 --> 01:38:04.460
Quando você armazena uma string na memória, quando você digita uma string-- como usuário,

01:38:04.460 --> 01:38:07.040
se você digitar 3 caracteres, vai usar

01:38:07.040 --> 01:38:10.280
3 mais 1 é igual a 4 bytes no total.

01:38:10.280 --> 01:38:14.130
Se você digitar David, usará 5 mais 1 igual a 6 bytes no total.

01:38:14.130 --> 01:38:14.630
Por que?

01:38:14.630 --> 01:38:20.210
Porque C adiciona automaticamente esse 0 especial no final da string.

01:38:20.210 --> 01:38:24.710
Eu desenhei com barra invertida 0 porque é assim que você representa 0 como um caractere,

01:38:24.710 --> 01:38:25.710
como personagem.

01:38:25.710 --> 01:38:28.230
Mas isso é literalmente apenas 0, como veremos em breve.

01:38:28.230 --> 01:38:31.100
Então sempre que há uma string na memória, ela sempre ocupa

01:38:31.100 --> 01:38:36.197
um byte a mais do que você, você mesmo, como o programador ou humano digitou.

01:38:36.197 --> 01:38:38.780
Na verdade, se convertermos isso novamente, apenas para fins de discussão,

01:38:38.780 --> 01:38:41.572
a esses números inteiros, o que está literalmente armazenado na memória do computador

01:38:41.572 --> 01:38:45.170
vai ser 72, 73, 33, e agora um 0.

01:38:45.170 --> 01:38:48.240
E o computador, por causa do C e como ele foi inventado,

01:38:48.240 --> 01:38:51.350
é inteligente o suficiente para saber que quando você imprime uma string,

01:38:51.350 --> 01:38:54.530
ele imprime todos os caracteres até ver um 0,

01:38:54.530 --> 01:38:56.150
e então simplesmente para de imprimir.

01:38:56.150 --> 01:38:58.470
Em particular, printf sabe como isso funciona.

01:38:58.470 --> 01:39:02.050
E é por isso que printf sabe quando parar de imprimir.

01:39:02.050 --> 01:39:03.800
Números decimais não são tão esclarecedores.

01:39:03.800 --> 01:39:05.940
Geralmente escreveremos os personagens assim.

01:39:05.940 --> 01:39:09.350
E, novamente, a barra invertida 0 é apenas uma simbologia especial.

01:39:09.350 --> 01:39:13.190
É o que o programador digita para deixar claro que você não está dizendo, HI!, 0.

01:39:13.190 --> 01:39:15.980
Você está dizendo HI!, e então é um 0 especial.

01:39:15.980 --> 01:39:20.887
Especificamente, são oito bits 0 que indicam

01:39:20.887 --> 01:39:22.220
que é o fim da string.

01:39:22.220 --> 01:39:26.330
Tecnicamente, essa barra invertida zero, se você quiser ser chique, é chamada de null,

01:39:26.330 --> 01:39:27.320
NULO.

01:39:27.320 --> 01:39:30.320
E acontece que você já viu isso antes, embora não tenhamos falado sobre isso.

01:39:30.320 --> 01:39:33.230
Aqui está o mesmo gráfico ASCII das últimas semanas.

01:39:33.230 --> 01:39:39.080
Se eu destacar isso, o que é o mapeamento do número decimal 0?

01:39:39.080 --> 01:39:42.830
NUL, que é apenas a fala do programador para o caractere nulo especial.

01:39:42.830 --> 01:39:46.550
Todos os 0 bits significam que a string termina aqui.

01:39:46.550 --> 01:39:48.510
Isso tudo acontece automaticamente para você.

01:39:48.510 --> 01:39:53.420
Você não precisa criar esses caracteres nulos ou esses zeros.

01:39:53.420 --> 01:40:00.030
Alguma pergunta, então, sobre esta implementação até agora?

01:40:00.030 --> 01:40:01.820
Alguma pergunta aqui?

01:40:01.820 --> 01:40:02.320
Não?

01:40:02.320 --> 01:40:03.195
Bem, deixe-me fazer isso.

01:40:03.195 --> 01:40:05.310
Deixe-me voltar ao VS Code em um segundo.

01:40:05.310 --> 01:40:07.770
E vamos corroborar isso com algum código.

01:40:07.770 --> 01:40:10.830
Deixe-me criar um pequeno programa chamado hi.c.

01:40:10.830 --> 01:40:12.070
E que tal fazermos isso?

01:40:12.070 --> 01:40:14.550
Deixe-me incluir stdio.h.

01:40:14.550 --> 01:40:18.670
Deixe-me incluir-- deixe-me digitar int main void, como sempre.

01:40:18.670 --> 01:40:20.910
E agora deixe-me fazer algo simples e meio ruim,

01:40:20.910 --> 01:40:24.960
mas char c1 é igual a aspas sem aspas, h, entre aspas simples.

01:40:24.960 --> 01:40:28.590
Char c2 é igual a aspas sem aspas, I, entre aspas simples.

01:40:28.590 --> 01:40:32.830
E por último, char c3 é igual a ponto de exclamação, entre aspas simples.

01:40:32.830 --> 01:40:34.500
E agora, deixe-me imprimir isto.

01:40:34.500 --> 01:40:36.960
Não posso usar %s porque não é uma string.

01:40:36.960 --> 01:40:40.290
São literalmente três caracteres, porque essa é a decisão de design que tomei.

01:40:40.290 --> 01:40:41.430
Mas eu poderia fazer isso--

01:40:41.430 --> 01:40:48.600
%c, %c, %c, que não vimos antes, mas %s é string, %i é int,

01:40:48.600 --> 01:40:51.060
%c é, de fato, char.

01:40:51.060 --> 01:40:54.150
Deixe-me colocar uma barra invertida n no final para limpeza,

01:40:54.150 --> 01:40:56.280
e agora faça, c1, c2, c3.

01:40:56.280 --> 01:41:00.430
Então, isso é como uma versão baseada em caracteres da string de impressão.

01:41:00.430 --> 01:41:01.650
Então deixe-me fazer OI!

01:41:01.650 --> 01:41:05.880
E então deixe-me fazer ./hi, e parece que usei printf com %s.

01:41:05.880 --> 01:41:09.750
Mas fiz as coisas manualmente, imprimindo cada caractere individual.

01:41:09.750 --> 01:41:11.700
O que é legal agora, porém, é que uma vez que você

01:41:11.700 --> 01:41:15.270
saiba que caracteres são apenas números e strings são apenas caracteres,

01:41:15.270 --> 01:41:16.560
você pode meio que bisbilhotar.

01:41:16.560 --> 01:41:21.970
Deixe-me mudar todos os três espaços reservados para %i.

01:41:21.970 --> 01:41:23.860
E isso é totalmente bom, também.

01:41:23.860 --> 01:41:26.310
Deixe-me repetir isso, dar oi.

01:41:26.310 --> 01:41:31.570
Na verdade, deixe-me fazer uma alteração, apenas para que possamos ver isso.

01:41:31.570 --> 01:41:37.710
Deixe-me adicionar espaços, apenas por uma questão de estética, deixe-me fazer oi, ./hi, Enter,

01:41:37.710 --> 01:41:40.350
e pronto, como agora, você pode realmente ver os números,

01:41:40.350 --> 01:41:44.085
que eu reivindiquei na semana zero, estavam de fato acontecendo sob o capô.

01:41:44.085 --> 01:41:45.960
Bem, não é assim que você faria strings.

01:41:45.960 --> 01:41:49.457
Seria incrivelmente tedioso ter três variáveis ​​para palavras de três letras, cinco

01:41:49.457 --> 01:41:50.790
variáveis ​​para palavras de cinco letras.

01:41:50.790 --> 01:41:52.998
Estamos usando, é claro, strings desde a semana passada,

01:41:52.998 --> 01:41:54.450
então vamos fazer isso.

01:41:54.450 --> 01:41:59.370
String s é igual a aspas sem aspas, aspas duplas "HI!"

01:41:59.370 --> 01:42:02.520
Para isso, não, por causa dessas rodinhas,

01:42:02.520 --> 01:42:04.560
Preciso incluir a biblioteca CS50.

01:42:04.560 --> 01:42:06.580
Mas voltaremos a isso nas próximas semanas.

01:42:06.580 --> 01:42:10.530
Mas, por enquanto, irei em frente e criarei uma string s chamada quote unquote,

01:42:10.530 --> 01:42:11.580
"OI!"

01:42:11.580 --> 01:42:14.760
E agora vou mudar isso para ser meu familiar %s,

01:42:14.760 --> 01:42:17.610
e agora é só imprimir o próprio s.

01:42:17.610 --> 01:42:20.430
Isso, é claro, é a mesma coisa da semana passada, ./hi,

01:42:20.430 --> 01:42:24.750
me dá exatamente a mesma coisa, mas agora estamos lidando, é claro, com strings.

01:42:24.750 --> 01:42:27.610
Mas como podemos ver um pouco além disso?

01:42:27.610 --> 01:42:28.810
Bem, que tal isso?

01:42:28.810 --> 01:42:31.530
Vamos pesquisar mais sobre os primitivos de hoje.

01:42:31.530 --> 01:42:35.580
Mesmo que s seja uma string, eu poderia tecnicamente imprimir seu primeiro

01:42:35.580 --> 01:42:39.000
caractere com %c fazendo s[0].

01:42:39.000 --> 01:42:43.110
Eu poderia tecnicamente imprimir seu segundo caractere com %c fazendo s[1].

01:42:43.110 --> 01:42:47.820
Eu poderia imprimir seu terceiro caractere com %c e imprimir s[2].

01:42:47.820 --> 01:42:50.430
Então, novamente, isso deriva logicamente do meu entendimento

01:42:50.430 --> 01:42:52.770
agora que as strings são arrays, como você observou.

01:42:52.770 --> 01:42:54.540
Deixe-me fazer--

01:42:54.540 --> 01:42:57.300
deixe-me fazer oi, ./hi.

01:42:57.300 --> 01:43:00.760
E nenhuma mudança visual, mas agora estou apenas mexendo.

01:43:00.760 --> 01:43:03.400
E, de fato, se você está realmente curioso, deixe-me fazer isso.

01:43:03.400 --> 01:43:06.870
Deixe-me mudar isso de volta para i, de volta para i--

01:43:06.870 --> 01:43:08.250
opa, de volta para i.

01:43:08.250 --> 01:43:11.310
E deixe-me adicionar um quarto, porque se estou realmente curioso agora,

01:43:11.310 --> 01:43:14.490
vamos ver o que há em s[3].

01:43:14.490 --> 01:43:16.020
Este é o quarto byte.

01:43:16.020 --> 01:43:18.990
E mesmo que a string em si seja HI,

01:43:18.990 --> 01:43:21.840
Acho que podemos corroborar toda essa coisa nula.

01:43:21.840 --> 01:43:26.248
Faça hi, ./hi, Enter e pronto.

01:43:26.248 --> 01:43:28.290
Você poderia ter feito isso na semana passada, se realmente

01:43:28.290 --> 01:43:29.580
queria explorar as cordas.

01:43:29.580 --> 01:43:33.060
Mas, por enquanto, está apenas revelando o que está acontecendo por baixo do capô.

01:43:33.060 --> 01:43:36.480
Perguntas então, sobre o que são essas strings?

01:43:36.480 --> 01:43:37.498
Sim?

01:43:37.498 --> 01:43:41.293
AUDIÊNCIA: [INAUDÍVEL]

01:43:41.293 --> 01:43:42.960
DAVID MALAN: Por que precisamos do colchete?

01:43:42.960 --> 01:43:45.430
AUDIÊNCIA: [INAUDÍVEL]

01:43:45.430 --> 01:43:47.180
DAVID MALAN: Por que você não precisa de colchetes?

01:43:47.180 --> 01:43:47.780
Boa pergunta.

01:43:47.780 --> 01:43:51.620
Por que não preciso de colchetes na linha 6?

01:43:51.620 --> 01:43:53.300
Porque s é uma string.

01:43:53.300 --> 01:43:56.930
Veremos em algumas semanas que s é, essencialmente,

01:43:56.930 --> 01:44:00.200
implementado sob o capô, de fato, como uma matriz,

01:44:00.200 --> 01:44:02.240
mas isso acontece automaticamente para você.

01:44:02.240 --> 01:44:06.800
Você pode tratar s apenas como um nome de variável sem colchetes.

01:44:06.800 --> 01:44:09.500
Você usará colchetes quando tiver matrizes de ints

01:44:09.500 --> 01:44:13.730
ou você cria manualmente arrays de chars ou doubles ou floats ou qualquer outra coisa.

01:44:13.730 --> 01:44:14.900
Mas cordas são especiais.

01:44:14.900 --> 01:44:15.440
Por que?

01:44:15.440 --> 01:44:19.190
Quero dizer, todo programa que você escreve parece usar strings, texto de alguma forma.

01:44:19.190 --> 01:44:21.930
Somos humanos gostamos de texto, não apenas de números e tal.

01:44:21.930 --> 01:44:25.910
Portanto, isso é tratado um pouco especialmente em C e em muitas outras linguagens

01:44:25.910 --> 01:44:28.580
também.

01:44:28.580 --> 01:44:31.170
Outras perguntas sobre isso aqui?

01:44:31.170 --> 01:44:31.670
Não?

01:44:31.670 --> 01:44:33.530
Vamos adicionar então, uma outra string à mistura.

01:44:33.530 --> 01:44:36.290
Então, em vez de apenas dizer OI!, por que não consideramos uma versão

01:44:36.290 --> 01:44:38.660
do programa que diz ambos, HI! e tchau!.

01:44:38.660 --> 01:44:41.420
E eu afirmo agora que aquela barra invertida zero,

01:44:41.420 --> 01:44:44.270
esse caractere nulo será cada vez mais importante agora

01:44:44.270 --> 01:44:46.820
se tivermos duas strings na memória, para que C saiba

01:44:46.820 --> 01:44:48.570
como distinguir um do outro.

01:44:48.570 --> 01:44:51.487
Então deixe-me ir em frente e me livrar dessas duas linhas por enquanto.

01:44:51.487 --> 01:44:55.430
Deixe-me recriar string s iguais, entre aspas, aspas duplas, "HI!"

01:44:55.430 --> 01:44:56.780
Deixe-me dar-me outro.

01:44:56.780 --> 01:44:59.905
E como estou apenas brincando, escolherei nomes de variáveis ​​bem curtos.

01:44:59.905 --> 01:45:04.410
String t é igual a aspas sem aspas, "BYE!"

01:45:04.410 --> 01:45:06.470
E então deixe-me imprimir os dois.

01:45:06.470 --> 01:45:11.300
Deixe-me imprimir %s, barra invertida n, vírgula s,

01:45:11.300 --> 01:45:16.910
e então printf %s barra invertida n, e então t.

01:45:16.910 --> 01:45:19.970
Demonstração tão simples de apenas essas duas variáveis.

01:45:19.970 --> 01:45:26.090
Faça hi, ./hi e, claro, imprime duas linhas, uma após a outra.

01:45:26.090 --> 01:45:27.980
O que realmente está acontecendo debaixo do capô?

01:45:27.980 --> 01:45:29.510
Bem, vamos voltar para a memória do computador.

01:45:29.510 --> 01:45:32.160
HI!, eu acho, vai ser, eu afirmo, praticamente o mesmo.

01:45:32.160 --> 01:45:36.170
Então s, afirmo, está no canto superior esquerdo, seguido pela barra invertida zero.

01:45:36.170 --> 01:45:40.035
E isso é importante agora porque TCHAU! provavelmente vai acabar lá.

01:45:40.035 --> 01:45:43.160
E visualmente, envolve a forma como desenhei essa grade de bytes,

01:45:43.160 --> 01:45:44.330
mas é contíguo.

01:45:44.330 --> 01:45:46.340
TCHAU-!

01:45:46.340 --> 01:45:51.470
nulo, AKA barra invertida zero, isso agora é útil para imprimir

01:45:51.470 --> 01:45:55.550
porque agora printf sabe onde começa e termina

01:45:55.550 --> 01:45:58.580
por meio desse caractere nulo especial.

01:45:58.580 --> 01:46:00.230
Mas podemos bisbilhotar agora também.

01:46:00.230 --> 01:46:01.620
O que mais posso fazer aqui?

01:46:01.620 --> 01:46:02.840
Que tal agora?

01:46:02.840 --> 01:46:08.870
Que tal eu entrar no meu código aqui, voltar ao código VS e deixar-me ir em frente

01:46:08.870 --> 01:46:13.790
e diga algo como, bem, se eu tiver duas dessas strings,

01:46:13.790 --> 01:46:15.410
você sabe, vamos colocá-los em uma matriz.

01:46:15.410 --> 01:46:20.520
Vamos fazer esse tipo de arrays em arrays, meio que no estilo inicial aqui.

01:46:20.520 --> 01:46:23.060
Então encadeie palavras[2].

01:46:23.060 --> 01:46:25.100
Então me dê uma matriz de duas strings é o que

01:46:25.100 --> 01:46:28.100
Estou dizendo aqui em código, embora ainda não tenhamos feito isso com strings.

01:46:28.100 --> 01:46:29.270
Nós só fizemos isso com ints.

01:46:29.270 --> 01:46:30.770
E agora deixe-me fazer isso.

01:46:30.770 --> 01:46:35.480
A primeira palavra AKA words[0] será igual, como antes, HI!

01:46:35.480 --> 01:46:40.940
E agora as palavras[1] serão iguais entre aspas, "BYE!"

01:46:40.940 --> 01:46:43.760
E agora fiz exatamente a mesma coisa, mas novamente, estou

01:46:43.760 --> 01:46:48.650
apenas evitando ter s, t, q, r e todas essas variáveis ​​diferentes em meu código.

01:46:48.650 --> 01:46:52.790
Só agora estou tratando-os como um único array de strings.

01:46:52.790 --> 01:46:54.750
Como altero meu código aqui embaixo?

01:46:54.750 --> 01:46:57.380
Bem, se eu quiser imprimir a primeira palavra, eu faço words[0].

01:46:57.380 --> 01:46:59.900
E se eu quiser imprimir a segunda palavra, eu faço words[1].

01:46:59.900 --> 01:47:02.088
Este não é um exercício útil no momento

01:47:02.088 --> 01:47:04.130
porque estou apenas tornando meu código mais complicado.

01:47:04.130 --> 01:47:06.830
Mas, novamente, isso nos permite bisbilhotar e ver o que há

01:47:06.830 --> 01:47:08.690
acontecendo porque existe aquele HI!

01:47:08.690 --> 01:47:09.530
e tchau!.

01:47:09.530 --> 01:47:10.700
Mas observe isso.

01:47:10.700 --> 01:47:14.670
Se eu realmente quiser ser legal, posso fazer isso.

01:47:14.670 --> 01:47:24.380
Vamos imprimir %c, %c, %c, barra invertida n, e então aqui, %c, %c, %c, %c,

01:47:24.380 --> 01:47:25.700
então quatro desses.

01:47:25.700 --> 01:47:28.430
E agora é aqui que as coisas ficam interessantes.

01:47:28.430 --> 01:47:30.620
Words é um array de strings.

01:47:30.620 --> 01:47:33.400
Mais uma vez, se me permite, o que é uma string?

01:47:33.400 --> 01:47:35.060
Uma matriz de caracteres.

01:47:35.060 --> 01:47:36.790
Então, basta usar a mesma lógica.

01:47:36.790 --> 01:47:41.110
Se as palavras são uma matriz de strings, você obtém a primeira string com palavras[0].

01:47:41.110 --> 01:47:44.530
Como você obtém o primeiro caractere na primeira string?

01:47:44.530 --> 01:47:52.150
Colchete 0, palavras[0][1] e, por último, palavras[0][2].

01:47:52.150 --> 01:47:57.460
E agora aqui embaixo, palavras[1], mas o primeiro caractere está lá.

01:47:57.460 --> 01:48:00.400
Word[1], o segundo caractere está aqui.

01:48:00.400 --> 01:48:03.190
Words[1], o terceiro caractere está aqui--

01:48:03.190 --> 01:48:04.720
whoops-- o terceiro personagem está aqui.

01:48:04.720 --> 01:48:07.898
E words[1], o quarto caractere está aqui.

01:48:07.898 --> 01:48:09.190
Não é assim que as pessoas programam.

01:48:09.190 --> 01:48:10.840
Isso é apenas para fins de demonstração.

01:48:10.840 --> 01:48:13.060
Meu Deus, já é tão tedioso e prolixo.

01:48:13.060 --> 01:48:20.410
Mas se eu fizer oi agora, ./hi, agora, estou reinventando manualmente %s,

01:48:20.410 --> 01:48:22.990
se eu esqueci que existia, usando %c sozinho.

01:48:22.990 --> 01:48:25.900
Mas você pode, de fato, manipular arrays dessa maneira.

01:48:25.900 --> 01:48:28.300
Mas como strings são arrays de caracteres,

01:48:28.300 --> 01:48:32.200
você também pode manipular strings dessa maneira.

01:48:32.200 --> 01:48:34.675
Alguma pergunta agora sobre esta sintaxe?

01:48:37.210 --> 01:48:38.800
Alguma pergunta aqui?

01:48:38.800 --> 01:48:39.460
Não?

01:48:39.460 --> 01:48:39.970
Não?

01:48:39.970 --> 01:48:42.070
Tudo bem, bem, vamos em frente e propor

01:48:42.070 --> 01:48:45.830
que resolvemos alguns outros problemas que talvez não tenhamos como antes.

01:48:45.830 --> 01:48:49.150
Mas primeiro, um rápido visual do que está acontecendo por baixo do capô aqui.

01:48:49.150 --> 01:48:52.420
Se aqui, novamente, é onde paramos na tela, HI! e tchau!

01:48:52.420 --> 01:48:56.470
costas com costas, aqui está realmente como eu acabei de tratar essas coisas.

01:48:56.470 --> 01:49:00.880
s colchete 0, 1, 2, 3 e então t 0, 1, 2, 3, 4.

01:49:00.880 --> 01:49:04.840
Mas, na verdade, assim que os coloco em uma matriz, a imagem se torna esta.

01:49:04.840 --> 01:49:07.030
Words[0] é todo o HI!.

01:49:07.030 --> 01:49:08.680
Words[1] é o tchau!

01:49:08.680 --> 01:49:11.470
Mas se eu realmente entrar no assunto e começar a indexar

01:49:11.470 --> 01:49:14.980
em caracteres individuais nessas strings, tudo o que estou usando

01:49:14.980 --> 01:49:20.710
é uma nova sintaxe para representar esses mesmos valores aqui.

01:49:20.710 --> 01:49:28.710
Perguntas então, sobre essas representações antes de prosseguirmos?

01:49:28.710 --> 01:49:29.430
Não?

01:49:29.430 --> 01:49:30.030
Sim?

01:49:30.030 --> 01:49:33.390
AUDIÊNCIA: O caractere da nova linha não é [INAUDÍVEL]?

01:49:33.390 --> 01:49:36.030
DAVID MALAN: O novo personagem da linha-- diz isso mais uma vez?

01:49:36.030 --> 01:49:38.597
AUDIÊNCIA: O novo caractere de linha ocupa algum espaço?

01:49:38.597 --> 01:49:40.180
DAVID MALAN: Ah, realmente boa pergunta.

01:49:40.180 --> 01:49:42.730
O novo caractere de linha ocupa algum espaço?

01:49:42.730 --> 01:49:45.340
Sim, no que diz respeito ao printf.

01:49:45.340 --> 01:49:48.790
Mas não estou armazenando a barra invertida n em minhas strings,

01:49:48.790 --> 01:49:53.460
printf está sendo entregue manualmente essa coisa.

01:49:53.460 --> 01:49:55.520
Tudo bem, então vamos em frente e considerar

01:49:55.520 --> 01:49:58.970
como podemos resolver alguns problemas que surgiram agora com essas strings,

01:49:58.970 --> 01:50:00.680
como segue aqui.

01:50:00.680 --> 01:50:02.760
Suponha que eu-- vamos fazer isso.

01:50:02.760 --> 01:50:04.400
Deixe-me voltar ao VS Code aqui.

01:50:04.400 --> 01:50:09.980
E deixe-me ir em frente e abrir um novo arquivo chamado, que tal, length.c.

01:50:09.980 --> 01:50:12.680
E vamos considerar por um momento como eu poderia realmente descobrir

01:50:12.680 --> 01:50:16.130
qual é o comprimento de uma string, que é diferente do comprimento de uma matriz.

01:50:16.130 --> 01:50:19.680
Eu afirmei anteriormente, você não pode descobrir dinamicamente qual é o comprimento de uma matriz

01:50:19.680 --> 01:50:20.180
é.

01:50:20.180 --> 01:50:24.020
Mas posso descobrir o comprimento de uma string, especificamente, porque

01:50:24.020 --> 01:50:26.960
deste detalhe de implementação desse caractere nulo.

01:50:26.960 --> 01:50:28.500
Então deixe-me ir em frente e fazer isso.

01:50:28.500 --> 01:50:31.940
Deixe-me incluir cs50.h neste segundo programa aqui.

01:50:31.940 --> 01:50:35.090
Deixe-me incluir stdio.h, como antes.

01:50:35.090 --> 01:50:38.120
E deixe-me fazer isso, int main void--

01:50:38.120 --> 01:50:40.970
e a primeira coisa que farei é pegar uma string do usuário.

01:50:40.970 --> 01:50:43.250
Vou perguntar ao usuário, como sempre, seu nome.

01:50:43.250 --> 01:50:48.170
Então, chamarei getString e direi qual é o seu nome, ponto de interrogação, como sempre.

01:50:48.170 --> 01:50:51.620
E aqui embaixo, se eu quiser descobrir o comprimento dessa string

01:50:51.620 --> 01:50:56.210
e imprimir o comprimento na tela, bem, eu

01:50:56.210 --> 01:50:58.465
pode fazer isso semelhante em espírito à média,

01:50:58.465 --> 01:50:59.840
onde estou acumulando algo.

01:50:59.840 --> 01:51:02.600
Deixe-me prosseguir e inicializar N com 0.

01:51:02.600 --> 01:51:05.120
Deixe-me dar--

01:51:05.120 --> 01:51:07.035
não é um loop for porque eu não tenho um--

01:51:07.035 --> 01:51:08.660
Não sei de antemão quanto tempo é.

01:51:08.660 --> 01:51:09.980
Mas e se eu fizer isso?

01:51:09.980 --> 01:51:20.600
Embora o valor em name[n] não seja igual a '/0'--

01:51:20.600 --> 01:51:23.390
sintaxe maluca no momento, mas é apenas o culminar

01:51:23.390 --> 01:51:25.590
desses vários blocos de construção.

01:51:25.590 --> 01:51:28.970
Deixe-me terminar o pensamento aqui, n++.

01:51:28.970 --> 01:51:33.656
E aqui embaixo, vamos apenas imprimir, com printf e %i,

01:51:33.656 --> 01:51:38.930
esse valor de N. Então eu afirmo que isso vai me mostrar o comprimento de qualquer

01:51:38.930 --> 01:51:43.220
string que eu digito, seja oi ou tchau ou David ou qualquer outra coisa.

01:51:43.220 --> 01:51:45.410
Eu inicializo uma variável como zero, e isso é bom

01:51:45.410 --> 01:51:47.535
porque é aí que você começa a contar em geral.

01:51:47.535 --> 01:51:50.990
Enquanto name[0] não é igual a barra invertida zero.

01:51:50.990 --> 01:51:51.930
O que isso está dizendo?

01:51:51.930 --> 01:51:55.580
Bem, se o nome é a string que o usuário digitou - e o nome é apenas uma matriz,

01:51:55.580 --> 01:51:56.460
como você observou--

01:51:56.460 --> 01:51:59.390
o nome[0] será o primeiro caractere.

01:51:59.390 --> 01:52:02.750
E eu estou fazendo a pergunta, bem, o primeiro caractere não é igual

01:52:02.750 --> 01:52:03.680
barra invertida zero?

01:52:03.680 --> 01:52:08.750
E se eu digitar David, D, não é, então continuo e adiciono 1 a N.

01:52:08.750 --> 01:52:10.750
Em seguida, verificarei o nome[1].

01:52:10.750 --> 01:52:13.895
Bem, se eu digitar David, o nome[1] será A.

01:52:13.895 --> 01:52:18.020
A não é igual a barra invertida zero, e assim vai de novo e de novo

01:52:18.020 --> 01:52:18.740
e de novo.

01:52:18.740 --> 01:52:23.090
Mas cinco etapas no total depois, chegará ao byte após

01:52:23.090 --> 01:52:26.480
DAVID, perceba, espere um minuto, isso é uma barra invertida n.

01:52:26.480 --> 01:52:29.750
O loop termina e imprimo o comprimento total.

01:52:29.750 --> 01:52:33.050
Arrays, em geral, não possuem esse caractere nulo.

01:52:33.050 --> 01:52:34.910
No entanto, as cordas sim.

01:52:34.910 --> 01:52:38.150
Novamente, as strings são especiais em relação a todos os outros tipos de dados

01:52:38.150 --> 01:52:39.590
falamos até agora.

01:52:39.590 --> 01:52:43.220
Mas como eu poderia, por exemplo, fazer isso de maneira diferente?

01:52:43.220 --> 01:52:47.220
Bem, vamos fatorar isso como uma função, como sempre fiz.

01:52:47.220 --> 01:52:50.540
Mas, em vez de implementá-lo sozinho, sabe de uma coisa?

01:52:50.540 --> 01:52:54.140
Acontece que o que há de bom em strings serem tão comuns,

01:52:54.140 --> 01:52:57.260
há muitas outras pessoas que resolveram esses problemas antes.

01:52:57.260 --> 01:53:00.290
E, de fato, há toda uma biblioteca de strings em C.

01:53:00.290 --> 01:53:04.190
Ele é usado por meio de um arquivo de cabeçalho chamado string.h.

01:53:04.190 --> 01:53:08.400
E o que string.h é, é uma biblioteca de funções relacionadas a strings.

01:53:08.400 --> 01:53:10.760
Na verdade, você pode ver nas páginas de manual do CS50

01:53:10.760 --> 01:53:16.217
para C, as funções string.h, pelo menos aquelas que recomendamos como mais úteis,

01:53:16.217 --> 01:53:18.050
e, em particular, se você bisbilhotar por lá,

01:53:18.050 --> 01:53:20.290
você verá que existe uma função chamada strlen.

01:53:20.290 --> 01:53:22.055
Significa comprimento da corda.

01:53:22.055 --> 01:53:24.680
Foi nomeado de forma muito sucinta, apenas porque é um pouco mais fácil

01:53:24.680 --> 01:53:25.850
para digitar do que o comprimento da string.

01:53:25.850 --> 01:53:28.800
Mas strlen informa o comprimento de uma string.

01:53:28.800 --> 01:53:30.990
Então, como posso usar isso no meu código aqui?

01:53:30.990 --> 01:53:34.020
Bem, acontece que posso simplificar isso um pouco.

01:53:34.020 --> 01:53:37.700
Deixe-me me livrar do meu loop, me livrar da minha contabilidade

01:53:37.700 --> 01:53:40.880
manualmente, e faça algo assim-- int n

01:53:40.880 --> 01:53:45.630
é igual a strlen do nome humano, nome.

01:53:45.630 --> 01:53:49.430
E agora vou usar printf, como antes, com %i barra invertida n,

01:53:49.430 --> 01:53:51.290
e imprima o valor de n.

01:53:51.290 --> 01:53:54.380
Mas há um bug no momento.

01:53:54.380 --> 01:53:58.480
O que eu esqueci de fazer?

01:53:58.480 --> 01:54:01.670
Sim, tenho que incluir o arquivo de cabeçalho na parte superior da tela,

01:54:01.670 --> 01:54:03.260
então deixe-me-- no topo do código.

01:54:03.260 --> 01:54:07.640
Deixe-me também incluir string.h no topo do meu arquivo,

01:54:07.640 --> 01:54:10.970
para que C saiba que, de fato, strlen existe.

01:54:10.970 --> 01:54:14.170
Deixe-me ir em frente e fazer comprimento, como antes.

01:54:14.170 --> 01:54:18.670
./length-- ou na verdade, realmente pela primeira vez, qual é o seu nome?

01:54:18.670 --> 01:54:22.360
DAVID. E espero ver, de fato, 5.

01:54:22.360 --> 01:54:26.950
Por outro lado, se eu executá-lo novamente e digitar HI!, agora vejo três.

01:54:26.950 --> 01:54:29.785
Portanto, strlen é apenas uma das funções dessa biblioteca.

01:54:29.785 --> 01:54:30.910
E há muitos mais.

01:54:30.910 --> 01:54:33.700
Na verdade, outra biblioteca que pode ser útil no futuro

01:54:33.700 --> 01:54:37.570
é este, ctype, que se relaciona com dados C

01:54:37.570 --> 01:54:40.580
tipos e muitas funções que podem ser úteis.

01:54:40.580 --> 01:54:43.690
Por exemplo, se você revisar sua documentação nas páginas de manual

01:54:43.690 --> 01:54:46.930
online, você verá que existem funções através das quais

01:54:46.930 --> 01:54:49.460
podemos resolver problemas como este.

01:54:49.460 --> 01:54:52.480
Deixe-me ir em frente e propor aqui -

01:54:52.480 --> 01:54:53.680
deixe-me ver.

01:54:53.680 --> 01:54:59.080
Vamos fazer um exemplo aqui envolvendo--

01:54:59.080 --> 01:55:03.250
que tal verificar se algo está em letras maiúsculas ou minúsculas,

01:55:03.250 --> 01:55:06.700
e convertendo-o apenas para letras maiúsculas.

01:55:06.700 --> 01:55:10.810
Deixe-me voltar ao VS Code e codificar um programa chamado uppercase.c.

01:55:10.810 --> 01:55:15.220
Neste arquivo vou começar incluindo agora, como sempre, cs50.h.

01:55:15.220 --> 01:55:17.710
Vou incluir stdio.h.

01:55:17.710 --> 01:55:21.670
E vou adicionar outro à mistura, que

01:55:21.670 --> 01:55:26.230
é string.h agora também, para que eu possa acessar o comprimento das coisas conforme necessário.

01:55:26.230 --> 01:55:28.570
Int main void vem a seguir.

01:55:28.570 --> 01:55:30.460
E então dentro da minha função principal, eu vou

01:55:30.460 --> 01:55:32.230
para ir em frente e declarar uma string chamada s.

01:55:32.230 --> 01:55:34.240
Vou chamar getString, como antes.

01:55:34.240 --> 01:55:38.170
E vou em frente e apenas pedir ao usuário uma string chamada antes.

01:55:38.170 --> 01:55:39.670
Quero fazer um antes e depois.

01:55:39.670 --> 01:55:41.350
O que quer que o usuário digite é antes.

01:55:41.350 --> 01:55:44.770
Mas eu quero forçar tudo para letras maiúsculas, depois disso.

01:55:44.770 --> 01:55:48.740
Deixe-me agora, neste loop aqui, fazer isso.

01:55:48.740 --> 01:55:53.800
Deixe-me imprimir entre aspas, "Depois", apenas para que possamos ver isso na tela.

01:55:53.800 --> 01:56:02.440
E deixe-me fazer quatro int i obtém 0, i é menor que strlen de s, i++.

01:56:02.440 --> 01:56:03.610
O que estou prestes a fazer?

01:56:03.610 --> 01:56:06.190
Estou prestes a iterar sobre todos os caracteres da string

01:56:06.190 --> 01:56:11.230
da esquerda para a direita, de 0 até, mas não completamente, o comprimento de s.

01:56:11.230 --> 01:56:13.990
E como faço para verificar se algo está em minúsculas,

01:56:13.990 --> 01:56:16.990
para que eu possa realmente forçá-lo a maiúsculas?

01:56:16.990 --> 01:56:19.630
Bem, acontece que eu poderia fazer isso literalmente.

01:56:19.630 --> 01:56:27.436
Se o caractere em s no local i for maior ou igual ao A maiúsculo,

01:56:27.436 --> 01:56:31.780
e comercial, e comercial, que significa e em vez de ou, que vimos

01:56:31.780 --> 01:56:37.930
no passado, s[i] é menor ou igual a pouco z, isso significa,

01:56:37.930 --> 01:56:41.800
logicamente em inglês, que isso é realmente minúsculo.

01:56:41.800 --> 01:56:44.830
Como faço agora para convertê-lo em maiúsculas, este caractere?

01:56:44.830 --> 01:56:48.160
Bem, eu poderia literalmente imprimir o mesmo caractere.

01:56:48.160 --> 01:56:52.280
Mas essa não seria a resposta aqui porque isso não está alterando o valor.

01:56:52.280 --> 01:56:54.470
Mas o que eu poderia fazer em vez disso?

01:56:54.470 --> 01:56:59.890
Bem, deixe-me puxar aqui bem rápido o gráfico ASCII como antes,

01:56:59.890 --> 01:57:03.220
e vamos ver se conseguimos obter algum insight.

01:57:03.220 --> 01:57:05.710
Se eu abrir o mesmo gráfico ASCII e supor

01:57:05.710 --> 01:57:09.790
o humano digitou um a minúsculo, isso é 97.

01:57:09.790 --> 01:57:13.240
Qual letra-- eu quero convertê-la em maiúscula

01:57:13.240 --> 01:57:18.660
A, então para qual número eu quero converter o 97, zero por semana?

01:57:18.660 --> 01:57:21.000
Então, 65, continuamos voltando a esse.

01:57:21.000 --> 01:57:23.010
E se o usuário digitar b minúsculo?

01:57:23.010 --> 01:57:27.550
Quero alterar o valor de 98 para 66 e assim por diante.

01:57:27.550 --> 01:57:30.130
E qualquer matemática rápida, quão distantes estão eles?

01:57:30.130 --> 01:57:33.120
Então é sempre 32, como maiúsculas para minúsculas

01:57:33.120 --> 01:57:37.990
é sempre, maravilhosamente, bom design, 32 de distância, um do outro.

01:57:37.990 --> 01:57:39.100
Então o que isso quer dizer?

01:57:39.100 --> 01:57:41.350
Bem, acho que vimos antes que sob o capô,

01:57:41.350 --> 01:57:42.600
um char é apenas um número.

01:57:42.600 --> 01:57:44.340
Você certamente pode fazer aritmética nele.

01:57:44.340 --> 01:57:46.507
E aqui, novamente, se você entender esses níveis inferiores

01:57:46.507 --> 01:57:48.180
primitivos, e se eu fizer isso?

01:57:48.180 --> 01:57:53.940
O que quer que s[i] seja, se eu souber na linha 13 que está em letras minúsculas,

01:57:53.940 --> 01:57:57.048
eu quero somar ou subtrair 32?

01:57:57.048 --> 01:57:57.840
AUDIÊNCIA: Subtrair.

01:57:57.840 --> 01:58:01.910
DAVID MALAN: Então, eu quero subtrair porque quero ir de 97 para 65

01:58:01.910 --> 01:58:06.560
ou 98 a 66, então, de fato, se você fizer algumas contas rápidas, isso lhe dará 32.

01:58:06.560 --> 01:58:10.970
Então basta tratar os caracteres como números, subtrair o 32,

01:58:10.970 --> 01:58:16.370
e imprimi-lo com %c, eu acho, apenas converterá letras minúsculas em maiúsculas.

01:58:16.370 --> 01:58:19.795
Se agora você avançar para o mundo real, Microsoft Word ou Google Docs,

01:58:19.795 --> 01:58:22.670
se você já escolheu a opção de menu que força as coisas a maiúsculas

01:58:22.670 --> 01:58:24.980
ou minúsculas de vez em quando, literalmente, isso é

01:58:24.980 --> 01:58:26.480
o que a Microsoft e o Google fizeram.

01:58:26.480 --> 01:58:29.605
Eles iteram sobre todos os caracteres do documento, verificam se estão em minúsculas,

01:58:29.605 --> 01:58:33.810
e se assim for, eles subtraem 32 dele e mostram o novo valor.

01:58:33.810 --> 01:58:36.650
E se, porém, não for uma letra minúscula?

01:58:36.650 --> 01:58:40.520
Acho que posso simplificar e apenas imprimir a carta atual inalterada,

01:58:40.520 --> 01:58:44.850
se meu objetivo é simplesmente forçar as coisas para todas as letras maiúsculas, e essa letra,

01:58:44.850 --> 01:58:46.490
então seria s[i].

01:58:46.490 --> 01:58:50.750
Então deixe-me ir em frente agora e fazer letras maiúsculas, espero, sem erros.

01:58:50.750 --> 01:58:55.670
./maiúsculo, e agora vou digitar David com um D maiúsculo,

01:58:55.670 --> 01:58:57.120
mas todo o resto em minúsculo.

01:58:57.120 --> 01:59:00.020
Mas agora a versão posterior é DAVID--

01:59:00.020 --> 01:59:01.190
um erro estético.

01:59:01.190 --> 01:59:04.400
Observe aqui, eu esqueci de incluir, só por uma questão de beleza,

01:59:04.400 --> 01:59:05.930
uma barra invertida n no final.

01:59:05.930 --> 01:59:07.640
Não tem problema, vou adicionar isso.

01:59:07.640 --> 01:59:08.870
Deixe-me consertar meu erro.

01:59:08.870 --> 01:59:12.050
Tornar maiúsculo, ./maiúsculo, Enter.

01:59:12.050 --> 01:59:14.240
DAVID, entra e pronto.

01:59:14.240 --> 01:59:16.820
E eu deliberadamente adicionei outro espaço depois,

01:59:16.820 --> 01:59:19.130
apenas para que eles se alinhassem bem, mesmo que antes

01:59:19.130 --> 01:59:22.070
e depois têm diferentes números de letras.

01:59:22.070 --> 01:59:25.630
Perguntas então, sobre essa implementação de forçar algo

01:59:25.630 --> 01:59:28.380
para maiúsculas, o que por si só não é tão esclarecedor,

01:59:28.380 --> 01:59:33.990
mas representa agora como você pode aproveitar esses primitivos de baixo nível.

01:59:33.990 --> 01:59:35.880
Pergunta?

01:59:35.880 --> 01:59:36.380
Não?

01:59:36.380 --> 01:59:38.633
Tudo bem, bem, isso honestamente é tedioso.

01:59:38.633 --> 01:59:40.550
Meu Deus, como a Microsoft, o Google, todo mundo,

01:59:40.550 --> 01:59:43.550
você tem que literalmente escrever este código apenas para fazer algo simples?

01:59:43.550 --> 01:59:46.310
Bem, não, é por isso que temos coisas como bibliotecas.

01:59:46.310 --> 01:59:49.220
E cada vez mais agora, para conjuntos de problemas, projetos e além,

01:59:49.220 --> 01:59:52.040
bem, você apenas usa bibliotecas com mais frequência disponíveis no mercado

01:59:52.040 --> 01:59:55.940
para resolver problemas que, certamente, outras pessoas tiveram antes de você.

01:59:55.940 --> 01:59:59.570
Então, como posso agora usar esta biblioteca, ctype.h?

01:59:59.570 --> 02:00:01.320
Bem, deixe-me voltar ao meu código.

02:00:01.320 --> 02:00:05.090
Deixe-me incluir isso entre meus arquivos de cabeçalho aqui.

02:00:05.090 --> 02:00:08.030
Só para poder folhear as coisas facilmente, costumo colocar meus cabeçalhos em ordem alfabética.

02:00:08.030 --> 02:00:11.238
Mas isso não é estritamente necessário, mas permite-me, à primeira vista, perceber,

02:00:11.238 --> 02:00:13.400
eu incluí ou não algo que eu preciso?

02:00:13.400 --> 02:00:15.570
Agora, deixe-me ir em frente e fazer isso.

02:00:15.570 --> 02:00:20.390
Acontece que se você ler a documentação da biblioteca de tipos C,

02:00:20.390 --> 02:00:24.710
há uma função, maravilhosamente chamada, if islower,

02:00:24.710 --> 02:00:28.910
que leva em um personagem como seu argumento, essencialmente, então s[i].

02:00:28.910 --> 02:00:32.182
E se isso retornar true, um valor booleano, se preferir,

02:00:32.182 --> 02:00:33.890
bem, vou forçá-lo a letras minúsculas.

02:00:33.890 --> 02:00:36.560
Mas não preciso mais fazer essa matemática.

02:00:36.560 --> 02:00:40.610
Acontece que, na biblioteca de tipos C, também há uma função chamada para superior

02:00:40.610 --> 02:00:43.130
que recebe um caractere como entrada, como s[i],

02:00:43.130 --> 02:00:45.060
e ele apenas faz as contas para você.

02:00:45.060 --> 02:00:47.270
Para que você possa abstrair a coisa 32,

02:00:47.270 --> 02:00:50.400
e saiba que outra pessoa resolveu esse problema para você.

02:00:50.400 --> 02:00:53.030
Caso contrário, posso deixar meu código inalterado abaixo

02:00:53.030 --> 02:00:55.200
porque eu não estou mudando mais nada.

02:00:55.200 --> 02:01:00.410
Portanto, se eu fizer letras maiúsculas agora e depois ./maiúsculas, David,

02:01:00.410 --> 02:01:03.710
com apenas um D maiúsculo, e agora ainda funciona.

02:01:03.710 --> 02:01:06.890
Mas se você ler mais a documentação, verifica-se que para superior

02:01:06.890 --> 02:01:07.520
é inteligente.

02:01:07.520 --> 02:01:10.220
Se você passar um caractere para maiúsculo, isso é minúsculo,

02:01:10.220 --> 02:01:13.040
obviamente, converte-o em maiúsculas fazendo essa matemática.

02:01:13.040 --> 02:01:17.240
Mas se você passar um caractere para maiúsculo que já esteja maiúsculo,

02:01:17.240 --> 02:01:21.540
a documentação que você veria lhe diz que o deixa inalterado.

02:01:21.540 --> 02:01:23.910
Então eu posso apertar tudo isso.

02:01:23.910 --> 02:01:25.880
Eu posso me livrar de todo o resto.

02:01:25.880 --> 02:01:29.150
Posso me livrar do todo se, e sem dúvida agora,

02:01:29.150 --> 02:01:33.620
implementar um programa igualmente correto, mas melhor projetado.

02:01:33.620 --> 02:01:34.250
Por que?

02:01:34.250 --> 02:01:38.000
Menos linhas de código mais fáceis de ler, menor probabilidade de erros,

02:01:38.000 --> 02:01:39.740
supondo que a biblioteca esteja correta.

02:01:39.740 --> 02:01:43.160
Isso apenas torna mais fácil e rápido para mim, agora, escrever código.

02:01:43.160 --> 02:01:47.960
Portanto, se eu fizer isso, pela última vez, em letras maiúsculas, Enter, ./maiúsculas,

02:01:47.960 --> 02:01:50.190
e digite meu nome, ainda funcionando.

02:01:50.190 --> 02:01:53.810
Mas agora observe, reduzimos isso a muito menos linhas de código,

02:01:53.810 --> 02:01:57.740
embora, usando agora esta biblioteca adicional.

02:01:57.740 --> 02:02:00.140
Perguntas então sobre como fizemos isso?

02:02:03.930 --> 02:02:06.230
Bem, mesmo que esse código, ouso dizer, esteja correto,

02:02:06.230 --> 02:02:09.120
ainda não é necessariamente bem projetado.

02:02:09.120 --> 02:02:12.590
Na verdade, há uma linha de código, uma função

02:02:12.590 --> 02:02:14.690
chamar esta implementação atual que é

02:02:14.690 --> 02:02:17.900
mais ineficiente do que deveria ser.

02:02:17.900 --> 02:02:20.630
E permita-me chamar sua atenção para isso aqui,

02:02:20.630 --> 02:02:24.320
linha 10, onde estamos chamando strlen.

02:02:24.320 --> 02:02:27.350
Mas estamos chamando dentro deste loop for, especificamente,

02:02:27.350 --> 02:02:29.000
dentro da condição.

02:02:29.000 --> 02:02:33.720
E por que isso pode não ser necessariamente a melhor ideia?

02:02:33.720 --> 02:02:36.810
Bem, o comprimento da corda está sempre mudando?

02:02:36.810 --> 02:02:38.950
Quero dizer, certamente não dentro do alcance deste loop.

02:02:38.950 --> 02:02:42.840
E aqui estamos dentro do nosso loop for nas linhas 10, 11, 12 e 13,

02:02:42.840 --> 02:02:45.242
perguntando a cada iteração a mesma pergunta.

02:02:45.242 --> 02:02:46.200
Qual é o comprimento de s?

02:02:46.200 --> 02:02:47.190
Qual é o comprimento de s?

02:02:47.190 --> 02:02:48.330
Qual é o comprimento de s?

02:02:48.330 --> 02:02:50.702
E, por sua vez, estamos chamando strlen toda vez,

02:02:50.702 --> 02:02:52.660
mesmo que estejamos recebendo a mesma resposta.

02:02:52.660 --> 02:02:54.960
Então eu ouso dizer que uma solução melhor aqui seria

02:02:54.960 --> 02:02:58.230
talvez seja para descobrir o comprimento de s anteriormente no meu código,

02:02:58.230 --> 02:02:59.490
e talvez declarar uma variável.

02:02:59.490 --> 02:03:02.580
Ou talvez faça algo sintaticamente um pouco mais elegante,

02:03:02.580 --> 02:03:05.070
e, de fato, um design muito comum em um loop como este,

02:03:05.070 --> 02:03:07.860
seria declarar não apenas uma variável como i,

02:03:07.860 --> 02:03:12.060
mas para realmente declarar uma segunda variável chamada n, por exemplo, onde

02:03:12.060 --> 02:03:16.530
n é apenas um número, defina n igual ao comprimento de s.

02:03:16.530 --> 02:03:18.900
Mas a partir daí, dentro dessa condição,

02:03:18.900 --> 02:03:24.540
em vez de chamar strlen de s de novo e de novo e de novo, o que posso fazer agora?

02:03:24.540 --> 02:03:28.110
Em vez disso, eu poderia apenas comparar i contra o próprio n,

02:03:28.110 --> 02:03:31.080
porque n agora só será calculado uma vez quando for inicializado,

02:03:31.080 --> 02:03:32.730
assim como eu é inicializado com zero.

02:03:32.730 --> 02:03:36.000
E depois disso, vamos comparar i, que está mudando,

02:03:36.000 --> 02:03:37.350
contra n, que não será.

02:03:37.350 --> 02:03:40.330
Portanto, será um pouco mais eficiente por design.

02:03:40.330 --> 02:03:42.900
Agora, com isso dito, um bom compilador também poderia

02:03:42.900 --> 02:03:46.080
reconhecer que existe essa possibilidade de otimização,

02:03:46.080 --> 02:03:47.100
e talvez faça isso por nós.

02:03:47.100 --> 02:03:49.080
Mas por enquanto, melhor adquirir o hábito, melhor

02:03:49.080 --> 02:03:52.260
para desenvolver a memória muscular para tomar as melhores decisões de design

02:03:52.260 --> 02:03:54.010
vocês mesmos.

02:03:54.010 --> 02:03:56.380
Perguntas, então, sobre como fizemos isso?

02:03:58.900 --> 02:03:59.650
Não?

02:03:59.650 --> 02:04:03.050
Certo, alguns blocos de construção finais para o dia.

02:04:03.050 --> 02:04:07.870
Então começamos falando sobre os argumentos de linha de comando que o clang usa,

02:04:07.870 --> 02:04:13.090
por meio do qual, qualquer coisa após o comando que você digita em um prompt, seja make

02:04:13.090 --> 02:04:18.160
ou clang ou mesmo CD no Linux, qualquer palavra depois, ou algo assim

02:04:18.160 --> 02:04:21.350
enigmático como -o é um argumento de linha de comando.

02:04:21.350 --> 02:04:22.840
É uma entrada para o comando.

02:04:22.840 --> 02:04:26.132
É diferente de um argumento de função porque um argumento de função, é claro,

02:04:26.132 --> 02:04:27.280
é uma entrada para uma função.

02:04:27.280 --> 02:04:28.345
Mas é a mesma ideia.

02:04:28.345 --> 02:04:30.970
É apenas uma sintaxe diferente após o cifrão no prompt.

02:04:30.970 --> 02:04:33.880
Bem, acontece que os argumentos da linha de comando

02:04:33.880 --> 02:04:37.660
são algo que você agora pode usar em seus próprios programas

02:04:37.660 --> 02:04:41.800
acessando palavras após o prompt.

02:04:41.800 --> 02:04:45.410
E deixe-me propor que inventemos isso da seguinte maneira.

02:04:45.410 --> 02:04:49.540
Deixe-me propor que voltemos ao VS Code aqui,

02:04:49.540 --> 02:04:53.560
e abrirei um novo arquivo aqui chamado greet.c.

02:04:53.560 --> 02:04:56.410
Então, em greet.c, será um programa que simplesmente cumprimenta

02:04:56.410 --> 02:04:57.070
o usuário.

02:04:57.070 --> 02:04:59.440
Se tivéssemos escrito isso na semana passada, teríamos feito isso.

02:04:59.440 --> 02:05:08.200
Inclua cs50.he, em seguida, inclua stdio.h e, em seguida, int main void,

02:05:08.200 --> 02:05:13.060
e então podemos fazer algo simples como string name equals getString,

02:05:13.060 --> 02:05:15.980
entre aspas, "Qual é o seu nome?"

02:05:15.980 --> 02:05:20.020
E então teríamos impresso, como sempre, Hello, %s,

02:05:20.020 --> 02:05:21.490
e, em seguida, conectando esse nome.

02:05:21.490 --> 02:05:25.300
Este é o mesmo programa que implementamos muitas vezes, apenas

02:05:25.300 --> 02:05:26.590
para ter certeza de que funciona...

02:05:26.590 --> 02:05:29.140
embora, não, não seja exatamente o mesmo programa.

02:05:29.140 --> 02:05:30.940
O ponto e vírgula está no lugar errado.

02:05:30.940 --> 02:05:32.960
Este agora é o mesmo programa.

02:05:32.960 --> 02:05:37.610
Portanto, faça saudação, ponto ./saudação e digitarei meu próprio nome. Olá, David.

02:05:37.610 --> 02:05:38.770
Então voltamos lá.

02:05:38.770 --> 02:05:41.770
Agora, o que é indiscutivelmente um pouco irritante sobre este programa,

02:05:41.770 --> 02:05:44.110
se eu digitar algo mais como, Carter,

02:05:44.110 --> 02:05:48.130
Entre, tenho que executar o programa, aguarde o prompt, digite meu nome,

02:05:48.130 --> 02:05:48.910
aperte Enter.

02:05:48.910 --> 02:05:52.360
Tudo bem, mas imagine se todo programa funcionasse assim.

02:05:52.360 --> 02:05:55.415
Como make, suponha que você só pode digitar make, então você espera por um prompt,

02:05:55.415 --> 02:05:58.540
em seguida, digite o nome do programa que deseja criar e pressione Enter.

02:05:58.540 --> 02:06:01.720
Ou pior, no Linux, quando você precisa mudar de diretório,

02:06:01.720 --> 02:06:05.263
como você pode ter para o conjunto de problemas um, e se você tivesse que digitar CD, Enter,

02:06:05.263 --> 02:06:07.930
agora digite o nome da pasta que você deseja mudar, Enter--

02:06:07.930 --> 02:06:09.710
Quero dizer, isso apenas retarda a vida.

02:06:09.710 --> 02:06:11.470
E assim fica irritante rapidamente.

02:06:11.470 --> 02:06:16.070
Portanto, os argumentos da linha de comando permitem que você expresse todo o seu pensamento de uma só vez.

02:06:16.070 --> 02:06:18.200
Então, como posso fazer isso?

02:06:18.200 --> 02:06:22.450
Bem, se eu quiser expressar a noção de argumentos de linha de comando em meu código,

02:06:22.450 --> 02:06:25.640
Eu poderia fazer algo assim.

02:06:25.640 --> 02:06:28.750
Eu poderia, pela primeira vez, subir e pegar

02:06:28.750 --> 02:06:33.730
livrar deste vazio, que a partir de hoje significa, este programa não aceita nenhum comando

02:06:33.730 --> 02:06:34.780
argumentos de linha.

02:06:34.780 --> 02:06:37.540
E eu posso mudá-lo para exatamente isso.

02:06:37.540 --> 02:06:43.490
Int argc, string argv, com colchetes.

02:06:43.490 --> 02:06:44.950
Agora é enigmático, reconhecidamente.

02:06:44.950 --> 02:06:46.150
E deixe-me ampliar.

02:06:46.150 --> 02:06:49.300
Mas acho que talvez possamos inferir agora, o que está acontecendo.

02:06:49.300 --> 02:06:52.750
Se main agora não tiver void como entrada, o que

02:06:52.750 --> 02:06:55.600
significa que não é preciso argumentos, certamente, o spoiler

02:06:55.600 --> 02:06:59.230
aqui está que agora main receberá argumentos de linha de comando de alguma forma.

02:06:59.230 --> 02:07:05.180
Algum palpite sobre o que argv é ou será?

02:07:05.180 --> 02:07:08.330
O que isso pode representar?

02:07:08.330 --> 02:07:11.390
É uma matriz de strings, certo, por meio da sintaxe.

02:07:11.390 --> 02:07:13.223
Sim?

02:07:13.223 --> 02:07:15.480
AUDIÊNCIA: Todos os personagens serão digitados.

02:07:15.480 --> 02:07:16.050
DAVID MALAN: Exatamente.

02:07:16.050 --> 02:07:18.550
Serão todos os personagens, ou realmente todas as palavras

02:07:18.550 --> 02:07:19.830
que você digita no prompt.

02:07:19.830 --> 02:07:21.765
Argc, como um int, algum palpite?

02:07:24.360 --> 02:07:28.700
A contagem de argumentos é o que geralmente significa, embora tecnicamente,

02:07:28.700 --> 02:07:30.290
você poderia chamar essas coisas de qualquer coisa.

02:07:30.290 --> 02:07:31.520
Mas esta é a convenção.

02:07:31.520 --> 02:07:35.780
Como afirmei anteriormente que os arrays não acompanham seu próprio comprimento,

02:07:35.780 --> 02:07:38.930
se você quiser saber quantas palavras o humano digitou no prompt

02:07:38.930 --> 02:07:41.420
após o nome do seu programa, você deve ser informado,

02:07:41.420 --> 02:07:45.650
não apenas a matriz das palavras, mas o comprimento dessa matriz.

02:07:45.650 --> 02:07:48.530
As strings, você pode descobrir o comprimento usando strlen,

02:07:48.530 --> 02:07:53.360
mas você não consegue descobrir o comprimento da matriz de strings, a coleção

02:07:53.360 --> 02:07:55.020
de palavras que o humano digitou.

02:07:55.020 --> 02:07:56.760
Então, como posso usar isso agora?

02:07:56.760 --> 02:07:59.190
Bem, deixe-me ir em frente e fazer isso.

02:07:59.190 --> 02:08:04.190
Deixe-me ir em frente e mudar este programa agora apenas para ser printf, aspas, aspas,

02:08:04.190 --> 02:08:11.630
"olá, %2 /n", então argv[1].

02:08:11.630 --> 02:08:14.780
Portanto, esta ainda não é a melhor versão do meu código, mas é a minha primeira.

02:08:14.780 --> 02:08:21.020
Cumprimente, e agora deixe-me cumprimentá-lo, David de uma só vez.

02:08:21.020 --> 02:08:23.210
Entre, olá, David.

02:08:23.210 --> 02:08:25.820
Agora deixe-me executá-lo novamente, ./saudar, Carter.

02:08:25.820 --> 02:08:27.620
Entre, olá, Carter.

02:08:27.620 --> 02:08:29.840
É uma melhoria marginal, mas não tenho

02:08:29.840 --> 02:08:32.330
esperar que getString me avise para pressionar Enter.

02:08:32.330 --> 02:08:34.370
É apenas acelerar as coisas, duas vezes mais rápido.

02:08:34.370 --> 02:08:36.890
Um comando a menos para digitar.

02:08:36.890 --> 02:08:41.390
Mas eu deliberadamente fiz [1], mas qual é o começo de argv?

02:08:41.390 --> 02:08:42.170
Seria [0].

02:08:44.730 --> 02:08:45.780
Bem, o que é isso?

02:08:45.780 --> 02:08:48.840
Às vezes, isso é útil, embora, por enquanto, não seja.

02:08:48.840 --> 02:08:54.110
Suponha que eu recompile meu código e execute este programa agora, cumprimente David.

02:08:54.110 --> 02:08:58.598
Alguém quer adivinhar o que há em argv[0]?

02:08:58.598 --> 02:08:59.530
AUDIÊNCIA: [INAUDÍVEL]

02:08:59.530 --> 02:09:00.220
DAVID MALAN: Diga de novo?

02:09:00.220 --> 02:09:01.230
AUDIÊNCIA: Cumprimente, olá.

02:09:01.230 --> 02:09:04.530
DAVID MALAN: Cumprimente, Entre, olá, ./cumprimente.

02:09:04.530 --> 02:09:08.280
Portanto, se você deseja criar um estilo inicial para seu programa para descobrir o que

02:09:08.280 --> 02:09:11.910
seu próprio nome é, ou pelo menos como foi executado na linha de comando,

02:09:11.910 --> 02:09:14.460
no terminal, você pode olhar para argv[0].

02:09:14.460 --> 02:09:17.160
Em geral, provavelmente não é tão útil, provavelmente melhor

02:09:17.160 --> 02:09:21.900
para começar a olhar para [1], que era a primeira palavra após o nome do programa.

02:09:21.900 --> 02:09:25.320
E se houvesse mais, eu poderia fazer isso, que tal argv[2],

02:09:25.320 --> 02:09:27.690
deixe-me adicionar um segundo %s.

02:09:27.690 --> 02:09:29.550
Deixe-me recompilar a saudação.

02:09:29.550 --> 02:09:35.490
Deixe-me fazer ./greet David Malan, Enter, e isso também agora funciona,

02:09:35.490 --> 02:09:37.112
tomando em duas palavras no prompt.

02:09:37.112 --> 02:09:38.820
Se eu realmente quero ser inteligente nisso agora,

02:09:38.820 --> 02:09:40.445
Eu poderia fazer algo assim, no entanto.

02:09:40.445 --> 02:09:44.700
Que tal se a contagem de argumentos, AKA argc,

02:09:44.700 --> 02:09:49.890
igual a igual a, então suponha que o humano digitou apenas seu primeiro nome,

02:09:49.890 --> 02:09:58.440
e imprima olá vírgula %s /n e depois argv[1].

02:09:58.440 --> 02:10:01.470
Caso contrário, se o humano não fornecer exatamente dois

02:10:01.470 --> 02:10:04.920
argumentos, o nome do programa e seu próprio nome,

02:10:04.920 --> 02:10:07.890
vamos apenas imprimir um valor padrão, para que não esqueçam o nome

02:10:07.890 --> 02:10:09.990
ou eles digitaram dois nomes ou três nomes.

02:10:09.990 --> 02:10:13.110
Vamos apenas fazer, hello comma world como padrão.

02:10:13.110 --> 02:10:15.270
E vamos simplesmente ignorar o que o humano digitou.

02:10:15.270 --> 02:10:20.850
Se eu recompilar isso, faça greet, posso fazer ./greet e David novamente, Enter.

02:10:20.850 --> 02:10:24.840
Ops, desculpe, o que estou perdendo?

02:10:24.840 --> 02:10:26.640
Sim, então erro de novato.

02:10:26.640 --> 02:10:30.090
Caso contrário, tudo bem, cumprimente novamente.

02:10:30.090 --> 02:10:34.050
./cumprimente, David, Entre, aqui está o meu olá, David.

02:10:34.050 --> 02:10:37.870
Mas se eu omitir meu nome, recebo apenas o genérico, como um valor padrão.

02:10:37.870 --> 02:10:41.590
E se eu ficar um pouco curioso e digitar os dois nomes, também serei ignorado.

02:10:41.590 --> 02:10:42.090
Por que?

02:10:42.090 --> 02:10:44.880
Porque eu simplesmente não criei suporte para argc de três.

02:10:44.880 --> 02:10:47.610
Eu poderia fazer o que quisesse, mas agora temos acesso

02:10:47.610 --> 02:10:50.730
a esses tipos de blocos de construção.

02:10:50.730 --> 02:10:52.780
Tudo bem, o que mais posso fazer aqui?

02:10:52.780 --> 02:10:57.660
Bem, pode haver alguns recursos finais para executarmos agora.

02:10:57.660 --> 02:11:00.090
Observe, porém, que em C, apesar do que você

02:11:00.090 --> 02:11:02.820
pode ver em livros ou tutoriais online, hoje em dia,

02:11:02.820 --> 02:11:06.180
os dois formatos oficiais para definir uma função principal

02:11:06.180 --> 02:11:11.130
são isso, que estamos usando há mais de duas semanas ou agora isso,

02:11:11.130 --> 02:11:14.250
por meio do qual, você altera o void para int argc,

02:11:14.250 --> 02:11:17.880
e então, por enquanto, string argv e colchetes vazios.

02:11:17.880 --> 02:11:20.608
E veremos que isso também é uma simplificação, algum treinamento

02:11:20.608 --> 02:11:21.400
rodas se você quiser.

02:11:21.400 --> 02:11:23.550
Mas, por enquanto, essas são as duas formas, mesmo

02:11:23.550 --> 02:11:26.550
embora você veja em tutoriais online e até mesmo em livros, algumas pessoas

02:11:26.550 --> 02:11:27.840
use main de maneiras diferentes.

02:11:27.840 --> 02:11:30.142
Estes são os dois agora para manter em mente.

02:11:30.142 --> 02:11:32.100
E observarei que esses argumentos de linha de comando

02:11:32.100 --> 02:11:33.360
estão em todo lugar.

02:11:33.360 --> 02:11:35.590
Provavelmente não esperava ver esta palavra na tela aqui.

02:11:35.590 --> 02:11:36.490
E o que isto quer dizer?

02:11:36.490 --> 02:11:37.920
Bem, acontece que por décadas-- há

02:11:37.920 --> 02:11:40.080
na verdade, este programa que vem com os sistemas Linux

02:11:40.080 --> 02:11:41.880
em particular chamado de cowsay.

02:11:41.880 --> 02:11:42.510
Por que?

02:11:42.510 --> 02:11:45.300
Provavelmente porque alguém teve muito tempo livre uma vez e decidiu

02:11:45.300 --> 02:11:49.920
escrever um programa que cria arte ASCII de uma vaca dizendo algo

02:11:49.920 --> 02:11:51.520
textualmente na tela.

02:11:51.520 --> 02:11:55.780
Mas você usa cowsay, apenas por diversão, por meio de argumentos de linha de comando.

02:11:55.780 --> 02:12:00.660
Então, por exemplo, deixe-me propor que eu volte ao VS Code

02:12:00.660 --> 02:12:03.020
aqui, não porque eu quero escrever qualquer código,

02:12:03.020 --> 02:12:04.770
mas eu só quero usar minha janela de terminal.

02:12:04.770 --> 02:12:07.320
E deixe-me maximizar minha janela de terminal aqui.

02:12:07.320 --> 02:12:11.880
E deixe-me ir em frente e digitar algo como, que tal cowsay,

02:12:11.880 --> 02:12:13.170
espaço moo?

02:12:13.170 --> 02:12:14.822
Portanto, o cowsay não é um programa que escrevi.

02:12:14.822 --> 02:12:16.030
Já existe há décadas.

02:12:16.030 --> 02:12:18.870
Mas nós instalamos no VS Code para você na nuvem.

02:12:18.870 --> 02:12:21.330
Leva pelo menos um argumento de linha de comando.

02:12:21.330 --> 02:12:23.070
O que você quer que a vaca diga?

02:12:23.070 --> 02:12:26.190
Eu posso dizer, cowsay moo, e apertar Enter, e pronto, lá

02:12:26.190 --> 02:12:29.490
é a minha arte ASCII de uma vaca dizendo moo na tela.

02:12:29.490 --> 02:12:31.090
Pode dizer várias palavras.

02:12:31.090 --> 02:12:33.960
Então eu posso dizer, Olá, mundo, entre.

02:12:33.960 --> 02:12:35.800
E agora diz: Olá, mundo.

02:12:35.800 --> 02:12:38.730
Portanto, este é apenas um exemplo de um programa bobo que usa linha de comando

02:12:38.730 --> 02:12:40.470
argumentos, mas leva outros também.

02:12:40.470 --> 02:12:43.650
Assim como o clang, use esta convenção de hífens

02:12:43.650 --> 02:12:45.750
para alterar a saída do programa.

02:12:45.750 --> 02:12:49.350
Traço algo é apenas uma convenção super comum com argumentos de linha de comando

02:12:49.350 --> 02:12:53.520
quando você deseja uma notação muito concisa para alguma opção como saída.

02:12:53.520 --> 02:12:56.460
Em Cowsay, li a documentação e descobri

02:12:56.460 --> 02:12:59.040
há um argumento de linha de comando traço f que

02:12:59.040 --> 02:13:03.460
permite que você mude a aparência da vaca, se quiser.

02:13:03.460 --> 02:13:10.170
Então, se eu fizer cowsay dash f, duck, e então alguma outra palavra como quack,

02:13:10.170 --> 02:13:11.640
não é mais uma vaca.

02:13:11.640 --> 02:13:15.850
Esse argumento de linha de comando o transforma em um pato minúsculo e adorável.

02:13:15.850 --> 02:13:19.020
E por último, só por diversão, porque passei muito tempo

02:13:19.020 --> 02:13:20.790
brincando com argumentos de linha de comando.

02:13:20.790 --> 02:13:25.260
Cowsay dash f, dragão, e então que tal, rawr, Enter,

02:13:25.260 --> 02:13:27.910
você pode até obter isso na tela aqui.

02:13:27.910 --> 02:13:30.150
Portanto, este também é apenas um exemplo do que você

02:13:30.150 --> 02:13:34.230
pode fazer com esses argumentos de linha de comando agora que temos esse bloco de construção.

02:13:34.230 --> 02:13:36.960
E há uma última coisa que podemos fazer com o código.

02:13:36.960 --> 02:13:39.150
Há um último recurso hoje que vamos

02:13:39.150 --> 02:13:41.610
apresentar antes de conectarmos todos esses pontos

02:13:41.610 --> 02:13:47.520
à legibilidade e criptografia falando, por último, sobre algo chamado

02:13:47.520 --> 02:13:48.450
status de saída

02:13:48.450 --> 02:13:52.380
Acontece que sempre que sua função principal sai,

02:13:52.380 --> 02:13:55.590
ele retorna um número inteiro secreto que você pode descobrir,

02:13:55.590 --> 02:13:58.260
como o programador ou um usuário avançado, o que era.

02:13:58.260 --> 02:14:02.398
E esses códigos de saída, status de saída, são normalmente usados ​​para indicar erros.

02:14:02.398 --> 02:14:05.190
Por exemplo, nos últimos dois anos, se você usou o zoom

02:14:05.190 --> 02:14:08.560
e você já teve algum tipo de erro, você deve ter visto uma tela como esta.

02:14:08.560 --> 02:14:11.040
Geralmente não é tão útil, talvez diga para você clicar

02:14:11.040 --> 02:14:13.050
Relate o problema ou entre em contato com o suporte.

02:14:13.050 --> 02:14:16.980
Mas muitas vezes em nosso mundo humano em Macs, PCs e telefones,

02:14:16.980 --> 02:14:20.010
você vê códigos de erro enigmáticos, como literalmente números

02:14:20.010 --> 02:14:23.640
que provavelmente só o Zoom conhece, ou a Microsoft ou o Google ou qualquer outra empresa

02:14:23.640 --> 02:14:25.050
escreveu o software que você está usando.

02:14:25.050 --> 02:14:28.260
Mas esse número corresponde a um erro específico

02:14:28.260 --> 02:14:32.070
que algum humano em algum lugar sabe que pode muito bem acontecer.

02:14:32.070 --> 02:14:34.950
Estes são usados ​​de forma semelhante, embora com um nome diferente

02:14:34.950 --> 02:14:38.260
sobre o qual falaremos mais adiante neste semestre, também na web.

02:14:38.260 --> 02:14:41.350
Você já viu isso-- talvez não um personagem, mas um número?

02:14:41.350 --> 02:14:43.485
Então, 404 significa o quê?

02:14:43.485 --> 02:14:44.880
AUDIÊNCIA: Erro.

02:14:44.880 --> 02:14:47.790
DAVID MALAN: Então erro, sim, mas realmente, não encontrado.

02:14:47.790 --> 02:14:48.410
Então por que?

02:14:48.410 --> 02:14:49.993
Quero dizer, esta é a coisa mais misteriosa.

02:14:49.993 --> 02:14:53.000
E falaremos em algumas semanas sobre o que esse e outros números significam,

02:14:53.000 --> 02:14:54.917
mas os números estão ao nosso redor na tecnologia,

02:14:54.917 --> 02:14:57.500
e muitas vezes significam algo para o pessoal técnico que

02:14:57.500 --> 02:15:00.270
escreveu o software, menos para humanos como você e eu.

02:15:00.270 --> 02:15:03.230
Por que tantos de nós reconhecemos o 404 é meio estranho,

02:15:03.230 --> 02:15:05.900
esse tipo existe há tempo suficiente para que todos saibamos disso.

02:15:05.900 --> 02:15:10.250
Mas na verdade é apenas um número especial que representa algum tipo de erro.

02:15:10.250 --> 02:15:13.100
Acontece que a última coisa que revelaremos hoje

02:15:13.100 --> 02:15:15.530
sobre o que temos dado como certo por duas semanas,

02:15:15.530 --> 02:15:18.200
é o que o int está em main.

02:15:18.200 --> 02:15:21.650
Vimos, há pouco, que a coisa entre parênteses, que

02:15:21.650 --> 02:15:24.680
até agora foi nulo, o que significa que não há argumentos de linha de comando.

02:15:24.680 --> 02:15:29.690
agora int argc string argv colchetes significa apenas, sim, argumentos de linha de comando.

02:15:29.690 --> 02:15:31.290
E vimos como acessá-los.

02:15:31.290 --> 02:15:33.620
Então, a última peça do quebra-cabeça, honestamente,

02:15:33.620 --> 02:15:37.460
de toda a sintaxe enigmática das últimas duas semanas, é exatamente o que int significa.

02:15:37.460 --> 02:15:40.610
Int está sempre lá para main, e indica

02:15:40.610 --> 02:15:44.300
esse main sempre retornará um número inteiro, mesmo que você e eu nunca tenhamos

02:15:44.300 --> 02:15:46.010
feito de forma explícita.

02:15:46.010 --> 02:15:50.450
Normalmente, main retorna 0, por padrão. Mas isso

02:15:50.450 --> 02:15:53.928
seria estranho se você visse uma mensagem de erro dizendo 0, então 0 está apenas oculto.

02:15:53.928 --> 02:15:55.470
Você nunca o veria na tela.

02:15:55.470 --> 02:15:58.670
Mas está acontecendo automaticamente por meio de como C é projetado.

02:15:58.670 --> 02:16:01.550
Então deixe-me escrever um programa final aqui.

02:16:01.550 --> 02:16:05.750
Vou chamá-lo, por exemplo, de status.c para mostrar esses status de saída.

02:16:05.750 --> 02:16:10.790
Código de status.c, e aqui em cima, deixe-me fazer algo simples como incluir

02:16:10.790 --> 02:16:18.020
cs50.h, então inclua stdio.h, e então int main--

02:16:18.020 --> 02:16:21.350
na verdade, vamos usar um argumento de linha de comando. int argc, string argv[],

02:16:21.350 --> 02:16:23.180
então isso é copiar, colar.

02:16:23.180 --> 02:16:26.000
Mas agora vamos fazer isso.

02:16:26.000 --> 02:16:29.280
Se argc não for igual a--

02:16:29.280 --> 02:16:30.780
por que não fazemos algo assim?

02:16:30.780 --> 02:16:33.740
Não vamos apenas padronizar para olá, mundo como da última vez.

02:16:33.740 --> 02:16:34.770
Vamos gritar com o usuário.

02:16:34.770 --> 02:16:38.802
Então, digamos algo como printf argumento de linha de comando ausente,

02:16:38.802 --> 02:16:40.760
para que saibam que erraram e precisam

02:16:40.760 --> 02:16:43.160
para executar o programa novamente corretamente.

02:16:43.160 --> 02:16:51.320
Caso contrário, vamos em frente e digamos, imprima, como antes, Olá, vírgula %s,

02:16:51.320 --> 02:16:56.730
e, em seguida, conecte argv[1], então o nome do humano no prompt.

02:16:56.730 --> 02:17:01.910
Agora, neste ponto, deixe-me executar status, ./status,

02:17:01.910 --> 02:17:03.590
e não digitarei nada primeiro.

02:17:03.590 --> 02:17:04.700
Eu recebo gritos.

02:17:04.700 --> 02:17:10.170
Desta vez, vou digitá-lo novamente. ./status David, e funciona corretamente.

02:17:10.170 --> 02:17:14.090
Mas agora deixe-me mostrar a você um comando um tanto secreto e enigmático.

02:17:14.090 --> 02:17:17.330
Você pode digitar isso no seu prompt, e é apenas uma coincidência

02:17:17.330 --> 02:17:18.740
que há outro cifrão.

02:17:18.740 --> 02:17:22.400
Echo $?, totalmente misterioso, mas permite que você

02:17:22.400 --> 02:17:25.490
para ver com qual status de saída seu programa terminou.

02:17:25.490 --> 02:17:27.559
Então deixe-me executar isso novamente da maneira errada.

02:17:27.559 --> 02:17:31.040
./status, recebo a mensagem de erro.

02:17:31.040 --> 02:17:32.780
O que foi devolvido secretamente?

02:17:32.780 --> 02:17:33.440
Eu não posso ver isso.

02:17:33.440 --> 02:17:37.280
Obviamente não há tela de erro, mas digitando echo $?,

02:17:37.280 --> 02:17:41.420
Eu posso ver que, oh, meu programa automaticamente, por padrão, retorna

02:17:41.420 --> 02:17:42.170
zero.

02:17:42.170 --> 02:17:46.879
No entanto, se eu executá-lo novamente corretamente, ./status David, Enter,

02:17:46.879 --> 02:17:48.690
esta é a versão correta.

02:17:48.690 --> 02:17:50.629
Mas se eu executar echo $?

02:17:50.629 --> 02:17:52.879
status novamente, ainda é inserido com 0.

02:17:52.879 --> 02:17:55.879
E para encurtar a história, esta é apenas uma oportunidade perdida.

02:17:55.879 --> 02:17:59.570
Quando algo dá errado, por que não retorno um valor diferente de 0?

02:17:59.570 --> 02:18:01.070
0, por padrão, significa sucesso.

02:18:01.070 --> 02:18:02.690
E está sempre lá automaticamente.

02:18:02.690 --> 02:18:04.940
Mas você pode controlar isso.

02:18:04.940 --> 02:18:11.160
Posso entrar no meu código aqui e retornar 1, caso contrário, se algo funcionar bem,

02:18:11.160 --> 02:18:14.870
Posso retornar 0, por padrão. E honestamente, se eu omitir o retorno zero,

02:18:14.870 --> 02:18:17.129
novamente, zero é retornado automaticamente.

02:18:17.129 --> 02:18:20.719
Então deixe-me ir em frente e ser explícito, só para saber o que está acontecendo.

02:18:20.719 --> 02:18:26.360
Faça status novamente, ./status, e vamos fazer isso corretamente com David.

02:18:26.360 --> 02:18:28.520
Entre, olá, David.

02:18:28.520 --> 02:18:32.059
Eco $?, zero.

02:18:32.059 --> 02:18:33.270
Então está tudo bem.

02:18:33.270 --> 02:18:38.240
Mas agora se eu fizer ./status e nada, ou várias coisas, mas não apenas David,

02:18:38.240 --> 02:18:40.530
Enter, recebo a mensagem de erro.

02:18:40.530 --> 02:18:45.230
Mas agora, se eu fizer eco $?, voila, agora é aquele.

02:18:45.230 --> 02:18:47.330
Então, o que isso significa agora?

02:18:47.330 --> 02:18:49.490
Isto é, no mundo gráfico, nós apenas

02:18:49.490 --> 02:18:51.020
mostrar algo assim na tela, que é

02:18:51.020 --> 02:18:52.459
um pouco mais informativo para o usuário.

02:18:52.459 --> 02:18:54.469
Mas mesmo no mundo do Linux, onde você não tem uma GUI,

02:18:54.469 --> 02:18:56.690
necessariamente, mesmo para os programas que escrevemos,

02:18:56.690 --> 02:18:58.549
você pode verificar esses status de saída.

02:18:58.549 --> 02:19:01.070
E, de fato, programadores mais confortáveis ​​e avançados,

02:19:01.070 --> 02:19:03.889
quando escrevem código que chama programas,

02:19:03.889 --> 02:19:07.340
seja cowsay ou qualquer outra coisa, você pode codificar,

02:19:07.340 --> 02:19:11.030
verifique qual é o status de saída de um programa e, em seguida, decida,

02:19:11.030 --> 02:19:13.170
meu programa funcionou ou não?

02:19:13.170 --> 02:19:16.219
E agora vamos conectar os pontos finais antes de

02:19:16.219 --> 02:19:19.070
adiar para alguns lanches de frutas.

02:19:19.070 --> 02:19:22.100
Criptografia, nomeadamente uma das aplicações desta semana

02:19:22.100 --> 02:19:24.770
através do qual você poderá enviar, se quiser,

02:19:24.770 --> 02:19:27.650
mensagens secretas e, melhor ainda, descriptografar mensagens secretas.

02:19:27.650 --> 02:19:29.780
Isso será além de talvez analisar

02:19:29.780 --> 02:19:32.120
a legibilidade do texto usando heurísticas, como nós

02:19:32.120 --> 02:19:34.040
identificados no início da segunda aula.

02:19:34.040 --> 02:19:38.299
Portanto, a criptografia é apenas a arte, a ciência de criptografar informações,

02:19:38.299 --> 02:19:41.330
informações embaralhadas para que, se você tiver uma mensagem secreta

02:19:41.330 --> 02:19:45.980
para enviar o chamado texto simples, você pode executá-lo através de algum algoritmo

02:19:45.980 --> 02:19:49.910
e transformá-lo no que é chamado de texto cifrado, criptografando-o.

02:19:49.910 --> 02:19:53.150
E apenas alguém que sabe qual algoritmo você usou

02:19:53.150 --> 02:19:55.880
e qual entrada você usou para o algoritmo, teoricamente,

02:19:55.880 --> 02:19:59.880
pode descriptografar esse processo e convertê-lo de volta à mensagem original.

02:19:59.880 --> 02:20:03.030
Então, se usarmos nosso modelo mental da semana passada, aqui está um problema.

02:20:03.030 --> 02:20:04.910
Aqui está uma entrada e saída.

02:20:04.910 --> 02:20:08.120
O objetivo que afirmo aqui é pegar algum texto simples, como a mensagem

02:20:08.120 --> 02:20:10.250
você deseja enviar, pense na escola primária

02:20:10.250 --> 02:20:13.640
se você já passou um bilhete para um amigo ou para sua paixão dizendo, eu te amo,

02:20:13.640 --> 02:20:16.910
é um pouco estranho se o professor ou outra pessoa interceptar o papel.

02:20:16.910 --> 02:20:19.490
E em inglês, apenas diz, eu te amo, ou o que quer que seja.

02:20:19.490 --> 02:20:22.350
Seria bom se você tivesse pelo menos criptografado de alguma forma.

02:20:22.350 --> 02:20:25.220
Mas a outra pessoa precisa saber qual algoritmo você usou

02:20:25.220 --> 02:20:27.230
e quais entradas você usa para esse algoritmo

02:20:27.230 --> 02:20:31.100
para que, em última instância, possam decodificar o chamado texto cifrado, que

02:20:31.100 --> 02:20:32.040
é a saída.

02:20:32.040 --> 02:20:34.190
Então, o que vai dentro da caixa hoje?

02:20:34.190 --> 02:20:37.970
Bem, um algoritmo, no que se refere à criptografia, é chamado de cifra.

02:20:37.970 --> 02:20:41.390
E uma cifra é um nome sofisticado para um algoritmo que criptografa texto

02:20:41.390 --> 02:20:43.250
de texto simples para texto cifrado.

02:20:43.250 --> 02:20:46.760
O problema é que precisa haver não apenas o algoritmo,

02:20:46.760 --> 02:20:48.750
precisa haver uma entrada para isso.

02:20:48.750 --> 02:20:52.590
E assim, por exemplo, você pode desenhar a figura assim pela primeira vez

02:20:52.590 --> 02:20:53.090
hoje.

02:20:53.090 --> 02:20:54.257
E nós vimos isso no código.

02:20:54.257 --> 02:20:57.180
Você pode fornecer várias entradas ou argumentos para funções.

02:20:57.180 --> 02:20:59.960
Então, nesta caixa preta, você pode imaginar passar a mensagem

02:20:59.960 --> 02:21:02.510
você deseja enviar e, em seguida, algum segredo.

02:21:02.510 --> 02:21:05.300
Assim, por exemplo, suponha que, o mais simples

02:21:05.300 --> 02:21:08.750
coisa que eu conseguia pensar quando criança era em vez de enviar a letra A,

02:21:08.750 --> 02:21:10.310
por que não escrevo a letra B?

02:21:10.310 --> 02:21:13.070
Em vez da letra B, por que não escrevo a letra C?

02:21:13.070 --> 02:21:16.280
Então eu posso deslocar o alfabeto inglês em um espaço.

02:21:16.280 --> 02:21:18.740
Então A se torna B, B se torna C, ponto, ponto, ponto,

02:21:18.740 --> 02:21:21.690
Z torna-se A. Você pode contornar no final.

02:21:21.690 --> 02:21:24.120
E vamos supor que não haja pontuação nesta parte da história.

02:21:24.120 --> 02:21:29.420
Este é um algoritmo muito simples -- adicione um valor a cada letra

02:21:29.420 --> 02:21:32.090
e envie o valor como o texto cifrado.

02:21:32.090 --> 02:21:35.540
E agora o professor, o colega, tem que saber que você usa,

02:21:35.540 --> 02:21:39.410
não apenas esse algoritmo rotacional, também conhecido como cifra de César,

02:21:39.410 --> 02:21:41.300
eles também precisam saber qual número você usa.

02:21:41.300 --> 02:21:45.200
Você adicionou 1 a cada letra, 2 a cada letra, 25 a cada letra?

02:21:45.200 --> 02:21:49.310
Agora, se eles são superinteligentes e provavelmente não tão jovens nesta história,

02:21:49.310 --> 02:21:51.165
eles também poderiam apenas tentar todas as possibilidades.

02:21:51.165 --> 02:21:53.040
E isso seria um ataque ao algoritmo.

02:21:53.040 --> 02:21:55.310
Este não é um algoritmo sofisticado, mas é

02:21:55.310 --> 02:21:56.970
o suficiente para enviar uma mensagem em sala de aula.

02:21:56.970 --> 02:21:58.940
Portanto, se as duas entradas agora forem HI!

02:21:58.940 --> 02:22:04.280
como a mensagem de texto simples e 1 como a chamada chave, o número secreto

02:22:04.280 --> 02:22:06.950
que só você e a outra pessoa sabem, você

02:22:06.950 --> 02:22:11.040
pode ser capaz de criptografar uma mensagem de uma forma para a outra.

02:22:11.040 --> 02:22:13.400
E assim, neste caso, por exemplo, HI!

02:22:13.400 --> 02:22:16.198
se tornaria IJ-!.

02:22:16.198 --> 02:22:17.990
Nesta versão do algoritmo, não estamos

02:22:17.990 --> 02:22:19.823
vai se preocupar com números ou pontuação.

02:22:19.823 --> 02:22:23.090
Operaremos apenas de A a Z, sejam letras maiúsculas ou minúsculas.

02:22:23.090 --> 02:22:28.250
Então, agora, se você receber um pedaço de papel em sala de aula com IJ nele,

02:22:28.250 --> 02:22:31.290
você, o destinatário, saberia o que é

02:22:31.290 --> 02:22:33.440
contanto que você saiba que o remetente usou um,

02:22:33.440 --> 02:22:36.500
porque você apenas inverte o algoritmo e subtrai um.

02:22:36.500 --> 02:22:39.110
O professor, eles provavelmente não sabem o que isso significa,

02:22:39.110 --> 02:22:41.443
e eles não vão perder tempo hackeando a mensagem,

02:22:41.443 --> 02:22:42.975
então parece mexido para eles.

02:22:42.975 --> 02:22:44.600
E é isso que obtemos da criptografia.

02:22:44.600 --> 02:22:47.430
Alguém que o intercepta, seja na aula ou no mundo real,

02:22:47.430 --> 02:22:51.080
na internet ou em qualquer outro lugar, não consegue descobrir, idealmente,

02:22:51.080 --> 02:22:52.700
o que você enviou.

02:22:52.700 --> 02:22:55.130
O oposto, é claro, é chamado de descriptografia,

02:22:55.130 --> 02:22:56.300
mas o processo é o mesmo.

02:22:56.300 --> 02:22:58.370
Agora passamos em menos 1.

02:22:58.370 --> 02:23:00.300
E então, que tal isso?

02:23:00.300 --> 02:23:02.840
Por que não terminamos com uma demonstração aqui?

02:23:02.840 --> 02:23:08.360
UIJT XBT DT50 - há um pouco de diferença nisso.

02:23:08.360 --> 02:23:11.060
Se passarmos isso e fizermos menos 1, bem,

02:23:11.060 --> 02:23:14.180
como extraímos o texto simples originalmente?

02:23:14.180 --> 02:23:18.200
Bem, se este é o texto cifrado, e subtraímos 1 de cada letra,

02:23:18.200 --> 02:23:28.010
Acho que U se torna T, I se torna H, J se torna I, T se torna S, X se torna W,

02:23:28.010 --> 02:23:37.580
B torna-se A, T torna-se S, D torna-se C, T torna-se S, e este foi, de facto, CS50.

02:23:37.580 --> 02:23:40.250
Coma um pato ao sair e alguns lanches no saguão.

02:23:40.250 --> 02:23:42.350
[APLAUSOS]

02:23:42.350 --> 02:23:43.850
[ROLANDO O FILME]

02:23:43.850 --> 02:23:47.500
[MÚSICA, TOCANDO]