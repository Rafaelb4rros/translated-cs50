WEBVTT

00:00:00.000 --> 00:00:02.988
[MÚSICA, TOCANDO]

00:01:12.582 --> 00:01:13.540
DAVID MALAN: Tudo bem.

00:01:13.540 --> 00:01:17.150
Este é o CS50 e já é a semana sete.

00:01:17.150 --> 00:01:20.240
E esta é a semana em que continuaremos de onde paramos

00:01:20.240 --> 00:01:22.430
com Python, apresentando a você um pouco mais de sintaxe

00:01:22.430 --> 00:01:25.580
e capacidades da linguagem para que você possa resolver problemas interessantes.

00:01:25.580 --> 00:01:27.580
Mas muitos desses problemas são cada vez mais agora

00:01:27.580 --> 00:01:29.180
vai envolver dados de alguma forma.

00:01:29.180 --> 00:01:31.250
Afinal, se você pensar em quase todos os sites

00:01:31.250 --> 00:01:36.320
ou aplicativo móvel ou processo hoje em dia que envolve a resolução de problemas,

00:01:36.320 --> 00:01:39.530
quase sempre envolve alguma quantidade de dados e frequentemente dados em escala.

00:01:39.530 --> 00:01:40.680
Muitos e muitos dados.

00:01:40.680 --> 00:01:42.430
E o que veremos primeiro hoje

00:01:42.430 --> 00:01:45.710
é que, sim, você pode usar o Python para resolver todos os problemas anteriores que já

00:01:45.710 --> 00:01:48.327
visto e também alguns dados específicos, mas às vezes é

00:01:48.327 --> 00:01:49.410
só vai incomodar.

00:01:49.410 --> 00:01:50.420
Vai ser um pouco doloroso.

00:01:50.420 --> 00:01:54.060
Vai ser mais trabalhoso do que você gostaria de apenas chegar a alguma resposta.

00:01:54.060 --> 00:01:56.870
E hoje também apresentaremos a você um novo idioma

00:01:56.870 --> 00:01:59.240
chamada SQL, Linguagem de Consulta Estruturada.

00:01:59.240 --> 00:02:02.780
E esta é uma linguagem que, com certeza, é muito menor,

00:02:02.780 --> 00:02:05.240
relativamente falando, do que C e Python.

00:02:05.240 --> 00:02:07.860
Ele meio que faz menos, mas não muito bem.

00:02:07.860 --> 00:02:11.240
E é uma linguagem para consultar bancos de dados, armazenar dados nele,

00:02:11.240 --> 00:02:13.950
atualizá-lo, inseri-lo, excluí-lo e muito mais.

00:02:13.950 --> 00:02:16.160
E é o tipo de tecnologia que é usada hoje em dia

00:02:16.160 --> 00:02:19.700
em, de fato, aplicativos da web e aplicativos móveis, ciência de dados, análise,

00:02:19.700 --> 00:02:20.940
e muito mais.

00:02:20.940 --> 00:02:23.600
É realmente bom em armazenar muitos e muitos dados.

00:02:23.600 --> 00:02:25.430
Agora, esta é mais uma linguagem.

00:02:25.430 --> 00:02:27.800
E acredite ou não, semana que vem apresentaremos a você

00:02:27.800 --> 00:02:31.880
a mais três linguagens, HTML e CSS, que não são tecnicamente

00:02:31.880 --> 00:02:32.900
linguagens de programação.

00:02:32.900 --> 00:02:35.630
Eles são todos sobre estética e marcação de informações.

00:02:35.630 --> 00:02:38.660
Mas também JavaScript, que é, na verdade, uma linguagem de programação.

00:02:38.660 --> 00:02:41.630
Mas os objetivos aqui no CS50 realmente estão indo

00:02:41.630 --> 00:02:44.000
ser para capacitá-lo a programar de forma mais geral.

00:02:44.000 --> 00:02:47.000
E, de fato, quando você estiver no mundo real daqui a alguns anos,

00:02:47.000 --> 00:02:50.330
invariavelmente haverá alguma outra linguagem popular por aí.

00:02:50.330 --> 00:02:53.880
E espero que nesta semana e na próxima e além, entre as metas

00:02:53.880 --> 00:02:56.630
não é apenas para ensinar esses idiomas especificamente, mas novamente,

00:02:56.630 --> 00:02:59.330
como aprender sozinho os futuros idiomas que ainda nem

00:02:59.330 --> 00:03:00.480
ouviu falar ainda.

00:03:00.480 --> 00:03:04.220
Dito isso, vamos começar com uma espécie de pesquisa.

00:03:04.220 --> 00:03:10.190
Se você acessar este URL em seu telefone ou laptop, cs50.ly/favorites,

00:03:10.190 --> 00:03:14.390
um formulário do Google muito simples espera por você que só vai pedir algumas

00:03:14.390 --> 00:03:16.530
de questões de múltipla escolha.

00:03:16.530 --> 00:03:24.800
Então vá para cs50.ly/favorites, e isso deve levar você a um formulário do Google que

00:03:24.800 --> 00:03:27.590
parece algo assim perguntando primeiro,

00:03:27.590 --> 00:03:31.700
a partir de agora na semana sete, qual é o seu idioma favorito entre essas opções

00:03:31.700 --> 00:03:32.250
aqui.

00:03:32.250 --> 00:03:34.220
E mais abaixo, mais uma pergunta.

00:03:34.220 --> 00:03:39.170
Se você pensar nos conjuntos de problemas de 0 a 6, o que foi, se houver,

00:03:39.170 --> 00:03:42.080
seu problema de conjunto de problemas favorito?

00:03:42.080 --> 00:03:45.110
Seja em Scratch, C ou Python.

00:03:45.110 --> 00:03:48.650
Então responda a essas duas perguntas.

00:03:48.650 --> 00:03:52.820
E em um momento, vou abrir minha tela aqui, onde você verá,

00:03:52.820 --> 00:03:56.570
e qualquer pessoa que já usou o Google Forms sabe, a planilha que é

00:03:56.570 --> 00:03:58.130
coletando agora esses dados.

00:03:58.130 --> 00:04:01.060
O Microsoft Office 365 pode fazer o mesmo se você usar um desses formulários.

00:04:01.060 --> 00:04:02.810
E o que você vê aqui agora é uma planilha

00:04:02.810 --> 00:04:06.770
no Planilhas Google, enumerando todas as perguntas do público.

00:04:06.770 --> 00:04:09.980
O idioma está na coluna B, o problema está na coluna C,

00:04:09.980 --> 00:04:13.190
e cada linha representa um aluno que respondeu.

00:04:13.190 --> 00:04:17.360
Alguns de vocês estavam super ansiosos para a aula de hoje às 8h33, horário do leste.

00:04:17.360 --> 00:04:19.040
10:32, 11:10.

00:04:19.040 --> 00:04:21.779
OK, então agora estamos entrando no tempo real da aula aqui.

00:04:21.779 --> 00:04:24.830
E se eu rolar para baixo, provavelmente veremos algumas dezenas,

00:04:24.830 --> 00:04:26.900
algumas centenas de respostas até agora.

00:04:26.900 --> 00:04:29.225
E sim, estamos obtendo muitas respostas aqui.

00:04:29.225 --> 00:04:31.100
E estou vendo alguns padrões surgirem, mas é

00:04:31.100 --> 00:04:34.190
não necessariamente óbvio para os olhos humanos quais são esses padrões.

00:04:34.190 --> 00:04:36.320
Agora, é claro, você pode usar as planilhas do Google.

00:04:36.320 --> 00:04:40.143
Você pode destacar os dados e criar gráficos magicamente a partir deles.

00:04:40.143 --> 00:04:42.560
Mas você só pode fazer o que o Google permite que você faça com os dados.

00:04:42.560 --> 00:04:45.350
E a mesma coisa para Microsoft Excel ou Apple Numbers.

00:04:45.350 --> 00:04:48.230
Mas não seria bom poder manipular os dados brutos,

00:04:48.230 --> 00:04:51.740
por mais simples que seja, apenas responder a perguntas sobre os dados?

00:04:51.740 --> 00:04:54.260
Talvez a longo prazo crie seus próprios gráficos, personalize-os

00:04:54.260 --> 00:04:56.240
do jeito que você quer, em vez de contemplado

00:04:56.240 --> 00:04:59.250
para software que está pronto para uso como este.

00:04:59.250 --> 00:05:02.130
Bem, como poderíamos fazer isso?

00:05:02.130 --> 00:05:05.330
Bem, deixe-me propor que tratemos este conjunto de dados agora

00:05:05.330 --> 00:05:08.790
como o que vamos chamar agora de um banco de dados de arquivo simples.

00:05:08.790 --> 00:05:10.850
Veremos hoje que existem bancos de dados mais sofisticados,

00:05:10.850 --> 00:05:15.200
mas o banco de dados mais simples do mundo é como um arquivo .csv.

00:05:15.200 --> 00:05:18.500
E vimos isso algumas semanas atrás em C. Escrevemos um pouco de código C

00:05:18.500 --> 00:05:23.660
que usava fprintf para gravar dados em um arquivo usando vírgulas como separador.

00:05:23.660 --> 00:05:25.910
Não fizemos muito mais com CSVs na época

00:05:25.910 --> 00:05:28.610
embora, porque é muito chato, doloroso, demorado,

00:05:28.610 --> 00:05:32.840
não é divertido usar C para algo assim por causa de malloc e memória e tudo

00:05:32.840 --> 00:05:33.413
aquela coisa.

00:05:33.413 --> 00:05:35.330
Mas com o Python, será muito mais fácil.

00:05:35.330 --> 00:05:39.530
E assim, sempre que você tiver acesso a algum conjunto de dados, basta baixá-lo

00:05:39.530 --> 00:05:42.140
para seu próprio Mac ou PC ou seu ambiente de nuvem,

00:05:42.140 --> 00:05:46.460
é uma espécie de candidato para agora escrever código para fazer algo com os dados.

00:05:46.460 --> 00:05:48.120
Talvez analisá-lo imediatamente.

00:05:48.120 --> 00:05:50.150
Se foi importado manualmente por humanos, talvez você

00:05:50.150 --> 00:05:52.550
tem que limpá-lo fazendo um monte de localizar e substituir

00:05:52.550 --> 00:05:54.852
mas não com o teclado, mas sim com o código.

00:05:54.852 --> 00:05:56.310
E então deixe-me ir em frente e fazer isso.

00:05:56.310 --> 00:05:59.780
Deixe-me voltar para minha planilha do Google aqui que tem

00:05:59.780 --> 00:06:02.010
todos os dados que chegam agora.

00:06:02.010 --> 00:06:08.430
E deixe-me ir em frente e fazer o download através do menu Arquivo aqui.

00:06:08.430 --> 00:06:09.590
E vamos ver.

00:06:09.590 --> 00:06:10.310
Download.

00:06:10.310 --> 00:06:12.170
E você pode ver um monte de opções.

00:06:12.170 --> 00:06:14.210
A maioria dos formatos pode ser familiar, mas hoje vamos

00:06:14.210 --> 00:06:17.602
concentre-se apenas neste, valores separados por vírgula ou CSV.

00:06:17.602 --> 00:06:20.810
Isso vai em frente e baixe no meu Mac aqui em meus próprios Downloads

00:06:20.810 --> 00:06:21.140
pasta.

00:06:21.140 --> 00:06:22.890
E agora vou seguir em frente e fazer isso.

00:06:22.890 --> 00:06:25.140
Deixe-me ir em frente e abrir o VS Code na nuvem aqui.

00:06:25.140 --> 00:06:28.140
E se você nunca fez isso antes, há algumas maneiras de fazê-lo.

00:06:28.140 --> 00:06:31.320
Mas a maneira mais simples de fazer upload de um arquivo para o seu espaço de código, por assim dizer,

00:06:31.320 --> 00:06:32.990
é apenas uma espécie de arrastar e soltar.

00:06:32.990 --> 00:06:36.020
Isso vai magicamente carregá-lo para o servidor lá.

00:06:36.020 --> 00:06:39.688
E veremos que, um, tem um nome de arquivo muito longo, que na verdade estou

00:06:39.688 --> 00:06:41.480
vai limpar isso porque isso vai

00:06:41.480 --> 00:06:43.880
muito tedioso digitar meu código.

00:06:43.880 --> 00:06:46.927
Então eu poderia clicar com o botão direito, é claro, aqui em cima,

00:06:46.927 --> 00:06:48.510
mas vou usar meu comando Linux.

00:06:48.510 --> 00:06:52.550
Então vamos mover este arquivo chamado CSV 50 2022 alguma coisa e vamos

00:06:52.550 --> 00:06:54.740
apenas nomeie de forma mais simples como favorites.csv.

00:06:54.740 --> 00:06:58.370
Então, tudo em minúsculas, sem espaços, uma espécie de bom básico.

00:06:58.370 --> 00:07:02.960
E deixe-me ir em frente agora e abrir este arquivo com o código favorites.csv.

00:07:02.960 --> 00:07:06.500
Vou fechar meu explorador de arquivos e veremos exatamente os mesmos dados

00:07:06.500 --> 00:07:09.890
como antes, mas não tão bonito quanto o Planilhas Google.

00:07:09.890 --> 00:07:13.640
Em vez disso, vemos aqui que ainda tenho três colunas, timestamp, language,

00:07:13.640 --> 00:07:17.013
problema e, em seguida, todos os valores abaixo, incluindo os timestamps

00:07:17.013 --> 00:07:18.180
e as respostas para as quais eles são.

00:07:18.180 --> 00:07:20.360
Mas não tem colunas adequadas.

00:07:20.360 --> 00:07:22.250
Apenas tem vírgulas separando-os.

00:07:22.250 --> 00:07:24.860
Agora, poderíamos facilmente escrever código Python

00:07:24.860 --> 00:07:28.820
assim como escrevemos código C para manipular arquivos como este

00:07:28.820 --> 00:07:30.140
seja para escrever ou ler.

00:07:30.140 --> 00:07:32.450
Mas, em vez disso, vamos fazer algo um pouco mais

00:07:32.450 --> 00:07:34.640
agradável, que é de fato na forma de Python.

00:07:34.640 --> 00:07:38.300
Portanto, o Python vem com suporte nativo para CSVs.

00:07:38.300 --> 00:07:41.200
Tem de fato um pacote chamado CSV que apenas

00:07:41.200 --> 00:07:43.700
permite que você leia e escreva e faça um monte de coisas úteis

00:07:43.700 --> 00:07:45.007
quando se trata de arquivos CSV.

00:07:45.007 --> 00:07:47.090
Então, vamos em frente e fazer algo com este arquivo.

00:07:47.090 --> 00:07:49.250
Deixe-me voltar aqui para o VS Code.

00:07:49.250 --> 00:07:51.860
Vou fechar favorites.csv por enquanto.

00:07:51.860 --> 00:07:55.430
Mas lembre-se de que o timestamp era a primeira coluna,

00:07:55.430 --> 00:07:58.640
a linguagem era a segunda coluna e o problema era a terceira.

00:07:58.640 --> 00:08:01.790
E observe como estamos usando vírgulas, elas não se alinham perfeitamente novamente,

00:08:01.790 --> 00:08:02.832
mas isso não é um problema.

00:08:02.832 --> 00:08:05.270
Há duas vírgulas em cada linha presumivelmente.

00:08:05.270 --> 00:08:09.892
E vou prosseguir e criar um arquivo chamado how about favorites.py então

00:08:09.892 --> 00:08:12.350
que posso começar a escrever algum código para manipular esses dados.

00:08:12.350 --> 00:08:13.600
E vamos fazer algo simples.

00:08:13.600 --> 00:08:16.910
Vamos apenas escrever um programa simples em Python que abre este arquivo,

00:08:16.910 --> 00:08:19.997
lê e imprime algo apenas como uma verificação de segurança

00:08:19.997 --> 00:08:22.830
que sei o que estou fazendo, mesmo que não vá ser útil.

00:08:22.830 --> 00:08:26.780
Portanto, em Python, se você deseja suporte a CSV, importe CSV.

00:08:26.780 --> 00:08:30.350
E isso lhe dá acesso a todas as suas capacidades mágicas.

00:08:30.350 --> 00:08:32.450
Deixe-me agora ir em frente e usar esta técnica

00:08:32.450 --> 00:08:35.960
para abrir um arquivo em Python, que é semelhante em C.

00:08:35.960 --> 00:08:37.789
Mas com Python, vamos fazer isso.

00:08:37.789 --> 00:08:39.020
A palavra-chave com.

00:08:39.020 --> 00:08:42.049
Vou abrir um arquivo chamado favorites.csv,

00:08:42.049 --> 00:08:43.880
que foi o nome mais curto que dei.

00:08:43.880 --> 00:08:46.280
Isso é opcional, mas apenas para explicitar, estou

00:08:46.280 --> 00:08:50.090
vai abri-lo no modo de leitura explicitamente, assim como f open

00:08:50.090 --> 00:08:51.720
tomou um segundo argumento também.

00:08:51.720 --> 00:08:54.500
E vou nomear este arquivo uma vez aberto simplesmente como arquivo,

00:08:54.500 --> 00:08:56.240
embora eu possa chamá-lo do que quiser.

00:08:56.240 --> 00:08:59.060
E agora é apenas um arquivo aberto.

00:08:59.060 --> 00:09:02.870
Tanto quanto Python sabe neste momento, é apenas texto, ou melhor ainda,

00:09:02.870 --> 00:09:04.250
são apenas zeros e uns.

00:09:04.250 --> 00:09:08.360
Se você deseja que este pacote Python chamado CSV realmente faça

00:09:08.360 --> 00:09:12.500
algo útil com ele, você deve carregar este arquivo agora na biblioteca.

00:09:12.500 --> 00:09:16.165
E a maneira mais simples de fazer isso é fornecer a mim mesmo uma variável chamada leitor

00:09:16.165 --> 00:09:17.540
porque eu quero ler este arquivo.

00:09:17.540 --> 00:09:19.430
Embora isso também eu pudesse chamar de qualquer outra coisa.

00:09:19.430 --> 00:09:22.610
Vou definir isso igual ao valor de retorno de uma função chamada

00:09:22.610 --> 00:09:24.710
csv.reader.

00:09:24.710 --> 00:09:28.220
E passo a isso pela documentação do arquivo aberto.

00:09:28.220 --> 00:09:29.780
Então passo um, eu abro o arquivo.

00:09:29.780 --> 00:09:32.030
E isso apenas me dá acesso aos bytes nele contidos.

00:09:32.030 --> 00:09:36.530
A segunda etapa agora com csv.reader informa ao pacote Python

00:09:36.530 --> 00:09:40.940
chamado CSV para fazer algo útil com ele e começar a analisar as vírgulas

00:09:40.940 --> 00:09:43.770
e permita-me analisá-lo ainda mais.

00:09:43.770 --> 00:09:45.180
Então vamos em frente e fazer isso.

00:09:45.180 --> 00:09:49.730
Deixe-me ir em frente agora e dentro deste loop, vamos dizer isso.

00:09:49.730 --> 00:09:52.340
Desculpe, dentro deste arquivo aberto, vamos fazer isso.

00:09:52.340 --> 00:09:58.040
Para cada linha, se preferir, ou linha no arquivo, também conhecido como

00:09:58.040 --> 00:10:04.910
leitor, vamos em frente e imprimir apenas o colchete de linha 1.

00:10:04.910 --> 00:10:06.198
Agora o que está acontecendo aqui?

00:10:06.198 --> 00:10:08.990
Bem, se você ler a documentação do leitor CSV

00:10:08.990 --> 00:10:13.610
função, o que ele devolve é essencialmente esse objeto especial, então

00:10:13.610 --> 00:10:16.850
falar, que permite tratá-lo como se fosse apenas

00:10:16.850 --> 00:10:20.660
uma lista realmente grande de linhas do arquivo, também conhecido como leitor.

00:10:20.660 --> 00:10:25.310
Então, dizendo para linha no leitor, esta é uma maneira muito mais sucinta

00:10:25.310 --> 00:10:28.763
de dizer me dê a primeira linha no arquivo mais mais,

00:10:28.763 --> 00:10:30.680
dê-me a segunda linha no arquivo mais mais,

00:10:30.680 --> 00:10:33.597
e assim por diante que teríamos feito muito mais mecanicamente em C.

00:10:33.597 --> 00:10:37.350
Isso é muito mais amigável ao Python e ao inglês, se você preferir.

00:10:37.350 --> 00:10:42.225
Portanto, em cada iteração desse loop, a linha conterá todos os dados

00:10:42.225 --> 00:10:43.100
da linha atual.

00:10:43.100 --> 00:10:45.590
Mas melhor ainda, o que a função do leitor faz

00:10:45.590 --> 00:10:50.240
para mim, isso me entrega cada linha não apenas como uma grande string ou STR

00:10:50.240 --> 00:10:51.590
de texto em Python.

00:10:51.590 --> 00:10:56.590
Isso me dá o que aparentemente se baseia na sintaxe da linha seis.

00:10:56.590 --> 00:10:57.460
Algum instinto?

00:10:57.460 --> 00:10:58.030
Sim.

00:10:58.030 --> 00:10:58.740
AUDIÊNCIA: Uma lista.

00:10:58.740 --> 00:11:00.698
DAVID MALAN: Está me devolvendo uma lista.

00:11:00.698 --> 00:11:02.880
E presumo que a pista visual para você seja o fato

00:11:02.880 --> 00:11:04.463
que estamos usando colchetes aqui.

00:11:04.463 --> 00:11:07.780
E, de fato, o colchete 1 não será o primeiro

00:11:07.780 --> 00:11:10.060
mas o segundo elemento dessa lista.

00:11:10.060 --> 00:11:11.280
E então, apenas adivinhe.

00:11:11.280 --> 00:11:14.400
Quando eu executar este código em um momento, o que será impresso?

00:11:14.400 --> 00:11:16.950
O carimbo de data/hora, o idioma ou o problema?

00:11:20.892 --> 00:11:21.392
Sim?

00:11:21.392 --> 00:11:22.350
AUDIÊNCIA: A linguagem.

00:11:22.350 --> 00:11:25.260
DAVID MALAN: O idioma porque é a segunda coluna que é

00:11:25.260 --> 00:11:27.848
no arquivo delimitado por essas vírgulas.

00:11:27.848 --> 00:11:29.140
Então deixe-me ir em frente e fazer isso.

00:11:29.140 --> 00:11:30.630
Deixe-me limpar meu terminal aqui.

00:11:30.630 --> 00:11:33.570
Deixe-me executar o Python de favorites.py e Enter.

00:11:33.570 --> 00:11:34.710
E tem tudo.

00:11:34.710 --> 00:11:35.490
Foi super rápido.

00:11:35.490 --> 00:11:37.090
Mas há uma lista muito longa aqui.

00:11:37.090 --> 00:11:41.130
E, de fato, se eu aumentar o tamanho do meu terminal e começar a rolar para cima,

00:11:41.130 --> 00:11:43.090
você apenas verá todos os dados brutos.

00:11:43.090 --> 00:11:44.490
Agora, isso ainda não é tão útil.

00:11:44.490 --> 00:11:46.032
Eu poderia apenas dar uma olhada no CSV.

00:11:46.032 --> 00:11:49.320
Mas claramente agora eu posso abrir o arquivo,

00:11:49.320 --> 00:11:52.830
analisá-lo, por assim dizer, ou seja, dividi-lo em suas partes constituintes,

00:11:52.830 --> 00:11:56.380
e fazer algo com partes específicas nele.

00:11:56.380 --> 00:11:56.880
Tudo bem.

00:11:56.880 --> 00:11:59.640
Então, se eu quiser fazer isso um pouco mais agradável,

00:11:59.640 --> 00:12:02.460
deixe-me pelo menos tornar isso semanticamente um pouco mais limpo.

00:12:02.460 --> 00:12:05.650
E você sabe o que, apenas para maior clareza, deixe-me apenas dar a mim mesmo uma variável.

00:12:05.650 --> 00:12:09.000
Não é estritamente necessário, mas sei que é

00:12:09.000 --> 00:12:12.958
o favorito, por exemplo, idioma.

00:12:12.958 --> 00:12:14.250
Então, vamos chamá-lo de favorito.

00:12:14.250 --> 00:12:16.410
Defina-o igual ao colchete de linha 1.

00:12:16.410 --> 00:12:18.600
E agora, só para ser mais explícito no meu código,

00:12:18.600 --> 00:12:21.030
mesmo assim, novamente, não precisamos da variável per se,

00:12:21.030 --> 00:12:22.840
este código, é claro, fará a mesma coisa.

00:12:22.840 --> 00:12:25.132
Está apenas usando uma variável adicional chamada favorite.

00:12:25.132 --> 00:12:28.450
Se eu descer aqui, rolar para cima, executar o programa novamente,

00:12:28.450 --> 00:12:30.280
Eu volto para os mesmos dados exatos.

00:12:30.280 --> 00:12:32.280
Mas isso é um trampolim para algo

00:12:32.280 --> 00:12:34.800
isso é ainda mais poderoso sobre o suporte Python

00:12:34.800 --> 00:12:38.610
para arquivos CSV é que você não precisa apenas tratar o retorno

00:12:38.610 --> 00:12:43.500
valor como uma lista com 0 e 1 e 2.

00:12:43.500 --> 00:12:48.540
Então, pensando intuitivamente aqui, por que esse talvez não seja o melhor design

00:12:48.540 --> 00:12:51.960
para entregar a você, o programador, os dados em uma lista

00:12:51.960 --> 00:12:55.640
que é numericamente indexado com 0, 1, 2?

00:12:55.640 --> 00:12:59.760
Isso claramente funciona, mas critique isso.

00:12:59.760 --> 00:13:00.890
O que poderia dar errado?

00:13:00.890 --> 00:13:03.282
O que é um pouco mal projetado?

00:13:03.282 --> 00:13:04.169
Sim?

00:13:04.169 --> 00:13:06.586
AUDIÊNCIA: Você tem que sempre lembrar quais são as coisas,

00:13:06.586 --> 00:13:10.945
qual é a ordem [INAUDÍVEL]

00:13:10.945 --> 00:13:11.820
DAVID MALAN: Exatamente.

00:13:11.820 --> 00:13:14.880
Então, sim, cabe a você repetir...

00:13:14.880 --> 00:13:18.360
cabe a você lembrar em qual coluna os dados realmente estão.

00:13:18.360 --> 00:13:22.020
E Deus me livre de estar colaborando com outra pessoa na planilha.

00:13:22.020 --> 00:13:24.803
Se você já usou as planilhas do Google, pode mover as colunas

00:13:24.803 --> 00:13:27.220
talvez apenas porque você deseja reorganizar visualmente as coisas.

00:13:27.220 --> 00:13:30.150
E se você fizer isso e outra pessoa baixar os mesmos dados,

00:13:30.150 --> 00:13:31.840
todo o seu código vai quebrar.

00:13:31.840 --> 00:13:33.360
Então, isso é apenas um design muito ruim.

00:13:33.360 --> 00:13:36.390
É frágil só porque você está no sistema de honra

00:13:36.390 --> 00:13:38.588
aquele significa os dados que você deseja.

00:13:38.588 --> 00:13:41.130
Então, não seria bom se pudesse ser um pouco mais explícito?

00:13:41.130 --> 00:13:47.130
Bem, lembre-se de que a primeira linha desse arquivo é, na verdade, this.

00:13:47.130 --> 00:13:50.730
E eu pausei a saída desta vez para que possamos ver mais opcionalmente.

00:13:50.730 --> 00:13:51.960
Acabei de refazer favorites.py.

00:13:51.960 --> 00:13:55.050
E observe que uma dessas coisas não é igual à outra.

00:13:55.050 --> 00:13:59.070
Cada saída era zero ou C ou Python, exceto esta primeira.

00:13:59.070 --> 00:14:00.855
Por que estou vendo a palavra linguagem aqui?

00:14:03.610 --> 00:14:05.860
De onde veio a linguagem?

00:14:05.860 --> 00:14:08.230
Você não tinha a capacidade de inserir manualmente.

00:14:08.230 --> 00:14:09.372
Não.

00:14:09.372 --> 00:14:10.330
De onde veio?

00:14:10.330 --> 00:14:11.030
Sim.

00:14:11.030 --> 00:14:11.850
AUDIÊNCIA: Esse seria o cabeçalho.

00:14:11.850 --> 00:14:12.630
DAVID MALAN: Sim, o cabeçalho.

00:14:12.630 --> 00:14:15.300
A primeira linha do arquivo, que por convenção humana

00:14:15.300 --> 00:14:18.210
geralmente apenas define o que as colunas representam para que haja

00:14:18.210 --> 00:14:20.470
alguma informação humana útil lá.

00:14:20.470 --> 00:14:24.400
Agora, isso não tem a intenção de fazer parte da minha produção no momento,

00:14:24.400 --> 00:14:25.710
então há uma maneira de pular isso.

00:14:25.710 --> 00:14:29.380
Se você quiser pular a primeira linha, você pode fazer algo assim.

00:14:29.380 --> 00:14:32.560
Você pode dizer a próxima linha e isso simplesmente ignorará essa linha.

00:14:32.560 --> 00:14:35.520
Então, estou começando realmente com todas as linhas seguintes.

00:14:35.520 --> 00:14:37.995
Mas há uma maneira melhor de lidar com isso do que isso.

00:14:37.995 --> 00:14:40.620
Isso eliminará a linha na saída, mas deixe-me prosseguir

00:14:40.620 --> 00:14:42.888
e usar um recurso diferente do pacote CSV

00:14:42.888 --> 00:14:45.430
isso só vai deixar tudo um pouco mais limpo.

00:14:45.430 --> 00:14:47.140
Então deixe-me limpar minha janela de terminal aqui.

00:14:47.140 --> 00:14:49.830
Deixe-me desfazer a próxima coisa que acabei de adicionar.

00:14:49.830 --> 00:14:54.690
E em vez de usar um leitor, deixe-me usar um leitor de dicionário,

00:14:54.690 --> 00:15:00.720
leitor de dict abreviado, que agora me retornará o equivalente a todos

00:15:00.720 --> 00:15:02.260
das linhas uma de cada vez.

00:15:02.260 --> 00:15:04.720
Portanto, ainda posso chamá-lo de leitor como antes.

00:15:04.720 --> 00:15:08.340
Mas como o nome indica, o que esse leitor vai retornar

00:15:08.340 --> 00:15:11.560
não é uma lista após lista após lista, mas um dicionário,

00:15:11.560 --> 00:15:13.140
um dicionário, um dicionário.

00:15:13.140 --> 00:15:16.210
E lembre-se, um dicionário é apenas uma coleção de pares chave-valor.

00:15:16.210 --> 00:15:17.640
Então, o que isso significa?

00:15:17.640 --> 00:15:18.390
Quais são as chaves?

00:15:18.390 --> 00:15:19.480
Quais são os valores?

00:15:19.480 --> 00:15:24.210
Bem, agora que estou usando um leitor de dicionário, posso fazer isso.

00:15:24.210 --> 00:15:27.270
Em vez de no sistema de honra, lembrando que quero a coluna um,

00:15:27.270 --> 00:15:30.630
Posso tratar a linha agora não como uma lista, mas como um dicionário.

00:15:30.630 --> 00:15:34.410
E isso significa que posso entrar aqui e dizer entre aspas "linguagem".

00:15:34.410 --> 00:15:36.150
E vimos isso na sexta semana.

00:15:36.150 --> 00:15:38.820
Python permite que você indexe em dicionários

00:15:38.820 --> 00:15:42.480
usando notação de colchetes em strings ou STRs no interior,

00:15:42.480 --> 00:15:44.790
assim como as listas permitem números.

00:15:44.790 --> 00:15:48.180
Mas isso agora eu acho que vai ser um pouco mais robusto.

00:15:48.180 --> 00:15:52.830
Se eu executar isso novamente, Python de favorites.py, funcionou bem.

00:15:52.830 --> 00:15:56.580
E deixe-me pausar a saída também usando este programa chamado more.

00:15:56.580 --> 00:15:58.600
Agora nem vejo o cabeçalho.

00:15:58.600 --> 00:16:03.660
Então agora quem trabalha com Python escreveu o código para este pacote

00:16:03.660 --> 00:16:06.600
para apenas analisar a primeira linha de código, use o cabeçalho

00:16:06.600 --> 00:16:10.230
como você acabou de chamá-lo como as chaves, e então toda vez que você

00:16:10.230 --> 00:16:13.380
iterar através deste loop, ele atualiza os valores, os valores, os valores,

00:16:13.380 --> 00:16:15.810
mas as teclas permanecem as mesmas.

00:16:15.810 --> 00:16:20.320
Alguma dúvida então sobre essa técnica?

00:16:20.320 --> 00:16:24.206
Basta dizer que isso seria doloroso em C. Sim?

00:16:24.206 --> 00:16:28.670
AUDIÊNCIA: [INAUDÍVEL]

00:16:33.395 --> 00:16:34.270
DAVID MALAN: Exatamente.

00:16:34.270 --> 00:16:39.130
Portanto, as chaves sempre serão aspas entre aspas "carimbo de data/hora, idioma,

00:16:39.130 --> 00:16:40.130
e problema".

00:16:40.130 --> 00:16:43.330
Mas em cada iteração deste loop aqui, a linha

00:16:43.330 --> 00:16:46.600
vai conter uma linha diferente de valores, linha diferente de valores,

00:16:46.600 --> 00:16:47.600
linha diferente de valores.

00:16:47.600 --> 00:16:50.830
Então, você receberá um dicionário para cada aluno que

00:16:50.830 --> 00:16:54.140
enviou o formulário do Google, se preferir, enquanto iterava por lá.

00:16:54.140 --> 00:16:54.640
Tudo bem.

00:16:54.640 --> 00:17:01.270
Assim que tivermos essa habilidade aqui, por que não vamos em frente e fazemos a transição para

00:17:01.270 --> 00:17:03.850
que tal não usar apenas aquele leitor de dicionário, que

00:17:03.850 --> 00:17:05.890
torna o código um pouco mais robusto.

00:17:05.890 --> 00:17:08.599
Porque agora, se você mover as colunas, não é grande coisa.

00:17:08.599 --> 00:17:11.170
Não importa se os índices numéricos mudam.

00:17:11.170 --> 00:17:13.660
Você ainda pode usar essas palavras-chave.

00:17:13.660 --> 00:17:15.460
Mas vamos realmente analisar os dados agora.

00:17:15.460 --> 00:17:18.619
Estou apenas cuspindo, o que não resolve nenhum problema para ninguém.

00:17:18.619 --> 00:17:22.750
Então, vamos contar a popularidade do Scratch, C e Python

00:17:22.750 --> 00:17:25.790
e veja o que todos estão pensando aqui.

00:17:25.790 --> 00:17:26.290
Tudo bem.

00:17:26.290 --> 00:17:27.470
Então, como posso fazer isso?

00:17:27.470 --> 00:17:29.890
Bem, deixe-me ir em frente e fazer isso aqui.

00:17:29.890 --> 00:17:33.880
Antes de começar a iterar, deixe-me definir, digamos, três variáveis.

00:17:33.880 --> 00:17:37.120
E para manter as coisas simples, direi uma variável chamada Scratch.

00:17:37.120 --> 00:17:40.270
Defina igual a 0 para 0 alunos até agora.

00:17:40.270 --> 00:17:44.200
C será igual a 0 e Python será igual a 0.

00:17:44.200 --> 00:17:46.157
Há uma maneira um pouco mais bonita de fazer isso,

00:17:46.157 --> 00:17:49.240
só porque são três linhas de código para fazer algo muito simples.

00:17:49.240 --> 00:17:53.080
Você poderia, alternativamente, em Python, mas não em C

00:17:53.080 --> 00:17:58.720
do Scratch vírgula C vírgula Python é igual a 0 vírgula 0.

00:17:58.720 --> 00:18:02.168
Então meio que um pouco mais elegante apenas para encaixar tudo em uma linha.

00:18:02.168 --> 00:18:04.210
Mas agora vamos fazer algo mais interessante.

00:18:04.210 --> 00:18:06.160
Na linha sete, ainda vou descobrir

00:18:06.160 --> 00:18:08.320
qual é o idioma favorito atual.

00:18:08.320 --> 00:18:11.740
E agora vou fazer algumas verificações condicionais.

00:18:11.740 --> 00:18:16.610
Que tal se esse favorito for igual a aspas, sem aspas, "Scratch",

00:18:16.610 --> 00:18:19.990
Vamos em frente e incrementar Scratch em 1.

00:18:19.990 --> 00:18:23.560
Não podemos fazer mais mais em Python, mas podemos fazer mais igual a 1.

00:18:23.560 --> 00:18:30.700
Que tal elif se favorito é igual a C, então vamos fazer C mais igual a 1.

00:18:30.700 --> 00:18:32.063
Poderíamos fazer outra coisa.

00:18:32.063 --> 00:18:33.730
Esta é realmente uma boa questão de design.

00:18:33.730 --> 00:18:34.840
Devo fazer outra coisa?

00:18:34.840 --> 00:18:36.880
Devo fazer elif?

00:18:36.880 --> 00:18:39.250
Algum instinto aqui?

00:18:39.250 --> 00:18:40.824
Sim.

00:18:40.824 --> 00:18:43.259
AUDIÊNCIA: [INAUDÍVEL]

00:18:46.322 --> 00:18:48.030
DAVID MALAN: Sim, instintos muito bons.

00:18:48.030 --> 00:18:50.370
Apenas no caso de alguém ir e adicionar outro idioma

00:18:50.370 --> 00:18:51.960
ao formulário na próxima semana porque obviamente

00:18:51.960 --> 00:18:53.370
vou apresentar outro idioma hoje,

00:18:53.370 --> 00:18:55.620
você não quer que seu código agora inflar artificialmente

00:18:55.620 --> 00:18:58.380
as pontuações para Python só porque você é

00:18:58.380 --> 00:19:00.340
misturando vários idiomas juntos.

00:19:00.340 --> 00:19:03.810
Portanto, o tipo mais defensivo da melhor maneira de escrever este código, eu concordo,

00:19:03.810 --> 00:19:07.680
seria elif favorito igual a Python.

00:19:07.680 --> 00:19:10.590
Então vamos em frente e incrementar Python mais igual a 1.

00:19:10.590 --> 00:19:12.840
E se houver um novo idioma na próxima semana, estaremos

00:19:12.840 --> 00:19:14.260
obviamente vai ter que atualizar o código,

00:19:14.260 --> 00:19:15.630
mas pelo menos não estamos contando mal.

00:19:15.630 --> 00:19:17.130
Só estamos sentindo falta do novo idioma.

00:19:17.130 --> 00:19:19.210
Então eu acho que é um pouco mais robusto.

00:19:19.210 --> 00:19:22.290
Tudo bem, agora bem no final deste programa e fora do loop

00:19:22.290 --> 00:19:25.680
quando terminar de contar, deixe-me ir em frente e imprimir

00:19:25.680 --> 00:19:27.060
usando algumas strings f.

00:19:27.060 --> 00:19:31.450
E o número total de pessoas cujo favorito é o Scratch?

00:19:31.450 --> 00:19:34.890
Portanto, esta é apenas a sintaxe da string f da sexta semana.

00:19:34.890 --> 00:19:38.940
Deixe-me ir em frente e imprimir outra string f para C. E eu, é claro,

00:19:38.940 --> 00:19:41.880
colocando as variáveis ​​entre chaves, todas minúsculas,

00:19:41.880 --> 00:19:45.060
mas as palavras em inglês para as quais estou usando letras maiúsculas.

00:19:45.060 --> 00:19:49.470
Vamos fazer um final com f Python dois pontos e depois entre chaves

00:19:49.470 --> 00:19:51.000
Citação de fechamento do Python.

00:19:51.000 --> 00:19:52.105
E acho que terminei.

00:19:52.105 --> 00:19:53.980
Deixe-me esconder meu terminal por um segundo.

00:19:53.980 --> 00:19:55.290
Aqui está o programa completo.

00:19:55.290 --> 00:19:56.730
As mesmas coisas de antes.

00:19:56.730 --> 00:19:58.980
Abra favoritos.csv.

00:19:58.980 --> 00:20:02.880
Abra-o ainda mais com o leitor de dicionário para fazer esse processamento para nós.

00:20:02.880 --> 00:20:06.330
Inicialize três variáveis ​​como 0 apenas para que tenhamos algo com o que contar.

00:20:06.330 --> 00:20:09.300
E, em seguida, itere sobre o arquivo linha por linha.

00:20:09.300 --> 00:20:12.120
E isso é apenas algum tipo de lógica condicional do estilo da primeira semana,

00:20:12.120 --> 00:20:14.410
embora em Python, contando coisas.

00:20:14.410 --> 00:20:14.910
Tudo bem.

00:20:14.910 --> 00:20:17.080
Então, como podemos agora executar isso?

00:20:17.080 --> 00:20:18.450
Deixe-me voltar ao meu terminal.

00:20:18.450 --> 00:20:20.610
Python de favorites.py.

00:20:20.610 --> 00:20:22.050
E aqui vamos nós.

00:20:22.050 --> 00:20:26.400
A partir de hoje, todos que estão fazendo reportagens ao vivo por meio do Formulário Google,

00:20:26.400 --> 00:20:30.190
seus idiomas favoritos são--

00:20:30.190 --> 00:20:31.330
interessante.

00:20:31.330 --> 00:20:34.510
Isso também é muito interessante depois de apenas uma semana de Python.

00:20:34.510 --> 00:20:36.310
Mas Scratch é um candidato saudável lá.

00:20:36.310 --> 00:20:38.210
Muito C. Portanto, uma mistura muito boa aqui.

00:20:38.210 --> 00:20:43.127
Então, esta será a melhor maneira de escrever este programa a longo prazo?

00:20:43.127 --> 00:20:45.460
Bem, como você observou, se houver um novo idioma na próxima semana,

00:20:45.460 --> 00:20:47.830
esta semana vamos ter que atualizar isso constantemente.

00:20:47.830 --> 00:20:51.610
E aqui é onde você deve deixar sua mente vagar para o futuro.

00:20:51.610 --> 00:20:55.270
Se tivermos uma quarta língua, quinta língua, sexta, sétima, oitava,

00:20:55.270 --> 00:20:59.410
quais aspectos aqui podem ter algum cheiro de código?

00:20:59.410 --> 00:21:04.310
Este provavelmente não é o melhor design para nos preparar para o futuro.

00:21:04.310 --> 00:21:07.480
O que pode ser melhor do que isso?

00:21:07.480 --> 00:21:08.417
Sim.

00:21:08.417 --> 00:21:09.880
AUDIÊNCIA: Precisamos adicionar um idioma à linha cinco.

00:21:09.880 --> 00:21:10.330
DAVID MALAN: Sim.

00:21:10.330 --> 00:21:12.288
Temos que continuar adicionando um idioma à linha cinco.

00:21:12.288 --> 00:21:13.340
E OK, não é grande coisa.

00:21:13.340 --> 00:21:16.690
Poderíamos adicionar SQL hoje e talvez JavaScript na próxima semana.

00:21:16.690 --> 00:21:19.510
Mas sempre que uma linha de código, uma linha de lógica,

00:21:19.510 --> 00:21:21.450
só vai crescer fora de controle.

00:21:21.450 --> 00:21:23.950
Já tivemos esse bate-papo algumas vezes com sintaxe diferente.

00:21:23.950 --> 00:21:25.700
Provavelmente há uma maneira melhor do que isso.

00:21:25.700 --> 00:21:26.440
Então vamos fazer isso.

00:21:26.440 --> 00:21:30.550
Em vez de usar essas variáveis ​​individuais, talvez possamos usar uma lista,

00:21:30.550 --> 00:21:35.560
mas uma lista seria um pouco confusa porque o que significa colchete 0?

00:21:35.560 --> 00:21:37.090
O que é colchete 1, colchete 2?

00:21:37.090 --> 00:21:40.930
Mas um dicionário, lembre-se, é este canivete suíço de estruturas de dados

00:21:40.930 --> 00:21:44.630
por meio do qual você pode associar qualquer coisa com qualquer outra coisa, chaves com valores.

00:21:44.630 --> 00:21:48.370
Então ouso dizer uma forma mais limpa de resolver esse problema que nos coloca

00:21:48.370 --> 00:21:52.570
para menos trabalho ou confusão depois seria criar uma nova variável chamada

00:21:52.570 --> 00:21:55.000
conta, se é isso que estamos fazendo, contando as coisas,

00:21:55.000 --> 00:21:58.340
e apenas defini-lo igual a um dicionário vazio.

00:21:58.340 --> 00:22:01.675
E você pode literalmente dizer dict com o parêntese aberto, parêntese fechado

00:22:01.675 --> 00:22:05.020
e nada ou o mais Pythonic apenas use open

00:22:05.020 --> 00:22:07.000
e feche as chaves sem nada dentro.

00:22:07.000 --> 00:22:11.320
Isso me dá um dicionário vazio, assim como colchetes me dá uma lista.

00:22:11.320 --> 00:22:13.990
Agora, minha lógica aqui tem que mudar um pouco.

00:22:13.990 --> 00:22:19.150
Mas o legal é que não preciso de uma condicional para cada idioma.

00:22:19.150 --> 00:22:22.240
Porque, novamente, se tivermos um quarto, um quinto, um sexto, esse pedaço de código

00:22:22.240 --> 00:22:24.580
também vai crescer um pouco fora de controle também.

00:22:24.580 --> 00:22:26.570
Então eu posso me livrar disso aqui.

00:22:26.570 --> 00:22:29.180
E o que eu acho que vou fazer é dizer isso.

00:22:29.180 --> 00:22:32.380
Qualquer que seja o favorito atual da linha atual no arquivo,

00:22:32.380 --> 00:22:38.420
por que não entramos em nossa variável de contagem nessa chave?

00:22:38.420 --> 00:22:40.303
E novamente, favorito é uma variável.

00:22:40.303 --> 00:22:41.720
Não é entre aspas "favorito".

00:22:41.720 --> 00:22:44.560
Vai ser Scratch ou C ou Python.

00:22:44.560 --> 00:22:47.350
E então por que não vamos em frente e apenas incrementamos o que quer que seja

00:22:47.350 --> 00:22:51.740
o valor dessa contagem está nessa chave?

00:22:51.740 --> 00:22:53.500
Agora, isso é tecnicamente bugado.

00:22:53.500 --> 00:22:57.140
Estamos muito perto, mas há um bug.

00:22:57.140 --> 00:23:00.350
Alguém quer conjecturar qual é o bug?

00:23:00.350 --> 00:23:00.890
Sim.

00:23:00.890 --> 00:23:04.215
AUDIÊNCIA: [INAUDÍVEL]

00:23:08.490 --> 00:23:11.640
DAVID MALAN: Uma boa pergunta que, no entanto, responde à minha pergunta.

00:23:11.640 --> 00:23:12.685
Então não.

00:23:12.685 --> 00:23:14.310
A mágica que você descreve não acontecerá.

00:23:14.310 --> 00:23:17.490
E, repetindo a hipótese, será que isso automaticamente

00:23:17.490 --> 00:23:22.590
criar uma chave para cada idioma que tentamos

00:23:22.590 --> 00:23:24.090
conectando-se a esses colchetes?

00:23:24.090 --> 00:23:25.140
Resposta curta não.

00:23:25.140 --> 00:23:27.750
É provável que isso crie um erro de chave, um daqueles

00:23:27.750 --> 00:23:29.640
mensagens de erro de rastreamento que você provavelmente já

00:23:29.640 --> 00:23:31.890
visto até agora em sala de aula ou em conjuntos de problemas

00:23:31.890 --> 00:23:37.410
pelo qual se Scratch não apareceu no dicionário antes ou C ou Python,

00:23:37.410 --> 00:23:40.330
então o dicionário não tem ideia do que você está falando.

00:23:40.330 --> 00:23:43.200
Acho que ainda precisamos de alguma lógica condicional, mas não

00:23:43.200 --> 00:23:45.900
que vai crescer cada vez mais com cada idioma.

00:23:45.900 --> 00:23:47.860
O que eu acho que provavelmente queremos fazer é isso.

00:23:47.860 --> 00:23:52.530
Se o favorito atual estiver no dicionário de contagem,

00:23:52.530 --> 00:23:56.730
e esta é a maneira Pythonica de apenas dizer esta chave neste dicionário,

00:23:56.730 --> 00:24:02.160
então vá em frente e faça com segurança a contagem de favorito mais igual a 1.

00:24:02.160 --> 00:24:05.250
Senão, para sua conjectura agora, senão o que eu quero fazer.

00:24:05.250 --> 00:24:10.330
A contagem de favoritos é igual a, sim, 1.

00:24:10.330 --> 00:24:14.380
Portanto, inicialize uma nova chave com um novo valor de 1

00:24:14.380 --> 00:24:16.630
porque obviamente estou apenas vendo essa linguagem.

00:24:16.630 --> 00:24:19.190
Caso contrário, incremente novamente e novamente.

00:24:19.190 --> 00:24:22.390
E agora aqui só preciso ajustar um pouco minha sintaxe.

00:24:22.390 --> 00:24:26.540
Não preciso imprimir todas essas coisas, uma de cada vez, manualmente.

00:24:26.540 --> 00:24:30.470
Na verdade, posso fugir, acho, com outro loop bem no fundo aqui.

00:24:30.470 --> 00:24:31.480
Então que tal eu fazer isso?

00:24:31.480 --> 00:24:34.790
Para cada favorito nessas contagens, e isto é,

00:24:34.790 --> 00:24:39.340
novamente, a maneira Pythonic de iterar todas as chaves em um dicionário,

00:24:39.340 --> 00:24:45.220
vá em frente e imprima usando uma string f qualquer que seja o favorito atual,

00:24:45.220 --> 00:24:52.180
Scratch ou C ou Python e, em seguida, dois pontos e, em seguida, descubra qual é a sua contagem.

00:24:52.180 --> 00:24:54.610
E você pode fazer isso acessando o dicionário de contagens,

00:24:54.610 --> 00:24:58.910
olhando para a chave favorita e recuperando seu valor.

00:24:58.910 --> 00:25:00.190
Então eu fecho minhas chaves.

00:25:00.190 --> 00:25:01.060
Eu fecho minhas citações.

00:25:01.060 --> 00:25:04.690
E mesmo que isso pareça feio no momento, agora é muito mais dinâmico.

00:25:04.690 --> 00:25:07.690
Porque se formos adicionar SQL ao arquivo CSV amanhã

00:25:07.690 --> 00:25:10.720
ou adicionarmos JavaScript na próxima semana, isso funcionará.

00:25:10.720 --> 00:25:12.760
Ele continuará funcionando agora automaticamente.

00:25:12.760 --> 00:25:15.140
Tudo o que altero é o formulário do Google, não meu código real.

00:25:15.140 --> 00:25:15.640
Tudo bem.

00:25:15.640 --> 00:25:17.620
Vamos tentar o Python de favorites.py.

00:25:17.620 --> 00:25:19.150
Cruze os dedos como sempre.

00:25:19.150 --> 00:25:23.020
E agora estão os dados a partir de agora.

00:25:23.020 --> 00:25:25.270
Dúvidas sobre este código aqui?

00:25:25.270 --> 00:25:26.195
Sim.

00:25:26.195 --> 00:25:28.093
AUDIÊNCIA: [INAUDÍVEL]

00:25:28.093 --> 00:25:29.510
DAVID MALAN: Realmente boa pergunta.

00:25:29.510 --> 00:25:33.040
E se você quisesse imprimi-lo em uma ordem específica?

00:25:33.040 --> 00:25:35.530
Bem, eu poderia lhe dar algumas soluções.

00:25:35.530 --> 00:25:37.390
Se você quiser imprimi-lo em--

00:25:37.390 --> 00:25:40.850
já está coincidentemente em ordem alfabética.

00:25:40.850 --> 00:25:43.630
Então você conseguiu isso de graça, embora seja apenas por acaso aqui.

00:25:43.630 --> 00:25:45.010
Mas há uma maneira de fazer isso.

00:25:45.010 --> 00:25:47.320
E deixe-me propor que desçamos aqui para o meu loop.

00:25:47.320 --> 00:25:50.320
E eu uso explicitamente uma função que talvez você ainda não tenha visto em Python,

00:25:50.320 --> 00:25:52.240
mas é literalmente chamado de classificado, que é

00:25:52.240 --> 00:25:54.970
vai pegar uma lista ou, neste caso, um dicionário

00:25:54.970 --> 00:25:58.270
e, por padrão, classifique-o por chave em ordem alfabética.

00:25:58.270 --> 00:26:00.907
Agora, se minha intuição estiver correta, isso não é

00:26:00.907 --> 00:26:03.490
vai mudar a saída, porque já é alfabética.

00:26:03.490 --> 00:26:05.980
Mas se você ler a documentação da função classificada,

00:26:05.980 --> 00:26:08.800
leva vários parâmetros potencialmente, alguns dos quais

00:26:08.800 --> 00:26:10.000
são parâmetros nomeados.

00:26:10.000 --> 00:26:11.870
E então você pode realmente fazer isso.

00:26:11.870 --> 00:26:14.200
Se você quer as contagens mas quer inverter

00:26:14.200 --> 00:26:18.018
a ordem por qualquer motivo aqui para que seja a ordem alfabética inversa.

00:26:18.018 --> 00:26:19.810
Agora deixe-me ir em frente e reexecutar isso e eu vou

00:26:19.810 --> 00:26:21.470
mantenha a saída anterior na tela.

00:26:21.470 --> 00:26:27.000
Digite e agora é para trás em ordem alfabética, se você quiser.

00:26:27.000 --> 00:26:29.130
Outras perguntas sobre isso aqui?

00:26:31.770 --> 00:26:33.830
Não?

00:26:33.830 --> 00:26:39.930
Que tal então fazermos a transição para alterar a classificação por valor.

00:26:39.930 --> 00:26:42.770
E isso vai aumentar um pouco rapidamente brevemente

00:26:42.770 --> 00:26:44.540
mas então vamos diminuir o tom novamente.

00:26:44.540 --> 00:26:47.600
Observe que agora isso está realmente classificando por chave.

00:26:47.600 --> 00:26:49.400
E se, especialmente se eu tiver muitos dados,

00:26:49.400 --> 00:26:52.670
seria bom fazer uma lista dos 10 melhores ou, neste caso, uma lista dos três primeiros

00:26:52.670 --> 00:26:58.890
e realmente ver na ordem das contagens, os valores quais são esses populares.

00:26:58.890 --> 00:27:00.620
Então não é C, Python, Scratch.

00:27:00.620 --> 00:27:03.770
Idealmente, deve ser Python, depois C e depois

00:27:03.770 --> 00:27:06.710
Scratch por causa dos valores e da magnitude dos mesmos.

00:27:06.710 --> 00:27:08.010
Então, como posso fazer isso?

00:27:08.010 --> 00:27:12.170
Bem, acontece que há outra chave, outro parâmetro que você

00:27:12.170 --> 00:27:16.550
pode passar para a função classificada que normalmente é

00:27:16.550 --> 00:27:17.925
implementado como uma função em si.

00:27:17.925 --> 00:27:19.633
E então eu vou seguir em frente e fazer isso.

00:27:19.633 --> 00:27:21.950
Vou definir temporariamente uma função chamada

00:27:21.950 --> 00:27:24.230
obter valor apenas para tornar minha vida mais fácil.

00:27:24.230 --> 00:27:29.390
E essa função get value vai levar, digamos, um parâmetro de linguagem.

00:27:29.390 --> 00:27:35.400
E então tudo o que vou fazer é retornar qualquer que seja a contagem desse idioma.

00:27:35.400 --> 00:27:37.850
Fora do contexto, esta é apenas uma função super simples

00:27:37.850 --> 00:27:41.252
que você forneça uma linguagem como Scratch, C ou Python,

00:27:41.252 --> 00:27:43.460
só vai dizer qual é a contagem disso

00:27:43.460 --> 00:27:46.400
naquele dicionário chamado contagens.

00:27:46.400 --> 00:27:51.440
Mas o que posso fazer agora aqui em minha chamada recém-introduzida para classificar é

00:27:51.440 --> 00:27:54.380
pode dizer a ele o que usar como sua chave.

00:27:54.380 --> 00:27:57.170
Em vez de usar literalmente a chave, Scratch, C,

00:27:57.170 --> 00:28:01.040
Python, posso substituir esse comportamento e dizer, quer saber?

00:28:01.040 --> 00:28:05.570
Para descobrir como classificar, vá em frente e chame esta função

00:28:05.570 --> 00:28:07.890
chamado obter valor.

00:28:07.890 --> 00:28:11.270
Observe que não coloquei parênteses após get value

00:28:11.270 --> 00:28:14.420
porque eu não quero chamar get value ali mesmo.

00:28:14.420 --> 00:28:20.737
Eu quero passar a função get value como ela mesma no argumento para o classificado

00:28:20.737 --> 00:28:23.570
função para que a função classificada escrita anos atrás pelas pessoas

00:28:23.570 --> 00:28:27.320
em Python pode chamar minha versão de obter valor de novo e de novo

00:28:27.320 --> 00:28:30.300
e novamente quando eles tentam classificar esses dados reais.

00:28:30.300 --> 00:28:36.350
Agora, se eu somar isso e deixar reverso igual a verdadeiro, vamos ver o que acontece.

00:28:36.350 --> 00:28:38.240
Python de favorites.py.

00:28:38.240 --> 00:28:38.810
Digitar.

00:28:38.810 --> 00:28:42.410
E agora eu recebo meu top 10, ou neste caso, a lista dos três primeiros.

00:28:42.410 --> 00:28:45.290
E se eu tivesse dados mais sofisticados com mais colunas

00:28:45.290 --> 00:28:47.150
todos juntos que eu realmente me importo, eu

00:28:47.150 --> 00:28:50.758
poderia até classificar isso de forma mais poderosa também.

00:28:50.758 --> 00:28:52.550
Mas deixe-me limpar isso um pouco, apenas

00:28:52.550 --> 00:28:54.592
então você já viu, mesmo que não usemos esses

00:28:54.592 --> 00:28:59.010
que muitas vezes no CS50 até o final da aula eles vão aparecer de novo.

00:28:59.010 --> 00:29:00.740
Tecnicamente, isso é um pouco--

00:29:00.740 --> 00:29:03.620
este não é necessariamente o melhor design para gastar todo esse tempo

00:29:03.620 --> 00:29:06.680
implementar uma função e depois usá-la apenas em um lugar.

00:29:06.680 --> 00:29:09.430
Em geral, argumentamos que você não precisa necessariamente

00:29:09.430 --> 00:29:11.930
precisa de uma variável se você for usá-la apenas em um lugar.

00:29:11.930 --> 00:29:13.430
Você realmente não precisa de uma função se estiver apenas

00:29:13.430 --> 00:29:14.638
vai usá-lo em um só lugar.

00:29:14.638 --> 00:29:17.160
E aqui temos um bom candidato para isso.

00:29:17.160 --> 00:29:19.400
E assim acontece em Python, se você não

00:29:19.400 --> 00:29:23.240
quer se preocupar em criar uma função apenas para usá-la uma vez,

00:29:23.240 --> 00:29:26.810
você pode criar o que é chamado de função anônima, também conhecida como

00:29:26.810 --> 00:29:29.900
uma função lambda, como o conhecido símbolo lambda.

00:29:29.900 --> 00:29:33.380
E uma função lambda, a sintaxe é um pouco estranha,

00:29:33.380 --> 00:29:34.490
mas você diz isso.

00:29:34.490 --> 00:29:36.080
Você literalmente diz lambda.

00:29:36.080 --> 00:29:38.660
Você literalmente então diz o nome do argumento

00:29:38.660 --> 00:29:42.470
que você deseja que essa função anônima sem nome assuma.

00:29:42.470 --> 00:29:44.430
Então você tem dois pontos.

00:29:44.430 --> 00:29:47.930
E então, simplesmente, você escreve o que deseja que o retorno

00:29:47.930 --> 00:29:49.850
valor desta função seja.

00:29:49.850 --> 00:29:51.800
Você nem diz return literalmente.

00:29:51.800 --> 00:29:53.720
Essas funções lambda devem ser usadas

00:29:53.720 --> 00:30:00.680
super sucintamente para que você possa expressar algo assim em uma linha.

00:30:00.680 --> 00:30:03.720
E admito que isso parece mais enigmático, eu acho, do que a versão anterior.

00:30:03.720 --> 00:30:06.512
Mas à medida que você se sentir mais confortável com Python ou outras linguagens que

00:30:06.512 --> 00:30:10.370
suporte a esse recurso, permite que você não se preocupe com linhas de código como essa

00:30:10.370 --> 00:30:12.690
e apenas aperte um pouco o seu código.

00:30:12.690 --> 00:30:16.670
Então, esta linha aqui, lambda language dois pontos conta o idioma,

00:30:16.670 --> 00:30:18.927
é a versão de uma linha disso.

00:30:18.927 --> 00:30:21.260
E você nem precisa se preocupar em escolher um nome para isso.

00:30:21.260 --> 00:30:23.840
Lambda diz a Python que não perdi tempo

00:30:23.840 --> 00:30:26.440
pensando em um nome para essa função.

00:30:26.440 --> 00:30:35.310
Então, perguntas sobre essa técnica de usar Python para analisar dados como esse?

00:30:35.310 --> 00:30:37.900
Alguma pergunta?

00:30:37.900 --> 00:30:39.860
Estamos quase terminando com o Python.

00:30:39.860 --> 00:30:42.070
Questões?

00:30:42.070 --> 00:30:42.640
Não?

00:30:42.640 --> 00:30:43.390
OK.

00:30:43.390 --> 00:30:45.790
Então, por que não tornamos as coisas um pouco mais interessantes?

00:30:45.790 --> 00:30:48.620
Porque tínhamos um conjunto de dados muito mais suculento com os problemas

00:30:48.620 --> 00:30:50.620
que atribuímos nas últimas semanas.

00:30:50.620 --> 00:30:54.970
Por que não vamos em frente e, simplesmente, acho

00:30:54.970 --> 00:30:57.290
escrevemos um código muito bom aqui.

00:30:57.290 --> 00:31:02.590
Acho que podemos mudar um pouco para dizer:

00:31:02.590 --> 00:31:05.720
vejamos, se não quero linguagem, quero problema.

00:31:05.720 --> 00:31:10.510
E se eu quiser classificar não por idioma, mas por problema, acho que é isso.

00:31:10.510 --> 00:31:12.580
Eu acho que se eu não tivesse esquecido algo aqui

00:31:12.580 --> 00:31:16.210
apenas alterando a coluna da qual estou lendo os dados e, em seguida,

00:31:16.210 --> 00:31:18.550
apenas para ser consistente, renomeando minhas variáveis

00:31:18.550 --> 00:31:21.310
só para eu saber o que estou olhando, o que será este programa agora

00:31:21.310 --> 00:31:25.470
fazer depois dessas pequenas mudanças?

00:31:25.470 --> 00:31:26.970
O que vou ver quando executar isso?

00:31:29.693 --> 00:31:31.860
Qual seria a primeira coisa que vejo quando executo isso?

00:31:34.950 --> 00:31:35.970
Turma difícil hoje.

00:31:35.970 --> 00:31:36.720
Sim.

00:31:36.720 --> 00:31:37.637
AUDIÊNCIA: O problema.

00:31:37.637 --> 00:31:39.110
DAVID MALAN: Sim.

00:31:39.110 --> 00:31:40.330
O problema principal.

00:31:40.330 --> 00:31:42.627
Portanto, o problema mais popular, com o qual estou um pouco preocupado

00:31:42.627 --> 00:31:45.210
pode ser olá ou apenas Scratch, mas vamos ver.

00:31:45.210 --> 00:31:47.700
Então deixe-me ir em frente e abrir a janela do meu terminal.

00:31:47.700 --> 00:31:50.670
Vou até maximizar a janela do meu terminal para que possamos ver muito.

00:31:50.670 --> 00:31:54.167
Deixe-me prosseguir e executar o Python de favorites.py.

00:31:54.167 --> 00:31:57.000
Vou seguir em frente agora e cruzar os dedos para não ter feito besteira

00:31:57.000 --> 00:31:57.660
e pressione Enter.

00:31:57.660 --> 00:31:59.550
E tudo bem, ótimo.

00:31:59.550 --> 00:32:00.480
Atingimos o pico cedo.

00:32:00.480 --> 00:32:03.840
Então o Scratch foi o programa mais popular de acordo com

00:32:03.840 --> 00:32:06.460
aos dados no momento em que baixei.

00:32:06.460 --> 00:32:08.520
Tenho certeza de que outros votos vieram desde então.

00:32:08.520 --> 00:32:13.080
Filter na quarta semana estava empatado com Tideman também.

00:32:13.080 --> 00:32:16.480
Mario é um terceiro próximo lá e assim por diante.

00:32:16.480 --> 00:32:19.540
Portanto, isso é útil para nós da equipe que não tanto ama

00:32:19.540 --> 00:32:21.040
aqui embaixo na parte inferior da lista.

00:32:21.040 --> 00:32:23.400
Foi um monte de código para escrever, mas agora

00:32:23.400 --> 00:32:26.250
que o escrevemos dessa forma dinâmica muito versátil,

00:32:26.250 --> 00:32:29.280
é muito bom para processar dados e fazer algumas análises.

00:32:29.280 --> 00:32:33.480
Mas ainda é um número decente de linhas para escrever manualmente.

00:32:33.480 --> 00:32:41.820
E é aqui que às vezes não é necessariamente a ferramenta certa para o trabalho,

00:32:41.820 --> 00:32:44.520
mas sim um candidato a usar algum outro idioma,

00:32:44.520 --> 00:32:47.428
especialmente quando não é apenas um programa único que você executa

00:32:47.428 --> 00:32:48.720
e você quer ver a resposta.

00:32:48.720 --> 00:32:53.130
E se você quiser obter informações do usuário e responder às perguntas dinamicamente

00:32:53.130 --> 00:32:55.050
como um aplicativo móvel faria, como um site faria,

00:32:55.050 --> 00:32:58.740
como o Microsoft Excel, o Apple Numbers ou o Google Sheets fariam por você.

00:32:58.740 --> 00:33:02.430
Bem, vamos fazer uma alteração final por enquanto nesta versão do programa

00:33:02.430 --> 00:33:05.020
e realmente receber alguma entrada do usuário.

00:33:05.020 --> 00:33:08.170
Além de carregar todos os dados na memória,

00:33:08.170 --> 00:33:13.290
vamos em frente e abaixo aqui não apenas imprimir o top 10

00:33:13.290 --> 00:33:16.660
list, se desejar, mas solicite ao usuário seus favoritos.

00:33:16.660 --> 00:33:18.660
Vou usar a função de entrada do Python e estou

00:33:18.660 --> 00:33:21.840
vou avisá-los com "favorito", entre aspas, diga-me o que

00:33:21.840 --> 00:33:23.370
seu problema favorito--

00:33:23.370 --> 00:33:27.660
em que problema você está interessado.

00:33:27.660 --> 00:33:33.267
E agora deixe-me prosseguir e dizer se esse favorito está na variável de contagem,

00:33:33.267 --> 00:33:35.850
então você não digitou algo aleatório que nós realmente não

00:33:35.850 --> 00:33:37.890
atribuir como um problema, então deixe-me ir em frente

00:33:37.890 --> 00:33:44.130
e imprima com uma string de formato qualquer que seja o seu favorito e mostre a você

00:33:44.130 --> 00:33:47.040
a popularidade real do mesmo pela indexação

00:33:47.040 --> 00:33:51.370
em contagens usando esse favorito como a chave e imprimindo isso.

00:33:51.370 --> 00:33:52.620
Então agora é um programa dinâmico.

00:33:52.620 --> 00:33:55.170
Ele não despeja todos os dados e todas as somas.

00:33:55.170 --> 00:33:59.100
Em vez disso, vai me permitir ver qual é a minha escolha de favorito.

00:33:59.100 --> 00:34:03.940
E eu vou em frente e digo, vamos ver, eu sou um fã do Mario aqui.

00:34:03.940 --> 00:34:04.950
Então entre.

00:34:04.950 --> 00:34:08.880
E, de fato, vemos o mesmo valor que vimos há pouco, mas apenas para Mario.

00:34:08.880 --> 00:34:11.880
Mas o ponto agora é que, primeiro, tudo isso é possível.

00:34:11.880 --> 00:34:15.630
Dois, é muito mais fácil e agradável do que seria em C.

00:34:15.630 --> 00:34:17.280
Isso ainda é apenas 15 linhas de código.

00:34:17.280 --> 00:34:19.238
E em C, novamente, há o gerenciamento de memória.

00:34:19.238 --> 00:34:21.947
Há a iteração nas strings tentando encontrar as vírgulas.

00:34:21.947 --> 00:34:23.190
Há muito mais trabalho.

00:34:23.190 --> 00:34:26.489
Mas, honestamente, mesmo quando você só quer responder a uma pergunta como esta

00:34:26.489 --> 00:34:29.067
no Excel e Apple Numbers, Google Sheets, geralmente, você

00:34:29.067 --> 00:34:30.150
pode apenas destacar as coisas.

00:34:30.150 --> 00:34:34.500
Você pode clicar em um botão e boom, obter sua resposta para soma ou máximo ou mínimo

00:34:34.500 --> 00:34:35.909
ou qualquer um desses tipos básicos.

00:34:35.909 --> 00:34:39.270
Não seria bom se não estivéssemos dando um passo para trás como programadores

00:34:39.270 --> 00:34:42.880
e sendo mais poderoso e ainda assim temos que fazer mais do trabalho?

00:34:42.880 --> 00:34:46.230
Então, às vezes, Python não é ou qualquer linguagem

00:34:46.230 --> 00:34:48.370
não é a melhor ferramenta para o trabalho.

00:34:48.370 --> 00:34:51.960
E isso agora nos permitirá introduzir algo mais geral

00:34:51.960 --> 00:34:53.670
chamado banco de dados relacional.

00:34:53.670 --> 00:34:57.137
Graduando-se de meros bancos de dados de arquivos simples, como arquivos de texto

00:34:57.137 --> 00:34:58.845
ou arquivos binários nos quais todos os seus dados

00:34:58.845 --> 00:35:00.570
é armazenado em algo mais adequado.

00:35:00.570 --> 00:35:02.566
Mas primeiro, perguntas.

00:35:02.566 --> 00:35:08.518
AUDIÊNCIA: [INAUDÍVEL]

00:35:12.943 --> 00:35:14.360
DAVID MALAN: Realmente boa pergunta.

00:35:14.360 --> 00:35:17.670
Para reiterar, se eu fosse - isso diferencia maiúsculas de minúsculas?

00:35:17.670 --> 00:35:21.470
Então, se eu digitar Mario em letras minúsculas e apertar Enter,

00:35:21.470 --> 00:35:23.450
Na verdade, não recebo essa resposta.

00:35:23.450 --> 00:35:26.720
Agora isso pode ser aceitável, porque o problema tecnicamente é um M maiúsculo.

00:35:26.720 --> 00:35:30.840
Mas isso é um pouco ridículo ser tão pedante sobre a entrada.

00:35:30.840 --> 00:35:34.250
Então, como poderíamos resolver isso?

00:35:34.250 --> 00:35:37.010
Alguma dica de como podemos tornar isso um pouco mais robusto?

00:35:37.010 --> 00:35:38.378
Sim.

00:35:38.378 --> 00:35:42.290
AUDIÊNCIA: [INAUDÍVEL]

00:35:45.848 --> 00:35:46.765
DAVID MALAN: OK, sim.

00:35:49.400 --> 00:35:49.900
Sim.

00:35:49.900 --> 00:35:51.700
Assim, poderíamos usar algumas funções diferentes, uma das quais

00:35:51.700 --> 00:35:54.970
é chamado de título, que o mudará para maiúsculas e minúsculas,

00:35:54.970 --> 00:35:58.390
como na maioria das frases em inglês, a primeira letra dessa frase.

00:35:58.390 --> 00:35:59.740
Poderíamos usar letras maiúsculas.

00:35:59.740 --> 00:36:00.940
Poderíamos usar superior.

00:36:00.940 --> 00:36:01.990
Poderíamos usar mais baixo.

00:36:01.990 --> 00:36:06.435
Mas, de fato, poderíamos apenas decidir como queremos padronizar a capitalização.

00:36:06.435 --> 00:36:08.810
Maiúsculas, minúsculas ou alguma combinação delas.

00:36:08.810 --> 00:36:11.770
E apenas certifique-se de alterar as próprias contagens.

00:36:11.770 --> 00:36:13.930
Certifique-se de fazer o mesmo para favoritar

00:36:13.930 --> 00:36:16.420
e certifique-se de manter um backup dos dados

00:36:16.420 --> 00:36:19.780
se você quiser mostrar a versão original que veio do CSV

00:36:19.780 --> 00:36:23.205
sem presumir apenas capitalizar tudo para o usuário.

00:36:23.205 --> 00:36:25.330
Mas, de fato, esse seria o cenário mais comum.

00:36:25.330 --> 00:36:28.540
Você apenas torna as coisas insensíveis a maiúsculas e minúsculas ao fazer essas correspondências.

00:36:28.540 --> 00:36:36.910
Outras perguntas agora sobre Python antes de deixá-lo para trás na próxima semana?

00:36:36.910 --> 00:36:39.880
Tudo bem, então vamos apresentar esses bancos de dados relacionais.

00:36:39.880 --> 00:36:43.060
Banco de dados relacional é o que cada--

00:36:43.060 --> 00:36:45.572
é uma maneira super popular de armazenar muitos dados.

00:36:45.572 --> 00:36:48.280
É isso que os Twitters do mundo, os Googles do mundo,

00:36:48.280 --> 00:36:52.390
os Metas do mundo usam para armazenar alguns de seus dados em escala.

00:36:52.390 --> 00:36:55.492
Existem alternativas para bancos de dados relacionais.

00:36:55.492 --> 00:36:57.700
De fato, hoje falaremos sobre uma linguagem chamada SQL.

00:36:57.700 --> 00:37:00.408
Há também um movimento, se preferir, ou uma alternativa geralmente

00:37:00.408 --> 00:37:02.330
chamado NoSQL, que é exatamente o oposto.

00:37:02.330 --> 00:37:03.280
Você não usa SQL.

00:37:03.280 --> 00:37:06.020
Existem coisas chamadas bancos de dados orientados a objetos e similares.

00:37:06.020 --> 00:37:11.110
Mas se você já ouviu falar de MySQL ou PostgreSQL ou Microsoft SQL

00:37:11.110 --> 00:37:15.580
Server ou Oracle ou MariaDB ou um monte de outros produtos,

00:37:15.580 --> 00:37:18.850
gratuitos e comerciais, é disso que eles estão falando.

00:37:18.850 --> 00:37:21.560
Bancos de dados projetados para armazenar muitos dados.

00:37:21.560 --> 00:37:23.710
E o que há de bom em bancos de dados relacionais

00:37:23.710 --> 00:37:26.530
é que eles são muito parecidos com as planilhas com as quais você

00:37:26.530 --> 00:37:29.800
eram presumivelmente familiares muito antes da aula de hoje.

00:37:29.800 --> 00:37:32.530
Então, um banco de dados relacional vai armazenar,

00:37:32.530 --> 00:37:35.452
como você verá, todos os dados em linhas e colunas.

00:37:35.452 --> 00:37:37.910
Agora, a terminologia será um pouco diferente.

00:37:37.910 --> 00:37:40.570
Em vez de folhas, você terá mesas.

00:37:40.570 --> 00:37:43.240
Mas essas tabelas ainda terão linhas e colunas.

00:37:43.240 --> 00:37:46.330
E você terá ainda mais controle sobre o desempenho

00:37:46.330 --> 00:37:51.970
dos seus dados quando você começar a acessá-los usando esta Linguagem de Consulta Estruturada

00:37:51.970 --> 00:37:53.050
ou SQL.

00:37:53.050 --> 00:37:56.440
Este é um idioma que você pode usar para aplicativos da web, aplicativos móveis.

00:37:56.440 --> 00:37:58.990
Muitos analistas se sentavam em seu Mac ou PC

00:37:58.990 --> 00:38:01.810
e realmente faça perguntas de dados para obter a resposta.

00:38:01.810 --> 00:38:05.050
E maravilhosamente, mesmo que haja alguma nova sintaxe hoje,

00:38:05.050 --> 00:38:07.570
O SQL realmente faz apenas quatro coisas básicas.

00:38:07.570 --> 00:38:10.030
CRUD é o tipo de acrônimo bruto aqui.

00:38:10.030 --> 00:38:14.470
CRUD é uma forma de lembrar que um banco de dados relacional suporta

00:38:14.470 --> 00:38:20.390
em última análise, criando dados, lendo dados, atualizando dados e excluindo dados.

00:38:20.390 --> 00:38:22.240
Então, mesmo se você estiver se sentindo como, uau, isso

00:38:22.240 --> 00:38:25.510
é muita sintaxe nova, que não é relativa às nossas linguagens anteriores,

00:38:25.510 --> 00:38:29.650
as únicas coisas que você realmente está fazendo são criar dados, ler dados, atualizar,

00:38:29.650 --> 00:38:30.910
e excluindo o mesmo.

00:38:30.910 --> 00:38:36.940
Agora um pouco confuso no SQL, as funções ou comandos correspondentes

00:38:36.940 --> 00:38:41.150
que existe esse mapa para CRUD são na verdade isso.

00:38:41.150 --> 00:38:44.290
Ainda é criar, mas há outro chamado inserir.

00:38:44.290 --> 00:38:48.250
Não é lido, que é mais a maneira do cientista da computação dizer isso,

00:38:48.250 --> 00:38:50.380
mas selecione, que é um pouco mais explícito.

00:38:50.380 --> 00:38:52.030
Como selecionar dados importantes para você.

00:38:52.030 --> 00:38:53.320
Atualização ainda é atualização.

00:38:53.320 --> 00:38:54.310
Excluir ainda é excluir.

00:38:54.310 --> 00:38:57.910
Mas há outro comando chamado drop, que permite descartar, ou seja, deletar,

00:38:57.910 --> 00:38:59.930
tabelas inteiras também.

00:38:59.930 --> 00:39:03.280
Então você pode criar tabelas usando a sintaxe que é

00:39:03.280 --> 00:39:05.480
geralmente vai ficar assim.

00:39:05.480 --> 00:39:06.910
Você dirá criar tabela.

00:39:06.910 --> 00:39:10.210
Você dará o nome da mesa, que você pode chamar mais

00:39:10.210 --> 00:39:14.260
o que você quiser, mas geralmente tudo em minúsculas, sem espaços é o melhor.

00:39:14.260 --> 00:39:18.550
Em seguida, entre parênteses, você pode especificar uma lista separada por vírgulas das colunas

00:39:18.550 --> 00:39:20.660
que você pode querer nesta tabela.

00:39:20.660 --> 00:39:24.070
Portanto, este é o código equivalente na linguagem SQL

00:39:24.070 --> 00:39:27.220
de abrir manualmente o Planilhas Google, Excel ou Numbers

00:39:27.220 --> 00:39:30.490
e clicando na célula superior esquerda e digitando timestamp

00:39:30.490 --> 00:39:34.180
e, em seguida, no próximo idioma de digitação e, em seguida, no terceiro problema de digitação.

00:39:34.180 --> 00:39:37.750
Esta é a maneira de definir quais são seus cabeçalhos, se você quiser,

00:39:37.750 --> 00:39:38.500
em uma planilha.

00:39:38.500 --> 00:39:39.790
Mas agora é chamado de mesa.

00:39:39.790 --> 00:39:42.100
Agora, não usaremos este comando manualmente primeiro.

00:39:42.100 --> 00:39:44.050
Vamos fazer algo um pouco mais simples.

00:39:44.050 --> 00:39:47.590
Vamos começar apenas importando esses dados nós mesmos.

00:39:47.590 --> 00:39:49.340
E eu vou seguir em frente e fazer isso.

00:39:49.340 --> 00:39:51.160
Deixe-me voltar ao VS Code aqui.

00:39:51.160 --> 00:39:54.040
Vou deixar para trás favorites.py por enquanto,

00:39:54.040 --> 00:39:57.100
porque agora vamos fazer a transição para essa outra linguagem chamada SQL.

00:39:57.100 --> 00:40:02.680
E para fazer isso, vou criar um novo arquivo de banco de dados.

00:40:02.680 --> 00:40:06.790
E vou fazer isso usando um comando chamado sqlite3,

00:40:06.790 --> 00:40:09.160
que é apenas a terceira versão do mesmo, e eu sou

00:40:09.160 --> 00:40:12.110
vai dar ao banco de dados um nome de favorites.db.

00:40:12.110 --> 00:40:14.860
Existem convenções diferentes, mas esta é uma das mais comuns.

00:40:14.860 --> 00:40:18.610
Quando pressiono Enter, isso vai criar para mim um novo banco de dados vazio apenas

00:40:18.610 --> 00:40:23.080
como abrir uma planilha sem título no Excel, Google Sheets ou Apple Numbers.

00:40:23.080 --> 00:40:25.720
Estou sendo solicitado se desejo criar favorites.db.

00:40:25.720 --> 00:40:26.890
Vou acertar Y para Sim.

00:40:26.890 --> 00:40:28.562
OK, estamos funcionando.

00:40:28.562 --> 00:40:30.520
Agora, você notará um prompt diferente.

00:40:30.520 --> 00:40:34.360
Não estou no prompt do Linux propriamente dito, que é sempre o cifrão.

00:40:34.360 --> 00:40:37.090
Agora estou dentro do programa chamado SQLite.

00:40:37.090 --> 00:40:41.500
E vamos usar SQLite, SQLite3, apenas como uma forma interativa por enquanto

00:40:41.500 --> 00:40:43.180
de brincar com o código SQL.

00:40:43.180 --> 00:40:48.550
No final de hoje, mostraremos como você pode usar SQL em código Python

00:40:48.550 --> 00:40:51.050
para que você ainda escreva código Python para fazer o que quiser,

00:40:51.050 --> 00:40:53.170
mas você pode conversar com bancos de dados usando Python.

00:40:53.170 --> 00:40:55.630
E é exatamente assim que os aplicativos da web, aplicativos móveis funcionam.

00:40:55.630 --> 00:40:59.140
Por exemplo, no iOS, em um iPhone, iPad ou similar,

00:40:59.140 --> 00:41:03.010
se você deseja armazenar dados, eles geralmente são armazenados em um banco de dados SQL,

00:41:03.010 --> 00:41:04.580
como estamos prestes a fazer.

00:41:04.580 --> 00:41:07.398
Mas você pode usar uma linguagem chamada SWIFT ou Objective C.

00:41:07.398 --> 00:41:09.190
E o mesmo existe no mundo do Android

00:41:09.190 --> 00:41:12.830
usando Java ou Kotlin ou qualquer outra coisa para consultar o banco de dados.

00:41:12.830 --> 00:41:16.270
Por enquanto, veremos o SQL isoladamente, como um analista pode apenas

00:41:16.270 --> 00:41:19.880
usar com seu Mac ou PC, mas vamos prepará-los até o final do dia.

00:41:19.880 --> 00:41:28.180
Portanto, neste terminal SQLite, deixe-me executar este comando primeiro.

00:41:28.180 --> 00:41:30.200
Vou primeiro colocar o SQLite no modo CSV,

00:41:30.200 --> 00:41:32.200
porque eu vou cortar alguns cantos inicialmente.

00:41:32.200 --> 00:41:34.600
E eu vou importar automaticamente

00:41:34.600 --> 00:41:38.560
todos os dados que foram enviados por meio do formulário do Google, que exportei

00:41:38.560 --> 00:41:41.410
como um CSV e carregado no meu espaço de código.

00:41:41.410 --> 00:41:45.790
E eu vou dizer automaticamente para transformar este arquivo CSV em um SQL

00:41:45.790 --> 00:41:48.040
banco de dados para mim apenas para que eu não tenha que descobrir

00:41:48.040 --> 00:41:49.760
quais são esses comandos de criação de tabela.

00:41:49.760 --> 00:41:53.200
Então, para fazer isso, vou dizer modo csv então

00:41:53.200 --> 00:41:57.850
esse SQLite sabe que este é o comando, sabe que este é um arquivo CSV.

00:41:57.850 --> 00:41:59.290
É literalmente .mode.

00:41:59.290 --> 00:42:01.480
Então o ponto vem antes da palavra-chave lá.

00:42:01.480 --> 00:42:05.770
E agora vou dizer .import e depois o nome do arquivo que eu quero

00:42:05.770 --> 00:42:08.020
para importar, que é favorites.csv.

00:42:08.020 --> 00:42:12.635
E agora o nome da tabela que quero criar com esses dados.

00:42:12.635 --> 00:42:15.010
E apenas para consistência, vou chamá-lo de favoritos.

00:42:15.010 --> 00:42:17.270
Eu poderia mudar essas coisas para serem o que eu quiser,

00:42:17.270 --> 00:42:18.530
mas eu vou fazer isso.

00:42:18.530 --> 00:42:20.860
E voila, nada parece ter acontecido.

00:42:20.860 --> 00:42:24.503
Mas, assim como em C e em Python e Linux, quando nada parece acontecer,

00:42:24.503 --> 00:42:25.670
isso geralmente é uma coisa boa.

00:42:25.670 --> 00:42:27.590
Significa que não errei.

00:42:27.590 --> 00:42:31.120
Então, se eu quiser ver o que acabou de acontecer, existe esse outro comando.

00:42:31.120 --> 00:42:33.430
E esses comandos que começam com pontos, esses

00:42:33.430 --> 00:42:37.690
são específicos do SQLite, que é de fato uma versão leve do SQL.

00:42:37.690 --> 00:42:39.010
Eles não são SQL, por si só.

00:42:39.010 --> 00:42:41.260
Então, se você estiver usando Oracle ou algo assim,

00:42:41.260 --> 00:42:43.135
você não vai usar esses comandos exatos.

00:42:43.135 --> 00:42:45.160
Você verá os que usamos em apenas um momento.

00:42:45.160 --> 00:42:46.660
E aqui está o primeiro.

00:42:46.660 --> 00:42:51.230
Quando digito .schema, o esquema de um banco de dados é o design do banco de dados.

00:42:51.230 --> 00:42:52.120
Quais são as tabelas?

00:42:52.120 --> 00:42:53.900
Quais são as colunas e tudo isso?

00:42:53.900 --> 00:42:58.390
Então, quando eu digito .schema, isso, neste caso, mostra a tabela de criação

00:42:58.390 --> 00:43:03.700
comando que foi desenhado automaticamente para mim apenas fazendo esta linha de importação.

00:43:03.700 --> 00:43:07.450
Assim que me sentir mais confortável com o SQL, eu poderia literalmente digitar isso sozinho

00:43:07.450 --> 00:43:09.560
ou use algum programa para gerar isso também.

00:43:09.560 --> 00:43:11.290
Mas o que está criando para mim é isso.

00:43:11.290 --> 00:43:15.580
Crie uma tabela se ela não existir, mesmo que seja mais concisa do que isso.

00:43:15.580 --> 00:43:18.130
Eu quero criar uma tabela chamada favoritos.

00:43:18.130 --> 00:43:20.590
E então as colunas dessa tabela vão

00:43:20.590 --> 00:43:24.880
para ser carimbo de data/hora, que será texto, vírgula, idioma,

00:43:24.880 --> 00:43:27.248
que também será texto, vírgula, problema,

00:43:27.248 --> 00:43:28.540
que também será texto.

00:43:28.540 --> 00:43:34.330
Isso foi inferido de maneira muito trivial pelo comando .import para apenas descobrir

00:43:34.330 --> 00:43:38.680
isso, sim, apenas me dê uma tabela de banco de dados de três colunas com base no Google

00:43:38.680 --> 00:43:40.390
Forma.

00:43:40.390 --> 00:43:41.740
Perguntas sobre isso?

00:43:41.740 --> 00:43:44.140
Estes são comandos que você executa uma vez para começar a funcionar.

00:43:44.140 --> 00:43:47.260
Você não executa esses comandos com frequência, mas nós os temos

00:43:47.260 --> 00:43:49.280
no slide apenas para referência.

00:43:49.280 --> 00:43:49.780
Tudo bem.

00:43:49.780 --> 00:43:52.010
Então agora vamos fazer algo um pouco mais interessante.

00:43:52.010 --> 00:43:55.330
Vou limpar meu terminal SQLite aqui, mas ainda estou no SQLite.

00:43:55.330 --> 00:43:58.570
Agora vou usar alguns dos meus primeiros comandos SQL, que

00:43:58.570 --> 00:44:02.440
recall estavam entre eles selecionados.

00:44:02.440 --> 00:44:05.522
Então CRUD, CRUD. O R foi selecionado.

00:44:05.522 --> 00:44:07.480
Este é talvez o mais comum, o mais útil,

00:44:07.480 --> 00:44:10.330
a coisa mais poderosa para usar com um banco de dados SQL

00:44:10.330 --> 00:44:13.000
selecionando dados para responder a perguntas semelhantes às que

00:44:13.000 --> 00:44:14.980
estavam tentando responder com Python.

00:44:14.980 --> 00:44:16.270
Esta é a sintaxe geral.

00:44:16.270 --> 00:44:19.900
Sempre que você quiser selecionar dados de um banco de dados SQL, diga literalmente selecionar.

00:44:19.900 --> 00:44:24.730
Em seguida, você especifica a coluna ou colunas das quais deseja selecionar os dados.

00:44:24.730 --> 00:44:28.450
Você literalmente escreve a palavra de e depois especifica o nome da tabela.

00:44:28.450 --> 00:44:32.030
Você deseja obter esses dados de ponto e vírgula, neste caso.

00:44:32.030 --> 00:44:35.200
Tudo o que está em maiúsculas aqui é uma palavra-chave SQL.

00:44:35.200 --> 00:44:37.750
Estritamente falando, você não precisa colocar as coisas em maiúsculas,

00:44:37.750 --> 00:44:40.150
mas nós encorajamos você a fazê-lo estilisticamente.

00:44:40.150 --> 00:44:43.030
E especialmente enquanto você está aprendendo e mesmo enquanto está escrevendo,

00:44:43.030 --> 00:44:47.530
apenas ajuda a distinguir o SQL das palavras que você escolheu, como os nomes

00:44:47.530 --> 00:44:49.460
das colunas e os dados nelas contidos.

00:44:49.460 --> 00:44:52.700
Portanto, adote no início desta convenção.

00:44:52.700 --> 00:44:56.240
Então deixe-me voltar agora para o meu espaço de código aqui.

00:44:56.240 --> 00:44:59.012
Estou executando minha janela de terminal com SQLite3 dentro dela.

00:44:59.012 --> 00:45:00.970
Suponha que eu só queira obter todos os dados

00:45:00.970 --> 00:45:04.720
da tabela de favoritos, que foi importada automaticamente.

00:45:04.720 --> 00:45:05.480
Vamos fazer isso.

00:45:05.480 --> 00:45:06.220
Selecione.

00:45:06.220 --> 00:45:07.630
Eu quero tudo.

00:45:07.630 --> 00:45:13.090
Bem, eu posso resolver o problema de linguagem de vírgula de carimbo de data/hora.

00:45:13.090 --> 00:45:13.840
Mas você sabe o que?

00:45:13.840 --> 00:45:15.850
Aqui já é uma comodidade.

00:45:15.850 --> 00:45:19.120
Se você quer tudo, existe o que chamamos de personagem curinga

00:45:19.120 --> 00:45:21.460
no SQL, que é apenas uma estrela, um asterisco, que

00:45:21.460 --> 00:45:25.120
significa dar-me todas as colunas sem que eu saiba nem mesmo como elas são chamadas.

00:45:25.120 --> 00:45:28.400
Deixe-me ir em frente agora e dizer de favoritos ponto e vírgula.

00:45:28.400 --> 00:45:33.010
E esta é a maneira SQL de abrir o banco de dados, iterando sobre

00:45:33.010 --> 00:45:36.400
cada linha nele, imprimindo cada linha nele, pronto.

00:45:36.400 --> 00:45:39.640
Essas três etapas, que eram como nove linhas de código Python

00:45:39.640 --> 00:45:42.700
dar ou receber anteriormente, agora é uma linha de SQL.

00:45:42.700 --> 00:45:43.990
Eu apertei Enter.

00:45:43.990 --> 00:45:46.370
Há todos os dados.

00:45:46.370 --> 00:45:48.130
Então eu vejo agora todos os dados.

00:45:48.130 --> 00:45:50.230
Basta enviá-lo como um CSV aqui.

00:45:50.230 --> 00:45:51.940
Mas não é o arquivo CSV.

00:45:51.940 --> 00:45:53.210
Agora é a mesa.

00:45:53.210 --> 00:45:54.580
E, de fato, só para garantir, deixe-me

00:45:54.580 --> 00:45:58.000
fazer isso, porque você verá o comportamento um pouco diferente na próxima vez que

00:45:58.000 --> 00:45:58.690
abra o arquivo.

00:45:58.690 --> 00:46:00.730
Acabei de sair do SQLite3.

00:46:00.730 --> 00:46:03.490
Vou executá-lo novamente, mas não vou reimportar os dados

00:46:03.490 --> 00:46:05.920
ou faça algo assim, porque meu arquivo agora existe.

00:46:05.920 --> 00:46:07.790
Na verdade, deixe-me dar um passo para trás.

00:46:07.790 --> 00:46:11.830
Se eu digitar ls no meu prompt do Linux, haverá meu favorites.py de antes.

00:46:11.830 --> 00:46:13.870
Aqui está o meu favorites.csv de antes.

00:46:13.870 --> 00:46:18.580
E aqui está um terceiro arquivo que criei há pouco, quando

00:46:18.580 --> 00:46:19.690
executou o SQLite3.

00:46:19.690 --> 00:46:21.130
Portanto, os dados são persistentes.

00:46:21.130 --> 00:46:23.050
Não está usando RAM ou memória.

00:46:23.050 --> 00:46:24.950
Tudo o que eu faço agora é salvo lá.

00:46:24.950 --> 00:46:27.653
Então, vamos executar novamente o SQLite3 com o mesmo arquivo.

00:46:27.653 --> 00:46:28.570
Mas eu não vou--

00:46:28.570 --> 00:46:31.130
Não preciso reimportar tudo, pois o arquivo já existe.

00:46:31.130 --> 00:46:32.800
Deixe-me agora fazer a mesma coisa novamente.

00:46:32.800 --> 00:46:36.460
Selecione a estrela dos favoritos para obter todos os dados.

00:46:36.460 --> 00:46:39.990
E o que você verá agora são os mesmos dados, mas um pouco mais bonitos agora.

00:46:39.990 --> 00:46:44.400
Como o executei novamente, desabilitei efetivamente o modo CSV desta vez.

00:46:44.400 --> 00:46:49.590
E o que estou vendo agora é todo o conteúdo deste banco de dados

00:46:49.590 --> 00:46:51.420
tabela chamada favoritos.

00:46:51.420 --> 00:46:53.370
Agora, não há nada de novo aqui, mas você é apenas

00:46:53.370 --> 00:46:55.980
vendo agora como uma versão ASCII ou Unicode de todos

00:46:55.980 --> 00:46:57.988
dos mesmos dados desse banco de dados.

00:46:57.988 --> 00:47:00.030
Bem, suponha que eu queira obter um subconjunto dos dados.

00:47:00.030 --> 00:47:01.238
Bem, deixe-me limpar minha tela.

00:47:01.238 --> 00:47:04.530
E, assim como no Linux, posso controlar L apenas para limpar as coisas esteticamente.

00:47:04.530 --> 00:47:06.580
Suponha que eu queira obter apenas os idiomas.

00:47:06.580 --> 00:47:09.540
Então eu poderia selecionar o idioma dos favoritos.

00:47:09.540 --> 00:47:12.930
E isso agora não selecionará todas as três colunas, também conhecidas como

00:47:12.930 --> 00:47:17.280
estrela, isso selecionará apenas a coluna de idioma e todos os dados nela contidos.

00:47:17.280 --> 00:47:19.020
Se eu apertar Enter, voila.

00:47:19.020 --> 00:47:21.150
Agora eu só vejo aqueles lá.

00:47:21.150 --> 00:47:22.990
Sem carimbos de data/hora, sem problemas.

00:47:22.990 --> 00:47:25.470
É apenas uma fatia da mesa, se você quiser.

00:47:25.470 --> 00:47:30.010
Tudo bem, ainda não é tão interessante porque é apenas uma grande coluna de dados.

00:47:30.010 --> 00:47:31.900
Mas agora as coisas ficam mais interessantes.

00:47:31.900 --> 00:47:35.850
Acontece que no SQL existem funções que acompanham essa linguagem,

00:47:35.850 --> 00:47:37.920
assim como C, assim como Python.

00:47:37.920 --> 00:47:41.790
No SQL, alguns dos mais úteis, alguns dos mais simples,

00:47:41.790 --> 00:47:42.630
são estes aqui.

00:47:42.630 --> 00:47:44.880
Média, contagem, distinto, inferior, máximo, mínimo,

00:47:44.880 --> 00:47:48.150
superior, que praticamente fazem o que dizem.

00:47:48.150 --> 00:47:50.533
E a contagem é particularmente útil.

00:47:50.533 --> 00:47:51.450
Vamos começar com isso.

00:47:51.450 --> 00:47:55.740
É uma pergunta razoável a ser feita quantas pessoas enviaram o Google

00:47:55.740 --> 00:47:58.523
Form no momento em que baixei o CSV.

00:47:58.523 --> 00:48:00.190
Bem, por que não vamos em frente e fazemos isso?

00:48:00.190 --> 00:48:02.850
Deixe-me voltar ao VS Code aqui na janela do meu terminal.

00:48:02.850 --> 00:48:06.900
Deixe-me selecionar não a estrela, mas a contagem de estrelas.

00:48:06.900 --> 00:48:10.020
Então me dê a contagem das linhas que estão sendo

00:48:10.020 --> 00:48:12.660
retornado do banco de dados chamado--

00:48:12.660 --> 00:48:14.190
a tabela do banco de dados chamada favoritos.

00:48:14.190 --> 00:48:16.648
Agora, quando pressiono Enter, não vou obter todos os dados.

00:48:16.648 --> 00:48:18.630
Eu só estou indo para obter simplesmente um número.

00:48:18.630 --> 00:48:21.480
430 linhas voltaram.

00:48:21.480 --> 00:48:22.740
Então isso é muito bom.

00:48:22.740 --> 00:48:24.580
Agora eu sei quantos dados estão lá.

00:48:24.580 --> 00:48:26.350
Bem, quais idiomas estavam lá?

00:48:26.350 --> 00:48:30.520
Bem, eu poderia selecionar o idioma dos favoritos como antes,

00:48:30.520 --> 00:48:33.270
mas isso não é tão útil, especialmente se estou herdando os dados.

00:48:33.270 --> 00:48:35.770
Como se eu fosse o analista que recebeu um conjunto de dados do meu chefe

00:48:35.770 --> 00:48:37.440
e eles querem que eu analise alguns números.

00:48:37.440 --> 00:48:39.810
OK, eu poderia carregar isso no Excel.

00:48:39.810 --> 00:48:40.770
Eu poderia resolver isso.

00:48:40.770 --> 00:48:44.400
Mas você pode usar o SQL agora para responder a perguntas bastante básicas também.

00:48:44.400 --> 00:48:48.540
Se você deseja selecionar os idiomas distintos no conjunto de dados porque

00:48:48.540 --> 00:48:51.000
não conhecia o formulário do Google, deixe-me ir em frente

00:48:51.000 --> 00:48:56.820
e selecione apenas os idiomas distintos da tabela de favoritos.

00:48:56.820 --> 00:49:00.330
E agora pressiono Enter e recebo uma resposta muito mais sucinta.

00:49:00.330 --> 00:49:02.220
Apenas os três idiomas em questão.

00:49:02.220 --> 00:49:04.963
Não é muito útil desde que criei o formulário do Google,

00:49:04.963 --> 00:49:07.380
mas certamente se você está herdando dados de outra pessoa,

00:49:07.380 --> 00:49:09.390
você acabou de baixar um conjunto de dados, pelo menos agora

00:49:09.390 --> 00:49:12.190
Estou sem dúvida envolvendo minha mente em torno do que está acontecendo.

00:49:12.190 --> 00:49:15.178
Agora, isso não é necessário para um conjunto de dados tão pequeno,

00:49:15.178 --> 00:49:16.470
mas posso combinar essas coisas.

00:49:16.470 --> 00:49:21.180
Selecione a contagem dos idiomas distintos neste conjunto de dados

00:49:21.180 --> 00:49:22.140
chamados de favoritos.

00:49:22.140 --> 00:49:25.220
E agora devo receber qual resposta?

00:49:25.220 --> 00:49:27.378
Então, esperançosamente, uma resposta chamada três.

00:49:27.378 --> 00:49:29.420
E o que você está recebendo de volta observe esteticamente

00:49:29.420 --> 00:49:32.180
também é como uma mini tabela temporária.

00:49:32.180 --> 00:49:36.890
Quando pedi apenas os idiomas distintos, o que o SQL entrega

00:49:36.890 --> 00:49:39.410
eu de volta é esta tabela temporária na memória

00:49:39.410 --> 00:49:43.340
que tem uma coluna chamada idioma e três linhas.

00:49:43.340 --> 00:49:45.210
Agora, isso não é salvo em nenhum lugar.

00:49:45.210 --> 00:49:47.450
É apenas executado efêmeramente assim.

00:49:47.450 --> 00:49:49.580
Mas é por isso que é retratado dessa maneira.

00:49:49.580 --> 00:49:52.610
O que você obtém são subconjuntos de seus dados, menores

00:49:52.610 --> 00:49:54.410
tabelas contendo alguns de seus dados.

00:49:54.410 --> 00:49:55.550
E a mesma coisa aqui embaixo.

00:49:55.550 --> 00:49:58.400
Este é um nome de coluna longo e maluco.

00:49:58.400 --> 00:50:00.480
Você pode renomeá-lo se realmente quiser.

00:50:00.480 --> 00:50:02.900
Mas isso é tudo que estamos vendo lá.

00:50:02.900 --> 00:50:07.100
E, de fato, se isso é um pouco feio, podemos criar um alias para essas coisas.

00:50:07.100 --> 00:50:12.090
N é um nome comum para uma variável, um número em qualquer linguagem de programação.

00:50:12.090 --> 00:50:15.200
Então, na verdade, posso criar um apelido para uma coluna chamada n.

00:50:15.200 --> 00:50:16.160
Pressione Enter.

00:50:16.160 --> 00:50:19.490
E agora estou obtendo uma mesa minúscula cuja coluna é chamada

00:50:19.490 --> 00:50:23.280
n que tem apenas um valor lá.

00:50:23.280 --> 00:50:28.500
Tudo bem, perguntas sobre essas aplicações dessas funções aqui?

00:50:31.950 --> 00:50:33.152
Perguntas, sim.

00:50:33.152 --> 00:50:35.000
AUDIÊNCIA: [INAUDÍVEL]

00:50:35.000 --> 00:50:36.400
DAVID MALAN: Fale um pouco mais alto.

00:50:36.400 --> 00:50:37.280
AUDIÊNCIA: AS.

00:50:37.280 --> 00:50:38.475
DAVID MALAN: Ah, AS. Como.

00:50:38.475 --> 00:50:39.350
Literalmente em inglês.

00:50:39.350 --> 00:50:42.650
Então renomeie esta coluna como this.

00:50:42.650 --> 00:50:45.317
Tecnicamente, ele cria um alias para a coluna.

00:50:45.317 --> 00:50:45.900
Então isso é tudo.

00:50:45.900 --> 00:50:46.818
Sim?

00:50:46.818 --> 00:50:49.955
AUDIÊNCIA: [INAUDÍVEL]

00:50:49.955 --> 00:50:50.830
DAVID MALAN: Exatamente.

00:50:50.830 --> 00:50:53.530
Distinct irá operar em qualquer coisa que você entre parênteses

00:50:53.530 --> 00:50:57.460
e livre-se de todas as duplicatas, devolvendo apenas as únicas.

00:50:57.460 --> 00:50:58.360
Correto.

00:50:58.360 --> 00:50:59.780
Outras perguntas aqui?

00:50:59.780 --> 00:51:00.524
Sim.

00:51:00.524 --> 00:51:02.944
AUDIÊNCIA: [INAUDÍVEL]

00:51:06.935 --> 00:51:08.060
DAVID MALAN: Boa pergunta.

00:51:08.060 --> 00:51:10.355
Quando você define um alias como n, o que acabei de fazer,

00:51:10.355 --> 00:51:12.230
torna-se como uma variável que você pode reutilizar?

00:51:12.230 --> 00:51:16.580
Resposta curta, não neste caso, mas você pode reutilizá-la em sua mesma consulta.

00:51:16.580 --> 00:51:20.630
Mesmo que essas consultas estejam ficando um pouco mais longas, admito,

00:51:20.630 --> 00:51:23.270
declarações que são, você pode realmente

00:51:23.270 --> 00:51:26.090
reutilizar n em uma consulta ainda mais longa.

00:51:26.090 --> 00:51:27.440
Então, mais tarde em sua consulta.

00:51:27.440 --> 00:51:30.380
E veremos alguns que vão começar a crescer em comprimento.

00:51:30.380 --> 00:51:33.050
Portanto, é uma boa maneira de apelidar as coisas apenas para serem

00:51:33.050 --> 00:51:35.190
um pouco mais conciso em sua consulta.

00:51:35.190 --> 00:51:38.480
Assim, podemos fazer a transição para algumas dessas consultas mais sofisticadas

00:51:38.480 --> 00:51:41.360
porque acontece que existem algumas outras técnicas que

00:51:41.360 --> 00:51:42.630
pode apresentar também.

00:51:42.630 --> 00:51:44.660
Aqui estão algumas outras palavras-chave em SQL.

00:51:44.660 --> 00:51:47.005
E, novamente, embora esta seja outra lista de coisas,

00:51:47.005 --> 00:51:49.130
há apenas quatro coisas fundamentalmente que estamos fazendo.

00:51:49.130 --> 00:51:51.600
Criação, leitura, atualização e exclusão de dados.

00:51:51.600 --> 00:51:55.580
Estes estão apenas nos permitindo ajustar exatamente como fazemos isso.

00:51:55.580 --> 00:51:59.210
Onde nos permitirá filtrar os dados, como faremos daqui a pouco.

00:51:59.210 --> 00:52:03.440
Como selecionar dados onde esta condicional é verdadeira.

00:52:03.440 --> 00:52:06.260
Like vai ser uma alternativa para um sinal de igual.

00:52:06.260 --> 00:52:11.210
Então, em vez de procurar exatamente Scratch ou exatamente Python ou exatamente C,

00:52:11.210 --> 00:52:13.790
você pode procurar por algo como ponto ponto ponto

00:52:13.790 --> 00:52:16.770
e pode ser uma combinação um pouco mais confusa, se preferir,

00:52:16.770 --> 00:52:18.020
também com outros personagens.

00:52:18.020 --> 00:52:19.790
Order by vai lidar com a classificação.

00:52:19.790 --> 00:52:23.360
Limit vai me deixar limitar o número total de linhas que voltam

00:52:23.360 --> 00:52:26.330
para 1 ou 10 ou finito se eu não quiser ver

00:52:26.330 --> 00:52:28.375
todas as mais de 400 linhas de uma vez, porque estou apenas

00:52:28.375 --> 00:52:29.750
tentando envolver minha mente em torno disso.

00:52:29.750 --> 00:52:32.207
E agrupar por é melhor mostrado por exemplo.

00:52:32.207 --> 00:52:34.290
Então, vamos brincar com apenas alguns deles também.

00:52:34.290 --> 00:52:36.080
Deixe-me voltar ao VS Code aqui.

00:52:36.080 --> 00:52:37.170
Vou limpar minha tela.

00:52:37.170 --> 00:52:39.530
Ainda estou na mesma instância do SQLite.

00:52:39.530 --> 00:52:44.040
E vamos contar quantos de vocês gostaram de C sem escrever código Python como antes.

00:52:44.040 --> 00:52:47.960
Então deixe-me ir em frente e selecionar a contagem das linhas

00:52:47.960 --> 00:52:54.530
de favoritos onde o idioma em cada linha é igual a C.

00:52:54.530 --> 00:52:58.100
E a convenção no SQLite é usar aspas simples a qualquer momento

00:52:58.100 --> 00:53:02.810
você está envolvendo uma string que deve representar um trecho literal de texto

00:53:02.810 --> 00:53:06.720
ao contrário de C, que era aspas duplas, ou Python, que era qualquer um.

00:53:06.720 --> 00:53:11.090
Então, isso está selecionando a contagem de linhas da tabela de favoritos onde

00:53:11.090 --> 00:53:13.730
o idioma em questão é C. Enter.

00:53:13.730 --> 00:53:15.410
E isso me dá 98.

00:53:15.410 --> 00:53:19.190
Observe, porém, se eu omitir esse predicado como fizemos antes,

00:53:19.190 --> 00:53:23.850
você receberá de volta o número total de linhas que estavam na tabela.

00:53:23.850 --> 00:53:26.030
Então, onde está o que é chamado de predicado que apenas

00:53:26.030 --> 00:53:30.020
me permite filtrar coisas como uma condição if ou algo semelhante em um idioma

00:53:30.020 --> 00:53:31.130
que já vimos antes.

00:53:31.130 --> 00:53:34.670
Você pode ser um pouco mais específico, como quantas pessoas realmente gostaram

00:53:34.670 --> 00:53:38.870
C e o problema do Mario especificamente?

00:53:38.870 --> 00:53:40.440
Bem, vamos fazer isso.

00:53:40.440 --> 00:53:45.830
Vamos em frente e selecione o número de linhas da tabela de favoritos

00:53:45.830 --> 00:53:49.640
onde a linguagem é C e.

00:53:49.640 --> 00:53:52.880
Portanto, ainda é literalmente a palavra es e ou, apenas

00:53:52.880 --> 00:53:57.830
como em Python, mas não como em C. E o problema é igual a Mario.

00:53:57.830 --> 00:54:01.520
Então, vamos ver se há algum fã de C e do problema do Mario.

00:54:01.520 --> 00:54:05.638
E três de nós realmente gostamos dessas duas coisas juntas neste caso.

00:54:05.638 --> 00:54:06.930
Tudo bem, o que mais podemos fazer?

00:54:06.930 --> 00:54:10.280
Bem, mais atraente pode ser ver, como em Python,

00:54:10.280 --> 00:54:13.580
para cada idioma, qual foi a sua popularidade?

00:54:13.580 --> 00:54:15.560
E no momento, não temos como

00:54:15.560 --> 00:54:17.960
de fazer isso, exceto em Python, onde tínhamos o loop

00:54:17.960 --> 00:54:20.710
e tínhamos essas variáveis ​​e o dicionário que fazia tudo isso

00:54:20.710 --> 00:54:21.410
contando para nós.

00:54:21.410 --> 00:54:24.710
Totalmente factível, mas tedioso, especialmente se seu trabalho for analisar dados.

00:54:24.710 --> 00:54:28.190
Meu Deus, mesmo escrevendo 15 linhas de código para responder perguntas simples

00:54:28.190 --> 00:54:29.390
é meio ridículo.

00:54:29.390 --> 00:54:31.560
O SQL pode fazer melhor por nós.

00:54:31.560 --> 00:54:33.630
Então deixe-me ir em frente e fazer isso.

00:54:33.630 --> 00:54:38.540
Deixe-me ir em frente e selecionar todos os idiomas e a contagem

00:54:38.540 --> 00:54:45.650
da tabela de favoritos, mas desta vez agrupados por idioma.

00:54:45.650 --> 00:54:48.440
Essa foi outra das palavras-chave que

00:54:48.440 --> 00:54:52.460
pode usar nesta lista abreviada de recursos extras do SQL.

00:54:52.460 --> 00:54:55.760
E este leva um momento para envolver sua mente,

00:54:55.760 --> 00:54:59.510
mas isso vai me dar uma tabela temporária de duas colunas onde

00:54:59.510 --> 00:55:02.030
a primeira coluna é um idioma e a segunda coluna

00:55:02.030 --> 00:55:05.330
é a contagem deste conjunto de dados.

00:55:05.330 --> 00:55:10.010
E agrupar por idioma significa apenas mostrar o Scratch apenas uma vez,

00:55:10.010 --> 00:55:12.350
mostre-me C apenas uma vez, mostre-me Python apenas uma vez.

00:55:12.350 --> 00:55:16.130
Isso é agrupar todos os valores idênticos juntos,

00:55:16.130 --> 00:55:19.260
mas mantenha o controle de quantos deles existem.

00:55:19.260 --> 00:55:27.200
E agora, se eu for para o SQLite e pressionar Enter, agora tenho na versão SQL

00:55:27.200 --> 00:55:29.720
exatamente a mesma saída que eu tive do Python

00:55:29.720 --> 00:55:32.120
isso me levou, o que, mais de 15 linhas antes.

00:55:32.120 --> 00:55:35.810
Agora estamos reduzidos a apenas um porque SQL, Linguagem de consulta estruturada,

00:55:35.810 --> 00:55:39.830
trata-se de construir consultas como esta para responder a perguntas e voltar

00:55:39.830 --> 00:55:41.152
responde rapidamente.

00:55:41.152 --> 00:55:42.860
Se quisermos limpar isso um pouco,

00:55:42.860 --> 00:55:44.960
você perguntou anteriormente sobre a ordem de classificação.

00:55:44.960 --> 00:55:46.200
Bem, nós podemos fazer isso também.

00:55:46.200 --> 00:55:48.930
Há outra frase-chave que podemos usar aqui.

00:55:48.930 --> 00:55:55.080
Podemos ordenar pela contagem dessas linhas e, em seguida, executar essa consulta aqui.

00:55:55.080 --> 00:55:57.480
Agora, infelizmente, eles estão do menor para o maior,

00:55:57.480 --> 00:55:58.675
mas podemos reverter isso.

00:55:58.675 --> 00:56:00.800
Acontece que minha consulta está começando a se resumir aqui.

00:56:00.800 --> 00:56:02.360
Vou diminuir o zoom por um momento.

00:56:02.360 --> 00:56:07.050
Se você deseja ordenar por contagem, o padrão é em ordem crescente,

00:56:07.050 --> 00:56:10.980
ASC abreviado. Se você quiser inverter a classificação no SQL,

00:56:10.980 --> 00:56:13.920
em vez de usar reverse equals true como fizemos em Python,

00:56:13.920 --> 00:56:16.380
você diz DESC para ordem decrescente.

00:56:16.380 --> 00:56:19.557
E agora obtemos quase a mesma saída, mas invertida.

00:56:19.557 --> 00:56:22.140
Portanto, é muito mais rápido responder às perguntas uma vez, é claro,

00:56:22.140 --> 00:56:24.660
você obtém alguma memória muscular e algum conforto com ela.

00:56:24.660 --> 00:56:26.280
Bem, o que mais posso fazer?

00:56:26.280 --> 00:56:28.890
E se eu me preocupar apenas com o idioma mais popular?

00:56:28.890 --> 00:56:31.140
Eu não me importo com o segundo lugar ou o terceiro lugar

00:56:31.140 --> 00:56:32.460
línguas ou qualquer outra coisa.

00:56:32.460 --> 00:56:34.830
Bem, deixe-me adicionar mais uma cláusula aqui.

00:56:34.830 --> 00:56:36.750
Limite a resposta a um.

00:56:36.750 --> 00:56:39.330
E não importa quantas linhas devem voltar agora,

00:56:39.330 --> 00:56:41.880
Acabei de obter o idioma número um a partir dos dados

00:56:41.880 --> 00:56:47.870
conjunto que coletamos com 270 votos para ele.

00:56:47.870 --> 00:56:52.060
Perguntas sobre isso?

00:56:52.060 --> 00:56:55.260
Alguma pergunta aqui?

00:56:55.260 --> 00:56:55.800
Não?

00:56:55.800 --> 00:56:58.620
Bem, e se estivermos começando a introduzir o SQL

00:56:58.620 --> 00:57:02.250
e era tarde demais para entrar no formulário do Google?

00:57:02.250 --> 00:57:04.260
Acontece que há sintaxe para isso também.

00:57:04.260 --> 00:57:05.670
Você pode criar dados, é claro.

00:57:05.670 --> 00:57:09.240
Não apenas as tabelas, mas os dados nelas e aqui está a sintaxe típica

00:57:09.240 --> 00:57:11.640
para inserir dados em um banco de dados SQL.

00:57:11.640 --> 00:57:14.850
Você literalmente diz inserir no nome da tabela.

00:57:14.850 --> 00:57:19.020
E então, entre parênteses, você especifica uma ou mais colunas para as quais você

00:57:19.020 --> 00:57:20.940
têm valores que você deseja inserir.

00:57:20.940 --> 00:57:22.950
Isso quer dizer que você não precisa dar valores

00:57:22.950 --> 00:57:25.650
para cada coluna na linha especificada.

00:57:25.650 --> 00:57:27.990
Se você só tem respostas para algumas dessas perguntas,

00:57:27.990 --> 00:57:29.940
você pode enumerá-los aqui assim.

00:57:29.940 --> 00:57:32.010
Mas os valores que você inserir serão estes.

00:57:32.010 --> 00:57:35.500
Então você literalmente diz após os valores dos parênteses próximos.

00:57:35.500 --> 00:57:38.430
E então em um segundo conjunto de parênteses com o mesmo comprimento

00:57:38.430 --> 00:57:42.370
lista separada por vírgulas, você especifica quais valores deseja inserir.

00:57:42.370 --> 00:57:43.710
Portanto, é um pouco detalhado.

00:57:43.710 --> 00:57:47.520
E, francamente, a longo prazo, você usará o código Python para fazer automaticamente

00:57:47.520 --> 00:57:50.010
esses tipos de inserções, mas vamos tentar isso.

00:57:50.010 --> 00:57:57.990
Agora mesmo, se eu selecionar um idioma diferente dos favoritos, novamente,

00:57:57.990 --> 00:57:58.833
nós vemos isso.

00:57:58.833 --> 00:58:00.000
Apenas esses três candidatos.

00:58:00.000 --> 00:58:01.870
Mas agora ensinamos um pouco de SQL.

00:58:01.870 --> 00:58:09.120
Então vamos inserir nos favoritos a coluna chamada idioma.

00:58:09.120 --> 00:58:10.620
E sabe de uma coisa?

00:58:10.620 --> 00:58:12.150
Eu vou dar um problema aqui.

00:58:12.150 --> 00:58:14.430
Os valores para os quais, e deixe-me diminuir o zoom,

00:58:14.430 --> 00:58:17.910
serão aspas sem aspas "SQL" e entre aspas sem aspas "fiftyville".

00:58:17.910 --> 00:58:20.130
Em breve você verá do que se trata.

00:58:20.130 --> 00:58:21.240
Ponto e vírgula.

00:58:21.240 --> 00:58:24.580
Nada parece acontecer, mas isso geralmente é uma coisa boa.

00:58:24.580 --> 00:58:26.580
E agora, se eu rolar de volta em minhas consultas,

00:58:26.580 --> 00:58:30.990
no SQLite3 você pode rolar para frente e para trás no tempo para evitar redigitar as coisas,

00:58:30.990 --> 00:58:35.400
agora eu deveria ver de fato quatro línguas candidatas aqui.

00:58:35.400 --> 00:58:39.150
Agora, suponha que você nunca foi realmente fã de C e talvez tenha programado

00:58:39.150 --> 00:58:42.990
um pouco no ensino médio ou no mundo real e você gostou de C++.

00:58:42.990 --> 00:58:50.010
Bem, há um monte de respostas para C. Então selecione a estrela dos favoritos

00:58:50.010 --> 00:58:53.430
onde idioma é igual a aspas fecha aspas "C."

00:58:53.430 --> 00:58:58.020
Aqui estão todos que enviaram a resposta para C. Vamos presumir que, não,

00:58:58.020 --> 00:58:59.850
eles realmente não queriam C, eles queriam C++,

00:58:59.850 --> 00:59:01.767
que não é um idioma que ensinamos na classe.

00:59:01.767 --> 00:59:03.910
Mas agora eu também poderia fazer isso.

00:59:03.910 --> 00:59:08.670
Você pode usar o comando update para definir uma coluna ou colunas para valores diferentes

00:59:08.670 --> 00:59:10.210
onde alguma condição é satisfeita.

00:59:10.210 --> 00:59:15.360
Portanto, se eu atualizar o nome da tabela, defina o nome da coluna igual a algum valor

00:59:15.360 --> 00:59:19.330
filtrando-o talvez por onde alguma condição é verdadeira.

00:59:19.330 --> 00:59:22.890
Então suponha que eu mudei de ideia, ou quer saber,

00:59:22.890 --> 00:59:31.320
vamos em frente e atualizar os favoritos, definir o idioma igual a talvez C++, onde

00:59:31.320 --> 00:59:33.870
linguagem é igual a C.

00:59:33.870 --> 00:59:35.910
Agora, isso é destrutivo, então você geralmente

00:59:35.910 --> 00:59:38.368
não quero fazer isso a menos que você tenha um backup de seus dados

00:59:38.368 --> 00:59:40.170
também, substituindo quais são as respostas das pessoas.

00:59:40.170 --> 00:59:42.753
Isso parece ter sido bem-sucedido, porque nenhuma mensagem de erro.

00:59:42.753 --> 00:59:45.270
E se eu executar novamente o select anterior que me dá

00:59:45.270 --> 00:59:49.410
todos os favoritos em que o idioma é igual a C, agora, na verdade, não recebo nenhum.

00:59:49.410 --> 00:59:53.127
Mas se eu procurar por C++, agora recebo muito.

00:59:53.127 --> 00:59:55.710
E se eu me livrar dessa cláusula where e apenas olhar

00:59:55.710 --> 01:00:00.330
no conteúdo do meu banco de dados, agora você vê que de fato o C++ está misturado com

01:00:00.330 --> 01:00:01.140
todos os outros dados.

01:00:01.140 --> 01:00:04.270
Isso não é o que todos vocês pretendiam, é claro, então posso desfazer isso.

01:00:04.270 --> 01:00:06.150
Deixe-me ir em frente e desfazer o que acabei de fazer.

01:00:06.150 --> 01:00:12.570
Deixe-me definir meu idioma favorito para C, onde o idioma é igual a C++.

01:00:12.570 --> 01:00:14.460
Mas o predicado é importante.

01:00:14.460 --> 01:00:16.230
Isso eu não vou fazer.

01:00:16.230 --> 01:00:20.190
E se eu acidentalmente omitir esse predicado, a cláusula where?

01:00:20.190 --> 01:00:22.545
Como isso estragaria as coisas, você pode pensar?

01:00:26.160 --> 01:00:26.970
Sim, na parte de trás.

01:00:26.970 --> 01:00:29.110
AUDIÊNCIA: [INAUDÍVEL]

01:00:29.110 --> 01:00:32.590
DAVID MALAN: Isso definiria o idioma de cada linha como C.

01:00:32.590 --> 01:00:34.060
E isso é perigoso.

01:00:34.060 --> 01:00:37.720
E se você começar a pesquisar erros de SQL ou similares,

01:00:37.720 --> 01:00:41.590
pessoas no mundo real executaram acidentalmente comandos como este.

01:00:41.590 --> 01:00:43.510
E sem citar nomes, um ex-membro

01:00:43.510 --> 01:00:47.200
de nossa equipe de professores em um ponto acidentalmente executou um comando como este

01:00:47.200 --> 01:00:51.610
e mudou o nome de todos os alunos em nosso banco de dados para Bobby, acho que era.

01:00:51.610 --> 01:00:55.120
O mesmo nome para cada linha porque eles simplesmente esqueceram um predicado.

01:00:55.120 --> 01:00:58.240
Aqui também há perigos no código, e você

01:00:58.240 --> 01:01:00.730
deve adotar o hábito rapidamente de sempre,

01:01:00.730 --> 01:01:03.730
um, fazendo backup de seus dados como com CP, por exemplo,

01:01:03.730 --> 01:01:09.010
no Linux ou qualquer outra técnica ou apenas certificando-se antes de pressionar Enter,

01:01:09.010 --> 01:01:11.322
sim, esta é realmente a consulta que desejo executar.

01:01:11.322 --> 01:01:13.030
E, de um modo geral, no mundo real,

01:01:13.030 --> 01:01:14.890
deve haver controles de processo em vigor.

01:01:14.890 --> 01:01:17.770
Como o estagiário não deveria ter acesso a produção

01:01:17.770 --> 01:01:19.570
banco de dados, o banco de dados ao vivo e similares.

01:01:19.570 --> 01:01:21.860
Mas você tem muito poder agora com essas consultas.

01:01:21.860 --> 01:01:25.520
Portanto, seja ainda mais cuidadoso, porque você pode facilmente fazer coisas ruins.

01:01:25.520 --> 01:01:26.660
Então deixe-me desfazer isso.

01:01:26.660 --> 01:01:30.790
Onde idioma é igual a aspas, sem aspas "C++."

01:01:30.790 --> 01:01:31.840
E eu vou diminuir o zoom.

01:01:31.840 --> 01:01:32.470
Digitar.

01:01:32.470 --> 01:01:34.480
E agora acho que estamos de volta aos negócios.

01:01:34.480 --> 01:01:36.100
C está entre as respostas.

01:01:36.100 --> 01:01:37.520
Sim?

01:01:37.520 --> 01:01:40.340
AUDIÊNCIA: [INAUDÍVEL]

01:01:42.293 --> 01:01:44.460
DAVID MALAN: É essencialmente fazer o que no final?

01:01:44.460 --> 01:01:45.270
AUDIÊNCIA: [INAUDÍVEL]

01:01:45.270 --> 01:01:46.680
DAVID MALAN: É essencialmente localizar e substituir.

01:01:46.680 --> 01:01:47.180
Sim.

01:01:47.180 --> 01:01:51.060
Em termos leigos, isso é localizar e substituir implementado com SQL.

01:01:51.060 --> 01:01:55.020
E, de fato, os autores do Microsoft Word ou do Google Docs

01:01:55.020 --> 01:01:58.290
pode muito bem estar usando uma linguagem como esta SQL

01:01:58.290 --> 01:02:01.710
quando você vai para a caixa de localização e substituição gráfica agradável e amigável.

01:02:01.710 --> 01:02:05.010
Isso pode muito bem ser o que eles estão fazendo sob o capô ou, é claro,

01:02:05.010 --> 01:02:07.770
eles poderiam estar usando algum outro idioma completamente.

01:02:07.770 --> 01:02:10.530
Há uma última sintaxe que vale a pena conhecer,

01:02:10.530 --> 01:02:14.280
excluir, que para o bem ou para o mal é ainda mais destrutivo, pelo que

01:02:14.280 --> 01:02:16.590
permite excluir linhas de tabelas.

01:02:16.590 --> 01:02:20.130
É diferente de drop, que permite excluir as próprias tabelas.

01:02:20.130 --> 01:02:21.630
Isso se concentra em linhas.

01:02:21.630 --> 01:02:26.250
Então suponha que você realmente não gostou,

01:02:26.250 --> 01:02:30.000
digamos, Tideman foi um pouco desafiador se você

01:02:30.000 --> 01:02:31.840
abordou esse problema mais confortável.

01:02:31.840 --> 01:02:34.800
Então, se você realmente não quer mais pensar no Tideman,

01:02:34.800 --> 01:02:40.080
então por que não excluímos dos favoritos onde o problema é igual, e eu

01:02:40.080 --> 01:02:42.240
não vai executá-lo de verdade, Tideman.

01:02:42.240 --> 01:02:45.360
Isso teria o efeito de excluir todas as linhas, incluindo

01:02:45.360 --> 01:02:50.010
o idioma nele contido e o carimbo de data/hora em que o aluno respondeu ao Tideman.

01:02:50.010 --> 01:02:53.910
Pior que isso seria isso.

01:02:53.910 --> 01:02:55.125
Por que isso pode ser ruim?

01:02:58.560 --> 01:03:00.930
OK, rindo porque não há predicado.

01:03:00.930 --> 01:03:04.960
Não há filtro, o que significa literalmente que isso excluiria todos os dados.

01:03:04.960 --> 01:03:07.740
Então, novamente, com grande poder vem uma grande responsabilidade.

01:03:07.740 --> 01:03:12.390
Agora, este foi apenas um conjunto de dados de 430 linhas criado por nós dinamicamente.

01:03:12.390 --> 01:03:15.240
Há, é claro, alguns conjuntos de dados realmente suculentos no mundo real.

01:03:15.240 --> 01:03:17.990
E um site que você pode ter ouvido falar ou um aplicativo que você pode ter usado

01:03:17.990 --> 01:03:20.460
é IMDb, o Internet Movie Database, que maravilhosamente

01:03:20.460 --> 01:03:24.330
disponibiliza alguns de seus dados para download como arquivos CSV

01:03:24.330 --> 01:03:27.420
ou tecnicamente arquivos TSV, valores separados por tabulações.

01:03:27.420 --> 01:03:31.830
Mas o que fizemos antes da aula foi baixar alguns desses dados para TV

01:03:31.830 --> 01:03:34.170
shows no mundo real e filmes no mundo real.

01:03:34.170 --> 01:03:35.962
E o que é maravilhoso sobre esse conjunto de dados é

01:03:35.962 --> 01:03:39.630
não são apenas dezenas, centenas ou mesmo milhares de linhas.

01:03:39.630 --> 01:03:44.190
Existem milhões de linhas de dados suculentos, programas de TV e filmes

01:03:44.190 --> 01:03:47.190
com o qual a maioria das pessoas provavelmente está familiarizada, pelo menos com um subconjunto.

01:03:47.190 --> 01:03:50.580
E veremos daqui a pouco que esses dados

01:03:50.580 --> 01:03:54.600
vem agora na forma de seis tabelas diferentes que lhe demos.

01:03:54.600 --> 01:03:56.610
E as mesas em questão para hoje vão

01:03:56.610 --> 01:04:00.735
ser as pessoas no negócio da TV, as estrelas nele, os shows que as pessoas

01:04:00.735 --> 01:04:01.860
estão produzindo e afins.

01:04:01.860 --> 01:04:04.860
Esta é uma imagem que revisitaremos para permitir

01:04:04.860 --> 01:04:07.110
você para entender quais são os dados reais.

01:04:07.110 --> 01:04:09.948
Parece uma boa oportunidade para um lanche.

01:04:09.948 --> 01:04:12.990
Na verdade, em apenas um momento, temos um monte de guloseimas de Rice Krispie

01:04:12.990 --> 01:04:13.690
no saguão.

01:04:13.690 --> 01:04:18.630
Mas se as pessoas pudessem reconhecer este mini bolo de casamento aqui.

01:04:18.630 --> 01:04:21.640
Zona CS50 Carter Zenke vai se casar esta semana.

01:04:21.640 --> 01:04:28.880
Parabéns a Carter também.

01:04:28.880 --> 01:04:30.550
Parabéns.

01:04:30.550 --> 01:04:31.940
Tudo bem.

01:04:31.940 --> 01:04:34.440
[APLAUSOS]

01:04:38.115 --> 01:04:40.952
Há apenas um pedaço de bolo naquela caixa, mas muito Rice Krispie

01:04:40.952 --> 01:04:41.910
mimos no transepto.

01:04:41.910 --> 01:04:45.420
Vamos demorar 10 minutos e voltaremos com o Internet Movie Database em 10.

01:04:45.420 --> 01:04:46.470
Tudo bem.

01:04:46.470 --> 01:04:47.320
Estamos de volta.

01:04:47.320 --> 01:04:51.000
Então, se você nunca foi, você pode ir para imdb.com agora mesmo

01:04:51.000 --> 01:04:53.020
e brinque ou baixe o aplicativo móvel.

01:04:53.020 --> 01:04:56.580
E é apenas um grande banco de dados de vários programas de TV e filmes

01:04:56.580 --> 01:04:58.090
e atores e afins.

01:04:58.090 --> 01:05:00.828
Mas o que realmente é bom é que você pode baixar alguns desses dados.

01:05:00.828 --> 01:05:02.370
E isso é o que eu fiz com antecedência.

01:05:02.370 --> 01:05:05.160
E o que fizemos foi escrever algum código Python

01:05:05.160 --> 01:05:09.540
para converter alguns dos bancos de dados de arquivo simples que eles permitem que você baixe

01:05:09.540 --> 01:05:13.890
e o convertemos em um banco de dados SQL com seis tabelas.

01:05:13.890 --> 01:05:17.940
Portanto, não apenas um, mas seis que, em última análise, são estes aqui.

01:05:17.940 --> 01:05:21.090
E deixe-me ajudá-lo a entender o que é esta imagem, que

01:05:21.090 --> 01:05:25.410
é um diagrama entidade relacionamento, que é apenas para dizer cada uma dessas caixas

01:05:25.410 --> 01:05:27.090
na tela representa uma tabela.

01:05:27.090 --> 01:05:31.230
E cada uma das setas ou bordas representa algum tipo de relacionamento

01:05:31.230 --> 01:05:32.100
pelas mesas.

01:05:32.100 --> 01:05:34.200
Porque até agora, os únicos dados que tínhamos

01:05:34.200 --> 01:05:36.270
foram essas três colunas na tabela de favoritos.

01:05:36.270 --> 01:05:39.130
Mas o que é realmente útil sobre bancos de dados SQL,

01:05:39.130 --> 01:05:41.700
como uma planilha do Google ou um arquivo do Excel,

01:05:41.700 --> 01:05:45.300
é que você pode ter várias planilhas ou em um banco de dados várias tabelas.

01:05:45.300 --> 01:05:50.010
E o que estamos prestes a ver é que no banco de dados IMDb para programas de TV,

01:05:50.010 --> 01:05:53.820
haverá uma mesa dedicada a todas as pessoas do ramo da TV.

01:05:53.820 --> 01:05:57.210
Haverá uma mesa dedicada para todos os programas de TV

01:05:57.210 --> 01:05:59.130
que estão em seu banco de dados a partir de agora.

01:05:59.130 --> 01:06:03.180
Haverá uma mesa dedicada a escritores desse setor,

01:06:03.180 --> 01:06:08.580
para as avaliações dos programas, para os gêneros aos quais os programas pertencem,

01:06:08.580 --> 01:06:09.700
comédia e afins.

01:06:09.700 --> 01:06:12.310
E, finalmente, haverá esta mesa,

01:06:12.310 --> 01:06:17.700
que de alguma forma associa as pessoas aos programas de TV que elas estrelam

01:06:17.700 --> 01:06:19.030
e vice versa.

01:06:19.030 --> 01:06:22.290
E então vamos considerar primeiro como isso se parece no código.

01:06:22.290 --> 01:06:25.110
E veremos que vai sobrecarregar intencionalmente no início,

01:06:25.110 --> 01:06:26.200
mas eu vou fazer isso.

01:06:26.200 --> 01:06:27.690
Vou voltar para a janela do meu terminal.

01:06:27.690 --> 01:06:30.240
E no intervalo baixei do site do curso

01:06:30.240 --> 01:06:33.960
um arquivo chamado shows.db, que criamos com antecedência para você.

01:06:33.960 --> 01:06:37.440
E se eu digitar ls, verei todos os meus arquivos favoritos anteriores.

01:06:37.440 --> 01:06:40.020
O arquivo CSV, o banco de dados e o Python.

01:06:40.020 --> 01:06:42.390
Mas agora eles são shows.db.

01:06:42.390 --> 01:06:45.540
Então, vou prosseguir na minha janela de terminal em tela cheia aqui.

01:06:45.540 --> 01:06:47.850
Não estou usando guias reais ou arquivos de código.

01:06:47.850 --> 01:06:52.380
Agora vou executar o sqlite3 no arquivo chamado shows.db.

01:06:52.380 --> 01:06:54.900
E eu só vou ver esta informação da versão aqui.

01:06:54.900 --> 01:06:57.120
Deixe-me limpar minha tela e executar o único comando

01:06:57.120 --> 01:07:01.170
Corri anteriormente para nos mostrar o esquema do banco de dados de favoritos.

01:07:01.170 --> 01:07:03.947
Agora veremos o esquema para o banco de dados shows.

01:07:03.947 --> 01:07:06.030
E há muita coisa acontecendo aqui, mas deixe-me rolar

01:07:06.030 --> 01:07:08.070
de volta ao topo, o começo.

01:07:08.070 --> 01:07:10.570
E nós vemos isso aqui.

01:07:10.570 --> 01:07:15.690
Então, quando executo .schema, vemos um despejo, realmente,

01:07:15.690 --> 01:07:20.310
de todos os comandos SQL create table que foram executados para criar este

01:07:20.310 --> 01:07:21.330
banco de dados para você.

01:07:21.330 --> 01:07:24.420
E uma dessas tabelas se chama gêneros e outra pessoas,

01:07:24.420 --> 01:07:27.370
classificações, shows, estrelas e assim por diante.

01:07:27.370 --> 01:07:29.340
E as colunas nele, mesmo que seja

01:07:29.340 --> 01:07:32.670
formatado de forma um pouco mais bonita do que a criação gerada automaticamente

01:07:32.670 --> 01:07:37.680
declaração de tabela para favoritos em que temos uma coluna por linha de saída

01:07:37.680 --> 01:07:41.520
aqui na mesa, por exemplo, pessoas, tem

01:07:41.520 --> 01:07:45.900
vai ser uma coluna de ID, como um identificador único como um Harvard ID, um Yale

01:07:45.900 --> 01:07:50.730
ID ou algo semelhante, uma coluna de nome, um ano de nascimento e outras coisas.

01:07:50.730 --> 01:07:53.760
Se eu rolar para baixo para shows, todos os shows do mundo

01:07:53.760 --> 01:07:58.410
vai ter um ID único também, um título claro, o ano em que

01:07:58.410 --> 01:08:00.390
estreou, e o número total de episódios

01:08:00.390 --> 01:08:02.370
a partir do momento em que baixamos os dados.

01:08:02.370 --> 01:08:04.080
E então o que mais há?

01:08:04.080 --> 01:08:08.170
Alguns deles são um pouco menos óbvios, como as classificações aqui.

01:08:08.170 --> 01:08:10.830
Portanto, as avaliações não têm uma coluna de ID, mas

01:08:10.830 --> 01:08:15.038
ter uma coluna de ID de programa e uma classificação em uma escala de cinco pontos ou 10 pontos

01:08:15.038 --> 01:08:16.830
escala ou similar e, em seguida, o número total

01:08:16.830 --> 01:08:19.319
de votos que foram coletados para contribuir para essa classificação.

01:08:19.319 --> 01:08:23.680
O IMDb permite que as pessoas votem a favor e não de programas e filmes e afins.

01:08:23.680 --> 01:08:26.380
E então, da mesma forma, o gênero é estruturado.

01:08:26.380 --> 01:08:29.290
Há um ID de programa e depois há um gênero,

01:08:29.290 --> 01:08:33.370
que vai ser uma palavra em inglês como comédia ou drama ou outra coisa.

01:08:33.370 --> 01:08:34.200
E então o que mais?

01:08:34.200 --> 01:08:38.609
Vamos um pouco mais abaixo aqui para estrelas e escritores.

01:08:38.609 --> 01:08:41.729
Se formos ao fundo aqui, estrelas e escritores

01:08:41.729 --> 01:08:43.470
também são estruturados de forma semelhante.

01:08:43.470 --> 01:08:46.890
Eles têm um ID de show e um ID de pessoa.

01:08:46.890 --> 01:08:48.540
Então mostre e pessoa.

01:08:48.540 --> 01:08:52.470
E então esta tabela de escritores tem um ID de show e um ID de pessoa.

01:08:52.470 --> 01:08:56.340
E há um monte de outras palavras que veremos em um momento.

01:08:56.340 --> 01:08:58.330
Mas o que esse código está insinuando?

01:08:58.330 --> 01:09:01.000
Bem, se eu voltar para a foto anterior aqui,

01:09:01.000 --> 01:09:05.160
você verá que esta imagem captura os relacionamentos

01:09:05.160 --> 01:09:07.020
entre essas várias tabelas.

01:09:07.020 --> 01:09:11.670
Então, por exemplo, se focarmos em shows por um momento, um show,

01:09:11.670 --> 01:09:15.359
novamente, tem um ID único, um título, um ano em que estreou,

01:09:15.359 --> 01:09:16.859
e um número total de episódios.

01:09:16.859 --> 01:09:20.550
Se você quiser descobrir qual gênero ou gêneros

01:09:20.550 --> 01:09:24.300
um show pertence, porque alguns shows são apenas comédias,

01:09:24.300 --> 01:09:29.010
alguns shows são apenas dramas, mas alguns shows são indiscutivelmente comédias e dramas

01:09:29.010 --> 01:09:30.700
dependendo do episódio ou algo do tipo.

01:09:30.700 --> 01:09:34.740
Então você pode imaginar querer associar dois ou três ou até mais gêneros

01:09:34.740 --> 01:09:35.640
com um show.

01:09:35.640 --> 01:09:39.830
Essa linha aqui nessa segunda tabela nos permite fazer isso.

01:09:39.830 --> 01:09:46.310
Cada linha na tabela de gêneros que veremos tem dois itens, um ID de programa

01:09:46.310 --> 01:09:49.250
que se relaciona com o ID de um programa.

01:09:49.250 --> 01:09:54.350
E é por isso que essas linhas literalmente se alinham com o nome da coluna específica.

01:09:54.350 --> 01:09:57.050
E um gênero, que vai ser, entre aspas, "comédia",

01:09:57.050 --> 01:09:59.250
entre aspas "drama" ou outra coisa.

01:09:59.250 --> 01:10:02.180
Agora com isso dito, questão de design.

01:10:02.180 --> 01:10:07.250
Por que deliberadamente não apenas nos livramos dessa tabela de gêneros

01:10:07.250 --> 01:10:12.950
e tornou nossas vidas mais simples apenas adicionando uma coluna de gênero ao programa

01:10:12.950 --> 01:10:13.640
mesa?

01:10:13.640 --> 01:10:17.150
E, novamente, uma tabela é como uma planilha com linhas e colunas.

01:10:17.150 --> 01:10:21.140
No momento, os shows têm apenas quatro colunas, ID, título, ano, episódios.

01:10:21.140 --> 01:10:28.980
Por que não apenas adicionar uma quinta coluna chamada gênero e colocar o gênero do programa lá?

01:10:28.980 --> 01:10:32.200
Alguma intuição aqui?

01:10:32.200 --> 01:10:34.960
Por que não manter as coisas simples?

01:10:34.960 --> 01:10:36.286
Sim, atrás.

01:10:36.286 --> 01:10:42.035
AUDIÊNCIA: [INAUDÍVEL]

01:10:42.035 --> 01:10:42.910
DAVID MALAN: Exatamente.

01:10:42.910 --> 01:10:46.670
Se você adicionar uma quinta coluna aqui e chamá-la de gênero,

01:10:46.670 --> 01:10:49.900
então você tem que escolher um gênero especificamente.

01:10:49.900 --> 01:10:55.840
Você tem que colocar naquela cela presumivelmente comédia ou drama ou musical ou algo assim

01:10:55.840 --> 01:10:56.480
outro.

01:10:56.480 --> 01:10:58.270
Agora, você pode escrever várias palavras na célula,

01:10:58.270 --> 01:11:00.645
mas, de um modo geral, isso seria um design desleixado e ruim.

01:11:00.645 --> 01:11:02.492
Como cada célula como em uma planilha

01:11:02.492 --> 01:11:03.700
deve realmente ter um valor.

01:11:03.700 --> 01:11:07.270
Pode ter várias palavras, mas não deve ser estranhamente separado por vírgula

01:11:07.270 --> 01:11:08.530
lista de várias coisas.

01:11:08.530 --> 01:11:10.655
Deve estar apenas em uma célula diferente nesse caso.

01:11:10.655 --> 01:11:14.320
Então, se você fosse projetar isso com apenas uma única coluna chamada gênero,

01:11:14.320 --> 01:11:16.510
você está impondo o que um cientista da computação

01:11:16.510 --> 01:11:19.480
chamaria um relacionamento um para um.

01:11:19.480 --> 01:11:21.580
Cada show tem um gênero.

01:11:21.580 --> 01:11:23.800
E isso não é necessariamente bom.

01:11:23.800 --> 01:11:26.170
Ou, estritamente falando, seria muitos para um,

01:11:26.170 --> 01:11:28.510
porque o mesmo gênero pode pertencer a vários shows,

01:11:28.510 --> 01:11:31.760
mas cada programa só poderia ter um gênero nesse caso.

01:11:31.760 --> 01:11:33.760
O que um banco de dados relacional permite que você faça,

01:11:33.760 --> 01:11:35.890
e relacional é de fato a palavra operativa,

01:11:35.890 --> 01:11:39.100
ele permite que você fatore algumas de suas informações

01:11:39.100 --> 01:11:44.590
e então ter talvez um show aqui em uma linha, mas então nesta tabela de gêneros,

01:11:44.590 --> 01:11:47.320
você poderia ter uma linha para aquele gênero de programa,

01:11:47.320 --> 01:11:52.450
ou você pode ter duas linhas na tabela de gêneros para comédia e para drama.

01:11:52.450 --> 01:11:55.490
Ou se tiver um terceiro gênero, você pode simplesmente adicionar outra linha aqui.

01:11:55.490 --> 01:11:59.380
Então você ainda tem uma linha para o show em si

01:11:59.380 --> 01:12:02.890
com todos os detalhes suculentos, mas um número variável de linhas

01:12:02.890 --> 01:12:05.950
por ter esse relacionamento com outra tabela.

01:12:05.950 --> 01:12:10.000
Enquanto isso, as classificações funcionam da mesma maneira, pelo menos neste caso.

01:12:10.000 --> 01:12:12.882
Um programa tem ID, título, ano e episódios.

01:12:12.882 --> 01:12:14.590
Mas se você quiser descobrir sua classificação,

01:12:14.590 --> 01:12:17.710
você tem que seguir a seta aqui, por assim dizer, e olhar para cima

01:12:17.710 --> 01:12:20.020
o show ID correspondente nesta tabela.

01:12:20.020 --> 01:12:23.750
Encontre a classificação desse programa e o número total de classificações.

01:12:23.750 --> 01:12:26.470
Então isso também foi levado em consideração, para o bem ou para o mal.

01:12:26.470 --> 01:12:28.600
Agora vamos considerar as pessoas.

01:12:28.600 --> 01:12:32.050
As pessoas têm apenas três colunas, ID, nome e nascimento.

01:12:32.050 --> 01:12:35.350
Mas não há menção ao programa de TV em que as pessoas estrelaram

01:12:35.350 --> 01:12:38.140
ou os programas de TV que uma pessoa escreveu.

01:12:38.140 --> 01:12:39.200
Bem, por que isso?

01:12:39.200 --> 01:12:42.730
Bem, se você tivesse uma quarta coluna aqui chamada show,

01:12:42.730 --> 01:12:45.560
bem, você teria que decidir em que programa essa pessoa está.

01:12:45.560 --> 01:12:47.560
E ninguém jamais poderia atuar novamente em outro show,

01:12:47.560 --> 01:12:49.310
porque não há espaço para armazenar os dados.

01:12:49.310 --> 01:12:53.560
Mas se alguém, é claro, um ator popular pode estrelar vários shows,

01:12:53.560 --> 01:12:57.790
bem, poderíamos ter um ID para essa pessoa, um nome, um ano de nascimento,

01:12:57.790 --> 01:12:58.360
obviamente.

01:12:58.360 --> 01:13:02.230
Como se houvesse apenas um Steve Carell como ator no mundo das pessoas.

01:13:02.230 --> 01:13:06.610
Mas Steve Carell neste exemplo poderia ter seu ID pessoal,

01:13:06.610 --> 01:13:09.220
qualquer que seja seu equivalente em Harvard ID, equivalente em Yale ID,

01:13:09.220 --> 01:13:12.130
aparecem em várias linhas nesta tabela para que

01:13:12.130 --> 01:13:14.470
pode ser associado a vários shows.

01:13:14.470 --> 01:13:18.830
E isso permite que você crie o que é chamado de relacionamento um para muitos,

01:13:18.830 --> 01:13:20.500
ou tecnicamente é bidirecional.

01:13:20.500 --> 01:13:22.450
É uma relação de muitos para muitos.

01:13:22.450 --> 01:13:23.120
Por que?

01:13:23.120 --> 01:13:26.470
Bem, um show certamente pode ter várias pessoas nele

01:13:26.470 --> 01:13:29.090
e várias pessoas escrevendo para ele, apenas no mundo real.

01:13:29.090 --> 01:13:33.910
Mas, inversamente, uma pessoa certamente poderia atuar em vários shows

01:13:33.910 --> 01:13:35.330
ou escrever vários programas.

01:13:35.330 --> 01:13:38.380
Portanto, é isso que você obtém com bancos de dados relacionais.

01:13:38.380 --> 01:13:41.440
Você coloca seu tipo de dados canônicos para as pessoas em um só lugar,

01:13:41.440 --> 01:13:46.150
para shows em outro lugar, e então você usa essas tabelas adicionais

01:13:46.150 --> 01:13:48.993
relacionar uma coisa com outra.

01:13:48.993 --> 01:13:50.410
Então não vamos nos deter nas fotos.

01:13:50.410 --> 01:13:53.350
Isso é apenas se você puder envolver sua mente em torno dos dados

01:13:53.350 --> 01:13:55.870
definir melhor dessa maneira, essa é uma maneira de pensar sobre isso.

01:13:55.870 --> 01:14:00.177
Mas lembre-se de que o código que acabamos de ver para o esquema, novamente, foi escalado rapidamente.

01:14:00.177 --> 01:14:02.260
Há muitas palavras-chave que ainda não mencionei.

01:14:02.260 --> 01:14:04.360
Mas alguns deles talvez sejam familiares.

01:14:04.360 --> 01:14:06.130
Eles são capitalizados de forma diferente aqui.

01:14:06.130 --> 01:14:08.140
Mas inteiro está na lista aqui.

01:14:08.140 --> 01:14:10.790
Nulo está na lista, embora tecnicamente não seja nulo.

01:14:10.790 --> 01:14:12.760
Vamos separar algumas dessas palavras-chave

01:14:12.760 --> 01:14:15.218
e considere o que eles realmente estão fazendo pelo seu banco de dados,

01:14:15.218 --> 01:14:18.640
porque agora estamos explorando recursos que não existem

01:14:18.640 --> 01:14:20.980
apenas no mundo das planilhas.

01:14:20.980 --> 01:14:24.190
Acontece que em um banco de dados SQL, especificamente

01:14:24.190 --> 01:14:27.265
SQLite que é a versão do SQL que usamos no CS50

01:14:27.265 --> 01:14:30.910
e que é comumente usado para coisas como aplicativos móveis hoje em dia.

01:14:30.910 --> 01:14:32.560
É como uma versão leve do SQL.

01:14:32.560 --> 01:14:35.590
É quando você não está tentando comandar o Twitter e ter bilhões

01:14:35.590 --> 01:14:37.150
e bilhões de linhas necessariamente.

01:14:37.150 --> 01:14:40.730
Você tem centenas, milhares, dezenas de milhares, talvez até alguns milhões,

01:14:40.730 --> 01:14:44.590
mas não números loucos, quantidades loucas de dados.

01:14:44.590 --> 01:14:49.250
No mundo do SQLite especificamente, existem esses cinco tipos de dados.

01:14:49.250 --> 01:14:52.390
Assim como em C, tínhamos int e char e assim por diante.

01:14:52.390 --> 01:14:54.190
No SQL, temos estes.

01:14:54.190 --> 01:14:57.447
Blob, que é meio engraçado, mas significa apenas grandes objetos binários.

01:14:57.447 --> 01:14:58.780
Portanto, é como um tipo de dados binário.

01:14:58.780 --> 01:15:02.830
Zeros e uns que não necessariamente se encaixam nas outras categorias.

01:15:02.830 --> 01:15:05.290
Integer, que é claro, é um número inteiro como o conhecemos.

01:15:05.290 --> 01:15:09.940
Numérico, que é uma espécie de catchall para números formatados de forma especial.

01:15:09.940 --> 01:15:14.710
Então, como uma data seria como ano, ano, ano, ano, traço mês, mês,

01:15:14.710 --> 01:15:16.390
traço dia, dia.

01:15:16.390 --> 01:15:18.015
E isso é realmente uma coisa maravilhosa.

01:15:18.015 --> 01:15:19.723
Dependendo do país de onde você é, você

01:15:19.723 --> 01:15:22.720
pode pensar que seu sistema de datas em seu país é ótimo ou horrível.

01:15:22.720 --> 01:15:27.040
O sistema dos EUA é horrível porque temos mês, dia e depois

01:15:27.040 --> 01:15:29.350
ano, o que é impossível de classificar.

01:15:29.350 --> 01:15:31.930
É a maneira errada de armazenar dados objetivamente.

01:15:31.930 --> 01:15:33.803
E ainda aqui estamos usando isso em escala.

01:15:33.803 --> 01:15:35.470
Outros países conseguiram isso melhor.

01:15:35.470 --> 01:15:38.383
O numérico no próprio SQL padroniza essas coisas.

01:15:38.383 --> 01:15:40.300
Portanto, não importa de que país você é.

01:15:40.300 --> 01:15:43.200
Você está armazenando seus dados dessa maneira específica, por exemplo.

01:15:43.200 --> 01:15:46.560
Os horários são padronizados e outros tipos de dados numéricos também.

01:15:46.560 --> 01:15:48.630
Real é sinônimo de fluxo.

01:15:48.630 --> 01:15:52.410
Então, algo com um ponto decimal e algum número de dígitos depois disso.

01:15:52.410 --> 01:15:55.530
E então o texto é apenas para strings e afins.

01:15:55.530 --> 01:16:00.240
Com outros bancos de dados ainda mais sofisticados, como MySQL, PostgreSQL, Oracle,

01:16:00.240 --> 01:16:02.370
e outros produtos dos quais você já deve ter ouvido falar,

01:16:02.370 --> 01:16:04.170
há ainda mais tipos de dados onde você tem

01:16:04.170 --> 01:16:05.712
para tomar decisões ainda mais refinadas.

01:16:05.712 --> 01:16:07.950
Mas para SQLite, é realmente muito leve

01:16:07.950 --> 01:16:12.120
e você ou nós apenas temos que decidir os tipos de dados para cada coluna em uma tabela.

01:16:12.120 --> 01:16:15.000
Mas há essas restrições adicionais no mundo do SQL.

01:16:15.000 --> 01:16:21.400
Você também pode dizer que as células nesta coluna podem ou não ser nulas.

01:16:21.400 --> 01:16:24.660
Então, se você quer se proteger de si mesmo para não estragar tudo

01:16:24.660 --> 01:16:26.880
e insira um nulo, que é um valor em branco,

01:16:26.880 --> 01:16:31.090
você pode projetar explicitamente uma tabela para ter uma coluna que não pode ser nula.

01:16:31.090 --> 01:16:33.090
E então, de fato, alguém apareceu durante o intervalo

01:16:33.090 --> 01:16:36.450
para me perguntar sobre eu ter inserido SQL manualmente,

01:16:36.450 --> 01:16:38.923
entre aspas "SQL" em nosso banco de dados de favoritos.

01:16:38.923 --> 01:16:40.590
Você deve se lembrar que eu meio que trapaceei.

01:16:40.590 --> 01:16:44.340
Acabei de inserir "SQL" entre aspas e "fiftyville",

01:16:44.340 --> 01:16:46.050
o nome de um novo problema, entre aspas.

01:16:46.050 --> 01:16:49.170
Mas o que eu não inseri no banco de dados?

01:16:49.170 --> 01:16:50.100
Um carimbo de data/hora.

01:16:50.100 --> 01:16:50.880
E eu poderia.

01:16:50.880 --> 01:16:54.240
Eu poderia ter colocado o dia e a hora atuais alguns minutos atrás, mas não o fiz.

01:16:54.240 --> 01:16:58.590
E tudo bem se for aceitável para você e para o produto que está construindo.

01:16:58.590 --> 01:17:00.300
Mas eu poderia ter evitado isso.

01:17:00.300 --> 01:17:05.100
Se tivéssemos definido a tabela para ter uma coluna de timestamp que não fosse apenas texto

01:17:05.100 --> 01:17:08.490
mas é texto que não é nulo, o SQL teria reclamado

01:17:08.490 --> 01:17:10.650
e não teria me deixado completar essa inserção.

01:17:10.650 --> 01:17:13.567
Portanto, existem esses tipos de defesas embutidas que você não necessariamente

01:17:13.567 --> 01:17:15.180
obter com uma planilha sozinho.

01:17:15.180 --> 01:17:17.170
E único significa exatamente isso.

01:17:17.170 --> 01:17:20.190
Se você quiser ter certeza de que todas as linhas dessa coluna

01:17:20.190 --> 01:17:24.480
é único, talvez para endereços de e-mail ou na Previdência Social dos EUA

01:17:24.480 --> 01:17:26.190
números ou qualquer coisa que você queira fazer

01:17:26.190 --> 01:17:30.330
Certifique-se de não ter duas versões de, você pode especificar que a coluna é única.

01:17:30.330 --> 01:17:32.170
E há outras restrições também.

01:17:32.170 --> 01:17:34.140
Mas, novamente, esta é apenas uma lista de recursos

01:17:34.140 --> 01:17:37.170
que você obtém de um banco de dados relacional adequado.

01:17:37.170 --> 01:17:39.990
Mas talvez o mais intelectualmente interessante

01:17:39.990 --> 01:17:42.420
e o mais poderoso é o que se chama

01:17:42.420 --> 01:17:45.000
aqui uma chave primária e uma chave estrangeira.

01:17:45.000 --> 01:17:47.640
E deixe-me voltar agora para esta saída.

01:17:47.640 --> 01:17:51.970
Se olharmos para shows, você verá que um show, novamente,

01:17:51.970 --> 01:17:55.320
tem um ID, um título, um ano e uma série de episódios.

01:17:55.320 --> 01:17:57.120
E agora os tipos de dados podem fazer sentido.

01:17:57.120 --> 01:17:59.820
Acontece que a identidade, assim como uma identidade de Harvard, uma identidade de Yale,

01:17:59.820 --> 01:18:01.150
vai ser um número inteiro.

01:18:01.150 --> 01:18:02.220
Portanto, um número simples.

01:18:02.220 --> 01:18:04.680
O título, é claro, será texto, mas não nulo.

01:18:04.680 --> 01:18:07.470
Seria estranho se um programa de TV não tivesse nome.

01:18:07.470 --> 01:18:08.615
Isso não pode ser.

01:18:08.615 --> 01:18:10.990
O mundo inteiro quebraria ou seu guia de TV e outros enfeites.

01:18:10.990 --> 01:18:13.590
Portanto, faz sentido dizer não nulo.

01:18:13.590 --> 01:18:14.670
O ano é numérico.

01:18:14.670 --> 01:18:15.990
Portanto, é um formulário padronizado.

01:18:15.990 --> 01:18:19.140
Episódios é um número inteiro, como quantos episódios foram produzidos.

01:18:19.140 --> 01:18:20.790
E então, por último, observe isso.

01:18:20.790 --> 01:18:24.090
A chave primária da tabela do show é aparentemente

01:18:24.090 --> 01:18:27.880
a coluna chamada ID mencionada algumas linhas antes.

01:18:27.880 --> 01:18:32.400
Isso significa apenas que o banco de dados usará o ID

01:18:32.400 --> 01:18:34.740
coluna como o identificador exclusivo.

01:18:34.740 --> 01:18:37.770
Portanto, é semelhante à palavra-chave exclusiva, mas a chave primária apenas

01:18:37.770 --> 01:18:40.260
significa que o banco de dados vai tratá-lo como especial também

01:18:40.260 --> 01:18:43.380
e certifique-se de que está identificando exclusivamente seus dados.

01:18:43.380 --> 01:18:45.300
Mas o que é interessante é isso.

01:18:45.300 --> 01:18:48.480
Observe se eu rolar de volta para pessoas, pessoas

01:18:48.480 --> 01:18:51.480
foram estruturados de forma semelhante, mas com atributos diferentes.

01:18:51.480 --> 01:18:56.310
Como aqui em cima tínhamos uma pessoa com uma identidade, um nome, um nascimento

01:18:56.310 --> 01:18:58.800
ano e uma chave primária de ID.

01:18:58.800 --> 01:19:01.080
Portanto, um ID é, novamente, inteiro.

01:19:01.080 --> 01:19:03.600
O nome é texto, mas não nulo, porque seria

01:19:03.600 --> 01:19:06.420
estranho ter um humano com absolutamente nenhum nome textualmente.

01:19:06.420 --> 01:19:07.860
O nascimento será numérico.

01:19:07.860 --> 01:19:11.590
Mas a chave primária das pessoas também é o ID.

01:19:11.590 --> 01:19:15.150
Portanto, essas são as colunas exclusivas que o banco de dados tratará de forma especial.

01:19:15.150 --> 01:19:15.810
Por que?

01:19:15.810 --> 01:19:17.310
Bem, nós apenas olhamos para shows.

01:19:17.310 --> 01:19:18.900
Nós apenas olhamos para as pessoas.

01:19:18.900 --> 01:19:22.380
Vamos nos concentrar agora neste aqui embaixo, estrelas.

01:19:22.380 --> 01:19:25.260
Como você determina quem estrela um programa de TV?

01:19:25.260 --> 01:19:26.370
Bem, nós tínhamos duas colunas.

01:19:26.370 --> 01:19:28.320
O ID do programa e o ID da pessoa.

01:19:28.320 --> 01:19:31.080
Esta é a encarnação de um relacionamento muitos para muitos.

01:19:31.080 --> 01:19:32.550
Uma pessoa pode estar em muitos shows.

01:19:32.550 --> 01:19:35.710
Um show certamente poderia ter muitas pessoas nele ou escrevendo para ele.

01:19:35.710 --> 01:19:37.250
Mas observe isso.

01:19:37.250 --> 01:19:41.220
Dentro desta tabela de duas colunas, mostre o ID e o ID da pessoa,

01:19:41.220 --> 01:19:44.070
há o que vai ser chamado de chave estrangeira chamada

01:19:44.070 --> 01:19:49.350
show ID que faz referência à coluna de ID da tabela do show

01:19:49.350 --> 01:19:51.367
e então outra chave estrangeira chamada ID da pessoa,

01:19:51.367 --> 01:19:53.700
embora eu pudesse chamar essas coisas entre parênteses de qualquer coisa

01:19:53.700 --> 01:19:57.495
Eu quero, que faça referência à coluna de ID da tabela de pessoas.

01:19:57.495 --> 01:20:00.120
Agora, você não precisará digitar comandos como este com frequência.

01:20:00.120 --> 01:20:02.700
Novamente, você configura o banco de dados uma vez no início

01:20:02.700 --> 01:20:04.590
normalmente, talvez com a ajuda de um TF,

01:20:04.590 --> 01:20:06.210
talvez com a ajuda do Google ou algo parecido.

01:20:06.210 --> 01:20:09.203
Mas uma vez que seu banco de dados é projetado, ele volta para o CRUD.

01:20:09.203 --> 01:20:12.120
Criar, ler, atualizar, excluir, as seleções, as inserções, as exclusões,

01:20:12.120 --> 01:20:12.690
e similar.

01:20:12.690 --> 01:20:14.310
Mas o que isso significa?

01:20:14.310 --> 01:20:17.520
Essas palavras-chave como chave primária e chave estrangeira

01:20:17.520 --> 01:20:23.100
são o que estão fazendo no código o que esta imagem estava pintando um momento atrás.

01:20:23.100 --> 01:20:27.570
Essas linhas aqui são desenhadas literalmente para alinhar com as coisas correspondentes.

01:20:27.570 --> 01:20:30.660
A ID da pessoa se alinha com a ID da pessoa.

01:20:30.660 --> 01:20:34.410
O ID do programa se alinha com o ID do programa.

01:20:34.410 --> 01:20:37.950
E então você está apenas vendo a versão gráfica, a versão do código, gráfica,

01:20:37.950 --> 01:20:40.860
código que cria esses relacionamentos.

01:20:40.860 --> 01:20:45.190
Agora, dado isso, vamos realmente ver como essas coisas se parecem.

01:20:45.190 --> 01:20:47.160
Então, deixe-me voltar ao VS Code aqui.

01:20:47.160 --> 01:20:48.400
Deixe-me limpar minha tela.

01:20:48.400 --> 01:20:51.000
Ainda estou dentro do SQLite com shows.db.

01:20:51.000 --> 01:20:53.480
Deixe-me seguir em frente e fazer o que faço com qualquer novo banco de dados.

01:20:53.480 --> 01:20:55.230
Se eu baixar algo ou estou tentando

01:20:55.230 --> 01:20:57.600
para envolver minha mente em torno de um problema, geralmente

01:20:57.600 --> 01:21:01.230
não vem com uma foto bonita ou uma palestra de três horas

01:21:01.230 --> 01:21:02.670
para explicar o que é o conjunto de dados.

01:21:02.670 --> 01:21:06.190
Em vez disso, você apenas tem o conjunto de dados em seu próprio conhecimento de SQL.

01:21:06.190 --> 01:21:07.440
Então deixe-me brincar.

01:21:07.440 --> 01:21:09.608
Então .schema me mostra todas as tabelas.

01:21:09.608 --> 01:21:10.900
Isso pode ser um ponto de partida.

01:21:10.900 --> 01:21:11.900
OK, isso é interessante.

01:21:11.900 --> 01:21:13.560
Eu sei o que as pessoas são.

01:21:13.560 --> 01:21:16.530
Vamos em frente e me mostre todas as pessoas.

01:21:16.530 --> 01:21:18.595
Então selecione a estrela das pessoas.

01:21:18.595 --> 01:21:20.970
Estou apenas tentando entender o que esse conjunto de dados

01:21:20.970 --> 01:21:24.330
parece de uma forma mais amigável.

01:21:24.330 --> 01:21:26.607
Isso já é muita gente.

01:21:26.607 --> 01:21:28.440
Como você vê os anos voando, tem havido

01:21:28.440 --> 01:21:31.170
um monte de gente no negócio de TV.

01:21:31.170 --> 01:21:33.540
Portanto, essa talvez não seja a melhor consulta a ser executada.

01:21:33.540 --> 01:21:39.300
Mas isso é indicativo de quão grande é esse conjunto de dados do IMDb.

01:21:39.300 --> 01:21:42.960
Em caso de dúvida e sempre que perder o controle sobre seu computador,

01:21:42.960 --> 01:21:44.940
O controle C é seu amigo para interromper.

01:21:44.940 --> 01:21:46.860
O que teria sido melhor, porque eu não

01:21:46.860 --> 01:21:49.980
acho que preciso conhecer todos os milhões de pessoas no mundo,

01:21:49.980 --> 01:21:52.470
Eu poderia me limitar a 10 pessoas.

01:21:52.470 --> 01:21:55.860
E isso é o suficiente agora para ter uma noção de Fred Astaire

01:21:55.860 --> 01:21:58.920
tem um ID de um, a primeira pessoa de todos os tempos.

01:21:58.920 --> 01:22:00.660
Ano de nascimento de 1899.

01:22:00.660 --> 01:22:04.740
Lauren Bacall e todas essas outras pessoas do passado.

01:22:04.740 --> 01:22:07.410
Você vê que eles são as primeiras 10 pessoas no banco de dados.

01:22:07.410 --> 01:22:09.160
Portanto, há um exemplo de alguns dos dados.

01:22:09.160 --> 01:22:12.540
Agora, se eu quiser entender o que é um show, eu sei disso tecnicamente.

01:22:12.540 --> 01:22:13.800
Conheço pela foto.

01:22:13.800 --> 01:22:15.400
Mas vamos apenas olhar para alguns dados brutos.

01:22:15.400 --> 01:22:18.210
Então, em vez de dizer selecione a estrela das pessoas, deixe-me ir em frente

01:22:18.210 --> 01:22:21.480
e selecione a estrela do limite de shows 10.

01:22:21.480 --> 01:22:26.250
E tudo bem, só ouvi falar ou vi alguns deles,

01:22:26.250 --> 01:22:27.970
mas esses são programas mais antigos.

01:22:27.970 --> 01:22:31.530
Mas vejo que todo programa tem uma identidade, um título, um ano em que estreou,

01:22:31.530 --> 01:22:32.910
e vários episódios.

01:22:32.910 --> 01:22:35.340
Mas talvez o mais opaco seja isso.

01:22:35.340 --> 01:22:41.520
Selecione estrela de estrelas onde esta é a tabela que associa pessoas

01:22:41.520 --> 01:22:42.330
com shows.

01:22:42.330 --> 01:22:46.950
Vou ver algum nome ou mostrar títulos aqui?

01:22:46.950 --> 01:22:49.127
Não de acordo com a definição que vimos anteriormente.

01:22:49.127 --> 01:22:50.460
Oh, eu deveria ter feito o meu limite.

01:22:50.460 --> 01:22:51.660
Deixe-me interromper isso.

01:22:51.660 --> 01:22:52.620
Deixe-me fazer isso de novo.

01:22:52.620 --> 01:22:54.180
Limite 10.

01:22:54.180 --> 01:22:55.050
Não.

01:22:55.050 --> 01:22:58.380
E é aqui que agora você definitivamente está no mundo do programador,

01:22:58.380 --> 01:23:01.780
porque esta seria a planilha mais irritante para usar no seu Mac ou PC

01:23:01.780 --> 01:23:02.280
sempre.

01:23:02.280 --> 01:23:04.528
Se você tivesse uma folha com todos esses números

01:23:04.528 --> 01:23:06.570
que associa uma coisa com a outra, meu Deus,

01:23:06.570 --> 01:23:08.910
como você descobre quem é ou o que é isso?

01:23:08.910 --> 01:23:12.780
Você tem que controlar manualmente F ou Command F procurando os dados.

01:23:12.780 --> 01:23:14.310
Mas um banco de dados não se importa.

01:23:14.310 --> 01:23:18.160
Depois de conhecer o SQL, você pode unir essas coisas novamente.

01:23:18.160 --> 01:23:21.360
Então, o que você está vendo aqui são chaves estrangeiras.

01:23:21.360 --> 01:23:22.150
Chaves estrangeiras.

01:23:22.150 --> 01:23:22.650
Por que?

01:23:22.650 --> 01:23:27.600
Porque show ID corresponde aos mesmos números dessa outra tabela

01:23:27.600 --> 01:23:30.990
chamado mostra que tem uma chave primária apropriada chamada ID.

01:23:30.990 --> 01:23:33.360
ID da pessoa é uma chave estrangeira neste contexto,

01:23:33.360 --> 01:23:38.620
porque se refere a números que pertencem realmente à tabela de pessoas e seu ID

01:23:38.620 --> 01:23:39.120
coluna.

01:23:39.120 --> 01:23:41.037
Portanto, esta é apenas uma maneira de ligá-los de alguma forma.

01:23:41.037 --> 01:23:44.100
E então, se você pensar, eu sempre penso nisso em minha mente como isso.

01:23:44.100 --> 01:23:47.760
Se esta é a tabela de pessoas, esta é a tabela de shows,

01:23:47.760 --> 01:23:51.690
e há essa mesa do meio no meio, a mesa das estrelas.

01:23:51.690 --> 01:23:56.490
Existe alguma maneira de unir esses dois, alinhando os IDs de um

01:23:56.490 --> 01:23:58.870
com o outro e recuperando mais alguns dados.

01:23:58.870 --> 01:24:01.690
Então, vamos brincar com alguns desses dados.

01:24:01.690 --> 01:24:05.148
Que tal começarmos onde enfatizamos anteriormente, gêneros.

01:24:05.148 --> 01:24:08.440
Então deixe-me ir em frente e dar uma olhada rápida em todos os gêneros neste banco de dados.

01:24:08.440 --> 01:24:10.500
Então selecione estrela de gêneros.

01:24:10.500 --> 01:24:13.030
A estrela geralmente será um pouco avassaladora,

01:24:13.030 --> 01:24:15.240
mas apenas me dá uma noção de quais são os dados.

01:24:15.240 --> 01:24:17.850
Mas vamos realmente olhar para--

01:24:17.850 --> 01:24:19.440
vamos ver todos eles lá.

01:24:19.440 --> 01:24:20.850
OK, isso é muito.

01:24:20.850 --> 01:24:24.210
Estes são todos os gêneros oficiais do IMDb.

01:24:24.210 --> 01:24:27.030
OK, não foi muito longo.

01:24:27.030 --> 01:24:28.350
Deixe-me filtrar isso.

01:24:28.350 --> 01:24:34.800
Então, de gêneros em que gênero é igual a comédia, C maiúsculo apenas baseado

01:24:34.800 --> 01:24:36.000
nos dados que estou vendo.

01:24:36.000 --> 01:24:38.220
OK, então o que estou vendo agora?

01:24:38.220 --> 01:24:40.838
E, de fato, deixe-me limitar isso arbitrariamente a 10,

01:24:40.838 --> 01:24:42.630
embora eu possa limitar isso a qualquer coisa que eu queira.

01:24:42.630 --> 01:24:45.060
Aqui estão 10 comédias.

01:24:45.060 --> 01:24:46.080
O que eles são?

01:24:46.080 --> 01:24:47.490
Bem, quem diabos sabe?

01:24:47.490 --> 01:24:49.590
Tudo o que sei são os 10 IDs de programas.

01:24:49.590 --> 01:24:51.180
Agora, eu poderia fazer algo assim.

01:24:51.180 --> 01:24:54.037
Como vimos antes com SQL, eu poderia fazer, tudo bem, bem

01:24:54.037 --> 01:24:55.620
vamos descobrir qual é esse ID de programa.

01:24:55.620 --> 01:25:03.750
Selecione a estrela dos programas em que o ID do programa que estou procurando é igual a quê?

01:25:03.750 --> 01:25:06.910
62614 ponto e vírgula.

01:25:06.910 --> 01:25:11.200
Então, eu poderia procurá-lo manualmente fazendo referência cruzada à outra tabela.

01:25:11.200 --> 01:25:14.860
Então esse era o programa em questão, a primeira comédia no conjunto de dados.

01:25:14.860 --> 01:25:16.200
Deixe-me procurar o segundo.

01:25:16.200 --> 01:25:20.610
Então, em vez disso, vamos fazer 63881 Enter.

01:25:20.610 --> 01:25:21.150
OK.

01:25:21.150 --> 01:25:22.410
Então esse é o show.

01:25:22.410 --> 01:25:23.640
E vamos fazer mais um.

01:25:23.640 --> 01:25:27.210
E basta dizer que isso está ficando entediante e vulnerável

01:25:27.210 --> 01:25:29.520
a erros rapidamente.

01:25:29.520 --> 01:25:31.710
Isso certamente não pode ser a maneira de fazer isso.

01:25:31.710 --> 01:25:35.280
E, de fato, o SQL nos permitirá fazer isso com um pouco mais de eficiência.

01:25:35.280 --> 01:25:36.790
Vamos fazer isso.

01:25:36.790 --> 01:25:39.210
Em vez de obter esta tabela temporariamente

01:25:39.210 --> 01:25:42.640
com todos esses IDs de programa e todos esses gêneros, vamos refinar a consulta.

01:25:42.640 --> 01:25:49.920
Então, vamos apenas selecionar o ID do programa na tabela de gêneros onde o gênero é igual a

01:25:49.920 --> 01:25:51.810
aspas abre aspas "comédia".

01:25:51.810 --> 01:25:56.670
Agora tenho uma grande lista de IDs de programas, todos cômicos.

01:25:56.670 --> 01:25:57.205
Quantos?

01:25:57.205 --> 01:25:58.830
Bem, posso combinar ideias anteriores.

01:25:58.830 --> 01:26:03.582
Posso contar todos os IDs de programas ou estrelas se quiser fazer isso também.

01:26:03.582 --> 01:26:05.040
Mas posso contar todos aqueles IDs de programas.

01:26:05.040 --> 01:26:09.880
48.706 comédias no banco de dados do IMDb para programas de TV.

01:26:09.880 --> 01:26:11.140
Então parece muito.

01:26:11.140 --> 01:26:14.010
Mas como posso agora usar essas informações e voltar

01:26:14.010 --> 01:26:18.100
os títulos de comédias no banco de dados sem fazer isso manualmente?

01:26:18.100 --> 01:26:19.720
Bem, vamos fazer isso.

01:26:19.720 --> 01:26:21.270
Eu tenho um momento atrás esta consulta.

01:26:21.270 --> 01:26:25.710
Selecione o ID do programa de gêneros onde o gênero atual

01:26:25.710 --> 01:26:29.295
é, entre aspas, "comédia".

01:26:29.295 --> 01:26:31.920
E se eu meio que aninhar essas consultas, como na escola primária

01:26:31.920 --> 01:26:33.030
matemática entre parênteses?

01:26:33.030 --> 01:26:35.940
E se eu combinar tudo isso entre parênteses?

01:26:35.940 --> 01:26:38.040
E agora deixe-me selecionar o que eu realmente quero.

01:26:38.040 --> 01:26:43.950
Deixe-me ir em frente e selecionar que tal o título de todos

01:26:43.950 --> 01:26:52.420
mostra onde está a ideia do programa nesta lista de IDs de programa.

01:26:52.420 --> 01:26:59.440
Então, se você concorda que a tabela shows tem uma coluna de ID, que de outra forma é

01:26:59.440 --> 01:27:02.170
conhecido como sua chave primária, o ID único que o identifica, apenas

01:27:02.170 --> 01:27:06.490
como nossos IDs de Harvard, nossos IDs de Yale, e você concorda que por um momento atrás

01:27:06.490 --> 01:27:09.580
esta consulta mais curta me dará de volta apenas o show

01:27:09.580 --> 01:27:13.840
IDs de todas as comédias no banco de dados,

01:27:13.840 --> 01:27:17.710
você pode realmente combinar ou aninhar essas consultas.

01:27:17.710 --> 01:27:19.843
Vai respeitar a ordem SQLite de operações

01:27:19.843 --> 01:27:21.760
com parênteses, assim como a matemática do ensino fundamental.

01:27:21.760 --> 01:27:24.070
Portanto, a coisa entre parênteses será executada primeiro.

01:27:24.070 --> 01:27:27.340
Isso retorna uma lista de IDs, como 48.000 IDs.

01:27:27.340 --> 01:27:30.160
E então esta consulta, a consulta externa, vai

01:27:30.160 --> 01:27:33.790
para obter o título de todos os shows onde o ID do show

01:27:33.790 --> 01:27:36.280
está nessa grande lista de 48.000.

01:27:36.280 --> 01:27:39.233
Então, se eu agora executá-los juntos, acho

01:27:39.233 --> 01:27:42.400
a lista ainda vai ser um pouco longa, mas deixe-me executá-la juntos.

01:27:42.400 --> 01:27:45.880
Agora vejo esta longa lista de resultados.

01:27:45.880 --> 01:27:46.900
Um pouco esmagador.

01:27:46.900 --> 01:27:50.650
Vamos em frente e talvez limitar a apenas 10

01:27:50.650 --> 01:27:52.460
como antes para fins de discussão.

01:27:52.460 --> 01:27:56.110
E agora vejo 10 comédias ordenadas arbitrariamente

01:27:56.110 --> 01:27:58.330
no entanto, eles estão no banco de dados que acontecem

01:27:58.330 --> 01:28:01.420
de fato ter a comédia como seu gênero.

01:28:01.420 --> 01:28:04.310
Se eu quiser fazer isso um pouco mais limpo, eu poderia fazer isso.

01:28:04.310 --> 01:28:05.260
Vamos ver.

01:28:05.260 --> 01:28:09.640
Por que não ordeno por ordem crescente de título, que é alfabética,

01:28:09.640 --> 01:28:12.190
ou o padrão também é ascendente.

01:28:12.190 --> 01:28:13.240
Limite 10.

01:28:13.240 --> 01:28:18.250
Agora vejo o top 10, quero dizer, coisas com nomes estranhos com símbolos de hash

01:28:18.250 --> 01:28:22.360
presumivelmente para obter seus títulos até o início ou talvez sejam hashtags.

01:28:22.360 --> 01:28:27.550
Aqui agora temos em ordem alfabética os 10 primeiros shows que são comédias.

01:28:27.550 --> 01:28:31.705
Alguma dúvida sobre esse tipo de consulta?

01:28:31.705 --> 01:28:33.580
É meio que muito, mas ao mesmo tempo é

01:28:33.580 --> 01:28:37.540
assim como compor as ideias menores de antes em um pouco mais

01:28:37.540 --> 01:28:39.820
consultas úteis.

01:28:39.820 --> 01:28:40.360
Sim.

01:28:40.360 --> 01:28:43.348
AUDIÊNCIA: [INAUDÍVEL]

01:28:46.343 --> 01:28:48.760
DAVID MALAN: As chaves estrangeiras precisam definir o relacionamento?

01:28:48.760 --> 01:28:51.850
Quando você cria a tabela, o programador ou o banco de dados

01:28:51.850 --> 01:28:54.280
administrador criaria esse relacionamento

01:28:54.280 --> 01:28:57.700
usando essas palavras-chave chave primária e chave estrangeira que

01:28:57.700 --> 01:29:01.330
ensina ao banco de dados o que está relacionado com o que está na imagem.

01:29:01.330 --> 01:29:02.530
Então você faz isso uma vez.

01:29:02.530 --> 01:29:07.390
E agora, sendo o tipo de programador familiarizado com o banco de dados,

01:29:07.390 --> 01:29:13.750
Estou apenas usando essas chaves estrangeiras de maneira consistente com seu design.

01:29:13.750 --> 01:29:15.680
E é aqui que é útil em algum momento,

01:29:15.680 --> 01:29:18.940
mesmo que ninguém lhe dê uma foto, para ter certeza de que você entendeu o banco de dados,

01:29:18.940 --> 01:29:22.180
porque isso vai informar literalmente o que você digita no SQL

01:29:22.180 --> 01:29:23.740
para obter os dados que lhe interessam.

01:29:23.740 --> 01:29:26.060
Bem, vamos fazer algo um pouco mais preciso.

01:29:26.060 --> 01:29:27.860
Que tal uma pergunta muito razoável.

01:29:27.860 --> 01:29:30.970
E, honestamente, é exatamente para isso que imdb.com e o aplicativo ou.

01:29:30.970 --> 01:29:34.600
E se você quiser encontrar todos os programas em que Steve Carell está?

01:29:34.600 --> 01:29:36.160
Tipo de consulta razoável.

01:29:36.160 --> 01:29:40.150
Literalmente algo que alguém pode digitar no Google ou mais especificamente no IMDb.

01:29:40.150 --> 01:29:42.130
Não é realmente óbvio à primeira vista como

01:29:42.130 --> 01:29:44.795
para fazer isso, porém, porque do meu banco de dados,

01:29:44.795 --> 01:29:47.170
se estas são minhas seis mesas, bem, posso facilmente obter

01:29:47.170 --> 01:29:48.460
Steve Carell daqui.

01:29:48.460 --> 01:29:51.105
Mas eu realmente só posso obter o número de identificação dele, seja lá o que for,

01:29:51.105 --> 01:29:53.230
seu nome, que já sei, e seu ano de nascimento.

01:29:53.230 --> 01:29:56.200
OK, interessante, mas não tem nada a ver com os programas em que ele está.

01:29:56.200 --> 01:30:00.850
Posso ver shows aqui, mas não há menção a Steve Carell

01:30:00.850 --> 01:30:02.710
porque não há identificação de pessoa aqui.

01:30:02.710 --> 01:30:04.660
Onde esse relacionamento é implementado?

01:30:04.660 --> 01:30:06.590
Bem, está implementado aqui.

01:30:06.590 --> 01:30:07.910
Então, como fazemos isso?

01:30:07.910 --> 01:30:10.210
Bem, aqui está o exemplo perfeito de uma lição

01:30:10.210 --> 01:30:13.450
estamos tentando enfatizar há semanas esses passos de bebê.

01:30:13.450 --> 01:30:17.750
Divida problemas maiores em problemas menores e vamos fazer algo assim.

01:30:17.750 --> 01:30:20.740
Vamos pegar tudo o que sei sobre Steve Carell no banco de dados.

01:30:20.740 --> 01:30:24.190
Vamos selecionar a estrela de pessoas onde o nome da pessoa

01:30:24.190 --> 01:30:26.890
é, entre aspas, "Steve Carell".

01:30:26.890 --> 01:30:28.630
Só quero ver que dados temos.

01:30:28.630 --> 01:30:30.640
E aqui está o que temos.

01:30:30.640 --> 01:30:33.130
Há apenas um Steve Carell nascido em 1962

01:30:33.130 --> 01:30:37.150
e seu ID exclusivo é 136797 de acordo com o IMDb.

01:30:37.150 --> 01:30:40.930
Este não é um identificador de ator global, por si só.

01:30:40.930 --> 01:30:45.010
Tudo bem, bem, como faço para obter agora todos os programas em que Steve Carell está?

01:30:45.010 --> 01:30:46.130
Bem, eu poderia fazer isso.

01:30:46.130 --> 01:30:51.190
Selecione estrela de estrelas, para não confundir os dois.

01:30:51.190 --> 01:30:53.500
Um é o símbolo, o outro é o nome da mesa.

01:30:53.500 --> 01:30:58.690
Onde o ID da pessoa é igual a 136797.

01:30:58.690 --> 01:31:03.070
Então eu acho que isso agora vai me dar tudo da tabela de estrelas

01:31:03.070 --> 01:31:04.943
que se relaciona com Steve Carell.

01:31:04.943 --> 01:31:07.360
E você verá que o ID da pessoa é o mesmo porque estou literalmente

01:31:07.360 --> 01:31:08.693
procurando apenas por Steve Carell.

01:31:08.693 --> 01:31:12.200
Mas há cerca de 20 shows em que ele esteve.

01:31:12.200 --> 01:31:14.450
Tudo bem, bem, aqui é onde as coisas ficariam entediantes.

01:31:14.450 --> 01:31:15.340
Quais são esses shows?

01:31:15.340 --> 01:31:21.460
Bem, eu poderia selecionar o título dos programas onde o ID do programa é igual.

01:31:21.460 --> 01:31:25.670
E aqui está sempre que você copia e cola, provavelmente está fazendo algo errado.

01:31:25.670 --> 01:31:27.890
OK, ele estava no The Dana Carvey Show.

01:31:27.890 --> 01:31:28.715
Familiarizado com isso.

01:31:28.715 --> 01:31:29.590
Vamos fazer outro.

01:31:29.590 --> 01:31:31.460
Vamos copiar e colar isso.

01:31:31.460 --> 01:31:34.090
Onde ID é igual a isso.

01:31:34.090 --> 01:31:34.890
Acima do topo.

01:31:34.890 --> 01:31:35.390
Outro.

01:31:35.390 --> 01:31:37.000
E se continuarmos cavando, provavelmente encontraremos o The Office.

01:31:37.000 --> 01:31:40.240
Mas meu Deus, vai demorar uma eternidade para fazer 20 consultas manualmente.

01:31:40.240 --> 01:31:41.252
Não é muito dinâmico.

01:31:41.252 --> 01:31:43.960
Mas e se aninharmos essas consultas um pouco mais dinamicamente?

01:31:43.960 --> 01:31:45.830
Então deixe-me começar do começo novamente.

01:31:45.830 --> 01:31:48.890
E se formos em frente e selecionarmos tudo

01:31:48.890 --> 01:31:56.410
sabemos sobre pessoas cujo nome é igual a Steve Carell.

01:31:56.410 --> 01:31:58.220
Isso nos deu anteriormente esses dados.

01:31:58.220 --> 01:31:59.470
Não preciso de todos esses dados.

01:31:59.470 --> 01:32:00.100
Eu sei o nome dele.

01:32:00.100 --> 01:32:01.517
Eu não me importo com o ano de nascimento dele.

01:32:01.517 --> 01:32:05.140
Então, vamos mudar isso para apenas me dar a identidade de Steve Carell.

01:32:05.140 --> 01:32:08.390
E isso me devolve agora esse conjunto de dados temporário menor.

01:32:08.390 --> 01:32:08.890
Tudo bem.

01:32:08.890 --> 01:32:12.195
Agora posso usar isso dentro de outra consulta?

01:32:12.195 --> 01:32:14.320
Bem, deixe-me encerrar tudo com parênteses.

01:32:14.320 --> 01:32:18.850
E agora deixe-me dizer selecionar estrela da tabela de estrelas

01:32:18.850 --> 01:32:22.477
onde o ID da pessoa é igual a isso.

01:32:22.477 --> 01:32:24.310
Portanto, não estou usando deliberadamente porque estou

01:32:24.310 --> 01:32:26.780
supondo que haja realmente apenas um Steve Carell no mundo.

01:32:26.780 --> 01:32:28.480
Portanto, não vou receber uma lista de Steve Carells.

01:32:28.480 --> 01:32:30.640
Estou recebendo de volta o único neste caso.

01:32:30.640 --> 01:32:31.810
Então igual está bom.

01:32:31.810 --> 01:32:33.310
In é quando você tem vários.

01:32:33.310 --> 01:32:34.840
Igual é quando você tem um.

01:32:34.840 --> 01:32:36.375
Deixe-me ir em frente e apertar Enter agora.

01:32:36.375 --> 01:32:37.750
OK, isso é mais dados do que eu preciso.

01:32:37.750 --> 01:32:40.430
Não preciso de 20 cópias da identidade pessoal de Steve Carell.

01:32:40.430 --> 01:32:41.380
Então deixe-me bater.

01:32:41.380 --> 01:32:46.420
Deixe-me voltar e obter a identificação do show de Steve Carell.

01:32:46.420 --> 01:32:52.070
E agora eu tenho uma lista de apenas 20 ou mais IDs de programas em que ele esteve.

01:32:52.070 --> 01:32:52.570
Tudo bem.

01:32:52.570 --> 01:32:53.597
Como posso usar isso agora?

01:32:53.597 --> 01:32:54.430
Bem, deixe-me bater um papo.

01:32:54.430 --> 01:32:57.040
Deixe-me colocar tudo entre parênteses.

01:32:57.040 --> 01:32:58.960
E agora deixe-me selecionar o que eu realmente quero.

01:32:58.960 --> 01:33:03.340
Selecione o título de mostra onde.

01:33:03.340 --> 01:33:05.020
E aqui está o floreio final.

01:33:05.020 --> 01:33:11.350
A tabela mostra tem um ID, tem um título, tem um ano e tem um episódio.

01:33:11.350 --> 01:33:21.610
E o que eu realmente quero, porém, é verificar quais programas têm ID, o que é?

01:33:21.610 --> 01:33:24.510
Alguém quer terminar o pensamento?

01:33:24.510 --> 01:33:25.860
Eu só quero-- sim.

01:33:25.860 --> 01:33:28.435
AUDIÊNCIA: [INAUDÍVEL]

01:33:28.435 --> 01:33:29.310
DAVID MALAN: Exatamente.

01:33:29.310 --> 01:33:30.570
ID neste.

01:33:30.570 --> 01:33:31.690
E isso está ficando feio.

01:33:31.690 --> 01:33:33.810
E quando você realmente escreve suas consultas em um arquivo de texto,

01:33:33.810 --> 01:33:35.730
você pode formatá-los bem e indentá-los.

01:33:35.730 --> 01:33:36.772
Minha fonte está ficando--

01:33:36.772 --> 01:33:38.938
Eu não quero torná-lo muito pequeno para caber tudo.

01:33:38.938 --> 01:33:40.230
Mas agora temos três consultas.

01:33:40.230 --> 01:33:43.380
Um está entre parênteses duplamente aninhados, então há o do meio,

01:33:43.380 --> 01:33:44.550
então há o externo.

01:33:44.550 --> 01:33:47.310
Então, esta última consulta vai me dar o título dos shows

01:33:47.310 --> 01:33:50.460
onde o ID do programa está nesta grande lista de 20

01:33:50.460 --> 01:33:52.410
ou então mostrar IDs em que Steve Carell está.

01:33:52.410 --> 01:33:54.812
E eu sabia disso porque procurei o nome dele aqui.

01:33:54.812 --> 01:33:57.270
E observe o que eu não fiz desta vez é que não fiz manualmente

01:33:57.270 --> 01:33:58.620
codificar seu número de identificação.

01:33:58.620 --> 01:33:59.430
Não há necessidade.

01:33:59.430 --> 01:34:02.508
Essa seria uma maneira ruim de implementar um site se você estiver

01:34:02.508 --> 01:34:04.050
usando um banco de dados sob o capô.

01:34:04.050 --> 01:34:07.470
Você quer que o IMDb de verdade procure o que quer que seja

01:34:07.470 --> 01:34:11.010
o humano digitou e ninguém saberá o ID pessoal de Steve Carell

01:34:11.010 --> 01:34:12.070
ou qualquer outra coisa.

01:34:12.070 --> 01:34:14.580
Então, aqui fizemos tudo isso dinamicamente.

01:34:14.580 --> 01:34:18.690
E agora, se eu apertar Enter, acho que recebo todos os shows dele.

01:34:18.690 --> 01:34:21.840
Vamos ordená-lo por título apenas para torná-lo mais organizado.

01:34:21.840 --> 01:34:24.810
E você provavelmente verá pelo menos um ou mais shows disso.

01:34:24.810 --> 01:34:29.520
E provavelmente o mais popular é, ponto ponto ponto, The Office.

01:34:29.520 --> 01:34:32.280
Este é literalmente o tipo de consulta que é

01:34:32.280 --> 01:34:37.200
sendo executado sob o capô quando você acessa sites ou aplicativos como o IMDb.

01:34:37.200 --> 01:34:42.030
Sua consulta textual provavelmente está sendo conectada a uma consulta SQL mais longa

01:34:42.030 --> 01:34:44.850
assim onde algum programador do IMDb provavelmente

01:34:44.850 --> 01:34:48.420
escrevi toda essa consulta com antecedência semanas, meses, anos atrás

01:34:48.420 --> 01:34:52.470
e eles estão de alguma forma conectando o valor que você, o humano

01:34:52.470 --> 01:34:55.550
digitado na caixa de pesquisa ou algo semelhante.

01:34:55.550 --> 01:35:03.010
Dúvidas agora sobre como encontrar este dado ou qualquer outro?

01:35:03.010 --> 01:35:03.890
Não?

01:35:03.890 --> 01:35:04.390
OK.

01:35:04.390 --> 01:35:06.980
Então, onde mais poderíamos ir com isso?

01:35:06.980 --> 01:35:12.700
Bem, vamos considerar de que outra forma poderíamos combinar dados.

01:35:12.700 --> 01:35:16.060
Suponha que a próxima pergunta, na verdade, talvez apropriadamente

01:35:16.060 --> 01:35:19.780
estaria focando não apenas em pessoas e shows e essas estrelas,

01:35:19.780 --> 01:35:23.680
mas como coletamos mais informações sobre os programas em si,

01:35:23.680 --> 01:35:25.430
como os gêneros, as classificações ou similares.

01:35:25.430 --> 01:35:28.030
De fato, vamos nos concentrar apenas nessas duas tabelas aqui.

01:35:28.030 --> 01:35:31.640
Lembre-se de que todo programa tem um ID, um título, um ano e episódios.

01:35:31.640 --> 01:35:34.660
Mas também pode ter um ou mais relacionamentos com linhas

01:35:34.660 --> 01:35:36.280
e esta outra tabela chamada gêneros.

01:35:36.280 --> 01:35:39.250
E isso é para que um show possa ser uma comédia, pode ser um drama,

01:35:39.250 --> 01:35:40.960
pode ser uma série de outras coisas.

01:35:40.960 --> 01:35:42.400
Uma linha por.

01:35:42.400 --> 01:35:45.040
Assim, você veria o mesmo ID de programa repetidas vezes

01:35:45.040 --> 01:35:48.760
e novamente com um gênero diferente escrito em inglês

01:35:48.760 --> 01:35:51.070
como comédia, drama ou afins.

01:35:51.070 --> 01:35:53.890
Bem, como faço para reconstituir esses dados?

01:35:53.890 --> 01:35:56.710
Bem, acontece que existem algumas maneiras diferentes de fazer isso.

01:35:56.710 --> 01:36:00.610
E deixe-me propor que introduzamos esta palavra-chave aqui, junte-se.

01:36:00.610 --> 01:36:05.525
E esta é realmente a palavra-chave mais poderosa do próprio SQL.

01:36:05.525 --> 01:36:06.650
Não precisa ser usado.

01:36:06.650 --> 01:36:09.310
Vimos com consultas aninhadas que você ainda pode

01:36:09.310 --> 01:36:13.490
selecionar dados em várias tabelas, mas aqui está outra maneira.

01:36:13.490 --> 01:36:14.660
Então deixe-me fazer isso.

01:36:14.660 --> 01:36:17.710
Deixe-me voltar ao meu banco de dados SQLite.

01:36:17.710 --> 01:36:23.680
E deixe-me selecionar de uma vez exatamente os dados que desejo.

01:36:23.680 --> 01:36:26.980
Selecione a estrela dos shows.

01:36:26.980 --> 01:36:30.500
E vamos limitar isso inicialmente a 10 para ver como fica.

01:36:30.500 --> 01:36:31.000
Tudo bem.

01:36:31.000 --> 01:36:32.250
Esses são, novamente, os dados do programa.

01:36:32.250 --> 01:36:34.690
Selecione estrela de gêneros.

01:36:34.690 --> 01:36:37.760
Vamos limitar isso a 10 também, apenas para envolver nossas mentes em torno disso.

01:36:37.760 --> 01:36:39.730
E agora isso não é tão útil.

01:36:39.730 --> 01:36:43.510
No entanto, os dados na coluna mais à esquerda aqui

01:36:43.510 --> 01:36:45.490
é a chave primária na tabela shows.

01:36:45.490 --> 01:36:46.870
Estes são apenas IDs exclusivos.

01:36:46.870 --> 01:36:51.530
Os dados aqui na tabela de gêneros, recall, show ID são a chave estrangeira.

01:36:51.530 --> 01:36:54.310
Portanto, são os mesmos números, mas apenas copiados para outra tabela

01:36:54.310 --> 01:36:56.650
para que possamos ter esse relacionamento entre eles.

01:36:56.650 --> 01:37:00.070
Como faço para alinhar esses números com esses números

01:37:00.070 --> 01:37:06.430
para recuperar uma tabela mais ampla que tenha título e ano e episódios e gênero e,

01:37:06.430 --> 01:37:08.950
caramba, avaliações e tudo isso também, se quisermos?

01:37:08.950 --> 01:37:11.230
Bem, você pode juntar essas tabelas apenas dizendo

01:37:11.230 --> 01:37:12.890
o banco de dados o que juntar em quê.

01:37:12.890 --> 01:37:13.940
Então deixe-me fazer isso.

01:37:13.940 --> 01:37:17.110
Selecione a estrela dos shows.

01:37:17.110 --> 01:37:21.760
Junte-se a essa tabela na tabela de gêneros.

01:37:21.760 --> 01:37:24.160
Bem, como você deseja juntar essas duas tabelas?

01:37:24.160 --> 01:37:26.860
E, novamente, as duas mesas da foto ficaram assim.

01:37:26.860 --> 01:37:30.400
Como você diz ao SQL programaticamente para colocar um deles

01:37:30.400 --> 01:37:32.420
bem ao lado do outro, alinhe todos os ID

01:37:32.420 --> 01:37:34.820
para que você obtenha apenas um conjunto de dados maior?

01:37:34.820 --> 01:37:39.160
Bem, podemos realmente usar esta sintaxe chamada join.

01:37:39.160 --> 01:37:41.140
Então, de volta ao VS Code aqui.

01:37:41.140 --> 01:37:44.380
E deixe-me juntar essas duas tabelas.

01:37:44.380 --> 01:37:45.970
Desculpe, erro de digitação aqui.

01:37:45.970 --> 01:37:51.940
Junte-se a gêneros na coluna de ID da tabela de shows, também conhecido como

01:37:51.940 --> 01:37:58.240
sua chave primária, igualando a coluna show ID da tabela de gêneros, também conhecido como

01:37:58.240 --> 01:37:59.210
a chave estrangeira.

01:37:59.210 --> 01:38:01.090
Então, em outras palavras, parece um pouco enigmático,

01:38:01.090 --> 01:38:05.080
mas estou apenas dizendo ao SQL como alinhar essas duas tabelas e qual coluna

01:38:05.080 --> 01:38:08.230
para combinar com o outro para que os números se alinhem

01:38:08.230 --> 01:38:10.610
e eu obtenho essencialmente uma mesa mais larga.

01:38:10.610 --> 01:38:14.930
Deixe-me ir em frente e apertar ponto e vírgula e Enter.

01:38:14.930 --> 01:38:17.330
E isso agora vai me dar muitos dados.

01:38:17.330 --> 01:38:18.600
Talvez tenhamos que interrompê-lo.

01:38:18.600 --> 01:38:22.650
Mas observe, mesmo de relance, estamos obtendo o ID, o título, o ano,

01:38:22.650 --> 01:38:25.130
o número de episódios, o ID novamente redundante,

01:38:25.130 --> 01:38:27.140
mas isso é de se esperar se eu me juntar a eles,

01:38:27.140 --> 01:38:29.360
e o gênero à direita.

01:38:29.360 --> 01:38:31.740
Deixe-me apertar o controle C para interromper.

01:38:31.740 --> 01:38:33.890
Deixe-me apenas limitar isso ao The Office.

01:38:33.890 --> 01:38:36.500
Então, onde título é igual a aspas, sem aspas "The Office"

01:38:36.500 --> 01:38:39.680
para que possamos nos concentrar em apenas um dado de amostra.

01:38:39.680 --> 01:38:43.490
E aqui, fato engraçado, houve mais de um Escritório.

01:38:43.490 --> 01:38:46.100
O que todos vocês provavelmente gostam é este

01:38:46.100 --> 01:38:49.250
que começou em 2005 com 188 episódios.

01:38:49.250 --> 01:38:53.060
Seu ID na tabela shows é 386676.

01:38:53.060 --> 01:38:54.710
Isso está confirmado aqui também.

01:38:54.710 --> 01:38:56.850
Novamente, acabamos de juntar as duas tabelas.

01:38:56.850 --> 01:38:57.350
Como?

01:38:57.350 --> 01:38:58.730
Alinhando esses campos.

01:38:58.730 --> 01:39:01.490
Mas agora que podemos ver que quase todos os The Offices

01:39:01.490 --> 01:39:04.700
produzidos ao longo das décadas são comédias, exceto esta.

01:39:04.700 --> 01:39:07.460
Houve uma versão do The Office produzida em 2001

01:39:07.460 --> 01:39:10.160
isso foi considerado mais um drama.

01:39:10.160 --> 01:39:11.940
Não tenho certeza se está relacionado ao outro.

01:39:11.940 --> 01:39:13.640
Como podemos vincular outros dados?

01:39:13.640 --> 01:39:16.920
Bem, vamos em frente e vincular as classificações também ou em vez disso.

01:39:16.920 --> 01:39:21.290
Então, em vez de juntar isso com gêneros, deixe-me ir em frente e voltar aqui

01:39:21.290 --> 01:39:28.550
e junte-se a shows em avaliações em shows.id é igual a ratings.show_ID.

01:39:28.550 --> 01:39:32.630
E vamos limitar ao The Office também para fins de discussão, onde o título é igual a

01:39:32.630 --> 01:39:35.820
aspas sem aspas "The Office" ponto e vírgula.

01:39:35.820 --> 01:39:39.650
E agora você pode ver que entre os vários escritórios,

01:39:39.650 --> 01:39:43.100
parece aquele que a maioria de nós provavelmente conhece e ama

01:39:43.100 --> 01:39:49.070
é o mais bem avaliado também com 9,0 com cerca de 585.000 pessoas tendo

01:39:49.070 --> 01:39:52.280
votos, enquanto esses outros programas parecem ter sido menos populares.

01:39:52.280 --> 01:39:56.370
E talvez seja por isso que você vê menos episódios para eles também.

01:39:56.370 --> 01:39:58.680
Embora tenhamos colocado os dados em vários lugares,

01:39:58.680 --> 01:40:02.670
você ainda pode reconstituí-lo alinhando as coisas dessa maneira

01:40:02.670 --> 01:40:04.970
e juntando as mesas.

01:40:04.970 --> 01:40:09.140
Perguntas agora sobre isso?

01:40:09.140 --> 01:40:16.540
Este é o cerne do que o SQL faz e o que os bancos de dados relacionais fazem por você.

01:40:16.540 --> 01:40:18.100
Questões?

01:40:18.100 --> 01:40:18.610
Tudo bem.

01:40:18.610 --> 01:40:20.470
Algumas características finais.

01:40:20.470 --> 01:40:22.660
Não há tanto assim...

01:40:22.660 --> 01:40:24.320
SQL requer prática como qualquer outra coisa.

01:40:24.320 --> 01:40:26.237
Mas em termos de sintaxe e recursos, vamos

01:40:26.237 --> 01:40:30.610
apenas apresentá-lo a alguns recursos finais aqui e problemas que surgem

01:40:30.610 --> 01:40:32.210
e como podemos resolvê-los.

01:40:32.210 --> 01:40:34.640
Vamos fazer isso também.

01:40:34.640 --> 01:40:36.980
Então, deixe-me voltar ao VS Code aqui.

01:40:36.980 --> 01:40:40.900
E vamos descobrir as informações de Steve Carell novamente.

01:40:40.900 --> 01:40:43.180
A última vez que fizemos isso com esta consulta aninhada

01:40:43.180 --> 01:40:47.503
obtendo seu ID e, em seguida, os IDs do programa e, em seguida, os títulos desses IDs do programa.

01:40:47.503 --> 01:40:49.420
Com o join, você pode fazer isso de maneira um pouco diferente.

01:40:49.420 --> 01:40:50.950
E qualquer uma dessas maneiras está bem.

01:40:50.950 --> 01:40:53.740
Um pode se tornar mais fácil mentalmente do que outro.

01:40:53.740 --> 01:40:57.040
Vamos em frente e selecione os títulos de quê.

01:40:57.040 --> 01:41:02.095
Vamos selecionar o título da tabela de pessoas.

01:41:02.095 --> 01:41:03.220
E vou apertar Enter.

01:41:03.220 --> 01:41:05.260
E quando você estiver usando o SQLite3 interativamente,

01:41:05.260 --> 01:41:09.400
se você se deparar com um prompt que diz ponto ponto ponto colchete angular,

01:41:09.400 --> 01:41:12.067
significa que você está continuando seu pensamento na próxima linha.

01:41:12.067 --> 01:41:13.900
Se você não pretendia isso, às vezes você pode

01:41:13.900 --> 01:41:16.510
pressione ponto e vírgula para terminar o pensamento e pressione

01:41:16.510 --> 01:41:18.460
Enter mesmo que isso gere um erro.

01:41:18.460 --> 01:41:21.430
Mas esta é uma maneira de formatar minhas consultas agora um pouco mais bem.

01:41:21.430 --> 01:41:24.597
Vou apenas adicionar um espaço em branco para facilitar a leitura.

01:41:24.597 --> 01:41:25.720
O que eu quero selecionar?

01:41:25.720 --> 01:41:28.000
Bem, eu quero selecionar o título dos shows

01:41:28.000 --> 01:41:35.320
da tabela de pessoas junto com a tabela de estrelas no ID da tabela de pessoas

01:41:35.320 --> 01:41:40.520
coluna igual à coluna de ID da pessoa da tabela de estrelas.

01:41:40.520 --> 01:41:44.230
Então, em outras palavras, se você pensar no que são as pessoas e no que são as estrelas,

01:41:44.230 --> 01:41:48.250
um tem um ID, outro tem um ID de pessoa, só agora estou conectando essas duas tabelas.

01:41:48.250 --> 01:41:49.450
Estou me juntando a esses dois.

01:41:49.450 --> 01:41:53.350
Mas eu quero fazer isso também com outra mesa.

01:41:53.350 --> 01:41:54.938
Deixe-me também participar.

01:41:54.938 --> 01:41:56.980
Então agora eu só tenho duas mãos, mas agora estou colocando

01:41:56.980 --> 01:41:59.320
uma terceira mesa unida aqui.

01:41:59.320 --> 01:42:05.960
Junte-se a shows em stars.show_id é igual a shows.id.

01:42:05.960 --> 01:42:08.500
Isso agora está vinculando três tabelas.

01:42:08.500 --> 01:42:12.100
Mas eu só me importo com isso para uma pessoa, então onde o nome da pessoa

01:42:12.100 --> 01:42:14.650
é igual a aspas sem aspas "Steve Carell."

01:42:14.650 --> 01:42:18.850
Mais enigmático, com certeza, mas o que estamos fazendo com essa consulta

01:42:18.850 --> 01:42:21.370
está apenas pegando todas as três tabelas que nos interessam

01:42:21.370 --> 01:42:23.440
e estamos juntando todos eles de uma vez

01:42:23.440 --> 01:42:27.250
usando esta nova sintaxe de junção literalmente dizendo ao banco de dados o que

01:42:27.250 --> 01:42:29.020
colunas para alinhar com o quê.

01:42:29.020 --> 01:42:32.350
E então filtramos bem no final, como antes, para voltar,

01:42:32.350 --> 01:42:35.650
se eu apertar Enter, a resposta que queremos, que neste caso

01:42:35.650 --> 01:42:40.030
está um pouco mais lento no momento, mas a mesma lista de 20 ou mais

01:42:40.030 --> 01:42:41.350
mostra que ele entrou.

01:42:41.350 --> 01:42:42.920
Há uma outra maneira de fazer isso.

01:42:42.920 --> 01:42:45.250
E novamente, tudo isso está nos slides online.

01:42:45.250 --> 01:42:47.890
Assim você pode repeti-los sem ter que anotar tudo e nós os colocamos

01:42:47.890 --> 01:42:48.820
nas notas também.

01:42:48.820 --> 01:42:50.450
Mas há outra maneira de fazer isso.

01:42:50.450 --> 01:42:52.780
Eu também poderia usar uma junção implícita.

01:42:52.780 --> 01:42:55.030
Então essa foi uma junção explícita porque eu literalmente digitei

01:42:55.030 --> 01:42:57.220
a palavra junte-se várias vezes nisso.

01:42:57.220 --> 01:43:00.880
Mas deixe-me ir em frente e selecionar o título dessas três tabelas.

01:43:00.880 --> 01:43:02.628
Pessoas, estrelas e shows.

01:43:02.628 --> 01:43:04.420
E isso pode ser melhor porque se você

01:43:04.420 --> 01:43:06.337
saiba de quais tabelas você deseja selecionar dados,

01:43:06.337 --> 01:43:08.980
apenas enumere-os separados por vírgulas, o que você pode preferir

01:43:08.980 --> 01:43:18.970
em sua mente, onde o ID da pessoa é igual ao ID da pessoa das estrelas e as estrelas

01:43:18.970 --> 01:43:25.450
show ID é igual ao show ID e o nome da pessoa é igual a Steve Carell.

01:43:25.450 --> 01:43:26.788
Portanto, esta é uma junção implícita.

01:43:26.788 --> 01:43:29.830
E, honestamente, também consulto constantemente minhas anotações para algumas dessas coisas.

01:43:29.830 --> 01:43:31.720
Não é o tipo de coisa que vai vir assim para você

01:43:31.720 --> 01:43:32.740
depois de apenas um dia.

01:43:32.740 --> 01:43:35.560
Mas é apenas uma maneira diferente de expressar a mesma coisa.

01:43:35.560 --> 01:43:37.720
Eu quero selecionar dados de três tabelas diferentes.

01:43:37.720 --> 01:43:43.120
E ei SQL, aqui está como eu quero que você alinhe essas tabelas para que eu possa

01:43:43.120 --> 01:43:45.640
obtenha dados semelhantes para Steve Carell.

01:43:45.640 --> 01:43:49.450
E isso agora alcançará os mesmos resultados em última instância.

01:43:49.450 --> 01:43:50.260
Deixe-me apertar Enter.

01:43:54.040 --> 01:43:54.920
E lá vamos nós.

01:43:54.920 --> 01:43:55.750
Então um pouco mais lento.

01:43:55.750 --> 01:43:57.850
E o desempenho pode variar com base no computador,

01:43:57.850 --> 01:44:01.270
com base na implementação do SQL, mas acho que ainda tenho as mesmas respostas.

01:44:01.270 --> 01:44:04.790
Agora suponha que, como sempre faço, e tive que pesquisar novamente da última vez,

01:44:04.790 --> 01:44:08.350
suponha que você se esqueça de como se escreve o nome de Steve Carell.

01:44:08.350 --> 01:44:10.240
São dois R's, dois L's ou algo parecido?

01:44:10.240 --> 01:44:12.903
Bem, eu também poderia fazer algo assim.

01:44:12.903 --> 01:44:14.320
Bem, vamos manter isso simples.

01:44:14.320 --> 01:44:17.103
Selecione a estrela de pessoas onde o nome é igual.

01:44:17.103 --> 01:44:20.020
Eu tenho acertado deliberadamente para não me envergonhar.

01:44:20.020 --> 01:44:22.000
Esse é o Steve Carell que continuo perguntando.

01:44:22.000 --> 01:44:25.960
Se você esquecer, bem, você pode tentar pesquisar apenas por Steves,

01:44:25.960 --> 01:44:28.450
mas, curiosamente, há um monte de Steves.

01:44:28.450 --> 01:44:30.070
Não sabemos quando nasceram.

01:44:30.070 --> 01:44:35.360
Mas provavelmente não é o Steve Carell que queremos se não tivermos seu sobrenome.

01:44:35.360 --> 01:44:38.770
Então eu poderia alternativamente fazer, bem, é Steve e então começa com um C,

01:44:38.770 --> 01:44:39.460
Eu penso.

01:44:39.460 --> 01:44:42.700
Bem, acontece que há outro curinga que você pode usar no SQL.

01:44:42.700 --> 01:44:46.060
Usamos o asterisco para selecionar todas as colunas.

01:44:46.060 --> 01:44:50.800
Você pode usar um sinal de porcentagem entre aspas para dizer algo C.

01:44:50.800 --> 01:44:54.370
Portanto, há 0 ou mais caracteres após a letra C.

01:44:54.370 --> 01:44:58.630
E agora isso não funciona porque agora eu estaria literalmente procurando

01:44:58.630 --> 01:45:01.690
para Steve espaço C algo.

01:45:01.690 --> 01:45:04.910
Mas lembre-se de que mencionei anteriormente uma outra palavra-chave,

01:45:04.910 --> 01:45:06.868
que é para uma correspondência mais difusa, por assim dizer,

01:45:06.868 --> 01:45:09.160
onde não é exatamente o que você está procurando, mas é

01:45:09.160 --> 01:45:10.630
como o que você está procurando.

01:45:10.630 --> 01:45:14.350
Se você disser onde o nome dele é como Steve espaço C algo,

01:45:14.350 --> 01:45:17.060
agora vamos recuperar um monte de Steves.

01:45:17.060 --> 01:45:19.810
Mas acho que agora provavelmente poderia encontrar o que estou realmente procurando

01:45:19.810 --> 01:45:20.920
pois se eu não me lembro do nome dele.

01:45:20.920 --> 01:45:22.510
Você pode usar vários sinais de porcentagem.

01:45:22.510 --> 01:45:25.260
Se você esquecer qual é o primeiro nome dele, pode inverter a ordem.

01:45:25.260 --> 01:45:29.940
Mas isso também é um recurso SQL muito poderoso.

01:45:29.940 --> 01:45:32.670
Dúvidas sobre essas consultas aqui?

01:45:32.670 --> 01:45:33.708
Sim.

01:45:33.708 --> 01:45:35.448
AUDIÊNCIA: [INAUDÍVEL]

01:45:35.448 --> 01:45:36.240
DAVID MALAN: Desculpe?

01:45:36.240 --> 01:45:38.730
AUDIÊNCIA: [INAUDÍVEL]

01:45:38.730 --> 01:45:40.003
DAVID MALAN: E aí?

01:45:40.003 --> 01:45:40.990
AUDIÊNCIA: [INAUDÍVEL]

01:45:40.990 --> 01:45:42.400
DAVID MALAN: Ah sim, claro.

01:45:42.400 --> 01:45:44.500
Então, a consulta que usei aqui.

01:45:44.500 --> 01:45:49.810
Há muitos Steves cujo sobrenome começa com C. Ops, longe demais.

01:45:49.810 --> 01:45:52.760
A última query que executei foi essa aqui.

01:45:52.760 --> 01:45:57.110
Então, onde o nome é como entre aspas "Steve C%."

01:45:57.110 --> 01:45:59.950
Portanto, essa é apenas mais uma ferramenta para o seu kit de ferramentas aqui.

01:45:59.950 --> 01:46:02.830
Mas você talvez tenha notado que aqueles dois -

01:46:02.830 --> 01:46:05.380
antes dessa consulta, as junções que fiz eram meio lentas.

01:46:05.380 --> 01:46:07.480
E honestamente, esse banco de dados nem é tão grande assim.

01:46:07.480 --> 01:46:10.120
Como sim, tem dezenas de milhares de linhas.

01:46:10.120 --> 01:46:13.630
Mas no mundo real e na maioria dos aplicativos que você e eu usamos muito todos os dias

01:46:13.630 --> 01:46:17.080
ou sites, há milhões, até bilhões de linhas de dados.

01:46:17.080 --> 01:46:22.210
E se eu tivesse que esperar no meu computador aqui ou no meu espaço de código um segundo ou dois

01:46:22.210 --> 01:46:25.990
para obter os dados, isso não funcionará para milhões de usuários ou clientes

01:46:25.990 --> 01:46:26.680
certamente.

01:46:26.680 --> 01:46:29.020
Então, como podemos realmente melhorar as coisas?

01:46:29.020 --> 01:46:34.330
Bem, acontece que outra vantagem de um banco de dados relacional adequado

01:46:34.330 --> 01:46:38.830
é que não é apenas uma planilha em que a responsabilidade de encontrar

01:46:38.830 --> 01:46:40.120
os dados que você está procurando.

01:46:40.120 --> 01:46:43.780
Você também pode instruir o banco de dados a indexar os dados para você.

01:46:43.780 --> 01:46:48.670
Um índice é uma folha de dicas eficiente para encontrar dados rapidamente.

01:46:48.670 --> 01:46:52.908
Como os livros no mundo real, muitas vezes têm índices no final do livro

01:46:52.908 --> 01:46:54.700
onde você pode procurar as coisas em ordem alfabética

01:46:54.700 --> 01:46:57.790
e, em seguida, você pode fazer referência cruzada para as páginas em que o tópico aparece.

01:46:57.790 --> 01:46:59.110
Mesma ideia em um banco de dados.

01:46:59.110 --> 01:47:03.190
Se você informar ao banco de dados com antecedência que deseja pesquisar em uma determinada coluna

01:47:03.190 --> 01:47:06.700
frequentemente, você pode dizer a ele para criar um índice sofisticado que apenas

01:47:06.700 --> 01:47:08.770
permitem pesquisar essa coluna mais rapidamente.

01:47:08.770 --> 01:47:11.560
Por padrão, essas colunas serão pesquisadas

01:47:11.560 --> 01:47:13.197
provavelmente por uma pesquisa linear.

01:47:13.197 --> 01:47:15.280
Nem mesmo busca binária, porque os dados podem não

01:47:15.280 --> 01:47:17.390
ser classificado porque veio em qualquer ordem.

01:47:17.390 --> 01:47:20.170
Mas se você criar um índice, provavelmente

01:47:20.170 --> 01:47:22.780
vai ficar algo mais próximo de logarítmico do que linear,

01:47:22.780 --> 01:47:24.892
e isso será uma grande vantagem geral.

01:47:24.892 --> 01:47:26.350
Então deixe-me fazer algo simples aqui.

01:47:26.350 --> 01:47:30.670
Primeiro, deixe-me ativar um recurso específico do SQLite que vai cronometrar todos

01:47:30.670 --> 01:47:33.190
das minhas consultas escrevendo .timer on.

01:47:33.190 --> 01:47:37.515
Eu só quero acompanhar quanto tempo cada um desses comandos leva.

01:47:37.515 --> 01:47:40.390
Este não é um comando lento, então isso será apenas relativo.

01:47:40.390 --> 01:47:43.300
Mas vamos apenas selecionar tudo da tabela shows

01:47:43.300 --> 01:47:45.970
onde o título é The Office.

01:47:45.970 --> 01:47:48.940
Vamos ver quanto tempo leva essa consulta relativamente simples.

01:47:48.940 --> 01:47:50.980
Tudo bem, não muito tempo.

01:47:50.980 --> 01:47:54.850
Em termos reais, menos de um segundo, 0,035 segundos.

01:47:54.850 --> 01:47:57.070
Portanto, não lento de forma alguma.

01:47:57.070 --> 01:48:00.160
Mas se você tem centenas, milhares, milhões de usuários,

01:48:00.160 --> 01:48:03.040
cada um desses milissegundos poderia muito bem somar.

01:48:03.040 --> 01:48:04.640
Então podemos fazer melhor?

01:48:04.640 --> 01:48:06.440
Bem, nós podemos se eu fizer isso.

01:48:06.440 --> 01:48:11.740
Se eu usar uma sintaxe como esta uma vez no início do design do meu banco de dados,

01:48:11.740 --> 01:48:17.980
Eu crio não uma tabela, mas um índice com algum nome em uma tabela específica em um

01:48:17.980 --> 01:48:18.820
ou mais colunas.

01:48:18.820 --> 01:48:21.370
Eu posso dar uma pista, uma dica para o banco de dados com antecedência

01:48:21.370 --> 01:48:26.260
dizendo por favor otimize com algum molho secreto pesquisando ou selecionando

01:48:26.260 --> 01:48:29.740
nesta coluna desta tabela para que minhas pesquisas sejam mais rápidas.

01:48:29.740 --> 01:48:30.860
Então deixe-me fazer isso.

01:48:30.860 --> 01:48:32.590
Deixe-me voltar ao VS Code aqui.

01:48:32.590 --> 01:48:36.460
Deixe-me criar um índice chamado que tal índice de título.

01:48:36.460 --> 01:48:40.240
Eu poderia chamá-lo do que quiser, mas quero pesquisar mais rapidamente os títulos.

01:48:40.240 --> 01:48:45.940
Vou chamar isso de índice de título, em vez de índice de título na tabela

01:48:45.940 --> 01:48:46.900
chamados shows.

01:48:46.900 --> 01:48:49.150
E entre parênteses está a sintaxe.

01:48:49.150 --> 01:48:50.620
A coluna chamada title.

01:48:50.620 --> 01:48:53.350
Novamente, peguei emprestada essa sintaxe canônica

01:48:53.350 --> 01:48:57.590
e acabei de traduzi-lo em algo específico do programa de TV.

01:48:57.590 --> 01:48:58.090
Tudo bem.

01:48:58.090 --> 01:49:00.040
O que isso vai fazer por mim?

01:49:00.040 --> 01:49:03.700
Depois de pressionar Enter, isso será criado na memória do computador,

01:49:03.700 --> 01:49:05.860
a memória do banco de dados algo chamado de B-tree.

01:49:05.860 --> 01:49:07.330
Não é uma árvore binária.

01:49:07.330 --> 01:49:11.627
Uma árvore B é, na verdade, uma estrutura de dados potencialmente mais eficiente

01:49:11.627 --> 01:49:13.960
sobre o qual não falamos algumas semanas atrás na semana cinco,

01:49:13.960 --> 01:49:15.710
mas se parece um pouco com isso,

01:49:15.710 --> 01:49:17.680
que se parece com uma árvore binária.

01:49:17.680 --> 01:49:21.847
Mas alguém percebeu o que torna isso não uma árvore binária?

01:49:21.847 --> 01:49:26.405
AUDIÊNCIA: [INAUDÍVEL]

01:49:26.405 --> 01:49:27.280
DAVID MALAN: Exatamente.

01:49:27.280 --> 01:49:31.570
Árvore binária, bi implicando dois, não tem mais do que dois filhos por nó,

01:49:31.570 --> 01:49:33.580
mas aqui está um exemplo perfeito, um, dois, três.

01:49:33.580 --> 01:49:35.990
E pode haver quatro filhos, cinco filhos ou mais.

01:49:35.990 --> 01:49:38.530
Mas o efeito disso, se você tiver uma árvore muito larga,

01:49:38.530 --> 01:49:40.780
a vantagem é que é muito curto.

01:49:40.780 --> 01:49:44.560
Ele puxa os dados mais para cima, para mais perto do nó, para o nó raiz.

01:49:44.560 --> 01:49:48.080
E lembre-se de que o nó raiz é onde começamos nossas pesquisas no passado,

01:49:48.080 --> 01:49:51.620
se era um BST, uma árvore de pesquisa binária, até mesmo um tri ou outros dados

01:49:51.620 --> 01:49:52.120
estruturas.

01:49:52.120 --> 01:49:53.380
Sempre começamos por cima.

01:49:53.380 --> 01:49:55.780
Portanto, quanto mais alto você pode extrair os dados, mesmo

01:49:55.780 --> 01:49:57.617
se torna a estrutura de dados muito ampla,

01:49:57.617 --> 01:50:00.700
você poderá fazer bum, bum, bum, pesquisar consultas ou pesquisar

01:50:00.700 --> 01:50:03.340
dados provavelmente muito mais rápido certamente do que se fosse apenas

01:50:03.340 --> 01:50:06.590
uma lista muito longa como uma coluna por padrão.

01:50:06.590 --> 01:50:09.970
Dito isso, deixe-me voltar ao VS Code.

01:50:09.970 --> 01:50:11.380
Ainda não criei o índice.

01:50:11.380 --> 01:50:13.277
Deixe-me ir em frente e pressionar Enter e criá-lo.

01:50:13.277 --> 01:50:14.860
Tudo bem, demorou um minuto, um momento.

01:50:14.860 --> 01:50:17.920
Demorou meio segundo, o que obviamente não é tão lento.

01:50:17.920 --> 01:50:20.380
Mas com mais dados, isso poderia ter sido ainda mais lento.

01:50:20.380 --> 01:50:22.600
Mas é uma operação única a partir de agora.

01:50:22.600 --> 01:50:27.910
E agora deixe-me acessar e selecionar os mesmos dados dos shows

01:50:27.910 --> 01:50:29.350
onde título é igual a The Office.

01:50:29.350 --> 01:50:34.360
Da última vez, há pouco, demorou 0,035 segundos.

01:50:34.360 --> 01:50:38.920
Não lento, mas também vai aumentar se eu tiver muitos usuários do IMDb.

01:50:38.920 --> 01:50:42.040
Vamos em frente agora e executar a mesma consulta novamente.

01:50:42.040 --> 01:50:44.700
Quanto tempo isso levou?

01:50:44.700 --> 01:50:47.010
0,001 segundos agora.

01:50:47.010 --> 01:50:48.720
Quer dizer, praticamente nada.

01:50:48.720 --> 01:50:50.970
E esse é o tipo de oportunidade agora.

01:50:50.970 --> 01:50:53.470
Quando você tem muitos dados e quer realmente acelerar

01:50:53.470 --> 01:50:56.130
essas buscas, esses índices, esses índices que só criam

01:50:56.130 --> 01:50:59.130
para você essas estruturas de dados mágicas na memória do banco de dados,

01:50:59.130 --> 01:51:02.430
ele permite que você pesquise em colunas que você tem certeza de que

01:51:02.430 --> 01:51:04.150
deseja pesquisar com mais eficiência.

01:51:04.150 --> 01:51:07.380
Agora, por outro lado, se você já usou o Google ou o Bing ou alguma pesquisa

01:51:07.380 --> 01:51:10.590
mecanismo de pesquisa avançada, algumas dessas caixas de texto

01:51:10.590 --> 01:51:13.470
que você pode pesquisar com mais precisão pode muito bem ser mais lento.

01:51:13.470 --> 01:51:14.190
Por que?

01:51:14.190 --> 01:51:16.950
Bem, provavelmente você não quer enlouquecer e apenas indexar

01:51:16.950 --> 01:51:19.380
cada coluna em cada tabela.

01:51:19.380 --> 01:51:21.020
Por que?

01:51:21.020 --> 01:51:25.070
Qual pode ser a intuição?

01:51:25.070 --> 01:51:28.490
Se os índices logicamente aceleram as coisas, por que não indexar tudo?

01:51:28.490 --> 01:51:30.710
Sempre haverá uma troca aqui.

01:51:30.710 --> 01:51:33.040
O que pode ser?

01:51:33.040 --> 01:51:34.000
Sim.

01:51:34.000 --> 01:51:34.875
AUDIÊNCIA: [INAUDÍVEL]

01:51:34.875 --> 01:51:37.167
DAVID MALAN: Sim, vai demorar muito espaço de armazenamento.

01:51:37.167 --> 01:51:38.960
Este é apenas um slide na tela.

01:51:38.960 --> 01:51:41.020
Mas isso tem que ir para algum lugar.

01:51:41.020 --> 01:51:43.360
Isso precisa de espaço na memória do computador

01:51:43.360 --> 01:51:44.740
ou no disco rígido ou similar.

01:51:44.740 --> 01:51:48.777
E tudo bem se você tiver espaço ilimitado, mas é provável que não.

01:51:48.777 --> 01:51:51.110
E isso vai ficar caro por diferentes razões.

01:51:51.110 --> 01:51:55.810
Talvez você só queira indexar certas colunas e certas tabelas

01:51:55.810 --> 01:51:56.860
e nem todos eles.

01:51:56.860 --> 01:51:57.777
Porque você sabe o quê?

01:51:57.777 --> 01:51:59.590
E se um usuário realmente quiser pesquisar

01:51:59.590 --> 01:52:05.020
talvez por meio de pesquisa avançada em alguma outra coluna ou tabela, tudo bem.

01:52:05.020 --> 01:52:07.240
Se de vez em quando uma consulta é lenta, estamos

01:52:07.240 --> 01:52:11.110
provavelmente obtendo o maior retorno possível otimizando os casos comuns,

01:52:11.110 --> 01:52:16.030
as consultas mais populares com as quais as pessoas realmente se importam.

01:52:16.030 --> 01:52:16.640
Tudo bem.

01:52:16.640 --> 01:52:22.450
Então, vamos fechar o círculo e trazer isso de volta para como realmente

01:52:22.450 --> 01:52:25.030
começou, que foi com algum código Python.

01:52:25.030 --> 01:52:27.550
Acontece que essas decisões não são nem uma nem outra.

01:52:27.550 --> 01:52:29.740
Acontece que no mundo real, os desenvolvedores

01:52:29.740 --> 01:52:33.320
estão constantemente usando um, dois, três idiomas ao mesmo tempo.

01:52:33.320 --> 01:52:36.940
E, de fato, na semana que vem eu falei sobre HTML, CSS e JavaScript, um dos quais

01:52:36.940 --> 01:52:39.310
é uma linguagem de programação adequada, mas essas linguagens

01:52:39.310 --> 01:52:40.510
costumam ser usados ​​juntos.

01:52:40.510 --> 01:52:46.300
Totalmente normal e comum usar Python e SQL ou Java e SQL

01:52:46.300 --> 01:52:49.300
ou SWIFT e SQL ou qualquer número de combinações diferentes

01:52:49.300 --> 01:52:50.710
com uma linguagem de banco de dados.

01:52:50.710 --> 01:52:53.920
Você pode usar sua linguagem de programação preferida, Java, Python,

01:52:53.920 --> 01:53:00.760
C++ para criar a interface do usuário e a lógica que implementa o programa

01:53:00.760 --> 01:53:01.330
em si.

01:53:01.330 --> 01:53:04.092
Mas para seus dados, o SQL é realmente um bom candidato.

01:53:04.092 --> 01:53:07.300
E, de fato, já vimos que o SQL pode apenas acelerar certas operações.

01:53:07.300 --> 01:53:08.140
Você pode mudar.

01:53:08.140 --> 01:53:11.200
Você pode recolher 15 linhas de código em apenas uma

01:53:11.200 --> 01:53:13.430
e você pode usar essas coisas juntas.

01:53:13.430 --> 01:53:14.740
Então deixe-me voltar para--

01:53:14.740 --> 01:53:16.720
Vou sair do SQLite.

01:53:16.720 --> 01:53:18.580
Vou minimizar a janela do meu terminal.

01:53:18.580 --> 01:53:22.030
E aqui é onde paramos antes com favorites.py.

01:53:22.030 --> 01:53:27.430
Com favorites.py, tudo estava sendo armazenado em favorites.csv.

01:53:27.430 --> 01:53:32.260
E lembre-se de que eventualmente importamos esse arquivo CSV para favorites.db

01:53:32.260 --> 01:53:35.920
automaticamente com .import apenas para que pudéssemos começar a brincar com SQL.

01:53:35.920 --> 01:53:37.990
Mas agora podemos amarrar esses dois juntos.

01:53:37.990 --> 01:53:40.690
E uma maneira de fazer isso é a seguinte.

01:53:40.690 --> 01:53:42.700
CS50 tem uma biblioteca para Python.

01:53:42.700 --> 01:53:47.350
Você deve se lembrar de ter disponível get string, get int, get float.

01:53:47.350 --> 01:53:49.360
Você não precisa estritamente usá-los em Python

01:53:49.360 --> 01:53:51.970
porque é muito mais fácil usar apenas a função de entrada

01:53:51.970 --> 01:53:55.570
e, em seguida, tente, aceite e converta as coisas em int ou float ou algo semelhante.

01:53:55.570 --> 01:54:00.520
Mas é muito mais trabalhoso usar SQL em Python sem uma biblioteca de terceiros.

01:54:00.520 --> 01:54:03.370
Muitas opções comerciais ou opções populares de código aberto

01:54:03.370 --> 01:54:05.200
são realmente complicados de usar.

01:54:05.200 --> 01:54:09.790
Então CS50 tem uma função muito útil dentro de sua biblioteca para Python

01:54:09.790 --> 01:54:12.640
que você deve usar e deve usar para o conjunto de problemas que

01:54:12.640 --> 01:54:18.100
apenas facilita a execução do Python, executa o SQL dentro do seu código Python.

01:54:18.100 --> 01:54:22.360
Mas é construído sobre uma alternativa de código aberto muito popular.

01:54:22.360 --> 01:54:24.350
Então você pode usar isso também no mundo real.

01:54:24.350 --> 01:54:26.800
Portanto, a documentação para isso está neste URL aqui,

01:54:26.800 --> 01:54:30.940
mas mostrarei o que precisamos saber aqui focando em favorites.py.

01:54:30.940 --> 01:54:35.540
Então, o que vou fazer aqui é o seguinte.

01:54:35.540 --> 01:54:42.550
Deixe-me deletar tudo de favorites.py, exceto digamos isso.

01:54:42.550 --> 01:54:45.970
Do CS50, importe SQL em letras maiúsculas.

01:54:45.970 --> 01:54:49.060
Isso é importar um recurso SQL da biblioteca do CS50

01:54:49.060 --> 01:54:53.200
isso vai me permitir abrir um arquivo DB no código.

01:54:53.200 --> 01:54:54.380
Como faço isso?

01:54:54.380 --> 01:54:56.650
Bem, deixe-me criar uma variável chamada DB para banco de dados,

01:54:56.650 --> 01:54:58.275
embora eu possa chamá-lo do que quiser.

01:54:58.275 --> 01:55:02.470
Deixe-me chamar esta função SQL e passar usando a sintaxe especial que é

01:55:02.470 --> 01:55:03.640
não é específico do CS50.

01:55:03.640 --> 01:55:09.640
É uma coisa da indústria. sqlite:///.

01:55:09.640 --> 01:55:14.640
Ao contrário de qualquer outro URL que você digita, este tem literalmente três neste contexto

01:55:14.640 --> 01:55:15.140
aqui.

01:55:15.140 --> 01:55:18.340
E então o nome do banco de dados, que neste caso é favorites.db.

01:55:18.340 --> 01:55:22.450
Esta é apenas uma maneira de dizer a esta biblioteca SQL que escrevemos

01:55:22.450 --> 01:55:27.640
mas isso funciona exatamente como alternativas de terceiros, abra favorites.db usando

01:55:27.640 --> 01:55:30.380
a tecnologia SQLite, se preferir.

01:55:30.380 --> 01:55:30.880
Tudo bem.

01:55:30.880 --> 01:55:32.338
Vamos apenas fazer uma pergunta ao usuário.

01:55:32.338 --> 01:55:36.057
Dê-me o seu problema favorito.

01:55:36.057 --> 01:55:38.140
Então, vamos usar input em vez de get string,

01:55:38.140 --> 01:55:41.450
mas poderíamos usar get string, mas eles são praticamente os mesmos para nossos propósitos.

01:55:41.450 --> 01:55:43.150
Vamos perguntar ao usuário qual é o seu favorito.

01:55:43.150 --> 01:55:49.960
E agora no código Python, vamos selecionar favorites.db

01:55:49.960 --> 01:55:55.450
todas as linhas em que os alunos especificam esse problema como favorito.

01:55:55.450 --> 01:55:57.610
Portanto, apenas no SQL, seria isso.

01:55:57.610 --> 01:56:04.210
Selecione a estrela dos favoritos onde o problema é igual

01:56:04.210 --> 01:56:08.170
e eu farei, bem, qualquer que seja o meu favorito.

01:56:08.170 --> 01:56:10.288
Tal problema é igual a Mario, por exemplo.

01:56:10.288 --> 01:56:13.330
Portanto, se eu estivesse apenas usando SQL, escreveria literalmente algo assim.

01:56:13.330 --> 01:56:15.130
Mas estou em um arquivo .py agora.

01:56:15.130 --> 01:56:16.870
Eu tenho que usar a sintaxe do Python.

01:56:16.870 --> 01:56:18.550
Mas o Python suporta strings.

01:56:18.550 --> 01:56:20.090
SQL é apenas texto.

01:56:20.090 --> 01:56:20.990
É apenas uma corda.

01:56:20.990 --> 01:56:24.220
Então eu certamente poderia colocar meu código SQL em uma string

01:56:24.220 --> 01:56:26.800
talvez e depois passá-lo para uma função Python.

01:56:26.800 --> 01:56:28.780
E aqui está a ponte entre os dois.

01:56:28.780 --> 01:56:31.960
Se você tratar o SQL como qualquer texto antigo, podemos colocá-lo em uma string

01:56:31.960 --> 01:56:32.840
e execute-o.

01:56:32.840 --> 01:56:34.837
Então deixe-me realmente fazer isso.

01:56:34.837 --> 01:56:36.670
Deixe-me ir em frente e criar uma variável chamada

01:56:36.670 --> 01:56:40.130
linhas, que eventualmente conterá todas as linhas do banco de dados.

01:56:40.130 --> 01:56:45.790
Deixe-me ir em frente e selecionar db.execute.

01:56:45.790 --> 01:56:49.030
Esta é a única função que você precisa conhecer dentro da biblioteca do CS50,

01:56:49.030 --> 01:56:51.310
e literalmente executa uma instrução SQL.

01:56:51.310 --> 01:56:56.140
E aí entre aspas, você passa literalmente o que quer executar.

01:56:56.140 --> 01:56:58.990
E deixe-me prosseguir e fechar o parêntese no final.

01:56:58.990 --> 01:57:00.740
E agora deixe-me tentar isso.

01:57:00.740 --> 01:57:05.260
Então, para linha em linhas, vamos iterar sobre todas as linhas, deixe-me prosseguir

01:57:05.260 --> 01:57:12.370
e imprima que tal linha, entre aspas.

01:57:12.370 --> 01:57:15.700
E o que eu quero aqui?

01:57:15.700 --> 01:57:20.020
Vamos imprimir o timestamp dessa pessoa para diversão.

01:57:20.020 --> 01:57:22.120
Tudo bem, deixe-me abrir a janela do meu terminal.

01:57:22.120 --> 01:57:23.890
Python de favorites.py.

01:57:23.890 --> 01:57:27.490
Cruzando meus dedos aqui com certeza.

01:57:27.490 --> 01:57:27.990
Digitar.

01:57:31.200 --> 01:57:31.770
Aqui vamos nós.

01:57:31.770 --> 01:57:32.280
Favoritos.

01:57:32.280 --> 01:57:34.500
Vou digitar Mario.

01:57:34.500 --> 01:57:35.070
OK.

01:57:35.070 --> 01:57:36.240
Então eu voltei--

01:57:36.240 --> 01:57:37.980
não é muito interessante, mas voltei

01:57:37.980 --> 01:57:40.830
todos os timestamps de alunos que digitaram Mario que nós

01:57:40.830 --> 01:57:42.330
importados para este banco de dados.

01:57:42.330 --> 01:57:45.360
Bem, o que realmente me importa é o quão popular Mario é.

01:57:45.360 --> 01:57:46.830
Então deixe-me mudar isso um pouco.

01:57:46.830 --> 01:57:50.490
Deixe-me mudar isso para contar o número de linhas.

01:57:50.490 --> 01:57:52.080
E deixe-me simplificar.

01:57:52.080 --> 01:57:56.260
Deixe-me dar um alias como propus anteriormente como n, onde n é um número.

01:57:56.260 --> 01:58:00.090
Então agora aqui embaixo, eu posso fazer isso.

01:58:00.090 --> 01:58:02.230
Imprima o valor de n.

01:58:02.230 --> 01:58:02.730
Tudo bem.

01:58:02.730 --> 01:58:04.450
Deixe-me voltar para a janela do meu terminal.

01:58:04.450 --> 01:58:05.910
Execute o Python em favorites.py.

01:58:05.910 --> 01:58:07.140
Deixe-me digitar Mario.

01:58:07.140 --> 01:58:08.070
Digitar.

01:58:08.070 --> 01:58:09.660
Certo, 39.

01:58:09.660 --> 01:58:11.790
Agora, tecnicamente estou trapaceando.

01:58:11.790 --> 01:58:14.430
Honestamente, se estou executando a contagem de seleção, temos

01:58:14.430 --> 01:58:17.752
visto antes, ele retorna apenas uma linha, não várias.

01:58:17.752 --> 01:58:20.460
Portanto, não há realmente nada para iterar, mas está funcionando bem.

01:58:20.460 --> 01:58:22.560
É apenas iterar uma vez, mas estou tendo sorte.

01:58:22.560 --> 01:58:26.100
Então, tecnicamente, o que eu provavelmente deveria fazer é isso.

01:58:26.100 --> 01:58:29.220
Eu provavelmente deveria me dar uma variável chamada linha,

01:58:29.220 --> 01:58:34.770
defini-lo igual à primeira linha e à única linha que voltou,

01:58:34.770 --> 01:58:39.510
e agora imprima essas linhas e colunas.

01:58:39.510 --> 01:58:40.890
Deixe-me executar novamente o programa.

01:58:40.890 --> 01:58:42.130
Vou digitar Mario novamente.

01:58:42.130 --> 01:58:42.660
Digitar.

01:58:42.660 --> 01:58:44.980
E ainda vejo 39.

01:58:44.980 --> 01:58:48.328
Então, é claro, não preciso estritamente fazer isso.

01:58:48.328 --> 01:58:49.620
Eu realmente não preciso de uma variável.

01:58:49.620 --> 01:58:52.590
Em vez disso, posso fazer o colchete de linhas 0.

01:58:52.590 --> 01:58:54.840
Mas deixe-me focar no que esta biblioteca está fazendo agora.

01:58:54.840 --> 01:59:01.620
Portanto, de acordo com a documentação, o que a função de execução do CS50 sempre faz por você é

01:59:01.620 --> 01:59:05.620
ele retorna uma lista de dicionários.

01:59:05.620 --> 01:59:10.558
Portanto, se sua consulta não retornar nada, como nenhuma correspondência, você receberá uma lista vazia.

01:59:10.558 --> 01:59:12.600
Como colchete aberto, colchete fechado, nada nele.

01:59:12.600 --> 01:59:14.520
Qualquer loop não vai executar nada útil,

01:59:14.520 --> 01:59:15.770
porque não há nada nele.

01:59:15.770 --> 01:59:18.660
Se, porém, você voltar uma linha, você vai

01:59:18.660 --> 01:59:22.740
para recuperar uma lista de tamanho um dentro da qual há um único dicionário.

01:59:22.740 --> 01:59:24.930
Esse dicionário terá chaves que

01:59:24.930 --> 01:59:29.200
correspondem ao que você selecionou, sejam as colunas ou a contagem.

01:59:29.200 --> 01:59:32.880
Então, quando selecionei a estrela antes, teria obtido todas as colunas.

01:59:32.880 --> 01:59:34.950
Foi assim que consegui acessar o timestamp.

01:59:34.950 --> 01:59:37.230
Aqui estou apenas selecionando contagem e não

01:59:37.230 --> 01:59:38.910
quero ter que digitar isso aqui.

01:59:38.910 --> 01:59:40.230
Isso pareceria meio atroz.

01:59:40.230 --> 01:59:42.355
Funcionaria, mas seria estranho apenas manter

01:59:42.355 --> 01:59:44.640
digitando novamente count parent parent star close parent.

01:59:44.640 --> 01:59:49.530
Então, acabei de criar um alias chamado n apenas para tornar minha vida mais fácil ou mais limpa

01:59:49.530 --> 01:59:50.380
aqui.

01:59:50.380 --> 01:59:55.680
Então, para ficar claro, a função de execução do CS50 retorna uma lista de dicionários

01:59:55.680 --> 01:59:57.360
quando você está usando select.

01:59:57.360 --> 02:00:01.500
E é assim que agora posso recuperar a primeira e única linha

02:00:01.500 --> 02:00:04.860
e imprima o valor final dessa linha.

02:00:04.860 --> 02:00:07.380
É idêntico a--

02:00:07.380 --> 02:00:08.650
Deixe-me fazer isso.

02:00:08.650 --> 02:00:11.610
Deixe-me destacar toda esta linha de texto.

02:00:11.610 --> 02:00:15.120
Deixe-me executar o SQLite3 de favorites.db na janela do meu terminal

02:00:15.120 --> 02:00:16.470
como fizemos antes do intervalo.

02:00:16.470 --> 02:00:19.170
Deixe-me apenas copiar e colar esta consulta.

02:00:19.170 --> 02:00:20.040
Digitar.

02:00:20.040 --> 02:00:24.550
Essa é a tabela que recebi antes, quando jogamos com SQL manualmente.

02:00:24.550 --> 02:00:28.170
E então, quando eu voltar a esta tabela, aqui está a chave, aqui está o valor,

02:00:28.170 --> 02:00:31.860
e eu só tenho uma linha, e é por isso que estou apenas indexando cegamente

02:00:31.860 --> 02:00:34.080
no colchete de linhas 0, porque sei que sempre há

02:00:34.080 --> 02:00:35.247
vai ser uma resposta lá.

02:00:35.247 --> 02:00:36.690
Vai ser 0 ou 1 ou mais.

02:00:36.690 --> 02:00:40.360
Mas agora eu sei que vai se chamar n por causa disso aqui.

02:00:40.360 --> 02:00:41.580
Então o que eu acabei de fazer?

02:00:41.580 --> 02:00:43.113
Bem, isso aqui é SQL.

02:00:43.113 --> 02:00:45.780
E isso sou apenas eu sendo como um cientista de dados fazendo perguntas

02:00:45.780 --> 02:00:48.640
sobre meus dados usando apenas consultas SQL em preto e branco.

02:00:48.640 --> 02:00:52.410
Este sou eu agora sendo um programador Python que quer falar com um banco de dados SQL

02:00:52.410 --> 02:00:53.700
usando Python.

02:00:53.700 --> 02:00:56.820
E a ponte que estamos usando é a biblioteca CS50.

02:00:56.820 --> 02:00:59.940
Mas, novamente, existem bibliotecas gratuitas de terceiros que você também pode usar.

02:00:59.940 --> 02:01:01.710
A nossa é muito simples.

02:01:01.710 --> 02:01:03.660
E, de fato, a documentação explicará

02:01:03.660 --> 02:01:07.113
como executar se comporta de maneira um pouco diferente para inserções, atualizações e exclusões.

02:01:07.113 --> 02:01:09.780
Você não recebe uma lista porque não está selecionando nada,

02:01:09.780 --> 02:01:13.050
mas você recebe de volta alguns valores de retorno.

02:01:13.050 --> 02:01:15.990
Perguntas sobre isso?

02:01:15.990 --> 02:01:18.030
Esse é o último do nosso código Python.

02:01:18.030 --> 02:01:23.320
Isso une tudo em espírito.

02:01:23.320 --> 02:01:24.768
Sim?

02:01:24.768 --> 02:01:29.460
AUDIÊNCIA: [INAUDÍVEL]

02:01:29.460 --> 02:01:31.810
DAVID MALAN: Este aqui?

02:01:31.810 --> 02:01:32.320
Sim.

02:01:32.320 --> 02:01:37.558
Portanto, db.execute, por definição, retorna uma lista de linhas.

02:01:37.558 --> 02:01:40.600
E cada uma dessas linhas é um dicionário porque é conveniente.

02:01:40.600 --> 02:01:42.100
Pares de valores-chave.

02:01:42.100 --> 02:01:45.040
Se estou selecionando a contagem de linhas, apenas

02:01:45.040 --> 02:01:48.250
sei por ter aprendido SQL uma hora atrás que isso é sempre

02:01:48.250 --> 02:01:52.540
vai me dar uma única linha cuja coluna neste caso é chamada de n.

02:01:52.540 --> 02:01:56.470
Então, se eu sei que é uma única linha, posso cegamente, como em C,

02:01:56.470 --> 02:02:00.160
entre nessa lista ou em uma matriz em C e vá para o primeiro local

02:02:00.160 --> 02:02:02.590
e, em seguida, trate-a como a única linha.

02:02:02.590 --> 02:02:04.330
O que você não quer fazer é isso.

02:02:04.330 --> 02:02:08.500
Mesmo que você, o humano, saiba que a consulta retorna uma linha,

02:02:08.500 --> 02:02:10.780
você não pode simplesmente mudar magicamente o nome da variável

02:02:10.780 --> 02:02:13.270
ser singular e esperar ter apenas um valor.

02:02:13.270 --> 02:02:14.960
Você sempre terá uma lista.

02:02:14.960 --> 02:02:18.190
Portanto, mesmo que haja apenas um valor nisso, cabe a você fazer algo

02:02:18.190 --> 02:02:19.780
assim para chegar lá.

02:02:19.780 --> 02:02:24.070
Ou, se preferir mais concisão, você pode fazer linhas colchete I colchete n.

02:02:24.070 --> 02:02:27.220
Isso vai conseguir a mesma coisa sem uma variável.

02:02:27.220 --> 02:02:29.095
Sim?

02:02:29.095 --> 02:02:33.970
AUDIÊNCIA: [INAUDÍVEL]

02:02:33.970 --> 02:02:34.720
DAVID MALAN: Bom.

02:02:34.720 --> 02:02:37.150
Então, eu tenho enganado esse tempo todo

02:02:37.150 --> 02:02:40.690
e trapacear porque isso só vai devolver Mario.

02:02:40.690 --> 02:02:44.530
Estou ignorando o favorito que o humano digitou aqui na linha cinco.

02:02:44.530 --> 02:02:45.770
Então deixe-me consertar isso.

02:02:45.770 --> 02:02:49.000
E isso vai nos levar a alguns dos problemas que surgem no final

02:02:49.000 --> 02:02:49.780
com SQL.

02:02:49.780 --> 02:02:53.320
A maneira certa de resolver esse problema - deixe-me me livrar da janela do meu terminal

02:02:53.320 --> 02:02:53.890
aqui.

02:02:53.890 --> 02:02:56.170
A maneira certa de resolver este problema não é

02:02:56.170 --> 02:02:59.170
para usar um fstring como fizemos no Python em geral,

02:02:59.170 --> 02:03:02.680
porque as consultas SQL, como veremos em breve, podem ser perigosas.

02:03:02.680 --> 02:03:06.940
Quando você deseja inserir os dados dos usuários em uma consulta

02:03:06.940 --> 02:03:10.540
que você escreveu com antecedência, você deve, você

02:03:10.540 --> 02:03:15.640
deve, é melhor usar um espaço reservado, ou seja, um ponto de interrogação neste caso.

02:03:15.640 --> 02:03:18.340
Isso é um tanto específico da biblioteca do CS50,

02:03:18.340 --> 02:03:21.910
mas apenas pegamos emprestada a convenção que todas as outras bibliotecas também usam.

02:03:21.910 --> 02:03:25.660
No mundo do SQL, pontos de interrogação simples são usados ​​como espaços reservados.

02:03:25.660 --> 02:03:28.190
E a maneira de fazer isso é a seguinte.

02:03:28.190 --> 02:03:32.020
Se você deseja inserir um valor para esse ponto de interrogação,

02:03:32.020 --> 02:03:37.180
assim como em printf em C, você especifica como um segundo ou terceiro ou quarto argumento

02:03:37.180 --> 02:03:39.320
todos os valores que você deseja conectar a isso.

02:03:39.320 --> 02:03:42.280
Então, em C, semanas atrás, estávamos usando %s.

02:03:42.280 --> 02:03:43.810
Mesma ideia exata.

02:03:43.810 --> 02:03:46.810
No SQL, é um ponto de interrogação que você usa.

02:03:46.810 --> 02:03:49.480
Isso agora, se eu abrir minha janela de terminal

02:03:49.480 --> 02:03:55.120
e eu executo o Python de favorites.py, digito Mario, ainda devo obter 39.

02:03:55.120 --> 02:03:58.750
Mas agora também posso digitar Scratch talvez e obter 44

02:03:58.750 --> 02:04:00.520
para aquela primeira peça em 0.

02:04:00.520 --> 02:04:02.900
E esse é ainda mais popular aqui.

02:04:02.900 --> 02:04:04.150
Então isso agora está correto.

02:04:04.150 --> 02:04:09.560
Funcionaria para usar um fstring aqui e, em seguida, inserir um valor como favorito

02:04:09.560 --> 02:04:10.060
aqui.

02:04:10.060 --> 02:04:11.977
Mas você verá em apenas um momento, não faça isso.

02:04:11.977 --> 02:04:15.640
Você se exporá a possíveis hacks ou ataques

02:04:15.640 --> 02:04:17.910
confiando na entrada do usuário.

02:04:17.910 --> 02:04:19.660
E então, de fato, vamos fazer a transição disso

02:04:19.660 --> 02:04:21.610
para exatamente alguns desses tipos de desafios,

02:04:21.610 --> 02:04:24.020
ou seja, dois antes de encerrarmos.

02:04:24.020 --> 02:04:27.820
Assim, no mundo do SQL, especialmente quando é usado em escala com os Twitters

02:04:27.820 --> 02:04:30.610
e os Googles do mundo, muitos dados

02:04:30.610 --> 02:04:32.610
provavelmente está entrando no banco de dados de uma só vez

02:04:32.610 --> 02:04:34.610
porque várias pessoas estão abrindo seus telefones

02:04:34.610 --> 02:04:36.070
ao mesmo tempo em todo o mundo.

02:04:36.070 --> 02:04:37.690
Eles estão clicando nos mesmos links mais ou menos

02:04:37.690 --> 02:04:39.107
ao mesmo tempo em todo o mundo.

02:04:39.107 --> 02:04:42.235
Quando você tem milhares de pessoas usando seu site ao mesmo tempo,

02:04:42.235 --> 02:04:44.110
ordem das operações vai ser importante.

02:04:44.110 --> 02:04:47.620
Mas, infelizmente, no SQL e em outros contextos de computação,

02:04:47.620 --> 02:04:50.150
existe o risco do que é conhecido como condição de corrida.

02:04:50.150 --> 02:04:53.710
Então, por exemplo, alguém já viu ou gostou disso?

02:04:53.710 --> 02:04:55.780
Este é o ovo recorde mundial.

02:04:55.780 --> 02:04:58.467
Ou é uma coisa que era muito popular há um tempo atrás.

02:04:58.467 --> 02:04:59.800
Ainda está meio forte.

02:04:59.800 --> 02:05:03.340
Mas se você for ao perfil do Instagram do World Record Egg,

02:05:03.340 --> 02:05:06.610
o objetivo era fazer a postagem do Instagram com mais curtidas de todos os tempos.

02:05:06.610 --> 02:05:08.000
E eles se saíram muito bem.

02:05:08.000 --> 02:05:09.170
É apenas isso.

02:05:09.170 --> 02:05:10.790
É apenas uma foto de um ovo.

02:05:10.790 --> 02:05:12.570
Agora, no auge da popularidade, como

02:05:12.570 --> 02:05:15.070
pode ter havido centenas, milhares, dezenas de milhares

02:05:15.070 --> 02:05:18.520
de pessoas clicando praticamente ao mesmo tempo neste ovo.

02:05:18.520 --> 02:05:20.830
Na verdade, isso cria um problema em potencial

02:05:20.830 --> 02:05:23.470
com a integridade dos dados do Instagram.

02:05:23.470 --> 02:05:24.010
Por que?

02:05:24.010 --> 02:05:26.302
Bem, se você tiver todas essas solicitações chegando de uma só vez,

02:05:26.302 --> 02:05:28.250
como você possivelmente acompanha todos eles

02:05:28.250 --> 02:05:31.850
e atualizar seu contador de forma que possa acompanhar todo esse tráfego?

02:05:31.850 --> 02:05:32.350
Por que?

02:05:32.350 --> 02:05:35.680
Bem, vamos apenas supor o que o Meta, anteriormente Facebook,

02:05:35.680 --> 02:05:38.860
estava fazendo sob o capô com o Instagram se esse fosse o código deles.

02:05:38.860 --> 02:05:41.890
Suponhamos, para fins de discussão, que os servidores do Instagram

02:05:41.890 --> 02:05:44.617
estão usando uma mistura de Python e SQL.

02:05:44.617 --> 02:05:47.200
Provavelmente não usando a biblioteca CS50, mas eles poderiam absolutamente

02:05:47.200 --> 02:05:50.680
estar usando essas duas línguas ou duas outras juntas.

02:05:50.680 --> 02:05:55.270
Suponha que eles façam isso para atualizar o número de curtidas dessa postagem.

02:05:55.270 --> 02:06:00.160
Eles primeiro executam uma consulta SQL como selecionar o número atual de curtidas

02:06:00.160 --> 02:06:03.580
de uma tabela chamada posts onde a ideia do post

02:06:03.580 --> 02:06:08.530
é igual a qualquer que seja o identificador exclusivo para esse ovo específico na tabela.

02:06:08.530 --> 02:06:12.460
E então eles armazenam o resultado nesta variável de linhas, assim como eu fiz.

02:06:12.460 --> 02:06:14.830
E então eles fazem isso.

02:06:14.830 --> 02:06:16.420
Eles criam uma variável chamada curtidas.

02:06:16.420 --> 02:06:18.700
Eles o definem igual ao colchete de linhas 0.

02:06:18.700 --> 02:06:21.280
Portanto, a primeira linha no conjunto de resultados.

02:06:21.280 --> 02:06:22.450
E eles recebem a chave de curtidas.

02:06:22.450 --> 02:06:25.030
Então, isso é literalmente o que acabei de fazer com a contagem.

02:06:25.030 --> 02:06:27.880
Deixe-me supor que o Instagram faz algo semelhante

02:06:27.880 --> 02:06:29.330
com o número total de curtidas.

02:06:29.330 --> 02:06:30.370
Porque é que eles estão a fazer isto?

02:06:30.370 --> 02:06:34.600
Porque eles então querem executar uma terceira linha de código que executa

02:06:34.600 --> 02:06:36.430
atualize a tabela de postagens.

02:06:36.430 --> 02:06:41.920
Defina o novo número de curtidas igual a algo em que a ideia da postagem

02:06:41.920 --> 02:06:43.330
é igual a esta outra coisa.

02:06:43.330 --> 02:06:46.870
Agora, observe como em printf há uma lista de valores separada por vírgulas.

02:06:46.870 --> 02:06:50.560
Eles querem atualizar o número atual de curtidas do valor atual

02:06:50.560 --> 02:06:51.970
ao valor atual mais 1.

02:06:51.970 --> 02:06:53.350
Então é likes mais 1.

02:06:53.350 --> 02:06:55.640
E então nós conectamos o ID para isso.

02:06:55.640 --> 02:06:57.760
Então suponha que isso é o que o Instagram está fazendo.

02:06:57.760 --> 02:07:02.860
Infelizmente, sempre que você executa várias linhas de código independentemente

02:07:02.860 --> 02:07:06.260
e você é tão popular como o Instagram que tem milhares,

02:07:06.260 --> 02:07:08.530
centenas de milhares de servidores potencialmente,

02:07:08.530 --> 02:07:11.470
é bem possível que se você e eu e todos os outros na sala

02:07:11.470 --> 02:07:13.630
clica naquele ovo ao mesmo tempo, não é

02:07:13.630 --> 02:07:17.093
vai ser o caso estatisticamente que três linhas de código são executadas para mim

02:07:17.093 --> 02:07:19.510
e então três linhas para você e então três linhas para você.

02:07:19.510 --> 02:07:21.490
Eles provavelmente vão ficar intercalados.

02:07:21.490 --> 02:07:24.430
Isso é executado para mim e então isso é executado para você

02:07:24.430 --> 02:07:27.520
e então eles voltam a fazer o trabalho para mim e assim por diante, apenas para

02:07:27.520 --> 02:07:30.820
de multitarefa, assim como um ser humano, mas em uma supervelocidade aqui.

02:07:30.820 --> 02:07:33.590
O problema, porém, é se essas linhas de código

02:07:33.590 --> 02:07:35.838
for interrompido, o que poderia dar errado?

02:07:35.838 --> 02:07:38.630
Bem, suponha que Carter e eu cliquemos no ovo ao mesmo tempo

02:07:38.630 --> 02:07:41.780
e suponha que o número atual de curtidas naquele dia seja 100.

02:07:41.780 --> 02:07:45.150
Que armazena nesta variável o valor 100.

02:07:45.150 --> 02:07:49.010
Mas se clicarmos tão perto no tempo, podemos obter a mesma resposta

02:07:49.010 --> 02:07:50.300
para esta consulta selecionada.

02:07:50.300 --> 02:07:54.380
A partir daquele momento em que David e Carter clicaram, teve 100 curtidas.

02:07:54.380 --> 02:07:58.220
Mas então esta última linha de código é executada para mim e talvez para Carter.

02:07:58.220 --> 02:08:03.380
Como essa resposta, o estado do banco de dados, foi armazenado nessa variável,

02:08:03.380 --> 02:08:08.870
então tanto Carter quanto eu resultaremos nesta linha de código

02:08:08.870 --> 02:08:10.610
sendo executado com o mesmo valor.

02:08:10.610 --> 02:08:17.480
Atualize a tabela de postagens definindo curtidas iguais a 101 para o ID dessa postagem.

02:08:17.480 --> 02:08:18.080
Por que?

02:08:18.080 --> 02:08:21.950
Porque, novamente, se cada uma dessas linhas de código em execução em servidores diferentes

02:08:21.950 --> 02:08:25.213
estão verificando o valor do número atual de curtidas

02:08:25.213 --> 02:08:28.130
mas então sendo interrompido porque Carter clicou na maldita coisa também

02:08:28.130 --> 02:08:30.350
e, em seguida, retomando seu trabalho em meu nome,

02:08:30.350 --> 02:08:33.890
podemos ter uma condição de corrida em que o código está correndo para terminar

02:08:33.890 --> 02:08:36.320
mas sendo interrompido por cliques de outros usuários.

02:08:36.320 --> 02:08:38.720
E o problema com isso é que se você

02:08:38.720 --> 02:08:42.710
inspecionando o valor de alguma variável, ou neste caso uma célula de banco de dados,

02:08:42.710 --> 02:08:45.650
e tomar uma decisão com base nisso, como atualizá-lo,

02:08:45.650 --> 02:08:46.995
agora você pode perder dados.

02:08:46.995 --> 02:08:50.120
E o Instagram provavelmente não é bom para publicidade se eles estão perdendo curtidas.

02:08:50.120 --> 02:08:54.620
E provavelmente é um problema não reter o valor 102

02:08:54.620 --> 02:08:57.230
e, em vez disso, insira o número 101 duas vezes.

02:08:57.230 --> 02:09:00.500
Na verdade, é semelhante em espírito a uma história que

02:09:00.500 --> 02:09:05.960
foi dito em um curso de banco de dados que fiz anos atrás, em que--

02:09:05.960 --> 02:09:08.900
é um pouco análogo a um cenário artificial

02:09:08.900 --> 02:09:10.070
envolvendo uma geladeira.

02:09:10.070 --> 02:09:12.380
E esta é a coisa mais próxima de uma geladeira que poderíamos colocar no palco.

02:09:12.380 --> 02:09:14.420
Mas imagine que você tem uma dessas pequenas geladeiras de dormitório

02:09:14.420 --> 02:09:16.040
em seu dormitório também e seu colega de quarto.

02:09:16.040 --> 02:09:19.102
E talvez vocês dois, como a história me foi contada, gostem muito de leite.

02:09:19.102 --> 02:09:21.560
E um de vocês está na aula, mas o outro chega em casa

02:09:21.560 --> 02:09:25.500
e você abre a geladeira do seu dormitório e pensa, que droga, acabou o leite.

02:09:25.500 --> 02:09:27.020
E assim você fecha a geladeira.

02:09:27.020 --> 02:09:29.720
Você atravessa a rua até a CVS ou alguma outra loja

02:09:29.720 --> 02:09:31.490
e você entra na fila para comprar leite.

02:09:31.490 --> 02:09:33.020
Enquanto isso, seu colega de quarto sai da aula.

02:09:33.020 --> 02:09:34.160
Eles voltam para o seu dormitório.

02:09:34.160 --> 02:09:35.702
Eles estão com muita sede de leite.

02:09:35.702 --> 02:09:37.010
Eles abrem a geladeira.

02:09:37.010 --> 02:09:38.510
Eles dizem, oh, estamos sem leite.

02:09:38.510 --> 02:09:41.630
E então eles seguem uma rota diferente, talvez para o CVS

02:09:41.630 --> 02:09:44.300
ou alguma outra loja próxima, entre na fila para comprar leite.

02:09:44.300 --> 02:09:48.260
Avance um pouco nesta história muito artificial e o que acontece?

02:09:48.260 --> 02:09:50.570
Droga, acabamos com dois galões de leite

02:09:50.570 --> 02:09:54.480
e não há como colocar galões de leite lá dentro, muito menos dois deles.

02:09:54.480 --> 02:09:56.000
Então isso é um problema.

02:09:56.000 --> 02:10:00.000
Mas qual é a relação com isso aqui?

02:10:00.000 --> 02:10:02.693
Bem, nós dois, sim, fizemos o quê?

02:10:02.693 --> 02:10:07.523
AUDIÊNCIA: [INAUDÍVEL]

02:10:16.685 --> 02:10:17.560
DAVID MALAN: Exatamente.

02:10:17.560 --> 02:10:19.925
AUDIÊNCIA: [INAUDÍVEL]

02:10:22.965 --> 02:10:23.840
DAVID MALAN: Exatamente.

02:10:23.840 --> 02:10:26.480
Então, para resumir, nós dois tivemos um processo de pensamento muito semelhante,

02:10:26.480 --> 02:10:28.820
tomou uma decisão semelhante com base nas mesmas informações,

02:10:28.820 --> 02:10:31.760
sem perceber que a informação, a geladeira,

02:10:31.760 --> 02:10:34.600
estava em processo de atualização.

02:10:34.600 --> 02:10:37.100
E claro, no mundo do Instagram, acontece assim.

02:10:37.100 --> 02:10:39.300
No mundo da geladeira, pode levar alguns minutos.

02:10:39.300 --> 02:10:41.840
Mas o problema é, em última análise, o resultado de nossa

02:10:41.840 --> 02:10:46.070
tendo tomado uma decisão sobre o estado do mundo e o estado do mundo

02:10:46.070 --> 02:10:48.600
estava no meio de ser atualizado.

02:10:48.600 --> 02:10:50.333
As perguntas se misturaram com outras.

02:10:50.333 --> 02:10:53.000
Ou, neste caso, alguém já estava a caminho da loja.

02:10:53.000 --> 02:10:54.960
Então, qual é a solução no mundo real?

02:10:54.960 --> 02:10:59.000
Bem, você poderia simplesmente pegar um post-it e colocar como ido para o leite

02:10:59.000 --> 02:11:02.060
para comunicar ao seu colega de quarto que eles não devem

02:11:02.060 --> 02:11:04.620
inspecionar o valor dessa variável e tomar uma decisão sobre ela.

02:11:04.620 --> 02:11:05.120
Por que?

02:11:05.120 --> 02:11:08.958
Porque ainda não é consistente com o resultado que está para acontecer.

02:11:08.958 --> 02:11:11.000
Você poderia ser mais dramático e você poderia realmente

02:11:11.000 --> 02:11:13.580
tranque a geladeira de alguma forma, coloque um cadeado em volta dela

02:11:13.580 --> 02:11:15.470
ou algo parecido, então eles não podem nem entrar lá.

02:11:15.470 --> 02:11:18.510
E isso também alcançaria o mesmo efeito.

02:11:18.510 --> 02:11:22.400
E isso é praticamente a solução para esse problema no código também.

02:11:22.400 --> 02:11:23.370
Não é seguro.

02:11:23.370 --> 02:11:27.110
Não é suficiente executar apenas três linhas de código como esta.

02:11:27.110 --> 02:11:32.000
Em vez disso, o que você provavelmente deseja fazer é usar palavras-chave SQL adicionais

02:11:32.000 --> 02:11:35.270
que não vamos gastar muito tempo na aula em si, mas estes.

02:11:35.270 --> 02:11:37.160
Existem soluções para este problema.

02:11:37.160 --> 02:11:39.320
Você pode começar o que é chamado de transação

02:11:39.320 --> 02:11:43.460
e você pode se comprometer mais explicitamente a tomar uma decisão,

02:11:43.460 --> 02:11:46.100
como atualizar o banco de dados para 101 ou 102.

02:11:46.100 --> 02:11:50.120
Ou se você perceber, espere um minuto, a pergunta de Carter está interrompendo a minha.

02:11:50.120 --> 02:11:53.540
Deixe-me voltar ao estado anterior e retroceder.

02:11:53.540 --> 02:11:54.290
Deixe-me desfazer.

02:11:54.290 --> 02:11:55.840
Controle Z, se quiser.

02:11:55.840 --> 02:11:58.340
Há também outra palavra-chave que não é mais tão usada

02:11:58.340 --> 02:11:59.600
no SQL que está travando.

02:11:59.600 --> 02:12:01.170
Você poderia literalmente voltar no dia.

02:12:01.170 --> 02:12:05.690
Bloqueie toda a tabela do banco de dados, impedindo que alguém a atualize

02:12:05.690 --> 02:12:09.320
ou fazer alterações ou mesmo lê-lo enquanto outra pessoa o acessa.

02:12:09.320 --> 02:12:12.320
Essa foi uma solução muito pesada porque retardou tudo.

02:12:12.320 --> 02:12:15.710
Mas, resumindo, as transações agora são um recurso do SQL

02:12:15.710 --> 02:12:17.840
que você não precisará necessariamente usar a si mesmo

02:12:17.840 --> 02:12:22.490
que resolvem esse problema fazendo o equivalente a dizer enquanto David's

02:12:22.490 --> 02:12:26.360
como o contador está em processo de atualização, mantenha Carter afastado,

02:12:26.360 --> 02:12:29.510
idealmente brevemente, e então deixe seus dados passarem também.

02:12:29.510 --> 02:12:32.240
É equivalente também a colocar um bilhete ou um cadeado na geladeira.

02:12:32.240 --> 02:12:33.920
E, de fato, quero dizer bloqueio literalmente.

02:12:33.920 --> 02:12:36.380
Eles foram uma vez chamados e ainda

02:12:36.380 --> 02:12:41.480
em alguns contextos também são chamados de bloqueios em bancos de dados.

02:12:41.480 --> 02:12:44.730
E o código para o qual você pode fazer isso é quase o mesmo.

02:12:44.730 --> 02:12:51.860
Você simplesmente agrupa as três consultas com uma instrução de transação e um commit.

02:12:51.860 --> 02:12:57.800
E o termo da arte aqui é que isso torna suas declarações atômicas.

02:12:57.800 --> 02:13:01.230
Portanto, atômico significa que eles são todos executados ou não são executados.

02:13:01.230 --> 02:13:04.340
Ou seja, eles estão todos muito bem acoplados sem interrupção.

02:13:04.340 --> 02:13:08.480
As transações resolvem esse problema e evitam ter dois galões de leite.

02:13:08.480 --> 02:13:11.360
E o último problema que surge é tragicamente

02:13:11.360 --> 02:13:14.510
tão comum no mundo real hoje é

02:13:14.510 --> 02:13:16.173
o que é chamado de ataque de injeção SQL.

02:13:16.173 --> 02:13:18.590
E é a isso que aludi anteriormente com o ponto de interrogação.

02:13:18.590 --> 02:13:20.298
Suponha que você tenha o hábito de registrar

02:13:20.298 --> 02:13:23.240
nos sites de Yale com seu ID de rede ou senha

02:13:23.240 --> 02:13:25.950
ou em Harvard, sua chave e senha de Harvard também.

02:13:25.950 --> 02:13:28.370
Suponha, para fins de discussão, que as pessoas que

02:13:28.370 --> 02:13:32.360
O login de chave de Harvard implementado permite que você digite seu endereço de e-mail,

02:13:32.360 --> 02:13:33.680
claro, e sua senha.

02:13:33.680 --> 02:13:37.160
Mas suponha que eles estejam usando SQL sob o capô

02:13:37.160 --> 02:13:39.770
para verificar seu nome de usuário e senha para ter certeza

02:13:39.770 --> 02:13:43.400
que você é David Malan ou Carter Zenke ou quem você diz ser.

02:13:43.400 --> 02:13:48.770
Ainda não mostrei a sintaxe, mas acontece que no SQL, --

02:13:48.770 --> 02:13:51.410
é uma forma especial de indicar um comentário.

02:13:51.410 --> 02:13:53.100
Significa ignorar tudo à direita.

02:13:53.100 --> 02:13:57.080
Então é como // em C ou o símbolo de hash em Python.

02:13:57.080 --> 02:13:59.430
-- apenas significa ignorar tudo à direita.

02:13:59.430 --> 02:14:01.440
E nós, é claro, vimos aspas simples.

02:14:01.440 --> 02:14:04.730
Então, uma maneira de travar um ataque de injeção de SQL

02:14:04.730 --> 02:14:08.870
é tentar injetar código SQL malicioso no banco de dados de outra pessoa

02:14:08.870 --> 02:14:10.220
sem que eles percebam.

02:14:10.220 --> 02:14:11.220
Como você faz isso?

02:14:11.220 --> 02:14:15.492
Bem, suponha que eu faça login como malan@harvard.edu aspas simples,

02:14:15.492 --> 02:14:16.316
traço.

02:14:16.316 --> 02:14:20.510
Não estou citando nada claramente e não há nada à direita

02:14:20.510 --> 02:14:21.770
do --

02:14:21.770 --> 02:14:23.150
de qualquer forma.

02:14:23.150 --> 02:14:25.500
Mas esse desequilíbrio vai ser útil.

02:14:25.500 --> 02:14:26.000
Por que?

02:14:26.000 --> 02:14:29.630
Porque se eu sou um hacker e estou presumindo que alguém em Harvard provavelmente

02:14:29.630 --> 02:14:33.680
está usando aspas simples para agrupar o endereço de e-mail do usuário

02:14:33.680 --> 02:14:38.360
e envolva a senha do usuário, e se eu tentar completar o pensamento deles

02:14:38.360 --> 02:14:40.370
e fechar uma dessas citações para eles?

02:14:40.370 --> 02:14:41.850
O que pode acontecer?

02:14:41.850 --> 02:14:43.220
Bem, nós poderíamos fazer isso.

02:14:43.220 --> 02:14:46.250
Aqui, por exemplo, deixe-me supor que é o código que Harvard escreveu,

02:14:46.250 --> 02:14:48.050
espero que não, debaixo do capô.

02:14:48.050 --> 02:14:51.500
Então, eles estão usando a biblioteca do CS50 em Python e estão usando SQL dentro.

02:14:51.500 --> 02:14:54.350
Suponha que eles tenham uma consulta como esta.

02:14:54.350 --> 02:15:00.380
Selecione a estrela dos usuários onde o nome de usuário é igual ao ponto de interrogação e senha

02:15:00.380 --> 02:15:01.315
é igual a ponto de interrogação.

02:15:01.315 --> 02:15:04.190
E então suponha que eles apenas conectem qualquer nome de usuário e senha

02:15:04.190 --> 02:15:05.070
digitado.

02:15:05.070 --> 02:15:08.090
E então, se eles retornarem algum número de linhas ponto ponto ponto,

02:15:08.090 --> 02:15:09.410
eles assumem que eu sou David.

02:15:09.410 --> 02:15:12.200
Eles assumem que Carter é Carter se tanto o nome de usuário quanto a senha forem

02:15:12.200 --> 02:15:12.890
no banco de dados.

02:15:12.890 --> 02:15:14.480
Apenas fim da história lá.

02:15:14.480 --> 02:15:15.680
Isso é bom.

02:15:15.680 --> 02:15:18.750
Isso tem o espaço reservado do ponto de interrogação, como discutimos anteriormente.

02:15:18.750 --> 02:15:21.140
Mas e se você não se lembrar disso?

02:15:21.140 --> 02:15:24.670
Você não leva isso muito a sério e usa sua última semana mais familiar

02:15:24.670 --> 02:15:28.690
fstrings em que usamos essas chaves para inserir valores.

02:15:28.690 --> 02:15:30.280
E se você fizer isso em vez disso?

02:15:30.280 --> 02:15:31.900
Então é quase a mesma ideia.

02:15:31.900 --> 02:15:34.950
Ainda é db execute, mas agora é select star dos usuários

02:15:34.950 --> 02:15:36.120
onde nome de usuário é igual.

02:15:36.120 --> 02:15:39.570
E agora observe que estou usando aspas simples, que são exigidas pelo SQL,

02:15:39.570 --> 02:15:41.850
mas estou usando fstrings com chaves.

02:15:41.850 --> 02:15:46.530
E a senha é igual à senha de aspas simples e, em seguida, fecha aspas simples.

02:15:46.530 --> 02:15:50.910
O problema é se você está apenas colando cegamente de forma eficaz

02:15:50.910 --> 02:15:55.530
a entrada do usuário nesse formulário da web no campo de nome de usuário e a senha

02:15:55.530 --> 02:15:59.890
campo, não há nada que impeça um usuário mal-intencionado, aluno, professor,

02:15:59.890 --> 02:16:03.090
pessoal de incluir uma única citação em seu nome.

02:16:03.090 --> 02:16:07.470
Ou talvez até benevolentemente se o nome deles acontecer

02:16:07.470 --> 02:16:10.440
ter uma única aspa, como alguns sobrenomes em particular.

02:16:10.440 --> 02:16:12.230
Então isso é muito frágil.

02:16:12.230 --> 02:16:12.730
Por que?

02:16:12.730 --> 02:16:15.090
Bem, suponha que se conectarmos meu malicioso,

02:16:15.090 --> 02:16:18.030
malan@harvard.edu aspas simples --

02:16:18.030 --> 02:16:20.430
observe o que acontece com o nome de usuário aqui.

02:16:20.430 --> 02:16:23.940
A variável de nome de usuário dentro das aspas

02:16:23.940 --> 02:16:26.340
será substituído por este.

02:16:26.340 --> 02:16:29.880
E observe aspas simples, que o programador de Harvard escreveu,

02:16:29.880 --> 02:16:35.969
malan@harvard.edu citação única que escrevi --

02:16:35.969 --> 02:16:40.170
que escrevi entre aspas simples que Harvard escreveu e o que mais

02:16:40.170 --> 02:16:41.160
eles querem depois disso.

02:16:41.160 --> 02:16:43.524
Qual é a implicação, porém, do traço, traço?

02:16:46.722 --> 02:16:48.680
Tudo à direita será ignorado.

02:16:48.680 --> 02:16:51.730
Portanto, a senha nunca é verificada neste cenário.

02:16:51.730 --> 02:16:55.855
Estou enganando o servidor para que ignore tudo após o --

02:16:55.855 --> 02:17:00.650
mas eu construí muito habilmente, muito maliciosamente um sintaticamente válido

02:17:00.650 --> 02:17:01.150
consulta.

02:17:01.150 --> 02:17:01.650
Por que?

02:17:01.650 --> 02:17:03.580
Porque eu forneci a aspa simples que é

02:17:03.580 --> 02:17:06.670
vai terminar o pensamento dessa primeira citação simples.

02:17:06.670 --> 02:17:09.219
E agora eu só saberia fazer isso se visse o código

02:17:09.219 --> 02:17:12.209
ou se eu tentar colocar apóstrofos aleatoriamente em formulários da web

02:17:12.209 --> 02:17:13.209
e veja se as coisas quebram.

02:17:13.209 --> 02:17:15.215
Geralmente é assim que os adversários atacam os sistemas.

02:17:15.215 --> 02:17:17.590
Eles digitam caracteres potencialmente perigosos, pressionam Enter.

02:17:17.590 --> 02:17:20.510
Se algo quebrar, eles não estão necessariamente no sistema,

02:17:20.510 --> 02:17:22.757
mas eles sabem que pode haver uma vulnerabilidade.

02:17:22.757 --> 02:17:25.340
E então eles começam a tentar coisas mais metodicamente como esta.

02:17:25.340 --> 02:17:27.850
Então isso aí vai ser ruim, porque efetivamente

02:17:27.850 --> 02:17:29.500
esmaece o restante da consulta.

02:17:29.500 --> 02:17:32.889
E esta consulta certamente retornará algumas linhas

02:17:32.889 --> 02:17:34.570
mesmo sem saber minha senha.

02:17:34.570 --> 02:17:37.450
E então esta lógica aqui ponto ponto ponto significa, bem,

02:17:37.450 --> 02:17:39.850
se um dado voltasse desta consulta, Harvard

02:17:39.850 --> 02:17:43.480
presumivelmente vai presumir que Malan se conectou.

02:17:43.480 --> 02:17:47.840
Mostre a ele sua conta ou o que quer que esteja sendo protegido aqui.

02:17:47.840 --> 02:17:50.559
Resumindo, usar fstrings é ruim.

02:17:50.559 --> 02:17:54.280
Usando qualquer equivalente como %s em C, ruim.

02:17:54.280 --> 02:17:56.559
Quando se trata de SQL, usando pontos de interrogação

02:17:56.559 --> 02:18:00.280
ou o que uma biblioteca de terceiros como o CS50 prescrever

02:18:00.280 --> 02:18:02.110
é a forma de resolver isso.

02:18:02.110 --> 02:18:02.620
Por que?

02:18:02.620 --> 02:18:07.540
Porque bibliotecas como a nossa são projetadas para serem pelo menos inteligentes e paranóicas.

02:18:07.540 --> 02:18:09.740
E o que faremos é isso.

02:18:09.740 --> 02:18:12.580
Quando você usa os pontos de interrogação e os valores são inseridos,

02:18:12.580 --> 02:18:16.660
vamos escapar de quaisquer personagens potencialmente perigosos

02:18:16.660 --> 02:18:18.520
dentro desses espaços reservados.

02:18:18.520 --> 02:18:21.580
E assim efetivamente, a aspa simples não será mais

02:18:21.580 --> 02:18:23.469
ser considerada uma aspa simples gramatical.

02:18:23.469 --> 02:18:26.870
Será apenas literalmente um caractere no nome de usuário ou senha.

02:18:26.870 --> 02:18:30.040
Então a biblioteca cuida disso para você

02:18:30.040 --> 02:18:33.500
porque você está inserindo o nome de usuário e a senha como argumentos separados.

02:18:33.500 --> 02:18:37.360
E então nós ou o terceiro que você está usando realmente higienizamos.

02:18:37.360 --> 02:18:41.510
Isso é limpar os dados e evitar esses caracteres ruins.

02:18:41.510 --> 02:18:44.650
Agora, isso é uma espécie de meme da internet que circulou por um tempo.

02:18:44.650 --> 02:18:47.320
Se você já dirigiu um carro ou esteve em um carro

02:18:47.320 --> 02:18:49.930
onde estão os leitores automáticos de portagens.

02:18:49.930 --> 02:18:52.969
Essa pessoa achou que seria engraçado tentar fazer algo assim.

02:18:52.969 --> 02:18:54.309
O que eles provavelmente estão fazendo?

02:18:54.309 --> 02:18:57.520
A presunção aqui é, se funcionou ou não, não está claro,

02:18:57.520 --> 02:19:01.570
é que aqui está o final do número real da placa,

02:19:01.570 --> 02:19:03.903
mas aqui está uma citação simples interessante e um ponto e vírgula.

02:19:03.903 --> 02:19:06.070
Isso é especialmente ruim porque significa que talvez você possa

02:19:06.070 --> 02:19:08.059
executar uma segunda consulta no banco de dados.

02:19:08.059 --> 02:19:11.170
Isso é alguém se divertindo tentando descartar todo o banco de dados

02:19:11.170 --> 02:19:16.090
tabela para qualquer município está digitalizando através de câmeras sua licença

02:19:16.090 --> 02:19:16.750
código da placa.

02:19:16.750 --> 02:19:19.150
E eu seria negligente se não terminássemos com esta nota.

02:19:19.150 --> 02:19:22.240
Pelo menos nos círculos da ciência da computação, há

02:19:22.240 --> 02:19:26.920
é alguém nomeado, sem relação com o nome TF que colocamos no banco de dados anteriormente,

02:19:26.920 --> 02:19:31.660
Little Bobby Tables, que termina com este quadrinho XKCD.

02:19:31.660 --> 02:19:36.340
E se você rir, se você rir, agora você é um legítimo programador SQL.

02:19:39.049 --> 02:19:42.030
Legal legal.

02:19:42.030 --> 02:19:44.740
Todo aluno de CS conhece a pequena Bobby Table.

02:19:44.740 --> 02:19:47.657
Então, se você nomear o pequeno Bobby Tables agora, você está dentro.

02:19:47.657 --> 02:19:49.240
Tudo bem, é isso por hoje.

02:19:49.240 --> 02:19:51.780
Nos vemos na próxima vez.

02:19:51.780 --> 02:19:55.130
[MÚSICA, TOCANDO]