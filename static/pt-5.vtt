WEBVTT

00:00:00.000 --> 00:00:01.992
[MÚSICA, TOCANDO]

00:01:12.587 --> 00:01:13.670
DAVID J. MALAN: Tudo bem.

00:01:13.670 --> 00:01:15.200
Este é CS50.

00:01:15.200 --> 00:01:20.270
E esta é a quinta semana, que será nossa última semana em C. Mas o que

00:01:20.270 --> 00:01:22.265
isso significa que teremos OK--

00:01:22.265 --> 00:01:25.470
[TODOS E APLAUSOS]

00:01:25.470 --> 00:01:28.500
Mas com esta semana, com a semana passada e realmente todas as semanas

00:01:28.500 --> 00:01:30.330
antes, você esperava adquirir,

00:01:30.330 --> 00:01:33.527
se devagar e com algum desafio, alguma construção fundamental

00:01:33.527 --> 00:01:35.610
blocos que ainda vão fundamentar tudo

00:01:35.610 --> 00:01:38.370
continuamos fazendo no semestre, mesmo durante a transição

00:01:38.370 --> 00:01:40.140
às chamadas linguagens de nível superior.

00:01:40.140 --> 00:01:43.260
Na próxima semana, de fato, apresentaremos o Python, uma linguagem muito popular que

00:01:43.260 --> 00:01:45.660
não tem ponteiros, não tem memória

00:01:45.660 --> 00:01:47.220
gestão a este nível muito baixo.

00:01:47.220 --> 00:01:49.290
Mas isso é só porque outra pessoa escreveu

00:01:49.290 --> 00:01:50.880
o código que fará isso por você.

00:01:50.880 --> 00:01:52.553
E vai facilitar a nossa vida.

00:01:52.553 --> 00:01:55.470
Porque significa quando você quer resolver um problema conceitualmente aqui

00:01:55.470 --> 00:01:58.140
para apenas fazer um trabalho real ou construir algo incrível,

00:01:58.140 --> 00:02:00.240
você não precisa realmente entrar nas mesmas ervas daninhas

00:02:00.240 --> 00:02:03.390
como fizemos deliberadamente esta semana e agora na última.

00:02:03.390 --> 00:02:06.600
Mas, em última análise, o objetivo é que você entenda melhor e possa

00:02:06.600 --> 00:02:10.560
aproveite então tudo o que um computador pode fazer mesmo nessas linguagens de nível superior.

00:02:10.560 --> 00:02:12.480
Então, hoje, vamos nos concentrar particularmente

00:02:12.480 --> 00:02:16.170
em estruturas de dados, como você pode estruturar seus dados na memória, quais

00:02:16.170 --> 00:02:19.500
realmente equivale a construir coisas digitalmente, costurando

00:02:19.500 --> 00:02:22.405
ideias e conceitos na memória usando este novo edifício

00:02:22.405 --> 00:02:24.780
bloco da semana passada, que obviamente são esses ponteiros.

00:02:24.780 --> 00:02:28.680
Os ponteiros permitem que você armazene endereços na memória, como em variáveis.

00:02:28.680 --> 00:02:32.040
Mas com esses endereços simples podemos deixar essas migalhas de pão.

00:02:32.040 --> 00:02:33.600
Podemos apontar daqui para lá.

00:02:33.600 --> 00:02:36.792
E podemos unir conceitualmente pedaços de dados.

00:02:36.792 --> 00:02:39.000
Mas haverá maneiras diferentes de fazer isso.

00:02:39.000 --> 00:02:41.010
E hoje vamos nos concentrar primeiro no que é geralmente

00:02:41.010 --> 00:02:42.960
conhecido como um tipo de dado abstrato.

00:02:42.960 --> 00:02:46.110
E semelhante a um tipo em C de forma mais geral, ele realmente

00:02:46.110 --> 00:02:47.250
tem algumas propriedades nele.

00:02:47.250 --> 00:02:50.520
Mas os detalhes de implementação subjacentes de um tipo de dados abstrato

00:02:50.520 --> 00:02:52.170
dependem de você.

00:02:52.170 --> 00:02:55.080
Ou seja, um tipo de dado abstrato pode representar uma coisa

00:02:55.080 --> 00:02:56.310
e pode fazer algo.

00:02:56.310 --> 00:03:00.420
Mas como você o implementa permite alguma discrição sob o capô.

00:03:00.420 --> 00:03:03.210
Assim, por exemplo, no mundo da ciência da computação,

00:03:03.210 --> 00:03:05.550
uma fila é, na verdade, um termo técnico.

00:03:05.550 --> 00:03:09.360
Este é um tipo de estrutura de dados que teoricamente poderíamos construir no código

00:03:09.360 --> 00:03:11.250
em C ou realmente qualquer outro idioma.

00:03:11.250 --> 00:03:14.800
Mas uma fila tem propriedades como as filas do mundo real.

00:03:14.800 --> 00:03:16.950
Por exemplo, se você já fez fila para algo

00:03:16.950 --> 00:03:21.060
para obter comida em um restaurante, ou ir a uma loja,

00:03:21.060 --> 00:03:24.540
ou espere o aeroporto liberá-lo, bem, você está na fila.

00:03:24.540 --> 00:03:26.250
Uma fila sendo algum tipo de linha.

00:03:26.250 --> 00:03:30.030
Mas o que é notável sobre as filas são propriedades específicas.

00:03:30.030 --> 00:03:34.920
Eles são estruturas de dados primeiro a entrar, primeiro a sair, virtualmente

00:03:34.920 --> 00:03:36.030
ou no mundo humano.

00:03:36.030 --> 00:03:38.370
Ou seja, a primeira pessoa na fila

00:03:38.370 --> 00:03:40.657
idealmente deve ser servido primeiro no restaurante.

00:03:40.657 --> 00:03:43.740
Ou a primeira pessoa na fila deve passar primeiro pela segurança do aeroporto.

00:03:43.740 --> 00:03:46.650
Por outro lado, se não fosse o primeiro a entrar, primeiro a sair,

00:03:46.650 --> 00:03:48.930
você pode imaginar o quão frustrado você ficaria

00:03:48.930 --> 00:03:51.223
se você tem essa injustiça inerente.

00:03:51.223 --> 00:03:54.390
Na verdade, se você já esteve na fila de uma loja, supermercado ou algo parecido,

00:03:54.390 --> 00:03:56.460
e de repente eles talvez abram uma nova linha.

00:03:56.460 --> 00:03:59.910
E agora a pessoa atrás de você pode cortar e seguir em frente.

00:03:59.910 --> 00:04:02.730
Isso porque eles quebraram o conceito de fila.

00:04:02.730 --> 00:04:06.750
Portanto, tem esse potencial inerente de injustiça, a menos que você mantenha

00:04:06.750 --> 00:04:09.310
esta propriedade é a primeira a entrar, a primeira a sair.

00:04:09.310 --> 00:04:12.570
Isso também seria verdade para uma lista de tarefas, apenas para fins de produtividade.

00:04:12.570 --> 00:04:16.815
Se você tem o hábito de fazer uma lista de tarefas no papel ou virtualmente, o ideal é

00:04:16.815 --> 00:04:18.690
você provavelmente quer passar pelo topo da lista

00:04:18.690 --> 00:04:21.120
para baixo para que você realmente obtenha as primeiras coisas que você

00:04:21.120 --> 00:04:25.140
pensamento feito primeiro, em vez de sempre focar no seu pensamento mais recente.

00:04:25.140 --> 00:04:28.230
Agora, no mundo das filas, geralmente

00:04:28.230 --> 00:04:31.300
duas operações, duas funções, se preferir,

00:04:31.300 --> 00:04:34.290
que qualquer fila teria no mundo real ou no virtual.

00:04:34.290 --> 00:04:38.280
Enqueue é geralmente o termo técnico para significar adicionar algo a uma fila.

00:04:38.280 --> 00:04:41.610
Mas, especificamente, significa adicioná-lo ao final da fila

00:04:41.610 --> 00:04:44.610
para que ninguém fure a fila, por exemplo, para ir na frente.

00:04:44.610 --> 00:04:46.380
E então desenfileirar é exatamente o oposto.

00:04:46.380 --> 00:04:48.480
Quando é hora da primeira pessoa da fila

00:04:48.480 --> 00:04:51.970
para ser atendido, o tempo para a primeira pessoa da fila passar pela segurança,

00:04:51.970 --> 00:04:54.040
eles estão desenfileirados, por assim dizer.

00:04:54.040 --> 00:04:57.600
Portanto, um conceito técnico, em última análise, conforme é implementado no código.

00:04:57.600 --> 00:04:59.760
Mas é realmente apenas um conceito do mundo real.

00:04:59.760 --> 00:05:02.670
E estes estão em contraste com outro tipo de dados abstratos

00:05:02.670 --> 00:05:04.560
que podemos chamar de pilha.

00:05:04.560 --> 00:05:08.370
E uma pilha, muito parecida com uma pilha de bandejas no refeitório

00:05:08.370 --> 00:05:10.698
tem propriedades fundamentalmente diferentes.

00:05:10.698 --> 00:05:13.740
Você ainda pode adicionar e remover coisas deles, mas considere o que acontece.

00:05:13.740 --> 00:05:16.980
Sempre que limpam todas as bandejas do refeitório ou refeitório,

00:05:16.980 --> 00:05:20.410
eles colocam uma das bandejas aqui e depois a próxima em cima dela.

00:05:20.410 --> 00:05:22.810
E então o próximo em cima disso, isso, isso, e assim por diante.

00:05:22.810 --> 00:05:24.810
Mas é claro, qual bandeja você presumivelmente

00:05:24.810 --> 00:05:28.740
tomar como usuário dessa pilha física?

00:05:28.740 --> 00:05:30.662
O de cima, presumivelmente.

00:05:30.662 --> 00:05:33.120
Você não vai se atrapalhar aqui e tentar puxar um para fora.

00:05:33.120 --> 00:05:35.328
E assim, isso parece ter uma propriedade oposta.

00:05:35.328 --> 00:05:40.292
LIFO, last in first out é o que caracteriza algo como uma pilha.

00:05:40.292 --> 00:05:42.750
E isso só faz sentido, certamente, no mundo físico

00:05:42.750 --> 00:05:45.083
de empilhar todas aquelas bandejas do refeitório porque simplesmente

00:05:45.083 --> 00:05:47.730
faz mais sentido pegar o mais recente

00:05:47.730 --> 00:05:50.580
adicionado um, o último adicionado primeiro.

00:05:50.580 --> 00:05:53.070
E pelo menos nesse contexto, as bandejas não necessariamente

00:05:53.070 --> 00:05:54.905
importa em que ordem eles são usados.

00:05:54.905 --> 00:05:57.030
Mas mesmo assim, você pode imaginar que talvez haja

00:05:57.030 --> 00:05:59.910
alguma velha bandeja suja e nojenta bem no fundo que

00:05:59.910 --> 00:06:03.330
nunca é usado porque você está constantemente reabastecendo a pilha.

00:06:03.330 --> 00:06:07.200
Portanto, pode muito bem haver efeitos colaterais desses tipos de recursos.

00:06:07.200 --> 00:06:09.990
Você pode estar familiarizado com o uso do Gmail, por exemplo, ou realmente

00:06:09.990 --> 00:06:11.340
qualquer programa de e-mail.

00:06:11.340 --> 00:06:14.710
O que você está vendo na sua caixa de entrada é tecnicamente uma pilha,

00:06:14.710 --> 00:06:16.710
pelo menos se você deixou os padrões configurados.

00:06:16.710 --> 00:06:17.210
Por que?

00:06:17.210 --> 00:06:18.180
Você recebe um novo e-mail?

00:06:18.180 --> 00:06:19.080
Onde isso vai parar?

00:06:19.080 --> 00:06:22.600
Não cinco páginas de e-mails depois, presumivelmente bem no topo.

00:06:22.600 --> 00:06:25.600
E o próximo está bem no topo, bem no topo, bem no topo.

00:06:25.600 --> 00:06:27.850
E assim, se você é como eu, você é culpado de eventualmente

00:06:27.850 --> 00:06:29.110
perder o controle de alguns e-mails.

00:06:29.110 --> 00:06:29.610
Por que?

00:06:29.610 --> 00:06:32.430
Porque você colocou muito mais e-mails na pilha

00:06:32.430 --> 00:06:35.730
que você perde a noção das coisas que conseguiu primeiro.

00:06:35.730 --> 00:06:37.543
Último a entrar primeiro a sair, porém, é mantido.

00:06:37.543 --> 00:06:40.710
O e-mail mais recente que você recebe pode muito bem ser o primeiro a ser respondido.

00:06:40.710 --> 00:06:43.950
Mas isso não é necessariamente bom para a capacidade de resposta a todos

00:06:43.950 --> 00:06:45.160
mais lá fora.

00:06:45.160 --> 00:06:50.700
Da mesma forma, se você armazenar todos os seus suéteres em uma pilha como esta,

00:06:50.700 --> 00:06:53.610
como uma pilha de pretos, abaixo dos quais há um vermelho e depois um azul.

00:06:53.610 --> 00:06:56.160
Stack pode ser perfeitamente adequado para manter as coisas organizadas.

00:06:56.160 --> 00:06:59.490
É a maneira sensata de fazer isso se você tiver apenas uma prateleira em seu dormitório ou em casa.

00:06:59.490 --> 00:07:02.160
Mas o que vai ser um efeito colateral de usar uma pilha

00:07:02.160 --> 00:07:06.270
para guardar seus suéteres, se houver, dessa maneira, em vez de

00:07:06.270 --> 00:07:07.770
para uma fila?

00:07:07.770 --> 00:07:08.790
Sim.

00:07:08.790 --> 00:07:10.275
AUDIÊNCIA: É mais difícil conseguir os vermelhos e os azuis?

00:07:10.275 --> 00:07:11.830
DAVID J. MALAN: É mais difícil conseguir os vermelhos e os azuis.

00:07:11.830 --> 00:07:15.010
Então, presumivelmente, você usará com muito mais frequência, por exemplo,

00:07:15.010 --> 00:07:16.950
se você quiser, preto em vez disso.

00:07:16.950 --> 00:07:19.920
Agora, as operações para adicionar coisas a uma pilha

00:07:19.920 --> 00:07:22.920
são semelhantes em espírito, mas apenas vocabulário diferente.

00:07:22.920 --> 00:07:25.950
Você empurra algo no topo de uma pilha.

00:07:25.950 --> 00:07:28.920
Mesmo que seja mais como no mundo da bandeja você coloca ou descansa.

00:07:28.920 --> 00:07:31.410
Mas empurrar significa adicionar algo ao topo da pilha.

00:07:31.410 --> 00:07:36.370
E estourar significa remover algo também do topo da pilha.

00:07:36.370 --> 00:07:40.590
Então não é questão de enfileirar no final e desenfileirar no começo.

00:07:40.590 --> 00:07:42.960
Com uma pilha, tudo acontece no topo.

00:07:42.960 --> 00:07:46.140
Você está empurrando para o topo e, em seguida, saindo do topo.

00:07:46.140 --> 00:07:49.480
Agora, quando se trata de código real, como podemos implementar algo assim?

00:07:49.480 --> 00:07:51.600
Bem, vamos nos concentrar em como você pode

00:07:51.600 --> 00:07:53.250
implementar a própria estrutura de dados.

00:07:53.250 --> 00:07:54.870
E não vamos implementar nenhuma função.

00:07:54.870 --> 00:07:57.360
Você pode implementar a noção de uma pilha como esta.

00:07:57.360 --> 00:07:58.620
Já vimos typedef antes.

00:07:58.620 --> 00:08:00.930
Significa apenas definir um novo tipo próprio.

00:08:00.930 --> 00:08:03.430
Struct significa aqui vem uma estrutura, também conhecida como

00:08:03.430 --> 00:08:06.780
uma estrutura de dados de uma ou mais variáveis ​​dentro.

00:08:06.780 --> 00:08:11.610
E vamos supor, como da última vez, tivemos-- já definimos os dados de uma pessoa

00:08:11.610 --> 00:08:13.110
digite usando um typedef separado.

00:08:13.110 --> 00:08:15.870
E cada pessoa tem um nome e um número ou algo assim.

00:08:15.870 --> 00:08:18.330
Deixe-me apenas estipular que essa pessoa já existe.

00:08:18.330 --> 00:08:20.670
Então, aqui, você pode ter que implementar uma pilha,

00:08:20.670 --> 00:08:24.390
uma matriz chamada pessoas de alguma capacidade.

00:08:24.390 --> 00:08:28.450
Talvez seja um array de tamanho 10, ou 100, ou o que for.

00:08:28.450 --> 00:08:30.810
Isso é uma constante aqui nesse contexto, capacidade.

00:08:30.810 --> 00:08:34.320
E cada elemento nesse array é uma estrutura de pessoa.

00:08:34.320 --> 00:08:37.270
E agora eu tenho isso também, tamanho.

00:08:37.270 --> 00:08:39.990
Agora, isso quase parece um sinônimo de capacidade.

00:08:39.990 --> 00:08:44.010
Mas talvez intuitivamente, alguém queira propor por que estou aparentemente

00:08:44.010 --> 00:08:47.010
mantendo separadamente a capacidade da pilha

00:08:47.010 --> 00:08:49.440
mas também o tamanho da pilha?

00:08:49.440 --> 00:08:52.720
Por que essas duas distinções aqui?

00:08:52.720 --> 00:08:53.800
Sim.

00:08:53.800 --> 00:08:57.515
AUDIÊNCIA: A capacidade é a altura que a pilha pode ter.

00:08:57.515 --> 00:08:58.390
DAVID J. MALAN: Sim.

00:08:58.390 --> 00:09:01.650
AUDIÊNCIA: Tamanho é o quão alto ele realmente está agora.

00:09:01.650 --> 00:09:02.650
DAVID J. MALAN: Perfeito.

00:09:02.650 --> 00:09:05.080
A capacidade é a altura que a pilha pode ter,

00:09:05.080 --> 00:09:09.550
como quanto espaço há para aqueles moletons no meu armário, por exemplo.

00:09:09.550 --> 00:09:12.590
Considerando que o tamanho é apenas literalmente neste momento no tempo,

00:09:12.590 --> 00:09:14.440
quantas camisolas estão na pilha.

00:09:14.440 --> 00:09:18.260
É capacidade ou menos presumivelmente no total lá.

00:09:18.260 --> 00:09:19.450
Então, o que é capacidade?

00:09:19.450 --> 00:09:22.360
Bem, poderíamos implementar isso talvez de uma maneira familiar.

00:09:22.360 --> 00:09:25.720
Eu poderia apenas definir um const em algum outro lugar no meu código do tipo int

00:09:25.720 --> 00:09:28.390
que apenas define a capacidade 50.

00:09:28.390 --> 00:09:30.550
Mas o que talvez seja a desvantagem

00:09:30.550 --> 00:09:34.030
de implementar uma pilha dessa maneira?

00:09:34.030 --> 00:09:37.120
De usar um array aqui dentro?

00:09:37.120 --> 00:09:42.190
Qual é a desvantagem agora de implementar uma pilha usando uma matriz e esse tamanho

00:09:42.190 --> 00:09:45.020
variável dentro.

00:09:45.020 --> 00:09:48.320
O que é uma ressalva aqui, talvez?

00:09:48.320 --> 00:09:48.900
Alguma mão?

00:09:48.900 --> 00:09:49.400
Sim.

00:09:49.400 --> 00:09:51.372
AUDIÊNCIA: [INAUDÍVEL]

00:09:51.600 --> 00:09:53.350
DAVID J. MALAN: Então vai ser mais difícil

00:09:53.350 --> 00:09:55.142
para alcançar elementos que não são os últimos.

00:09:55.142 --> 00:09:56.740
Esse é o adicionado mais recentemente.

00:09:56.740 --> 00:09:59.600
Portanto, pode haver alguns moletons, por assim dizer, bem abaixo.

00:09:59.600 --> 00:10:01.120
Então já vimos isso antes.

00:10:01.120 --> 00:10:03.640
Mas em algum momento também uma limitação deste design

00:10:03.640 --> 00:10:05.740
é o que vai ser finito.

00:10:05.740 --> 00:10:09.580
Posso colocar no máximo neste exemplo 50 moletons ou 50 e-mails,

00:10:09.580 --> 00:10:11.800
ou 50 bandejas de refeitório, o que é bom.

00:10:11.800 --> 00:10:13.600
Mas pelo menos é de fato finito.

00:10:13.600 --> 00:10:15.370
E pelo menos na memória do computador,

00:10:15.370 --> 00:10:19.010
pode ser bom usar mais, e mais, e mais, talvez à medida que mais coisas forem

00:10:19.010 --> 00:10:20.260
sendo adicionado ao computador.

00:10:20.260 --> 00:10:21.910
Então talvez eu faça isso 500.

00:10:21.910 --> 00:10:24.970
Ou diabos, por que não faço 5.000 ou 50.000?

00:10:24.970 --> 00:10:26.680
Bem, qual é o trade-off lá?

00:10:26.680 --> 00:10:30.040
Se eu quiser ter espaço suficiente para crescer, parece

00:10:30.040 --> 00:10:33.370
como se eu devesse aumentar o valor da capacidade infinitamente.

00:10:33.370 --> 00:10:39.480
Mas por que eu não quero mudar de 50 para 500, ou 5.000, ou 50.000?

00:10:39.480 --> 00:10:42.630
Qual é a desvantagem, talvez apenas intuitivamente?

00:10:42.630 --> 00:10:43.696
Sim.

00:10:43.696 --> 00:10:47.170
AUDIÊNCIA: Porque não quero mexer na memória que não deveria.

00:10:47.170 --> 00:10:48.280
DAVID J. MALAN: Você não quer mexer na memória que não é

00:10:48.280 --> 00:10:49.480
deveria estar tocando.

00:10:49.480 --> 00:10:52.810
E, neste caso, não seria... isso não seria um risco per se

00:10:52.810 --> 00:10:54.650
a menos que você realmente transborde a pilha.

00:10:54.650 --> 00:10:58.060
Mas há um problema relacionado ao solicitar tanta memória.

00:10:58.060 --> 00:11:00.520
Qual seria outra desvantagem?

00:11:00.520 --> 00:11:06.015
AUDIÊNCIA: Você só tem um elemento e você tem [INAUDÍVEL] 5.000 [INAUDÍVEL]..

00:11:06.015 --> 00:11:06.890
DAVID J. MALAN: Sim.

00:11:06.890 --> 00:11:07.910
[RISOS] Exatamente.

00:11:07.910 --> 00:11:10.160
Portanto, se você tem capacidade para 5.000 pessoas, mas está apenas

00:11:10.160 --> 00:11:14.030
usando um desses elementos, é estranho dizê-lo não tecnicamente.

00:11:14.030 --> 00:11:16.310
O que é apenas para dizer muito, muito desperdício.

00:11:16.310 --> 00:11:17.450
Isso é apenas um design ruim.

00:11:17.450 --> 00:11:19.760
Está correto, funcionará para até 5.000 elementos.

00:11:19.760 --> 00:11:23.030
Mas meu Deus, você está desperdiçando 4.999 vagas extras.

00:11:23.030 --> 00:11:25.280
E isso não vai acabar bem, especialmente se você estiver

00:11:25.280 --> 00:11:27.170
usando mais estruturas de dados na memória.

00:11:27.170 --> 00:11:29.720
Seu Mac, seu PC, seu telefone com certeza vai acabar

00:11:29.720 --> 00:11:31.220
de memória se você pedir tanto.

00:11:31.220 --> 00:11:33.830
Seria bom se houvesse um pouco mais de dinamismo,

00:11:33.830 --> 00:11:36.770
seja uma pilha ou uma fila, ambas

00:11:36.770 --> 00:11:39.080
pode ser implementado de forma um pouco semelhante em espírito.

00:11:39.080 --> 00:11:43.700
Mas vamos concluir esta abstração comparando-- graças a um amigo nosso,

00:11:43.700 --> 00:11:46.880
A professora Shannon Duvall, da Elon University, que gentilmente organizou

00:11:46.880 --> 00:11:50.030
esta animação gráfica com pouco menos de dois minutos de duração que pinta

00:11:50.030 --> 00:11:52.640
uma imagem desses dois tipos de estruturas de dados abstratas.

00:11:52.640 --> 00:11:57.050
E então vamos nos aprofundar em como podemos implementar problemas como esses.

00:11:57.050 --> 00:11:58.990
Se pudéssemos diminuir drasticamente as luzes.

00:11:58.990 --> 00:11:59.657
[REPRODUÇÃO DE VÍDEO]

00:11:59.657 --> 00:12:01.220
[MÚSICA, TOCANDO]

00:12:04.010 --> 00:12:06.920
- Era uma vez um cara chamado Jack.

00:12:06.920 --> 00:12:10.250
Quando se tratava de fazer amigos, Jack não tinha jeito.

00:12:10.250 --> 00:12:13.250
Então Jack foi falar com o cara mais popular que ele conhecia.

00:12:13.250 --> 00:12:15.920
Ele foi até Lou e perguntou, o que eu faço?

00:12:15.920 --> 00:12:18.410
Lou viu que seu amigo estava realmente aflito.

00:12:18.410 --> 00:12:21.020
Bem, começou Lou, olha só como você está vestido.

00:12:21.020 --> 00:12:23.630
Você não tem nenhuma roupa com um visual diferente?

00:12:23.630 --> 00:12:24.770
Sim, disse Jack.

00:12:24.770 --> 00:12:25.820
Eu com certeza faço.

00:12:25.820 --> 00:12:28.250
Venha até minha casa que eu mostro para você.

00:12:28.250 --> 00:12:29.540
Então eles foram para a casa de Jack.

00:12:29.540 --> 00:12:33.290
E Jack mostrou a Lou a caixa onde ele guardava todas as suas camisas e calças,

00:12:33.290 --> 00:12:34.250
em suas meias.

00:12:34.250 --> 00:12:37.280
Lou disse, vejo que você tem todas as suas roupas em uma pilha.

00:12:37.280 --> 00:12:39.800
Por que você não usa alguns outros de vez em quando?

00:12:39.800 --> 00:12:43.110
Jack disse, bem, quando eu tiro roupas e meias,

00:12:43.110 --> 00:12:45.710
Eu os lavo e guardo na caixa.

00:12:45.710 --> 00:12:48.260
Então vem a manhã seguinte e eu pulo.

00:12:48.260 --> 00:12:51.440
Vou até a caixa e tiro minhas roupas de cima.

00:12:51.440 --> 00:12:54.050
Lou rapidamente percebeu o problema com Jack.

00:12:54.050 --> 00:12:57.020
Ele guardava roupas, CDs e livros empilhados.

00:12:57.020 --> 00:12:59.480
Quando ele pegava algo para ler ou vestir,

00:12:59.480 --> 00:13:02.030
ele escolheu um livro top ou cueca.

00:13:02.030 --> 00:13:04.460
Então, quando terminasse, ele o colocaria de volta.

00:13:04.460 --> 00:13:06.980
Voltaria, no topo da pilha.

00:13:06.980 --> 00:13:09.440
Conheço a solução, disse um Lou triunfante.

00:13:09.440 --> 00:13:11.990
Você precisa aprender a começar a usar uma fila.

00:13:11.990 --> 00:13:14.840
Lou pegou as roupas de Jack e as pendurou em um armário.

00:13:14.840 --> 00:13:17.630
E quando ele esvaziou a caixa, ele simplesmente a jogou fora.

00:13:17.630 --> 00:13:21.560
Então ele disse, agora, Jack, no final do dia, coloque suas roupas à esquerda

00:13:21.560 --> 00:13:23.010
quando você os guarda.

00:13:23.010 --> 00:13:24.770
Então amanhã de manhã quando você ver o sol

00:13:24.770 --> 00:13:28.430
brilhe, pegue suas roupas da direita do final da fila.

00:13:28.430 --> 00:13:29.930
Você não vê? disse Lu.

00:13:29.930 --> 00:13:31.340
Vai ser tão bom.

00:13:31.340 --> 00:13:34.670
Você usará tudo uma vez antes de usar algo duas vezes.

00:13:34.670 --> 00:13:37.610
E com tudo em filas no armário e na estante,

00:13:37.610 --> 00:13:40.220
Jack começou a se sentir bastante seguro de si.

00:13:40.220 --> 00:13:44.603
Tudo graças a Lou e sua fila maravilhosa.

00:13:44.603 --> 00:13:45.477
[TERMINAR REPRODUÇÃO]

00:13:45.477 --> 00:13:46.560
DAVID J. MALAN: Tudo bem.

00:13:46.560 --> 00:13:46.890
[RISOS]

00:13:46.890 --> 00:13:47.557
AUDIÊNCIA: Ótimo!

00:13:47.557 --> 00:13:48.600
[APLAUSOS]

00:13:48.600 --> 00:13:49.890
DAVID J. MALAN: Claro.

00:13:49.890 --> 00:13:52.558
Isso mostra uma imagem dessas duas estruturas de dados abstratas.

00:13:52.558 --> 00:13:54.600
Mas se realmente mergulharmos sob o capô

00:13:54.600 --> 00:13:56.850
poderíamos implementá-los de várias maneiras diferentes.

00:13:56.850 --> 00:13:59.682
Mas eu realmente acho que precisamos de alguns blocos de construção através dos quais

00:13:59.682 --> 00:14:01.140
poderíamos resolver problemas como esses.

00:14:01.140 --> 00:14:03.220
E veremos hoje também, alguns outros também.

00:14:03.220 --> 00:14:06.983
Então, vamos voltar para a segunda semana quando implementamos - apresentamos a você

00:14:06.983 --> 00:14:08.400
à sua primeira estrutura de dados.

00:14:08.400 --> 00:14:09.330
Isso é uma matriz.

00:14:09.330 --> 00:14:12.630
E uma matriz, lembre-se, era apenas um pedaço de memória

00:14:12.630 --> 00:14:16.500
em que os elementos foram armazenados por design de volta para trás.

00:14:16.500 --> 00:14:19.800
É uma matriz de memória contígua especificamente.

00:14:19.800 --> 00:14:23.400
Então, com um array, certamente poderíamos armazenar não apenas uma coisa, mas duas,

00:14:23.400 --> 00:14:25.210
ou três, ou até mais.

00:14:25.210 --> 00:14:29.280
E assim, por exemplo, se tratarmos a memória do meu computador como esta abstração

00:14:29.280 --> 00:14:33.720
aqui, e retratados aqui estão três bytes ou alguma multiplicação deles,

00:14:33.720 --> 00:14:37.230
suponha que estamos armazenando na memória do computador um array de tamanho três,

00:14:37.230 --> 00:14:39.540
armazenar os dígitos um, dois e três.

00:14:39.540 --> 00:14:43.170
Bem, lembre-se de que, se diminuirmos o zoom na semana passada,

00:14:43.170 --> 00:14:44.880
há outras coisas acontecendo na memória.

00:14:44.880 --> 00:14:48.000
Portanto, mesmo se quisermos adicionar outro número a esse array

00:14:48.000 --> 00:14:51.360
que não pensamos quando iniciamos o programa, como o número

00:14:51.360 --> 00:14:54.340
quatro, o ideal seria colocá-lo aqui ao lado dele.

00:14:54.340 --> 00:14:55.900
Caso contrário, não é mais um array.

00:14:55.900 --> 00:14:57.650
Então, por definição, se estivermos usando um array,

00:14:57.650 --> 00:14:59.940
tem que terminar logo depois dos três.

00:14:59.940 --> 00:15:02.550
Mas o que mais está acontecendo dentro da memória do seu computador?

00:15:02.550 --> 00:15:04.740
Bem, supondo que seu programa tenha qualquer tamanho,

00:15:04.740 --> 00:15:06.870
e você tem outras variáveis, outras funções,

00:15:06.870 --> 00:15:09.420
você o administra há algum tempo, há muita coisa acontecendo.

00:15:09.420 --> 00:15:11.470
E sua memória está sendo usada e reutilizada.

00:15:11.470 --> 00:15:13.680
Então, por exemplo, em algum lugar na memória pode

00:15:13.680 --> 00:15:18.200
ser imediatamente adjacente a isso, Olá, vírgula, mundo, barra invertida zero,

00:15:18.200 --> 00:15:19.950
o caractere nulo, só porque talvez você

00:15:19.950 --> 00:15:22.230
tem outra variável em algum lugar lá que

00:15:22.230 --> 00:15:25.110
está armazenando essa string específica ao lado de seu existente

00:15:25.110 --> 00:15:26.183
matriz de tamanho três.

00:15:26.183 --> 00:15:28.350
E todos esses Oscar the Grouches aqui realmente apenas

00:15:28.350 --> 00:15:31.110
representam o que chamamos de valores de lixo da semana passada.

00:15:31.110 --> 00:15:33.660
Obviamente há pedaços lá porque eles não desaparecem.

00:15:33.660 --> 00:15:36.600
Eles sempre estarão dentro do computador implementado de alguma forma.

00:15:36.600 --> 00:15:38.700
Mas nós realmente não sabemos ou nos importamos com o que eles são.

00:15:38.700 --> 00:15:40.500
Eles são os restos desses bytes tendo

00:15:40.500 --> 00:15:44.440
sido usado para outras variáveis ​​mais antigas, chamadas de função anteriores ou similares.

00:15:44.440 --> 00:15:47.970
Mas o problema claramente aqui é que, OK, um, dois, três está aí.

00:15:47.970 --> 00:15:48.900
Mas o H está aqui.

00:15:48.900 --> 00:15:52.380
E a menos que eu queira começar a morder minha corda

00:15:52.380 --> 00:15:57.060
substituindo o H por um quatro, simplesmente não podemos encaixá-lo ali.

00:15:57.060 --> 00:15:59.440
E ainda, embora haja Oscars em todo o lugar,

00:15:59.440 --> 00:16:00.773
esses são de fato valores de lixo.

00:16:00.773 --> 00:16:04.132
E, portanto, poderíamos usar esse espaço porque tecnicamente não é utilizado.

00:16:04.132 --> 00:16:06.090
Nós simplesmente não sabemos ou nos importamos com quais são os valores.

00:16:06.090 --> 00:16:08.940
Então, onde eu poderia colocar um, dois, três, quatro?

00:16:08.940 --> 00:16:09.660
Bem, meu Deus.

00:16:09.660 --> 00:16:12.420
Eu tenho toda essa memória aqui que não é usada.

00:16:12.420 --> 00:16:16.830
Eu certamente poderia mudar esses valores de lixo para um, dois, três, quatro.

00:16:16.830 --> 00:16:21.720
Mas para fazer isso, talvez eu precise fazer um pouco de trabalho aqui.

00:16:21.720 --> 00:16:25.230
Não é só dizer bum e acontece.

00:16:25.230 --> 00:16:28.680
Agora com C e com código, eu teria que fazer isso um pouco mais metodicamente.

00:16:28.680 --> 00:16:31.410
Então deixe-me abstrair tudo o mais que é uma distração.

00:16:31.410 --> 00:16:35.208
Deixe-me assumir que há de fato pelo menos quatro bytes disponíveis para números,

00:16:35.208 --> 00:16:38.250
bem aqui que poderíamos colocá-los em vários lugares diferentes.

00:16:38.250 --> 00:16:44.230
O que está envolvido agora em mover o um, dois, três para este novo pedaço de memória

00:16:44.230 --> 00:16:45.423
então podemos somar os quatro?

00:16:45.423 --> 00:16:47.340
Bem, acho que conceitualmente teremos

00:16:47.340 --> 00:16:49.590
para copiar o do antigo para o novo.

00:16:49.590 --> 00:16:51.240
Copie os dois do antigo para o novo.

00:16:51.240 --> 00:16:53.130
Copie os três do antigo para o novo.

00:16:53.130 --> 00:16:56.070
E então, finalmente, podemos nos livrar da velha memória.

00:16:56.070 --> 00:16:59.160
Esses três bytes originais agora podem se parecer com Oscar the Grouch

00:16:59.160 --> 00:17:01.770
e apenas ser valores de lixo para todas as intenções e propósitos.

00:17:01.770 --> 00:17:06.630
Mas agora tenho espaço para um quarto byte onde posso colocar o número quatro.

00:17:06.630 --> 00:17:08.400
Então isso é legal.

00:17:08.400 --> 00:17:12.450
Mas qual é a desvantagem dessa abordagem?

00:17:12.450 --> 00:17:15.780
Qual é a desvantagem de resolver o problema dessa maneira, onde o problema em questão

00:17:15.780 --> 00:17:20.220
é apenas aumentar o array, por assim dizer, aumentar seu tamanho,

00:17:20.220 --> 00:17:23.750
para caber um ou mais números?

00:17:23.750 --> 00:17:26.240
Parece bastante direto.

00:17:26.240 --> 00:17:27.615
Mas sim.

00:17:27.615 --> 00:17:29.198
AUDIÊNCIA: Que está simplesmente fora de ordem.

00:17:29.198 --> 00:17:31.653
Você move o um, dois, três, quatro para o fundo.

00:17:31.653 --> 00:17:33.320
DAVID J. MALAN: Talvez esteja fora de ordem.

00:17:33.320 --> 00:17:36.445
Mas acho que está tudo bem porque a ordem é apenas relativa.

00:17:36.445 --> 00:17:38.525
Tanto tempo ainda é contíguo de volta, para trás,

00:17:38.525 --> 00:17:41.150
para voltar em um pedaço diferente de memória, acho que estamos bem lá.

00:17:41.150 --> 00:17:43.790
Não é como se eu tivesse mudado de quatro, três, dois, um.

00:17:43.790 --> 00:17:44.960
Mas um palpite razoável.

00:17:44.960 --> 00:17:45.855
Sim.

00:17:45.855 --> 00:17:47.635
AUDIÊNCIA: [INAUDÍVEL]

00:17:48.970 --> 00:17:50.020
DAVID J. MALAN: Sim.

00:17:50.020 --> 00:17:51.490
Eu realmente não planejei com antecedência aqui.

00:17:51.490 --> 00:17:53.990
Se eu tiver que adicionar outro número, como cinco ou qualquer outra coisa,

00:17:53.990 --> 00:17:56.198
bem, talvez eu tenha que passar por esses obstáculos novamente.

00:17:56.198 --> 00:17:58.240
Talvez eu tenha sorte e talvez haja espaço lá.

00:17:58.240 --> 00:18:00.850
Mas não se eu tiver outras variáveis ​​e outras coisas acontecendo,

00:18:00.850 --> 00:18:03.410
isso também pode ser usado em algum momento.

00:18:03.410 --> 00:18:04.420
Outros pensamentos?

00:18:04.420 --> 00:18:05.020
Sim.

00:18:05.020 --> 00:18:06.230
AUDIÊNCIA: Eficiência lenta.

00:18:06.230 --> 00:18:08.600
DAVID J. MALAN: Eficiência lenta, por quê?

00:18:08.600 --> 00:18:10.340
AUDIÊNCIA: [INAUDÍVEL]

00:18:10.815 --> 00:18:11.690
DAVID J. MALAN: Sim.

00:18:11.690 --> 00:18:13.920
Quero dizer, é apenas ineficiente.

00:18:13.920 --> 00:18:16.430
É um design ruim, sem dúvida.

00:18:16.430 --> 00:18:17.030
Por que?

00:18:17.030 --> 00:18:20.398
Porque eu tinha uma cópia de todo o meu trabalho original aqui.

00:18:20.398 --> 00:18:22.440
E como você notou, se eu quiser adicionar um quinto número,

00:18:22.440 --> 00:18:24.815
Vou ter que copiar de novo, e de novo, e de novo.

00:18:24.815 --> 00:18:27.770
E faça as coisas n vezes de novo e de novo.

00:18:27.770 --> 00:18:29.600
Agora, talvez isso seja necessário.

00:18:29.600 --> 00:18:30.640
Em breve veremos com certeza.

00:18:30.640 --> 00:18:33.890
Mas parece que isso não vai acabar bem, especialmente se o array não for

00:18:33.890 --> 00:18:36.440
de tamanho três ou quatro, mas 300, 400.

00:18:36.440 --> 00:18:40.490
Seu computador acaba gastando muito tempo apenas girando suas rodas.

00:18:40.490 --> 00:18:42.410
Quero dizer, honestamente, melhor pode ser isso.

00:18:42.410 --> 00:18:46.430
Se esta é a minha mesma matriz encarnada fisicamente agora, um, dois, três,

00:18:46.430 --> 00:18:48.120
está literalmente na ponta da prateleira.

00:18:48.120 --> 00:18:50.810
Portanto, não há espaço para o número quatro.

00:18:50.810 --> 00:18:53.660
Talvez onde possamos levar essa história é, bem, vamos apenas

00:18:53.660 --> 00:18:55.310
encontrar espaço para os quatro.

00:18:55.310 --> 00:18:58.220
Vamos colocar os quatro, por exemplo, aqui,

00:18:58.220 --> 00:19:01.790
substituindo algum valor de lixo disponível, algum byte sobressalente aqui.

00:19:01.790 --> 00:19:03.080
Mas agora, espere um minuto.

00:19:03.080 --> 00:19:06.140
Eu quebrei a definição de uma matriz.

00:19:06.140 --> 00:19:08.580
Não posso ter um, dois, três e depois quatro aqui.

00:19:08.580 --> 00:19:12.720
Então talvez possa haver um mecanismo se eu colocar isso de novo,

00:19:12.720 --> 00:19:14.990
onde quando você chegar ao final dos elementos existentes

00:19:14.990 --> 00:19:18.980
talvez eu apenas de alguma forma aponte digitalmente para a quarta matriz.

00:19:18.980 --> 00:19:22.700
E talvez possamos unir todos esses valores diferentes na memória

00:19:22.700 --> 00:19:25.220
de modo que, se você seguir as setas, por assim dizer,

00:19:25.220 --> 00:19:28.310
podemos reconstruir exatamente qual é a ordem

00:19:28.310 --> 00:19:32.030
sem ter que encontrar ou abrir espaço aqui ou pegar todos esses números

00:19:32.030 --> 00:19:33.990
e mova todos eles para lá.

00:19:33.990 --> 00:19:36.480
Então essa é talvez a direção em que iremos aqui.

00:19:36.480 --> 00:19:41.220
Então, vamos ver como podemos chegar a esse ponto da seguinte maneira.

00:19:41.220 --> 00:19:43.770
Deixe-me ir em frente e abrir, digamos, VS Code aqui.

00:19:43.770 --> 00:19:48.110
Deixe-me abrir um programa chamado list.c no meu terminal.

00:19:48.110 --> 00:19:51.740
E deixe-me ir em frente e criar um programa relativamente simples

00:19:51.740 --> 00:19:54.320
isso apenas demonstra o que fizemos na segunda semana

00:19:54.320 --> 00:19:56.400
quando introduzimos arrays como segue.

00:19:56.400 --> 00:20:00.590
Deixe-me incluir stdio.h para que possamos imprimir as coisas.

00:20:00.590 --> 00:20:02.480
Deixe-me fazer int main void.

00:20:02.480 --> 00:20:04.310
Nenhum argumento de linha de comando por enquanto.

00:20:04.310 --> 00:20:10.105
Deixe-me dar a mim mesmo uma matriz chamada lista de tamanho três.

00:20:10.105 --> 00:20:12.980
E vou codificar para mantê-lo simples para fins de leitura, cada

00:20:12.980 --> 00:20:14.438
dos quais será um número inteiro.

00:20:14.438 --> 00:20:16.970
E agora, só para termos alguns detalhes sobre os quais falar,

00:20:16.970 --> 00:20:19.670
deixe-me colocar o colchete de lista zero o número um,

00:20:19.670 --> 00:20:23.570
colchete de lista um o número dois, e colchete de lista dois o número três.

00:20:23.570 --> 00:20:27.680
Então, estou apenas traduzindo em código o que acabamos de ver pictoricamente na tela

00:20:27.680 --> 00:20:30.740
e também fisicamente aqui com esses números na mesa.

00:20:30.740 --> 00:20:33.570
Agora, vamos fazer algo levemente útil para isso.

00:20:33.570 --> 00:20:38.750
Que tal fazermos quatro int eu obtenho zero, i é menor que três, i mais, mais.

00:20:38.750 --> 00:20:41.030
Vamos apenas imprimir cada um desses números apenas

00:20:41.030 --> 00:20:43.250
para ter certeza de que eles estão realmente na memória como eu pretendia.

00:20:43.250 --> 00:20:47.240
Portanto, por cento i barra invertida n vírgula i e, em seguida, um ponto e vírgula.

00:20:47.240 --> 00:20:48.630
E acho que é isso por enquanto.

00:20:48.630 --> 00:20:49.820
Então nada de interessante.

00:20:49.820 --> 00:20:51.290
Nenhum problema resolvido ainda.

00:20:51.290 --> 00:20:52.470
Apenas uma prova de conceito.

00:20:52.470 --> 00:20:54.710
Para que agora, quando eu limpar meu terminal e executar

00:20:54.710 --> 00:20:59.090
listar sem erros aparentes no terminal.

00:20:59.090 --> 00:21:02.360
E assim, quando eu agora faço lista de barra de ponto, devo ver, espero que da esquerda

00:21:02.360 --> 00:21:04.250
para a direita, um, dois, três.

00:21:04.250 --> 00:21:07.370
Mas é claro, se eu quiser adicionar um quarto número agora,

00:21:07.370 --> 00:21:09.020
não há mecanismo para tal.

00:21:09.020 --> 00:21:12.470
Certamente no código que acabei de escrever eu poderia voltar aqui

00:21:12.470 --> 00:21:14.120
e mude isso para um quatro.

00:21:14.120 --> 00:21:17.810
Eu poderia descer aqui e alterar as listas entre três e quatro.

00:21:17.810 --> 00:21:20.985
Eu poderia apenas alterar manualmente o código, recompilar o código.

00:21:20.985 --> 00:21:23.360
Mas claro, isso não me dá nenhuma pista adicional

00:21:23.360 --> 00:21:24.870
para o quinto ou sexto número.

00:21:24.870 --> 00:21:27.560
Então, deixe-me tentar fazer um desenho de abordagem diferente

00:21:27.560 --> 00:21:29.330
alguma inspiração da semana passada.

00:21:29.330 --> 00:21:33.050
Se eu quiser alocar memória dinamicamente,

00:21:33.050 --> 00:21:37.220
talvez porque não sei quando escrevi o programa quantos bytes quero,

00:21:37.220 --> 00:21:39.380
temos outra função desde a semana passada que

00:21:39.380 --> 00:21:42.530
não requer que você se comprometa antecipadamente com um certo número de bytes

00:21:42.530 --> 00:21:47.060
por meio de qual função você pode simplesmente pedir ao sistema operacional um pedaço de memória.

00:21:47.060 --> 00:21:49.070
Então malloc, aloque memória.

00:21:49.070 --> 00:21:51.260
Agora, uma matriz é apenas um pedaço de memória.

00:21:51.260 --> 00:21:53.240
E embora desde a segunda semana estejamos

00:21:53.240 --> 00:21:56.420
usando este açúcar sintático, esta conveniência de apenas usar

00:21:56.420 --> 00:21:58.910
colchetes e indexação nele, é

00:21:58.910 --> 00:22:02.780
apenas tornando mais fácil manipular um pedaço de memória que é contíguo

00:22:02.780 --> 00:22:04.860
todos juntos de volta, para trás, para trás.

00:22:04.860 --> 00:22:08.090
Então, hoje, assim como na semana passada, podemos tirar essas rodinhas

00:22:08.090 --> 00:22:11.570
e talvez seja um pouco mais deliberado em como alocamos a memória.

00:22:11.570 --> 00:22:14.130
Deixe-me ir, por exemplo, e fazer isso.

00:22:14.130 --> 00:22:17.480
Deixe-me excluir meu conteúdo da minha função principal aqui.

00:22:17.480 --> 00:22:18.920
Volte para o principal.

00:22:18.920 --> 00:22:24.650
E deixe-me propor agora que eu declaro, por exemplo, que tal minha lista não

00:22:24.650 --> 00:22:26.600
mais como uma matriz, mas como um ponteiro.

00:22:26.600 --> 00:22:28.700
Lista de estrelas int.

00:22:28.700 --> 00:22:31.670
E eu vou prosseguir e inicializar isso

00:22:31.670 --> 00:22:34.532
para ser que tal um pedaço de três números inteiros por enquanto?

00:22:34.532 --> 00:22:35.990
Então, ainda vou codificá-lo.

00:22:35.990 --> 00:22:38.880
Mas estou dando um passo em direção a mais dinamismo por enquanto.

00:22:38.880 --> 00:22:43.033
Então deixe-me alocar três vezes qualquer que seja o tamanho de um int.

00:22:43.033 --> 00:22:45.200
Mas geralmente serão quatro bytes, como sabemos.

00:22:45.200 --> 00:22:47.900
Isso realmente será 3 vezes 4 igual a 12.

00:22:47.900 --> 00:22:49.500
Mas é um pouco mais dinâmico.

00:22:49.500 --> 00:22:51.530
E agora, o que posso fazer aqui embaixo?

00:22:51.530 --> 00:22:53.280
Bem, isso é apenas um pedaço de memória.

00:22:53.280 --> 00:22:58.760
Então eu posso literalmente listar colchetes zero igual a um.

00:22:58.760 --> 00:23:01.220
O colchete de lista um é igual a dois.

00:23:01.220 --> 00:23:04.460
O colchete de lista dois é igual a três.

00:23:04.460 --> 00:23:07.220
E voila, alcance exatamente o mesmo efeito.

00:23:07.220 --> 00:23:10.130
Porque, novamente, uma matriz é apenas um pedaço de memória contígua.

00:23:10.130 --> 00:23:13.950
Mas malloc dá a você qualquer pedaço antigo de memória contígua

00:23:13.950 --> 00:23:16.890
então você pode tratar um como o outro aqui.

00:23:16.890 --> 00:23:20.280
Agora, se você realmente quer ser legal, você pode fazer algo assim.

00:23:20.280 --> 00:23:24.360
Você pode desreferenciar o endereço na lista e ir para lá.

00:23:24.360 --> 00:23:29.080
Você pode descer aqui e desreferenciar a lista mais um e ir para lá.

00:23:29.080 --> 00:23:31.360
Mas honestamente, ninguém realmente escreve código como este.

00:23:31.360 --> 00:23:32.400
É muito enigmático.

00:23:32.400 --> 00:23:35.080
É um pouco longe demais, pelo menos para a maioria das pessoas.

00:23:35.080 --> 00:23:38.130
E então, acho que o açúcar sintático enquanto continuo descrevendo,

00:23:38.130 --> 00:23:40.497
apenas a notação de colchetes mais fácil de usar

00:23:40.497 --> 00:23:43.080
faz exatamente a mesma coisa, descobre a aritmética do ponteiro,

00:23:43.080 --> 00:23:46.800
e coloca cada um desses números inteiros nos blocos corretos.

00:23:46.800 --> 00:23:50.950
Agora, só para ser super pedante, deixe-me verificar se algo deu errado.

00:23:50.950 --> 00:23:54.930
Portanto, se list equals equals null, isso significa que algo deu errado.

00:23:54.930 --> 00:23:58.200
Como se meu computador estivesse sem memória, o que devemos verificar normalmente.

00:23:58.200 --> 00:24:02.490
Então, deixe-me retornar imediatamente um sinalizando qualquer coisa diferente de zero,

00:24:02.490 --> 00:24:05.250
o que normalmente significa sucesso, apenas para sair deste programa

00:24:05.250 --> 00:24:06.490
porque algo está errado.

00:24:06.490 --> 00:24:09.780
Mas agora deixe-me propor que eu tive um...

00:24:09.780 --> 00:24:10.620
bem, vamos fazer isso.

00:24:10.620 --> 00:24:14.880
Para int i obtém zero, i menor que 3, i mais mais.

00:24:14.880 --> 00:24:17.280
Embora um design melhor seja sempre usar um const.

00:24:17.280 --> 00:24:19.440
Mas estou fazendo isso apenas para fins de demonstração.

00:24:19.440 --> 00:24:21.270
Vamos imprimir cada um desses ints também.

00:24:21.270 --> 00:24:23.530
E apenas certifique-se de que eu não estraguei nada.

00:24:23.530 --> 00:24:26.140
E deixe-me abrir a janela do meu terminal novamente.

00:24:26.140 --> 00:24:29.680
Deixe-me fazer a lista novamente.

00:24:29.680 --> 00:24:30.180
Huh.

00:24:30.180 --> 00:24:35.220
Declarando implicitamente a função de biblioteca malloc, digitamos void star something,

00:24:35.220 --> 00:24:39.570
algo implicitamente declarando são as palavras operativas lá.

00:24:39.570 --> 00:24:41.070
O que eu errei?

00:24:41.070 --> 00:24:41.640
Sim.

00:24:41.640 --> 00:24:43.890
AUDIÊNCIA: [INAUDÍVEL] precisa do cabeçalho [INAUDÍVEL]..

00:24:43.890 --> 00:24:44.765
DAVID J. MALAN: Sim.

00:24:44.765 --> 00:24:46.980
Esqueci o arquivo de cabeçalho no qual malloc é declarado.

00:24:46.980 --> 00:24:50.118
Eu me lembro agora, OK, isso está no padrão lib.h.

00:24:50.118 --> 00:24:52.410
E não há problema em procurar coisas assim se você esquecer.

00:24:52.410 --> 00:24:55.170
Deixe-me incluir a lib.h padrão.

00:24:55.170 --> 00:24:56.820
Agora deixe-me limpar meu terminal.

00:24:56.820 --> 00:24:59.070
Execute o make list novamente.

00:24:59.070 --> 00:25:00.880
Agora estamos bem. lista de barra de ponto.

00:25:00.880 --> 00:25:04.630
E agora, o que eu fiz de errado?

00:25:07.570 --> 00:25:08.070
Oh.

00:25:08.070 --> 00:25:09.090
[RISOS] OK.

00:25:09.090 --> 00:25:10.800
Momento não intencional, mas ensinável.

00:25:10.800 --> 00:25:11.790
O que eu fiz errado?

00:25:11.790 --> 00:25:13.494
[RISOS] Sim.

00:25:13.494 --> 00:25:15.150
AUDIÊNCIA: Você está imprimindo [INAUDÍVEL].

00:25:15.150 --> 00:25:16.025
DAVID J. MALAN: Sim.

00:25:16.025 --> 00:25:20.080
Estou imprimindo os valores de i em vez do que está no local i na matriz.

00:25:20.080 --> 00:25:22.440
Então, o que eu realmente queria fazer era imprimir isso.

00:25:22.440 --> 00:25:22.990
Obrigado.

00:25:22.990 --> 00:25:26.280
Agora, deixe-me recompilar a lista make list ponto slash.

00:25:26.280 --> 00:25:30.700
E agora, esses são os três valores que eu esperava, não os índices deles.

00:25:30.700 --> 00:25:33.090
Agora, deixe-me apenas propor que, para fins de discussão

00:25:33.090 --> 00:25:37.980
que me arrependo de ter alocado espaço apenas para três números inteiros.

00:25:37.980 --> 00:25:40.985
E talvez eu realmente devesse ter alocado espaço suficiente para quatro.

00:25:40.985 --> 00:25:43.110
Agora, não é assim que você faria isso na prática.

00:25:43.110 --> 00:25:45.193
Porque presumivelmente se você mudar de ideia

00:25:45.193 --> 00:25:46.800
basta voltar e corrigir o código.

00:25:46.800 --> 00:25:48.900
Mas deixe-me propor que em algum lugar aqui

00:25:48.900 --> 00:25:52.020
é um programa mais complicado e o tempo passa, ponto, ponto, ponto.

00:25:52.020 --> 00:25:54.190
Há muitos outros códigos interessantes lá.

00:25:54.190 --> 00:25:57.610
Mas, em algum momento, posso querer me dar mais memória.

00:25:57.610 --> 00:25:58.780
Então, como posso fazer isso?

00:25:58.780 --> 00:26:02.310
Bem, deixe-me pedir ao sistema operacional agora quatro novos bytes de memória

00:26:02.310 --> 00:26:05.280
para que possamos pelo menos na versão um implementar a ideia no quadro

00:26:05.280 --> 00:26:08.610
onde acabei de copiar os três bytes para os novos quatro bytes

00:26:08.610 --> 00:26:10.360
e então adicionou um quarto valor.

00:26:10.360 --> 00:26:11.970
Então, vou usar malloc novamente.

00:26:11.970 --> 00:26:13.980
E eu vou dizer, aqui está um novo ponteiro.

00:26:13.980 --> 00:26:17.490
Vou chamá-lo de temp, tmp para abreviar, o que é bastante comum quando você apenas

00:26:17.490 --> 00:26:18.810
preciso dele brevemente.

00:26:18.810 --> 00:26:20.670
Vou então ligar para malloc novamente.

00:26:20.670 --> 00:26:24.810
Eu vou dizer, dê-me quatro números inteiros usando tamanho de.

00:26:24.810 --> 00:26:26.070
Deixe-me novamente ter certeza.

00:26:26.070 --> 00:26:30.397
Portanto, se temp igual a nulo, algo deu errado.

00:26:30.397 --> 00:26:31.980
Então deixe-me devolver imediatamente um.

00:26:31.980 --> 00:26:35.550
E para garantir, antes de devolver um,

00:26:35.550 --> 00:26:39.370
deixe-me liberar a lista original para não vazar memória.

00:26:39.370 --> 00:26:41.250
Portanto, não estou apenas devolvendo um imediatamente.

00:26:41.250 --> 00:26:44.160
Estou sendo um bom cidadão e lembrando, bem,

00:26:44.160 --> 00:26:49.440
se esta chamada malloc foi bem-sucedida e de fato eu cheguei até a linha 18,

00:26:49.440 --> 00:26:54.222
mas a linha 18 falhou, devo liberar a memória que eu anteriormente malloc'd.

00:26:54.222 --> 00:26:55.680
Então, novamente, essa é a regra de ouro.

00:26:55.680 --> 00:26:57.600
Se você alocar, você deve ser o único

00:26:57.600 --> 00:26:59.880
para liberá-lo antes mesmo de sair.

00:26:59.880 --> 00:27:03.240
Agora, depois de fazer isso, acho que preciso fazer o que fizemos pictoricamente

00:27:03.240 --> 00:27:06.660
na tela onde preciso copiar o um, o dois, o três

00:27:06.660 --> 00:27:08.790
da matriz antiga para a nova.

00:27:08.790 --> 00:27:10.180
Então, como posso fazer isso?

00:27:10.180 --> 00:27:11.850
Bem, deixe-me dar uma volta.

00:27:11.850 --> 00:27:15.420
Então, para int, obtenho zero, i menor que 3, i mais mais,

00:27:15.420 --> 00:27:18.490
porque o tamanho do original ainda é o mesmo.

00:27:18.490 --> 00:27:23.880
Deixe-me seguir em frente e tratar o novo pedaço de memória chamado temp como um array

00:27:23.880 --> 00:27:24.670
em si.

00:27:24.670 --> 00:27:27.150
E assim, posso absolutamente usar esses colchetes como antes.

00:27:27.150 --> 00:27:28.320
É apenas um pedaço de memória.

00:27:28.320 --> 00:27:29.730
Estou tratando como um array.

00:27:29.730 --> 00:27:34.740
E deixe-me adicionar a esse valor o que estiver na lista original no local i

00:27:34.740 --> 00:27:35.470
também.

00:27:35.470 --> 00:27:41.790
Então, novamente, é apenas este exercício de copiar do antigo para o novo passo a passo

00:27:41.790 --> 00:27:44.130
o um, o dois e o três.

00:27:44.130 --> 00:27:46.110
Mas ainda preciso de uma etapa adicional.

00:27:46.110 --> 00:27:50.817
Se meu objetivo agora é ter um quarto valor aqui,

00:27:50.817 --> 00:27:53.400
bem, eu só vou codificar isso para fins de demonstração.

00:27:53.400 --> 00:27:56.520
E eu vou para o último local de temp,

00:27:56.520 --> 00:27:58.320
que é de tamanho quatro.

00:27:58.320 --> 00:28:04.260
O que significa que o último elemento em temp é o colchete de temperatura três,

00:28:04.260 --> 00:28:05.580
porque é indexado a zero.

00:28:05.580 --> 00:28:07.310
Mas há quatro espaços totais lá.

00:28:07.310 --> 00:28:09.810
E eu vou apenas arbitrariamente para fins de discussão

00:28:09.810 --> 00:28:11.010
coloque o número quatro lá.

00:28:11.010 --> 00:28:16.920
E foi isso que aconteceu quando propusemos mudar o lixo final

00:28:16.920 --> 00:28:18.480
valor lá para aqueles quatro.

00:28:18.480 --> 00:28:22.350
Mas agora preciso fazer o que o slide fez por nós magicamente na tela.

00:28:22.350 --> 00:28:24.510
Agora devo fazer algumas coisas finais.

00:28:24.510 --> 00:28:28.350
Devo liberar a lista original, o que ainda não fiz, pois só

00:28:28.350 --> 00:28:30.420
chamado gratuitamente mais cedo em casos de erro.

00:28:30.420 --> 00:28:32.070
E isso era apenas para estar seguro.

00:28:32.070 --> 00:28:34.110
Agora posso liberar a lista.

00:28:34.110 --> 00:28:39.390
E agora, se eu quiser informar o computador que eu quero listar, cite

00:28:39.390 --> 00:28:43.740
tire aspas, minha variável chamada lista para apontar não para o pedaço antigo

00:28:43.740 --> 00:28:46.410
como originalmente, mas o novo pedaço, eu acho

00:28:46.410 --> 00:28:50.280
Eu posso apenas fazer isso-- lista é igual a tmp.

00:28:50.280 --> 00:28:53.670
E, novamente, isso é apenas dizer que se a lista for um ponteiro, o que era.

00:28:53.670 --> 00:28:58.230
Porque olhe para a linha superior aqui, na linha seis

00:28:58.230 --> 00:29:02.790
Eu declarei list para ser um ponteiro para um pedaço de memória.

00:29:02.790 --> 00:29:06.370
Enquanto isso, Temp é um ponteiro separado para um pedaço de memória.

00:29:06.370 --> 00:29:10.470
Então, aqui embaixo, esta linha 33 é apenas uma questão de eu dizer,

00:29:10.470 --> 00:29:13.980
OK, doravante, porque já liberei o antigo pedaço de memória,

00:29:13.980 --> 00:29:17.370
minha variável de lista não deve apontar para este pedaço de três bytes

00:29:17.370 --> 00:29:22.290
mas este pedaço de quatro bytes ou realmente 12 no total agora.

00:29:22.290 --> 00:29:26.310
Ou melhor, 16 agora porque temos quatro desses bytes.

00:29:26.310 --> 00:29:30.090
Perguntas agora sobre este código, cujo ponto

00:29:30.090 --> 00:29:33.570
foi simplesmente demonstrar como poderíamos implementar

00:29:33.570 --> 00:29:38.310
no código essa ideia de alocar corretamente, mas ineficientemente

00:29:38.310 --> 00:29:44.610
uma nova matriz de tamanho suficiente e, em seguida, preenchê-la com um novo quarto valor.

00:29:44.610 --> 00:29:48.720
Perguntas sobre o que acabamos de fazer aqui?

00:29:48.720 --> 00:29:49.220
Não?

00:29:49.220 --> 00:29:51.140
Sim.

00:29:51.140 --> 00:29:53.590
AUDIÊNCIA: [INAUDÍVEL]

00:29:59.380 --> 00:30:00.630
DAVID J. MALAN: Boa pergunta.

00:30:00.630 --> 00:30:03.360
Neste ponto da história, com a linha 33,

00:30:03.360 --> 00:30:07.410
não tenho duas variáveis ​​diferentes apontando para o mesmo pedaço de memória?

00:30:07.410 --> 00:30:08.520
Resposta curta, sim.

00:30:08.520 --> 00:30:10.800
Mas é aqui que a semântica talvez seja convincente.

00:30:10.800 --> 00:30:14.007
List é a variável que pretendo usar a longo prazo

00:30:14.007 --> 00:30:15.090
e guarde na memória.

00:30:15.090 --> 00:30:18.102
E, novamente, suponha que haja ainda mais código acontecendo aqui que acabamos de

00:30:18.102 --> 00:30:18.810
ainda não escrevi.

00:30:18.810 --> 00:30:20.790
Portanto, é útil ter essa variável.

00:30:20.790 --> 00:30:23.280
Temp era apenas um mal necessário.

00:30:23.280 --> 00:30:27.570
Porque aqui em cima, não teria sido correto fazer isso.

00:30:27.570 --> 00:30:31.140
Não teria sido correto dizer lista na linha 18

00:30:31.140 --> 00:30:33.720
é igual ao novo pedaço de memória porque este

00:30:33.720 --> 00:30:35.700
teria representado um vazamento de memória.

00:30:35.700 --> 00:30:42.060
Se eu mudar prematuramente a temperatura para apontar não para o pedaço antigo, mas para o novo pedaço,

00:30:42.060 --> 00:30:44.470
nesse ponto, ninguém está apontando para o pedaço antigo.

00:30:44.470 --> 00:30:46.260
E então eu perdi esses três bytes.

00:30:46.260 --> 00:30:47.970
Valgrind, por exemplo, gritaria com você

00:30:47.970 --> 00:30:51.070
por ter perdido tantos bytes na memória.

00:30:51.070 --> 00:30:53.730
Portanto, neste caso aqui, deixo isso como temp.

00:30:53.730 --> 00:30:55.590
Sim, é duplicado neste ponto.

00:30:55.590 --> 00:30:58.380
Mas não é grande coisa se foi apenas significado semanticamente

00:30:58.380 --> 00:30:59.610
para ser um valor temporário.

00:30:59.610 --> 00:31:03.900
Mas aqui embaixo, correndo o risco de mais uma linha de código,

00:31:03.900 --> 00:31:07.380
Eu ainda quero, ser um bom cidadão, lista livre, e talvez

00:31:07.380 --> 00:31:09.690
apenas para uma boa medida, retorne zero explicitamente.

00:31:09.690 --> 00:31:15.870
Mas observe, não está fazendo isso duas vezes por si só na linha 31.

00:31:15.870 --> 00:31:17.130
O que estou libertando?

00:31:17.130 --> 00:31:19.620
O endereço original da lista.

00:31:19.620 --> 00:31:21.900
A versão de três inteiros.

00:31:21.900 --> 00:31:23.740
Então eu mudo o que a lista aponta.

00:31:23.740 --> 00:31:25.740
Então está apontando para um pedaço completamente diferente

00:31:25.740 --> 00:31:27.360
de memória, este de tamanho quatro.

00:31:27.360 --> 00:31:31.150
Eventualmente, quando terminar de usar esta memória para esta demonstração,

00:31:31.150 --> 00:31:32.370
Eu ainda preciso liberar a lista.

00:31:32.370 --> 00:31:34.500
Mas neste ponto do enredo 40, é

00:31:34.500 --> 00:31:38.190
apontando para o novo pedaço de memória, que eu também preciso devolver

00:31:38.190 --> 00:31:40.290
para o sistema operacional gratuitamente.

00:31:40.290 --> 00:31:41.236
Sim.

00:31:41.236 --> 00:31:42.634
AUDIÊNCIA: [INAUDÍVEL]

00:31:44.458 --> 00:31:46.250
DAVID J. MALAN: Quando a temperatura seria nula?

00:31:46.250 --> 00:31:48.290
Então, deixe-me rolar para trás um pouco.

00:31:48.290 --> 00:31:50.890
Isso é ser um bom cidadão e um bom programador.

00:31:50.890 --> 00:31:54.250
Sempre que se trata de usar malloc, malloc

00:31:54.250 --> 00:31:57.755
pode retornar nulo se o computador estiver sem memória.

00:31:57.755 --> 00:31:59.380
Portanto, este é talvez um programa muito maior.

00:31:59.380 --> 00:32:01.040
Você tem outras coisas acontecendo nele.

00:32:01.040 --> 00:32:04.450
E assim, você simplesmente não tem memória suficiente disponível para ser entregue.

00:32:04.450 --> 00:32:06.970
Malloc precisa sinalizar para você que há algum erro.

00:32:06.970 --> 00:32:10.090
E assim, comprará a convenção de acordo com a documentação,

00:32:10.090 --> 00:32:12.623
de acordo com as páginas de manual, retorna nulo.

00:32:12.623 --> 00:32:14.290
Portanto, este sou apenas eu sendo um bom cidadão.

00:32:14.290 --> 00:32:16.900
Caso contrário, aqui está outro erro que pode fazer com que seu programa

00:32:16.900 --> 00:32:19.690
travar com uma falha de segmentação. Se você voltar

00:32:19.690 --> 00:32:24.820
null, mas você assume que é uma boa memória indo para o endereço zero, também conhecido como

00:32:24.820 --> 00:32:27.850
null, travará seu programa intencionalmente.

00:32:27.850 --> 00:32:28.390
Sim.

00:32:28.390 --> 00:32:31.046
AUDIÊNCIA: Se você quiser escrever [INAUDÍVEL] na parte inferior

00:32:31.046 --> 00:32:33.703
de um programa, e você acabou de colocar [INAUDÍVEL],,

00:32:33.703 --> 00:32:36.120
seria [INAUDÍVEL] o mesmo [INAUDÍVEL], certo?

00:32:36.120 --> 00:32:37.120
DAVID J. MALAN: Correto.

00:32:37.120 --> 00:32:41.820
Se eu mudasse minha linha final 40 aqui para ser temporária,

00:32:41.820 --> 00:32:44.140
isso também funcionaria.

00:32:44.140 --> 00:32:46.560
E aqui, isso é realmente uma questão de design.

00:32:46.560 --> 00:32:48.120
É uma coisa muito minuciosa.

00:32:48.120 --> 00:32:49.380
Nós provavelmente poderíamos debater isso.

00:32:49.380 --> 00:32:53.460
Mas porque neste ponto da história minha principal variável

00:32:53.460 --> 00:32:55.770
para lembrar onde a lista está é chamada de lista.

00:32:55.770 --> 00:32:59.010
Esta é a forma mais responsável de o fazer, libertando a lista,

00:32:59.010 --> 00:33:01.830
só para que meus colegas, meu TA não

00:33:01.830 --> 00:33:05.160
pergunto por que você está liberando memória temporária que você já liberou.

00:33:05.160 --> 00:33:06.930
É apenas uma coisa semântica neste ponto.

00:33:06.930 --> 00:33:07.680
Mas bom instinto.

00:33:07.680 --> 00:33:08.970
Também funcionaria.

00:33:08.970 --> 00:33:09.690
Correto.

00:33:09.690 --> 00:33:12.112
Talvez apenas não seja um bom design.

00:33:12.112 --> 00:33:14.070
Acontece que isso fica irritante rapidamente

00:33:14.070 --> 00:33:16.980
como fez na foto de fazer toda essa duplicação.

00:33:16.980 --> 00:33:20.010
E mesmo que tecnicamente seja necessário copiar esses valores,

00:33:20.010 --> 00:33:22.350
se você precisar de um pedaço maior e mais novo de memória,

00:33:22.350 --> 00:33:27.300
existe pelo menos uma função em C que simplifica muito isso para nós.

00:33:27.300 --> 00:33:29.400
E, de fato, deixe-me ir em frente e fazer isso.

00:33:29.400 --> 00:33:33.840
Em vez de usar malloc, desta vez na linha 18

00:33:33.840 --> 00:33:37.170
além da primeira vez que usei na linha seis,

00:33:37.170 --> 00:33:41.310
Na verdade, vou tentar introduzir outra função chamada realloc, que

00:33:41.310 --> 00:33:44.700
como o nome sugere tenta realocar a memória para você.

00:33:44.700 --> 00:33:47.010
E funciona um pouco diferente do malloc.

00:33:47.010 --> 00:33:49.330
realloc espera dois argumentos.

00:33:49.330 --> 00:33:51.840
O primeiro é qual é o pedaço de memória

00:33:51.840 --> 00:33:55.650
que você quer tentar crescer ou encolher, ou seja, realocar

00:33:55.650 --> 00:33:56.880
ser um tamanho diferente.

00:33:56.880 --> 00:33:59.580
E então você especifica o tamanho que deseja.

00:33:59.580 --> 00:34:04.800
E, de fato, neste caso, quero quatro vezes o tamanho de int.

00:34:04.800 --> 00:34:10.500
E isso agora me dará um novo endereço de um pedaço de memória que é

00:34:10.500 --> 00:34:12.960
grande o suficiente para caber todos os quatro números.

00:34:12.960 --> 00:34:17.190
Mas o que é maravilhoso sobre o realloc é que ele

00:34:17.190 --> 00:34:20.020
cuidará de todas as cópias para mim.

00:34:20.020 --> 00:34:21.969
Então, na verdade, eu vou descer aqui.

00:34:21.969 --> 00:34:25.960
Vou me livrar de tudo isso, desse loop for extra.

00:34:25.960 --> 00:34:28.710
E o que eu simplesmente vou fazer é isso.

00:34:28.710 --> 00:34:34.290
Uma vez que posso confiar após as linhas 18 a 23

00:34:34.290 --> 00:34:37.710
esse realloc funcionou e não retornou null porque estou sem memória,

00:34:37.710 --> 00:34:41.850
Posso apenas dizer, OK, lembre-se imediatamente de que os novos pontos da lista

00:34:41.850 --> 00:34:44.230
em vez disso, neste novo pedaço de memória.

00:34:44.230 --> 00:34:46.710
E então, ainda posso fazer esta linha.

00:34:46.710 --> 00:34:50.190
Mas posso ajustar a semântica aqui e apenas dizer lista colchete três

00:34:50.190 --> 00:34:56.310
o novo local final na nova lista é quatro.

00:34:56.310 --> 00:34:58.020
Eu não preciso liberar isso aqui.

00:34:58.020 --> 00:34:59.580
Eu não preciso fazer isso.

00:34:59.580 --> 00:35:02.280
Tudo o que preciso agora na parte inferior é o loop for final

00:35:02.280 --> 00:35:03.988
para apenas imprimir esses valores.

00:35:03.988 --> 00:35:06.030
Resumindo, mesmo que tenha sido um pouco rápido,

00:35:06.030 --> 00:35:09.720
usando realloc apenas move toda a cópia

00:35:09.720 --> 00:35:13.330
processo que eu mesmo implementei há pouco usando um loop for.

00:35:13.330 --> 00:35:16.500
Ele apenas o move para realloc e permite que ele lide com a cópia para mim.

00:35:16.500 --> 00:35:17.520
Não é mais eficiente.

00:35:17.520 --> 00:35:20.400
Mas pelo menos significa que estou escrevendo menos código, o que é mais agradável.

00:35:20.400 --> 00:35:22.830
E espero que as pessoas que escreveram malloc ou realloc

00:35:22.830 --> 00:35:27.030
são mais espertos do que eu e eles apenas introduzirão bugs com menor probabilidade

00:35:27.030 --> 00:35:28.930
também.

00:35:28.930 --> 00:35:29.710
Isso foi muito.

00:35:29.710 --> 00:35:30.754
Alguma pergunta?

00:35:30.754 --> 00:35:32.754
AUDIÊNCIA: Por que você ainda tem que [INAUDÍVEL]??

00:35:34.580 --> 00:35:35.830
DAVID J. MALAN: Boa pergunta.

00:35:35.830 --> 00:35:40.750
Por que você ainda precisa tornar a lista igual à temperatura, como fiz na linha 24?

00:35:40.750 --> 00:35:44.200
Então, idealmente, eu faria isso.

00:35:44.200 --> 00:35:48.910
Idealmente, eu apenas mudaria esta linha 18 para ser list.

00:35:48.910 --> 00:35:50.350
Ou seja, ligue...

00:35:50.350 --> 00:35:52.570
ou melhor ainda, idealmente eu apenas

00:35:52.570 --> 00:35:55.180
digamos realoque esta lista para ter este novo tamanho.

00:35:55.180 --> 00:35:57.760
Mas, novamente, as coisas podem dar errado ao alocar memória.

00:35:57.760 --> 00:36:01.760
Você precisa verificar um valor de retorno para ver se foi bem-sucedido ou não.

00:36:01.760 --> 00:36:04.220
E assim, precisamos usar um valor de retorno.

00:36:04.220 --> 00:36:05.680
Portanto, não vamos introduzir temp.

00:36:05.680 --> 00:36:07.120
Vamos apenas usar list.

00:36:07.120 --> 00:36:09.610
Mas aqui é onde um vazamento de memória pode acontecer.

00:36:09.610 --> 00:36:13.240
Na chance realloc falha e não

00:36:13.240 --> 00:36:16.240
tem memória suficiente para seus quatro bytes, portanto

00:36:16.240 --> 00:36:18.100
ele retorna por definição nulo.

00:36:18.100 --> 00:36:23.110
Você não pode sobrescrever o valor original da lista com null para então verificá-lo.

00:36:23.110 --> 00:36:23.680
Por que?

00:36:23.680 --> 00:36:27.190
Porque agora quem se lembra onde estavam os três bytes originais?

00:36:27.190 --> 00:36:30.790
Se você alterar prematuramente o valor da lista, você perdeu.

00:36:30.790 --> 00:36:32.780
Você vazou memória nesse sentido.

00:36:32.780 --> 00:36:34.990
E então, é por isso-- deixe-me desfazer esta mudança--

00:36:34.990 --> 00:36:39.370
Eu declaro um ponteiro temporário com o único propósito de fazer

00:36:39.370 --> 00:36:41.060
com certeza posso verificar o valor de retorno.

00:36:41.060 --> 00:36:44.660
E então, assim que estiver bom, agora atualizarei o valor de list.

00:36:44.660 --> 00:36:47.590
Então, está fazendo um switcheroo certificando-se primeiro

00:36:47.590 --> 00:36:51.070
que você tem um novo valor para trocar com o antigo.

00:36:51.070 --> 00:36:53.630
Outras perguntas sobre este código?

00:36:53.630 --> 00:36:54.523
Sim.

00:36:54.523 --> 00:36:59.882
AUDIÊNCIA: O realloc [INAUDÍVEL] memória onde [INAUDÍVEL] está armazenado?

00:36:59.882 --> 00:37:00.840
DAVID J. MALAN: De fato.

00:37:00.840 --> 00:37:03.660
realloc libera automaticamente a memória anterior para você.

00:37:03.660 --> 00:37:05.610
E melhor ainda, é ainda mais inteligente do que isso.

00:37:05.610 --> 00:37:10.230
Se você tiver sorte e houver espaço logo após o seu

00:37:10.230 --> 00:37:13.900
pedaço de memória, então um, dois, três, valor de lixo, em vez de um,

00:37:13.900 --> 00:37:16.560
dois, três, Olá, mundo, realloc nem vai

00:37:16.560 --> 00:37:18.990
se preocupe em copiar coisas do antigo para o novo.

00:37:18.990 --> 00:37:21.330
Ele apenas dirá, OK, agora vou reservar

00:37:21.330 --> 00:37:24.690
para você mais bytes do que você originalmente pediu, então não

00:37:24.690 --> 00:37:26.460
tem que perder tempo fazendo essa cópia.

00:37:26.460 --> 00:37:29.310
E assim, nesse sentido, esta versão agora não só ainda está correta,

00:37:29.310 --> 00:37:32.790
é ainda melhor projetado porque não estamos perdendo tempo com esse loop for.

00:37:32.790 --> 00:37:36.060
Podemos ter que recorrer a ele se houver, de fato, Hello, world ou algo assim

00:37:36.060 --> 00:37:36.900
mais no caminho.

00:37:36.900 --> 00:37:39.990
Mas esperamos ter sorte e salvar essas etapas.

00:37:39.990 --> 00:37:46.610
Outras perguntas sobre essa manipulação de código aqui?

00:37:46.610 --> 00:37:48.038
Sim, no meio.

00:37:48.038 --> 00:37:49.442
AUDIÊNCIA: Então [INAUDÍVEL]?

00:37:53.190 --> 00:37:56.110
DAVID J. MALAN: E se você quiser redimensionar uma matriz bidimensional?

00:37:56.110 --> 00:38:00.540
Tão muito semelhante em espírito que você pode usar o mesmo truque.

00:38:00.540 --> 00:38:03.150
Deixe-me acenar para isso por enquanto só porque eu

00:38:03.150 --> 00:38:06.270
acho que vai aumentar significativamente a complexidade.

00:38:06.270 --> 00:38:08.100
Mas muito mesmo primitivos em última análise.

00:38:08.100 --> 00:38:12.570
Uma matriz bidimensional é essencialmente apenas um comprimento duplamente ou quadraticamente

00:38:12.570 --> 00:38:16.050
lista de memória mais longa que usando a notação de colchetes

00:38:16.050 --> 00:38:18.520
está fazendo parte dessa matemática mental para você.

00:38:18.520 --> 00:38:24.060
Mas não é fundamentalmente diferente do que está acontecendo sob o capô.

00:38:24.060 --> 00:38:27.417
Então, com isso dito e esse código em nosso currículo,

00:38:27.417 --> 00:38:30.000
mesmo que isso não seja algo que você frequentemente

00:38:30.000 --> 00:38:33.390
precisa se codificar, vamos propor agora como

00:38:33.390 --> 00:38:36.780
podemos construir algumas estruturas de dados reais nós mesmos.

00:38:36.780 --> 00:38:39.750
O novo ingrediente aqui sendo esta realidade

00:38:39.750 --> 00:38:44.520
que se você quiser redimensionar um pedaço de memória para abrir espaço para as coisas,

00:38:44.520 --> 00:38:45.780
agora temos essa capacidade.

00:38:45.780 --> 00:38:47.040
Endereços de memória.

00:38:47.040 --> 00:38:50.160
E os ponteiros apenas nos dão a capacidade de apontar para as coisas

00:38:50.160 --> 00:38:51.570
e mover as coisas na memória.

00:38:51.570 --> 00:38:54.060
Mas agora que temos malloc e até mesmo realloc,

00:38:54.060 --> 00:38:56.100
você pode imaginar, talvez rebobinando, e você

00:38:56.100 --> 00:39:00.090
poderia implementar essa pilha, essa fila usando não uma matriz por

00:39:00.090 --> 00:39:02.790
se, porque você tem que se comprometer com um tamanho de array com antecedência.

00:39:02.790 --> 00:39:06.840
Mas se você implementar sua pilha ou sua fila usando um ponteiro e então

00:39:06.840 --> 00:39:10.680
malloc e realloc, e talvez outra pessoa escreva todo esse código para você,

00:39:10.680 --> 00:39:14.490
talvez agora você possa imaginar que agora a pilha pode crescer

00:39:14.490 --> 00:39:17.400
ou encolher usando realloc de acordo.

00:39:17.400 --> 00:39:23.400
Você não precisa dizer preventivamente me dê cinco bytes, ou 50, ou 500, ou 5.000.

00:39:23.400 --> 00:39:25.360
Você pode dizer, apenas me dê um inicialmente.

00:39:25.360 --> 00:39:27.850
E se eu precisar de mais, vou realloc, realloc, realloc.

00:39:27.850 --> 00:39:29.880
E se você continuar tirando coisas da pilha,

00:39:29.880 --> 00:39:33.630
você pode realocar na outra direção e pedir cada vez menos bytes

00:39:33.630 --> 00:39:36.550
e o sistema operacional também pode recuperar essa memória.

00:39:36.550 --> 00:39:38.130
Portanto, agora temos esse bloco de construção.

00:39:38.130 --> 00:39:39.900
Vamos ver o que podemos fazer com isso.

00:39:39.900 --> 00:39:43.050
Tivemos alguns trechos de sintaxe nas últimas semanas, todos

00:39:43.050 --> 00:39:46.090
vamos combinar agora de uma maneira um pouco mais inteligente.

00:39:46.090 --> 00:39:49.920
Então struct é esta palavra-chave em C que nos permite construir nossa própria estrutura na memória,

00:39:49.920 --> 00:39:52.530
como uma coleção de duas ou três ou mais variáveis,

00:39:52.530 --> 00:39:54.480
como uma pessoa que já vimos antes.

00:39:54.480 --> 00:40:01.320
O operador ponto, lembre-se, usamos quando você tem uma estrutura como uma pessoa

00:40:01.320 --> 00:40:02.980
e você quer entrar nela.

00:40:02.980 --> 00:40:07.170
Então pessoa.nome ou pessoa.número.

00:40:07.170 --> 00:40:08.520
Fizemos isso algumas semanas atrás.

00:40:08.520 --> 00:40:12.030
Agora, mas o operador ponto apenas permite que você entre em uma estrutura

00:40:12.030 --> 00:40:14.160
e obter as variáveis ​​individuais dentro.

00:40:14.160 --> 00:40:17.520
E então, o operador estrela, infelizmente, tem muitos usos agora.

00:40:17.520 --> 00:40:18.810
Uma delas era a multiplicação.

00:40:18.810 --> 00:40:20.880
Meu Deus, isso era fácil antigamente.

00:40:20.880 --> 00:40:23.520
Agora é usado para declarar ponteiros.

00:40:23.520 --> 00:40:25.680
Também é usado para desreferenciar o ponteiro.

00:40:25.680 --> 00:40:29.430
Então, para fazer um existir e, em seguida, vá para esse endereço.

00:40:29.430 --> 00:40:31.900
Infelizmente, é o mesmo símbolo para todos eles.

00:40:31.900 --> 00:40:33.270
Mas está tudo relacionado.

00:40:33.270 --> 00:40:35.183
Mas com esses três símbolos, verifica-se--

00:40:35.183 --> 00:40:37.350
você vai pegar um último hoje-- e meu Deus,

00:40:37.350 --> 00:40:40.320
finalmente se parece com o conceito.

00:40:40.320 --> 00:40:42.870
Acontece que há uma maneira inteligente a qualquer momento

00:40:42.870 --> 00:40:45.870
você quer usar o ponto e a estrela juntos, ou seja, ir

00:40:45.870 --> 00:40:49.830
em algum lugar, e vá para um endereço, e então olhe dentro de uma estrutura,

00:40:49.830 --> 00:40:53.523
você pode literalmente usar um símbolo de seta em seu teclado.

00:40:53.523 --> 00:40:54.690
Não é um único toque de tecla.

00:40:54.690 --> 00:40:57.750
É um hífen e, em seguida, um colchete angular aberto.

00:40:57.750 --> 00:40:59.520
Mas pelo menos parece uma flecha.

00:40:59.520 --> 00:41:02.700
E veremos de fato no código hoje, as coisas que eu estava desenhando pictoricamente

00:41:02.700 --> 00:41:04.680
na tela da última vez com setas amarelas,

00:41:04.680 --> 00:41:07.380
agora você também pode expressar em código.

00:41:07.380 --> 00:41:12.000
E assim, aqui temos nossa próxima estrutura de dados chamada lista encadeada.

00:41:12.000 --> 00:41:15.330
E este é um dos conceitos poderosos mais úteis em C.

00:41:15.330 --> 00:41:18.030
É o tipo de coisa que você pode dar como certo em Java

00:41:18.030 --> 00:41:19.920
e Python e linguagens de nível superior.

00:41:19.920 --> 00:41:24.150
Mas hoje veremos como nós ou outros podemos realmente construir essas coisas apenas

00:41:24.150 --> 00:41:25.830
usando essas mesmas primitivas.

00:41:25.830 --> 00:41:29.430
Então, uma lista encadeada nos permitirá realmente fazer

00:41:29.430 --> 00:41:32.490
para que usamos um dedo de espuma na semana passada permitir

00:41:32.490 --> 00:41:35.100
nos ligar, por exemplo, esses três valores talvez

00:41:35.100 --> 00:41:36.540
com aquele quarto valor ali.

00:41:36.540 --> 00:41:39.390
E então, se houver um quinto, talvez esse outro dedo de espuma

00:41:39.390 --> 00:41:41.790
aponta ainda mais para o quinto valor.

00:41:41.790 --> 00:41:45.930
A chave é que você pode unir estruturas de dados mais sofisticadas

00:41:45.930 --> 00:41:49.440
sem ter que pegar tudo isso e encontrar um novo espaço.

00:41:49.440 --> 00:41:51.750
Você só precisa pelo menos conectar os pontos de alguma forma.

00:41:51.750 --> 00:41:54.568
Nós só precisamos de alguma forma apontar de um para o outro.

00:41:54.568 --> 00:41:57.360
E isso vai tornar as coisas muito mais eficientes, ao que parece.

00:41:57.360 --> 00:41:58.802
Então como chegamos lá?

00:41:58.802 --> 00:42:00.510
Então aqui está a memória do meu computador como sempre.

00:42:00.510 --> 00:42:03.720
Suponha que eu esteja armazenando o valor um em algum lugar lá

00:42:03.720 --> 00:42:06.180
e está no endereço 0x123, tanto faz.

00:42:06.180 --> 00:42:10.140
E estou armazenando o número dois em outro lugar da memória, 0x456.

00:42:10.140 --> 00:42:13.500
E número três no endereço 0x789.

00:42:13.500 --> 00:42:15.780
Isso não está em array por definição.

00:42:15.780 --> 00:42:17.412
Por que?

00:42:17.412 --> 00:42:19.620
Mesmo que sejam as únicas três coisas na tela,

00:42:19.620 --> 00:42:20.715
o que torna isso não uma matriz?

00:42:20.715 --> 00:42:21.550
AUDIÊNCIA: Não é contíguo.

00:42:21.550 --> 00:42:23.050
DAVID J. MALAN: Não é contíguo.

00:42:23.050 --> 00:42:25.450
Portanto, isso viola a definição de uma matriz.

00:42:25.450 --> 00:42:27.880
Mas você sabe, especialmente porque eles são sequenciais,

00:42:27.880 --> 00:42:30.250
para um ser humano, parece uma lista.

00:42:30.250 --> 00:42:33.120
Portanto, seria bom se houvesse um tipo de dados chamado lista.

00:42:33.120 --> 00:42:35.820
E não há em C. Haverá em Python.

00:42:35.820 --> 00:42:36.930
Mas você sabe o que?

00:42:36.930 --> 00:42:40.270
Se eu pudesse de alguma forma unir esses três valores

00:42:40.270 --> 00:42:42.330
para que eu possa ir de um para o outro para o outro,

00:42:42.330 --> 00:42:45.660
então acho que poderíamos alcançar a ideia do conceito de uma lista

00:42:45.660 --> 00:42:48.420
sem essa restrição realmente irritante de que todos sejam

00:42:48.420 --> 00:42:51.210
contígua como em uma matriz.

00:42:51.210 --> 00:42:52.260
Então, como faço isso?

00:42:52.260 --> 00:42:55.970
Bem, no final das contas eu só tenho memória à minha disposição.

00:42:55.970 --> 00:42:58.880
Não há mais rodinhas para tirar aqui.

00:42:58.880 --> 00:43:01.620
Isso é o que temos sob o capô de um computador.

00:43:01.620 --> 00:43:04.760
Então, se tudo o que tenho é memória, acho que a solução

00:43:04.760 --> 00:43:08.390
a este problema de unir esses valores em uma lista

00:43:08.390 --> 00:43:11.090
deve ser para gastar um pouco mais de memória.

00:43:11.090 --> 00:43:13.770
Esse é literalmente o único recurso que temos agora.

00:43:13.770 --> 00:43:17.180
Deixe-me propor que, se quisermos criar uma lista conceitualmente

00:43:17.180 --> 00:43:21.140
de três valores aleatórios, embora visualmente bonitos

00:43:21.140 --> 00:43:25.280
posições na memória, deixe-me adicionar um pouco mais de memória à imagem.

00:43:25.280 --> 00:43:27.200
Então, além de armazenar aquele, vou

00:43:27.200 --> 00:43:30.300
para me deixar algum espaço, um pequeno bloco de rascunho, se você quiser,

00:43:30.300 --> 00:43:31.880
para usar alguns outros bits também.

00:43:31.880 --> 00:43:34.310
O mesmo para os dois, o mesmo para os três.

00:43:34.310 --> 00:43:38.450
E talvez você possa ver para onde isso está indo com base na semana passada.

00:43:38.450 --> 00:43:43.640
Se eu quiser de alguma forma conectar o um aos dois,

00:43:43.640 --> 00:43:48.290
quaisquer instintos sobre o que devo escrever nesta caixa aqui que

00:43:48.290 --> 00:43:52.460
me levaria efetivamente de um para os dois?

00:43:52.460 --> 00:43:53.390
O que poderia ir aqui?

00:43:53.390 --> 00:43:53.900
Sim.

00:43:53.900 --> 00:43:55.852
AUDIÊNCIA: [INAUDÍVEL]

00:43:56.882 --> 00:43:58.965
DAVID J. MALAN: Poderíamos armazenar o endereço de dois.

00:43:58.965 --> 00:44:01.463
E então, especificamente, o que você gostaria que eu escrevesse aqui?

00:44:01.463 --> 00:44:05.220
AUDIÊNCIA: ponteiro [INAUDÍVEL] 0x456.

00:44:05.220 --> 00:44:06.220
DAVID J. MALAN: Perfeito.

00:44:06.220 --> 00:44:09.220
Idealmente, eu apenas colocaria nesta caixa outro número inteiro,

00:44:09.220 --> 00:44:11.690
aquele que passa a ser representado em hexadecimal.

00:44:11.690 --> 00:44:12.940
Mas isso é apenas um sistema básico.

00:44:12.940 --> 00:44:15.320
É apenas uma coisa humana para nós olharmos.

00:44:15.320 --> 00:44:18.110
Vou colocar o valor 0x456 aqui.

00:44:18.110 --> 00:44:19.690
Então deixe-me ir em frente e revelar isso.

00:44:19.690 --> 00:44:21.290
0x456 vai lá.

00:44:21.290 --> 00:44:23.290
Talvez você possa ver mais aonde isso está indo.

00:44:23.290 --> 00:44:25.390
Bem, se eu quiser ir do dois para o três,

00:44:25.390 --> 00:44:29.050
Acho que preciso colocar abaixo dos dois o endereço dos três, que

00:44:29.050 --> 00:44:30.760
dá-me 0x789.

00:44:30.760 --> 00:44:33.400
Agora, se três é o fim da lista, eu não

00:44:33.400 --> 00:44:35.230
quero que seja algum valor de lixo.

00:44:35.230 --> 00:44:38.020
Porque isso implicaria que quem sabe para onde está apontando.

00:44:38.020 --> 00:44:39.377
Preciso de um valor definitivo.

00:44:39.377 --> 00:44:40.960
E quais seriam seus instintos?

00:44:40.960 --> 00:44:44.920
Se eu quiser deixar claro com algum valor sentinela especial

00:44:44.920 --> 00:44:47.350
que o buck pára aqui, o que eu coloco?

00:44:47.350 --> 00:44:48.525
Quais podem ser minhas opções?

00:44:48.525 --> 00:44:49.150
AUDIÊNCIA: Nulo?

00:44:49.150 --> 00:44:49.480
DAVID J. MALAN: Sim.

00:44:49.480 --> 00:44:50.110
Tão nulo.

00:44:50.110 --> 00:44:55.240
Não NUL, per se, mas NULL, que foi a nova palavra-chave que introduzimos na última vez

00:44:55.240 --> 00:44:58.960
semana, que representa apenas um ponteiro vazio, se preferir.

00:44:58.960 --> 00:45:01.780
Tecnicamente, o endereço 0x0.

00:45:01.780 --> 00:45:03.760
Então, literalmente, o endereço zero.

00:45:03.760 --> 00:45:06.430
E o que os humanos fizeram anos atrás, eles apenas decidiram, quer saber?

00:45:06.430 --> 00:45:09.850
Nada deve viver no endereço zero na memória.

00:45:09.850 --> 00:45:12.700
Vamos apenas reservar aquele byte especial para ser

00:45:12.700 --> 00:45:15.850
um sinal especial, um valor sentinela tal que se você alguma vez

00:45:15.850 --> 00:45:19.540
veja um endereço zero em um ponteiro, significa apenas que é inválido.

00:45:19.540 --> 00:45:20.720
Isso não existe.

00:45:20.720 --> 00:45:24.940
Agora, escrevemos isso embora um pouco mais agradável para os olhos como apenas NULL

00:45:24.940 --> 00:45:25.780
em todos os caps.

00:45:25.780 --> 00:45:27.500
E essa é uma palavra-chave em C também.

00:45:27.500 --> 00:45:31.120
Mas é claro que, na semana passada, afirmei que quem se importa onde as coisas estão na memória.

00:45:31.120 --> 00:45:34.730
E honestamente, isso rapidamente se torna tedioso, mesmo se preocupando com esses valores.

00:45:34.730 --> 00:45:37.840
Então, deixe-me abstrair isso e propor que, se nós

00:45:37.840 --> 00:45:40.780
quer lembrar onde todos esses números estão na memória,

00:45:40.780 --> 00:45:43.570
vamos nos dar um último pedaço de memória

00:45:43.570 --> 00:45:47.110
que apenas nos permite iniciar todo o processo.

00:45:47.110 --> 00:45:50.800
Deixe-me alocar no lado esquerdo aqui não espaço para um número,

00:45:50.800 --> 00:45:54.850
como um, dois, três, apenas espaço para um ponteiro que doravante

00:45:54.850 --> 00:45:57.320
Acho que vou chamar a lista por convenção.

00:45:57.320 --> 00:46:00.880
E, em seguida, armazene naquele ponteiro adicional

00:46:00.880 --> 00:46:03.340
um valor que apenas inicia todo o processo.

00:46:03.340 --> 00:46:06.280
Este é o mapa do tesouro, se você quiser, que você recebe.

00:46:06.280 --> 00:46:11.630
E isso tem o endereço do primeiro nó real na memória.

00:46:11.630 --> 00:46:13.630
Agora, tecnicamente, poderíamos começar com isso.

00:46:13.630 --> 00:46:15.940
Mas acontece que veremos que é um pouco mais limpo

00:46:15.940 --> 00:46:18.880
para usar um único ponteiro simples que leva

00:46:18.880 --> 00:46:22.330
às coisas de que você gosta, em vez de apenas começar com o primeiro elemento

00:46:22.330 --> 00:46:22.940
y.

00:46:22.940 --> 00:46:25.150
Bem, se você quiser se livrar desse elemento,

00:46:25.150 --> 00:46:27.150
seria bom se você pudesse pelo menos aguentar firme

00:46:27.150 --> 00:46:29.590
para uma folha de papel vazia que indica que a lista é

00:46:29.590 --> 00:46:31.430
vazio seria um argumento para isso.

00:46:31.430 --> 00:46:33.700
Então, novamente, quem se importa com esses endereços agora?

00:46:33.700 --> 00:46:36.940
Agora, com um aceno de mão, vamos apenas abstrair.

00:46:36.940 --> 00:46:38.770
E aí estão os nossos ponteiros.

00:46:38.770 --> 00:46:42.550
Cada um desses endereços nos quadrados na parte inferior

00:46:42.550 --> 00:46:46.390
estão simplesmente apontando para o próximo elemento da lista.

00:46:46.390 --> 00:46:48.730
O jargão para introduzir aqui seria que agora

00:46:48.730 --> 00:46:50.890
que temos esses números inteiros um, dois, três,

00:46:50.890 --> 00:46:53.290
mas eles estão nessas embalagens, se você quiser,

00:46:53.290 --> 00:46:58.660
essas estruturas que possuem metadados que são dados adicionais relacionados a

00:46:58.660 --> 00:47:00.460
mas não os dados com os quais você realmente se preocupa.

00:47:00.460 --> 00:47:01.150
Isso é dados.

00:47:01.150 --> 00:47:02.290
Isso é metadados.

00:47:02.290 --> 00:47:05.200
Esta coisa aqui, retangular, vamos chamar de nó--

00:47:05.200 --> 00:47:08.530
NÓ. E é apenas um termo artístico que significa que é como um recipiente

00:47:08.530 --> 00:47:12.130
no código para armazenar alguns valores.

00:47:12.130 --> 00:47:14.050
Esta então é uma lista encadeada.

00:47:14.050 --> 00:47:17.860
E esta então é a encarnação gráfica

00:47:17.860 --> 00:47:20.240
de um nó apontando para o outro.

00:47:20.240 --> 00:47:22.990
Nesse caso, eles acontecem por acaso e por design

00:47:22.990 --> 00:47:25.450
desta mesa contígua inicialmente.

00:47:25.450 --> 00:47:27.490
Mas não há exigência de que sejam assim.

00:47:27.490 --> 00:47:28.420
Aquele pode estar ali.

00:47:28.420 --> 00:47:29.080
Os dois ali.

00:47:29.080 --> 00:47:29.955
Os três ali.

00:47:29.955 --> 00:47:33.430
Eu só precisaria de mais dedos de espuma para apontar um para o outro.

00:47:33.430 --> 00:47:36.355
Dúvidas sobre este conceito de lista encadeada?

00:47:36.355 --> 00:47:38.050
AUDIÊNCIA: [INAUDÍVEL]

00:47:38.050 --> 00:47:39.547
DAVID J. MALAN: Sim, na parte de trás.

00:47:39.547 --> 00:47:43.820
AUDIÊNCIA: [INAUDÍVEL] array [INAUDÍVEL] por ponteiro que está fora do array

00:47:43.820 --> 00:47:44.514
em si?

00:47:44.514 --> 00:47:46.139
DAVID J. MALAN: Você pode dizer isso de novo?

00:47:46.139 --> 00:47:49.195
AUDIÊNCIA: As matrizes tradicionais sempre iniciam o ponteiro [INAUDÍVEL]

00:47:49.195 --> 00:47:50.653
que está fora do [INAUDÍVEL]?

00:47:50.653 --> 00:47:51.987
DAVID J. MALAN: Uma boa pergunta.

00:47:51.987 --> 00:47:53.867
Os arrays tradicionais começam com um ponteiro

00:47:53.867 --> 00:47:55.200
que está fora da estrutura?

00:47:55.200 --> 00:47:56.430
Resposta curta, não.

00:47:56.430 --> 00:48:00.210
Arrays são especiais em C e algumas outras linguagens.

00:48:00.210 --> 00:48:04.060
E o nome de uma matriz é tecnicamente um símbolo, se preferir,

00:48:04.060 --> 00:48:08.700
que o computador-- o programa conhece mapas para um local específico na memória.

00:48:08.700 --> 00:48:12.540
É apenas um rótulo, sinônimo de endereço de memória.

00:48:12.540 --> 00:48:14.320
Não ocupa espaço.

00:48:14.320 --> 00:48:17.580
Então, para ficar claro, o nome de uma matriz não ocupa espaço

00:48:17.580 --> 00:48:19.530
como aquele quadrado extra à esquerda.

00:48:19.530 --> 00:48:22.810
Mas você precisa daquele quadrado extra à esquerda ao implementar uma lista encadeada

00:48:22.810 --> 00:48:25.530
para que você possa determinar se a lista é do tamanho

00:48:25.530 --> 00:48:29.650
zero não há nada sendo apontado, ou tamanho três neste caso.

00:48:29.650 --> 00:48:32.820
Nós mesmos estamos assumindo mais responsabilidades.

00:48:32.820 --> 00:48:33.390
Sim.

00:48:33.390 --> 00:48:35.350
AUDIÊNCIA: [INAUDÍVEL]

00:48:39.099 --> 00:48:41.307
DAVID J. MALAN: Como você aponta para o próximo elemento?

00:48:41.307 --> 00:48:42.780
Você pode elaborar?

00:48:42.780 --> 00:48:47.103
AUDIÊNCIA: Esses elementos apontando para o próximo, como [INAUDÍVEL]??

00:48:47.103 --> 00:48:48.520
DAVID J. MALAN: Ah, boa pergunta.

00:48:48.520 --> 00:48:50.603
Se cada um desses elementos estiver apontando para o próximo,

00:48:50.603 --> 00:48:52.360
como três apontam para os outros?

00:48:52.360 --> 00:48:53.800
Resposta curta, não.

00:48:53.800 --> 00:48:55.960
Pelo menos neste projeto temos mais tecnicamente

00:48:55.960 --> 00:48:58.300
o que é chamado de lista encadeada individualmente.

00:48:58.300 --> 00:49:01.490
E como as setas indicam, ele só vai em uma direção.

00:49:01.490 --> 00:49:04.960
Então, se você de alguma forma encontrar no código talvez um loop for, talvez um loop while,

00:49:04.960 --> 00:49:09.700
de alguma forma você está no código aqui, você não tem como no código

00:49:09.700 --> 00:49:13.150
para ir para trás, a menos que mudemos isso para uma lista duplamente vinculada

00:49:13.150 --> 00:49:17.440
onde adiciono outra caixa que me permite ter setas em ambas as direções.

00:49:17.440 --> 00:49:23.080
Ou talvez eu apenas faça circular e conecte os três de volta

00:49:23.080 --> 00:49:24.940
para aquele, o que você pode fazer totalmente.

00:49:24.940 --> 00:49:27.183
Mas isso tende a tornar a vida mais difícil porque agora você

00:49:27.183 --> 00:49:30.100
tem que descobrir quando você está preso em um loop em sua estrutura de dados.

00:49:30.100 --> 00:49:31.370
Mas é factível também.

00:49:31.370 --> 00:49:34.480
Mas como está, é um beco sem saída por design.

00:49:34.480 --> 00:49:36.730
Outras perguntas sobre este design aqui?

00:49:40.250 --> 00:49:42.570
Bem, como podemos implementar essa estrutura no código?

00:49:42.570 --> 00:49:46.370
Bem, deixe-me apenas conectar os pontos a algo que vimos antes aqui.

00:49:46.370 --> 00:49:50.780
Foi assim que, algumas semanas atrás, introduzimos a noção de pessoa.

00:49:50.780 --> 00:49:53.270
E alegamos que uma pessoa pode ter um nome e um número.

00:49:53.270 --> 00:49:55.937
Na semana passada, é claro, tiramos algumas dessas rodinhas.

00:49:55.937 --> 00:49:59.120
E uma string é tecnicamente uma estrela char em ambos os casos.

00:49:59.120 --> 00:50:01.640
Mas realmente, não há nenhuma diferença conceitual além disso.

00:50:01.640 --> 00:50:06.110
Mas vamos usar esse mesmo paradigma para implementar um nó

00:50:06.110 --> 00:50:07.757
como descrevi na foto.

00:50:07.757 --> 00:50:09.590
Então deixe-me me livrar do nome e do número

00:50:09.590 --> 00:50:11.360
porque isso está relacionado apenas a uma pessoa.

00:50:11.360 --> 00:50:15.440
E deixe-me renomear essa estrutura para fins de discussão para node.

00:50:15.440 --> 00:50:20.000
Isso então convida à pergunta, bem, o que precisa entrar em um nó?

00:50:20.000 --> 00:50:22.970
Bem, minimamente, um número inteiro.

00:50:22.970 --> 00:50:27.417
Mas é aqui que precisamos pensar um pouco mais, apenas conceitualmente.

00:50:27.417 --> 00:50:29.750
Mesmo que você não tenha ideia de como digitar no teclado,

00:50:29.750 --> 00:50:33.920
o que mais precisa fazer parte de um nó com base nessas imagens retangulares

00:50:33.920 --> 00:50:36.455
que desenhamos?

00:50:36.455 --> 00:50:37.330
Do que mais precisamos?

00:50:37.330 --> 00:50:38.246
Sim.

00:50:38.246 --> 00:50:39.755
AUDIÊNCIA: [INAUDÍVEL]

00:50:39.755 --> 00:50:40.630
DAVID J. MALAN: Sim.

00:50:40.630 --> 00:50:42.650
Precisamos de um ponteiro para outro nó.

00:50:42.650 --> 00:50:48.190
Então, se eu ainda não sei como implementar isso, pode ser algo como ponteiro

00:50:48.190 --> 00:50:49.847
para outro nó, como faço isso?

00:50:49.847 --> 00:50:50.680
Bem, você sabe o que?

00:50:50.680 --> 00:50:53.290
Acontece que você idealmente diria isso.

00:50:53.290 --> 00:50:59.260
Se você sabe que o próximo nó é um nó por definição, bem,

00:50:59.260 --> 00:51:02.752
sempre que precisamos de um ponteiro, usamos apenas o tipo de dados e uma estrela.

00:51:02.752 --> 00:51:04.960
E vou arbitrariamente, mas acho razoável,

00:51:04.960 --> 00:51:08.920
chame este segundo quadrado na parte inferior desses retângulos

00:51:08.920 --> 00:51:11.770
next como o nome do meu atributo aqui.

00:51:11.770 --> 00:51:15.760
Mas a estrela do nó apenas indica que a próxima variável

00:51:15.760 --> 00:51:19.118
não será um nó em si, mas o endereço de um nó.

00:51:19.118 --> 00:51:20.410
E foi exatamente isso que fizemos.

00:51:20.410 --> 00:51:26.240
Você me fez colocar 0x456, 0x789 naquela caixa, que é o endereço de outro nó.

00:51:26.240 --> 00:51:30.730
Portanto, a maneira como expressamos isso no código seria o nó estrela a seguir.

00:51:30.730 --> 00:51:33.830
Mas podemos chamar a variável do que quisermos.

00:51:33.830 --> 00:51:35.890
Agora, isso é um pouco de mentira branca.

00:51:35.890 --> 00:51:37.120
Mas vamos consertar isso agora.

00:51:37.120 --> 00:51:39.400
Este código não será realmente compilado.

00:51:39.400 --> 00:51:41.710
C leva você literalmente, lembre-se.

00:51:41.710 --> 00:51:45.220
E se você usar algum termo no topo do seu arquivo

00:51:45.220 --> 00:51:47.405
que você não define até mais tarde em seu arquivo,

00:51:47.405 --> 00:51:49.030
você verá alguma mensagem de erro.

00:51:49.030 --> 00:51:50.738
Nós vimos isso quando eu errei e eu

00:51:50.738 --> 00:51:53.500
esqueci de incluir os protótipos de função no topo do meu código.

00:51:53.500 --> 00:51:55.000
Isso está relacionado em espírito.

00:51:55.000 --> 00:51:57.880
Eu pareço aqui na minha uma, duas, três, quarta linha de código,

00:51:57.880 --> 00:52:00.880
Estou tentando usar esse novo termo de arte que inventei aqui

00:52:00.880 --> 00:52:04.220
no meu código chamado node, embora também seja um termo CS.

00:52:04.220 --> 00:52:08.410
Mas em nenhum lugar acima disso parece que eu defini o que é um nó.

00:52:08.410 --> 00:52:09.613
Não é um tipo de dados em C.

00:52:09.613 --> 00:52:11.530
Todos os cientistas da computação sabem o que é um nó.

00:52:11.530 --> 00:52:13.900
Mas não vem de graça com o idioma.

00:52:13.900 --> 00:52:16.330
Então eu preciso fazer outra coisa.

00:52:16.330 --> 00:52:20.420
Eu preciso que essa palavra aqui venha primeiro para que eu possa usá-la aqui.

00:52:20.420 --> 00:52:22.270
E assim, temos este catch-22.

00:52:22.270 --> 00:52:26.290
Como pode uma estrutura ser auto-referencial, ou seja,

00:52:26.290 --> 00:52:30.440
apontar para outra versão de si mesmo se a palavra ainda não existe?

00:52:30.440 --> 00:52:34.510
Portanto, a solução para isso em C, que não precisávamos para uma pessoa

00:52:34.510 --> 00:52:36.550
porque não havia noção de listagem--

00:52:36.550 --> 00:52:37.900
conectando é uma lista--

00:52:37.900 --> 00:52:41.380
precisamos de mais uma palavra-chave aqui que não precisávamos para uma pessoa.

00:52:41.380 --> 00:52:43.490
E reutilizamos essa palavra-chave aqui.

00:52:43.490 --> 00:52:45.250
Um detalhe tão irritante.

00:52:45.250 --> 00:52:49.840
Mas se chamarmos preventivamente tudo isso de struct node,

00:52:49.840 --> 00:52:54.370
agora você pode se referir à coisa interna como uma estrela do nó struct.

00:52:54.370 --> 00:52:58.630
Mas então você pode encurtar o nome de tudo de struct node

00:52:58.630 --> 00:52:59.920
para apenas nó.

00:52:59.920 --> 00:53:01.570
Uma espécie de sequência irritante de etapas.

00:53:01.570 --> 00:53:05.050
Mas, resumindo, sempre que você estiver construindo um nó, uma lista encadeada na memória,

00:53:05.050 --> 00:53:06.340
este é apenas o paradigma.

00:53:06.340 --> 00:53:10.060
Você usa typedef, struct, o nome da coisa que deseja definir, como node.

00:53:10.060 --> 00:53:14.020
Você usa esse nome no interior se quiser apontar de um para outro.

00:53:14.020 --> 00:53:18.730
E então você pode encurtá-lo aqui para ser chamado apenas de nó.

00:53:18.730 --> 00:53:23.690
Dúvidas então sobre esse código aqui?

00:53:23.690 --> 00:53:26.480
Perguntas sobre o que acabamos de fazer?

00:53:26.480 --> 00:53:32.120
Bem, se eu retroceder apenas um momento para a imagem final, qual seria a vantagem

00:53:32.120 --> 00:53:34.310
para ser claro, de ter pulado esses aros

00:53:34.310 --> 00:53:37.160
e adicionou essa complexidade se você quiser?

00:53:37.160 --> 00:53:41.390
Que problema acabamos de resolver ligando esses três valores

00:53:41.390 --> 00:53:42.050
para ser claro?

00:53:42.050 --> 00:53:42.560
Sim.

00:53:42.560 --> 00:53:44.801
AUDIÊNCIA: Fazendo listas que não são [INAUDÍVEL]..

00:53:44.801 --> 00:53:46.426
DAVID J. MALAN: Fazendo listas que são--

00:53:46.426 --> 00:53:47.805
AUDIÊNCIA: Não [INAUDÍVEL].

00:53:47.805 --> 00:53:50.180
DAVID J. MALAN: Oh, isso não é contíguo, se você quiser.

00:53:50.180 --> 00:53:52.870
Então, fazendo listas que não são contíguas na memória.

00:53:52.870 --> 00:53:56.440
A vantagem disso é que, se eu quiser adicionar o número quatro a esta lista,

00:53:56.440 --> 00:53:59.710
parece que eu poderia escolher qualquer pedaço de memória disponível

00:53:59.710 --> 00:54:00.520
na tela.

00:54:00.520 --> 00:54:04.270
Eu só preciso apontar do final da lista atual

00:54:04.270 --> 00:54:06.250
para onde quer que o outro esteja na memória.

00:54:06.250 --> 00:54:10.270
O que não preciso fazer, para ser claro, é copiar o um, o dois ou o três.

00:54:10.270 --> 00:54:11.840
Tudo pode ficar parado.

00:54:11.840 --> 00:54:14.890
O que significa que, em termos de tempo, posso fazer isso muito mais rapidamente,

00:54:14.890 --> 00:54:17.140
ao que parece, sem copiar as coisas de novo e de novo.

00:54:17.140 --> 00:54:20.710
E mesmo sem usar realloc para deixá-lo fazer toda a cópia

00:54:20.710 --> 00:54:22.060
potencialmente para mim.

00:54:22.060 --> 00:54:25.990
Mas como veremos ainda mais nas próximas semanas, cada vez que nos beneficiarmos

00:54:25.990 --> 00:54:28.450
e resolver algum problema, pagamos um preço.

00:54:28.450 --> 00:54:29.680
Há uma troca.

00:54:29.680 --> 00:54:32.440
O que é uma desvantagem como você pode perceber agora

00:54:32.440 --> 00:54:36.040
de usar uma lista vinculada em vez de uma matriz?

00:54:36.040 --> 00:54:36.670
Sim.

00:54:36.670 --> 00:54:37.900
AUDIÊNCIA: Você usa o dobro de memória.

00:54:37.900 --> 00:54:38.290
DAVID J. MALAN: Sim.

00:54:38.290 --> 00:54:39.880
Quero dizer, usamos o dobro da memória.

00:54:39.880 --> 00:54:42.547
Porque agora além de armazenar os inteiros um, dois, três,

00:54:42.547 --> 00:54:45.040
Também preciso armazenar um ponteiro para cada um deles.

00:54:45.040 --> 00:54:48.460
E honestamente, mesmo esta imagem é um pouco simplificada.

00:54:48.460 --> 00:54:51.910
Tecnicamente, na maioria dos sistemas atuais, cada int teria quatro bytes.

00:54:51.910 --> 00:54:54.767
Tecnicamente hoje, a maioria dos ponteiros teria oito bytes.

00:54:54.767 --> 00:54:57.100
Eu só não queria desenhar essa forma estranha no quadro

00:54:57.100 --> 00:54:59.558
onde o quadrado inferior é ainda maior que o quadrado superior.

00:54:59.558 --> 00:55:02.698
Mas, tecnicamente, estamos usando mais que o dobro do espaço

00:55:02.698 --> 00:55:03.490
para esses ponteiros.

00:55:03.490 --> 00:55:04.573
Portanto, há essa compensação.

00:55:04.573 --> 00:55:07.060
Agora, felizmente, décadas depois que C foi inventado,

00:55:07.060 --> 00:55:09.650
a memória é geralmente muito mais barata hoje em dia.

00:55:09.650 --> 00:55:12.180
E então, não há problema em gastar mais, se necessário.

00:55:12.180 --> 00:55:14.180
E isso depende do que você deseja otimizar.

00:55:14.180 --> 00:55:16.420
Mas isso é absolutamente uma desvantagem.

00:55:16.420 --> 00:55:20.320
Qual é outra desvantagem de ter feito a transição para uma lista encadeada?

00:55:20.320 --> 00:55:22.070
AUDIÊNCIA: [INAUDÍVEL]

00:55:22.070 --> 00:55:23.870
DAVID J. MALAN: Você não pode indexar nele.

00:55:23.870 --> 00:55:26.370
Agora, eu nem tentei no código.

00:55:26.370 --> 00:55:31.640
Mas quando você tem uma lista vinculada, não pode mais usar a notação de colchetes.

00:55:31.640 --> 00:55:32.780
Por que porque?

00:55:32.780 --> 00:55:36.410
Bem, a notação de colchetes apenas assume a contiguidade da memória.

00:55:36.410 --> 00:55:37.820
A localização zero é aqui.

00:55:37.820 --> 00:55:39.950
O local um é literalmente um à direita.

00:55:39.950 --> 00:55:42.590
O local dois é literalmente um à direita, um à direita.

00:55:42.590 --> 00:55:45.350
Essas coisas, mesmo que eu tenha desenhado da direita para a esquerda

00:55:45.350 --> 00:55:48.050
para apenas manter as coisas bonitas, existem lacunas aqui.

00:55:48.050 --> 00:55:49.970
E esta é apenas a minha interpretação disso.

00:55:49.970 --> 00:55:51.225
Essas lacunas podem ser grandes.

00:55:51.225 --> 00:55:52.100
Eles podem ser estreitos.

00:55:52.100 --> 00:55:53.720
Eles podem estar aqui em baixo, aqui em cima.

00:55:53.720 --> 00:55:57.320
Eles podem estar em qualquer lugar, desde que estejamos ligando as coisas nesta lista.

00:55:57.320 --> 00:56:01.130
O computador não pode mais usar colchete zero, colchete um, colchete dois

00:56:01.130 --> 00:56:04.490
porque não pode fazer aritmética simples e pular para o meio.

00:56:04.490 --> 00:56:06.980
E agora, aqui está talvez o pior preço que pagamos.

00:56:06.980 --> 00:56:09.860
Se você não tem notação de colchetes, ou realmente,

00:56:09.860 --> 00:56:12.920
você não tem contiguidade, o algoritmo fez

00:56:12.920 --> 00:56:16.540
nós apenas nos sacrificamos por esse dinamismo?

00:56:16.540 --> 00:56:20.230
Se você voltar até a semana zero.

00:56:20.230 --> 00:56:23.680
E demos um nome a ele na terceira semana.

00:56:23.680 --> 00:56:27.250
Que algoritmo não podemos usar agora se não podemos assumir que a memória está

00:56:27.250 --> 00:56:29.603
para trás, para trás, para trás, para trás?

00:56:29.603 --> 00:56:30.350
AUDIÊNCIA: Binário?

00:56:30.350 --> 00:56:31.940
DAVID J. MALAN: Pesquisa binária.

00:56:31.940 --> 00:56:32.570
Por que?

00:56:32.570 --> 00:56:36.350
Porque a busca binária, assim como a lista telefônica, na primeira semana,

00:56:36.350 --> 00:56:39.950
requer ser capaz de pular aritmeticamente direto para o meio.

00:56:39.950 --> 00:56:42.260
Pegue o comprimento total dele, divida por dois e bum.

00:56:42.260 --> 00:56:44.802
Você está bem aí no meio com alguma aritmética simples.

00:56:44.802 --> 00:56:49.520
Aqui eles podem ser dispostos, novamente, com essas grandes ou pequenas lacunas.

00:56:49.520 --> 00:56:52.148
Não há matemática simples que eu possa fazer para pular imediatamente

00:56:52.148 --> 00:56:53.190
para o do meio.

00:56:53.190 --> 00:56:55.100
E, de fato, novamente, se esta TV fosse maior,

00:56:55.100 --> 00:56:59.038
os dois poderiam tecnicamente estar na memória bem aqui embaixo ou até bem aqui.

00:56:59.038 --> 00:57:01.580
O dedo de espuma pode estar apontando em várias direções

00:57:01.580 --> 00:57:03.380
dependendo de onde malloc colocou a coisa.

00:57:03.380 --> 00:57:05.630
Simplesmente não há como fazer pesquisa binária.

00:57:05.630 --> 00:57:08.360
E assim, parece que pagamos outro preço de fato

00:57:08.360 --> 00:57:09.980
em termos de desempenho.

00:57:09.980 --> 00:57:13.170
Agora estamos falando sobre o tempo linear novamente.

00:57:13.170 --> 00:57:14.580
Então isso é uma regressão.

00:57:14.580 --> 00:57:16.128
Agora, isso também é muito.

00:57:16.128 --> 00:57:18.920
Parece um bom momento para alguns muffins e frutas no saguão.

00:57:18.920 --> 00:57:21.837
E quando voltarmos, tentaremos resolver o problema que acabamos de criar.

00:57:21.837 --> 00:57:23.060
Então nos vemos em 10.

00:57:23.060 --> 00:57:24.290
Então estamos de volta.

00:57:24.290 --> 00:57:26.900
E vamos ver se não podemos pegar alguns desses níveis mais altos

00:57:26.900 --> 00:57:29.930
conceitos de unir esses nós na memória

00:57:29.930 --> 00:57:31.933
e traduzi-lo para algum código real.

00:57:31.933 --> 00:57:34.100
Mas vamos fazer isso passo a passo antes de eu realmente

00:57:34.100 --> 00:57:35.360
comece a escrevê-lo no VS Code.

00:57:35.360 --> 00:57:38.485
Então, se, Carter, você não se importar em me ajudar com alguns recursos visuais,

00:57:38.485 --> 00:57:41.630
deixe-me propor que, linha por linha, resolvamos alguns dos problemas

00:57:41.630 --> 00:57:44.730
que acabamos de criar para nós mesmos ao construir essa coisa na memória.

00:57:44.730 --> 00:57:48.620
Então vamos em frente e primeiro considerar como nós

00:57:48.620 --> 00:57:52.950
poderia construir uma lista encadeada contendo os números de fato um, então dois, então

00:57:52.950 --> 00:57:53.450
três.

00:57:53.450 --> 00:57:55.160
E vamos traduzir cada uma dessas etapas para o código

00:57:55.160 --> 00:57:57.510
e então juntaremos tudo em algo que realmente funcione.

00:57:57.510 --> 00:58:00.020
Então, que tal o primeiro passo aqui será apenas isso.

00:58:00.020 --> 00:58:04.460
Para declarar um ponteiro chamado lista que inicialmente não tem valor,

00:58:04.460 --> 00:58:05.990
pelo menos neste ponto da história.

00:58:05.990 --> 00:58:07.640
Lista é o nome da variável.

00:58:07.640 --> 00:58:09.980
Nó estrela significa apenas que isso é essencialmente

00:58:09.980 --> 00:58:12.590
vai ser a nossa pracinha aqui que

00:58:12.590 --> 00:58:14.780
aponta para o início da lista.

00:58:14.780 --> 00:58:17.750
Claro, é ideal se tiver um valor.

00:58:17.750 --> 00:58:21.050
Porque quando inicialmente chamamos essa linha de código,

00:58:21.050 --> 00:58:24.050
apenas nos dá aquele quadrado aqui à esquerda.

00:58:24.050 --> 00:58:27.230
Mas tem um valor de lixo porque não há sinal de igual do outro lado

00:58:27.230 --> 00:58:27.780
lá.

00:58:27.780 --> 00:58:30.080
Então, vamos propor que façamos mais uma etapa aqui

00:58:30.080 --> 00:58:34.160
e, na verdade, inicializá-lo como nulo para que, se apenas

00:58:34.160 --> 00:58:37.177
sabemos que não é lixo, pelo menos tem algum valor conhecido.

00:58:37.177 --> 00:58:40.010
E nulo é uma boa maneira de significar que neste ponto da história

00:58:40.010 --> 00:58:41.240
A lista está vazia.

00:58:41.240 --> 00:58:44.390
De fato, null indica que não há nós na lista.

00:58:44.390 --> 00:58:46.930
Então essa imagem agora ficaria assim, onde vamos apenas

00:58:46.930 --> 00:58:48.680
desenhar - em vez de escrever nulo em todos os lugares,

00:58:48.680 --> 00:58:51.680
Vou deixar os quadrados em branco quando não for um valor de lixo, por si só.

00:58:51.680 --> 00:58:54.320
É literalmente 0x0 ou nulo.

00:58:54.320 --> 00:58:57.650
Então é isso para construir uma lista encadeada de tamanho zero.

00:58:57.650 --> 00:58:58.942
Acabamos então.

00:58:58.942 --> 00:59:01.400
Mas agora queremos adicionar um, depois um dois e depois um três.

00:59:01.400 --> 00:59:03.290
Então, o próximo passo aqui pode ser este.

00:59:03.290 --> 00:59:08.030
Se eu quiser alocar o primeiro dos meus retângulos em nossa imagem anterior,

00:59:08.030 --> 00:59:09.200
Vou ligar para malloc.

00:59:09.200 --> 00:59:12.650
E vou pedir memória suficiente para caber em um nó inteiro.

00:59:12.650 --> 00:59:15.572
Agora, tecnicamente, acho que serão quatro bytes para o int

00:59:15.572 --> 00:59:17.780
e oito bytes para o ponteiro, embora eu não

00:59:17.780 --> 00:59:19.650
desenhe-o em escala no quadro.

00:59:19.650 --> 00:59:21.890
Tecnicamente, isso será o quê, 12 bytes?

00:59:21.890 --> 00:59:24.740
Mas, novamente, o tamanho do nó apenas calcula quantos

00:59:24.740 --> 00:59:26.450
bytes que eu realmente preciso dinamicamente.

00:59:26.450 --> 00:59:30.200
Isso vai me retornar o endereço daquele pedaço de memória, que

00:59:30.200 --> 00:59:33.860
aparentemente vou armazenar dentro de uma variável temporária chamada n

00:59:33.860 --> 00:59:35.060
para abreviar para nó.

00:59:35.060 --> 00:59:37.010
Mas vamos ver o que isso faz pictoricamente.

00:59:37.010 --> 00:59:39.710
Então, quando esta linha de código é executada, primeiro obtenho,

00:59:39.710 --> 00:59:41.930
à esquerda, aquela variável n.

00:59:41.930 --> 00:59:45.410
Tem um valor de lixo por padrão porque não executei

00:59:45.410 --> 00:59:47.143
a coisa toda da direita para a esquerda.

00:59:47.143 --> 00:59:49.310
Enquanto isso, no lado direito da expressão,

00:59:49.310 --> 00:59:51.320
Agora tenho um nó em algum lugar da memória.

00:59:51.320 --> 00:59:52.550
Aconteceu de ser gratuito aqui.

00:59:52.550 --> 00:59:54.203
Foi aqui que malloc colocou para mim.

00:59:54.203 --> 00:59:56.120
Mas tem dois valores de lixo inicialmente.

00:59:56.120 --> 01:00:01.040
Mas como é um nó de acordo com meu typedef anterior, cada nó que propus

01:00:01.040 --> 01:00:03.980
vai ter um número e um próximo ponteiro.

01:00:03.980 --> 01:00:05.660
Assim, podemos ver aqueles rotulados aqui.

01:00:05.660 --> 01:00:07.640
Mas eles têm dois valores de lixo inicialmente.

01:00:07.640 --> 01:00:11.120
Mas tudo o que me importa inicialmente é que, em última análise, n

01:00:11.120 --> 01:00:13.520
está apontando para aquele pedaço de código.

01:00:13.520 --> 01:00:18.600
Inicialmente, se pudermos recuar duas etapas, temos... duas etapas.

01:00:18.600 --> 01:00:20.720
Então temos inicialmente-- oh, um passo à frente.

01:00:20.720 --> 01:00:25.790
Temos essa linha de código que nos dá essa variável aqui, que tem lixo.

01:00:25.790 --> 01:00:29.660
Quando este lado da expressão é executado, isso aloca a memória.

01:00:29.660 --> 01:00:32.720
E então, quando copiamos da direita para a esquerda o endereço

01:00:32.720 --> 01:00:36.290
desse pedaço de memória, é isso que nos dá conceitualmente essa flecha.

01:00:36.290 --> 01:00:38.848
E o lixo vai embora porque agora é um ponteiro válido.

01:00:38.848 --> 01:00:40.640
Claro, ainda há dois valores de lixo

01:00:40.640 --> 01:00:43.940
porque não definimos este nó para armazenar um número como o número um.

01:00:43.940 --> 01:00:46.107
Então, vamos em frente e executar outra linha de código

01:00:46.107 --> 01:00:49.850
como este, que, embora enigmático, é apenas uma aplicação de ideias

01:00:49.850 --> 01:00:51.890
vimos na semana quatro e anteriores.

01:00:51.890 --> 01:00:56.060
Star n significa começar nesta variável e ir até lá.

01:00:56.060 --> 01:01:00.240
Seguir a seta é o que a estrela ou o operador de referência faz por nós.

01:01:00.240 --> 01:01:03.440
E então, o operador ponto, lembre-se, quando introduzimos structs pela primeira vez,

01:01:03.440 --> 01:01:06.110
como para uma estrutura de pessoa, nos permite ir

01:01:06.110 --> 01:01:08.190
no campo numérico ou no próximo campo.

01:01:08.190 --> 01:01:10.910
Então, se eu fizer asterisco n, e depois entre parênteses

01:01:10.910 --> 01:01:12.890
para garantir que a ordem das operações seja preservada,

01:01:12.890 --> 01:01:15.920
número de ponto e, em seguida, atribua a ele o número real um,

01:01:15.920 --> 01:01:18.270
que coloca aquele no topo desse retângulo.

01:01:18.270 --> 01:01:20.747
Agora, reconhecidamente, essa sintaxe não é muito amigável.

01:01:20.747 --> 01:01:21.830
É chato lembrar.

01:01:21.830 --> 01:01:23.070
Você tem que ter os parênteses.

01:01:23.070 --> 01:01:24.660
Portanto, há outra sintaxe para isso.

01:01:24.660 --> 01:01:27.335
Sempre que você estiver fazendo duas coisas como esta no código,

01:01:27.335 --> 01:01:31.010
desreferenciando um ponteiro que está indo para um endereço.

01:01:31.010 --> 01:01:34.940
E então, usando a notação de ponto para entrar na estrutura,

01:01:34.940 --> 01:01:38.900
você descobre que maravilhosamente C nos dá essa sintaxe, pela qual

01:01:38.900 --> 01:01:41.510
você pode apenas mudar a estrela e os parênteses

01:01:41.510 --> 01:01:43.387
e o ponto para ser apenas uma seta.

01:01:43.387 --> 01:01:45.720
E, novamente, não é um único caractere em seu teclado.

01:01:45.720 --> 01:01:47.690
É um hífen e, em seguida, um colchete angular aberto.

01:01:47.690 --> 01:01:49.400
Mas eu meio que gosto da semântica disso.

01:01:49.400 --> 01:01:53.810
Porque este código agora corresponde à imagem-- n seta

01:01:53.810 --> 01:01:56.780
leva você ao valor que você deseja acessar ou, finalmente,

01:01:56.780 --> 01:01:58.050
mudar desta forma.

01:01:58.050 --> 01:01:59.930
Há uma etapa, porém, que esquecemos,

01:01:59.930 --> 01:02:03.110
claro, que é que não podemos deixar esse valor de lixo aqui.

01:02:03.110 --> 01:02:07.070
Como o valor do lixo é algum valor desconhecido que efetivamente

01:02:07.070 --> 01:02:08.510
está apontando quem sabe para onde.

01:02:08.510 --> 01:02:10.580
E não queremos interpretar mal acidentalmente

01:02:10.580 --> 01:02:14.160
esse valor de lixo como sendo um endereço válido e corre o risco de ir para lá.

01:02:14.160 --> 01:02:17.660
Então, é claro, que valor devemos colocar aqui?

01:02:17.660 --> 01:02:20.780
Nosso velho amigo nulo, apenas para significar que isso é realmente

01:02:20.780 --> 01:02:21.665
o fim da lista.

01:02:21.665 --> 01:02:23.790
E poderíamos fazer isso com uma linha de código como esta.

01:02:23.790 --> 01:02:27.300
E, novamente, vamos conotar apenas deixando essa caixa vazia em branco.

01:02:27.300 --> 01:02:29.450
Então, agora, temos uma lista de tamanho um.

01:02:29.450 --> 01:02:33.050
Vamos adicionar o segundo número a ele como nestas linhas aqui.

01:02:33.050 --> 01:02:39.150
List equals n nos permite lembrar que, de fato, temos essa lista aqui.

01:02:39.150 --> 01:02:40.980
Então, se pudermos dar um passo à frente.

01:02:40.980 --> 01:02:42.920
Aqui está a aparência da imagem agora.

01:02:42.920 --> 01:02:45.470
E tecnicamente, vamos dar um passo adiante aqui.

01:02:45.470 --> 01:02:50.270
Isso é realmente o que está acontecendo na memória quando minha lista de tamanho um existe.

01:02:50.270 --> 01:02:55.148
Minha variável principal chamada lista está apontando exatamente para o primeiro nó.

01:02:55.148 --> 01:02:57.440
Neste ponto da história eu não preciso saber ou me importar

01:02:57.440 --> 01:03:00.200
sobre a variável temporária que chamei de n, embora

01:03:00.200 --> 01:03:01.550
pode muito bem ainda estar lá.

01:03:01.550 --> 01:03:03.950
Mas, de fato, isso agora representa essa lista vinculada.

01:03:03.950 --> 01:03:05.900
Vamos agora realmente adicionar o número dois.

01:03:05.900 --> 01:03:09.590
Então, com a mesma linha de código de antes, vou alocar outro nó.

01:03:09.590 --> 01:03:10.700
Tamanho do nó.

01:03:10.700 --> 01:03:12.620
Idealmente, eu estaria verificando null aqui.

01:03:12.620 --> 01:03:15.090
Mas estamos fazendo as partes interessantes apenas nos slides.

01:03:15.090 --> 01:03:16.740
Vamos agora em frente e retratar isso.

01:03:16.740 --> 01:03:17.825
Então, o que acontece com isso?

01:03:17.825 --> 01:03:21.740
Isso traz de volta nosso ponteiro n, que pode estar lá o tempo todo.

01:03:21.740 --> 01:03:23.250
Mas estamos fazendo isso passo a passo.

01:03:23.250 --> 01:03:26.120
É um valor de lixo porque ainda não copiamos da direita para a esquerda.

01:03:26.120 --> 01:03:27.980
Malloc, é claro, nos dá um segundo pedaço

01:03:27.980 --> 01:03:31.100
de memória, que talvez acabe com dois valores de lixo

01:03:31.100 --> 01:03:34.100
por padrão. Eu omiti os rótulos agora só porque eles ainda vão

01:03:34.100 --> 01:03:36.590
para ser número e próximo, respectivamente.

01:03:36.590 --> 01:03:40.610
Uma vez que copiamos da direita para a esquerda, o valor do lixo realmente se torna uma seta.

01:03:40.610 --> 01:03:44.900
Oscar desaparece porque agora é de fato um ponteiro válido apontando aqui.

01:03:44.900 --> 01:03:48.290
Agora, os próprios valores number e next são inválidos--

01:03:48.290 --> 01:03:49.140
valor lixo.

01:03:49.140 --> 01:03:53.570
Aqui é onde podemos começar a usar nossa nova sintaxe como a notação de seta

01:03:53.570 --> 01:03:55.430
ou a estrela e o ponto se preferir.

01:03:55.430 --> 01:03:57.860
E podemos mudar o valor de n--

01:03:57.860 --> 01:03:59.870
siga a seta para numerar.

01:03:59.870 --> 01:04:01.220
E isso se torna dois.

01:04:01.220 --> 01:04:05.340
Da mesma forma, podemos fazer isso novamente e definir a seta n a seguir.

01:04:05.340 --> 01:04:08.930
Então comece em n, siga a seta, acesse o próximo campo,

01:04:08.930 --> 01:04:10.670
e defina-o como nulo.

01:04:10.670 --> 01:04:13.460
Ainda não terminamos porque ainda não

01:04:13.460 --> 01:04:14.908
uniu as coisas.

01:04:14.908 --> 01:04:16.700
Então é aqui que as coisas ficam interessantes.

01:04:16.700 --> 01:04:18.470
Como faço para combinar esses dois?

01:04:18.470 --> 01:04:20.160
Bem, deixe-me propor isso.

01:04:20.160 --> 01:04:24.080
Deixe-me propor em nossa próxima linha aqui, nós realmente atualizamos por enquanto

01:04:24.080 --> 01:04:26.420
lista igual a n.

01:04:26.420 --> 01:04:29.690
Ou seja, seja qual for o endereço, seja qual for o destino,

01:04:29.690 --> 01:04:33.330
lista de alteração para ser o mesmo endereço que aponta para a mesma coisa.

01:04:33.330 --> 01:04:37.280
Então, se n está apontando aqui, vamos mudar a lista para apontar aqui.

01:04:37.280 --> 01:04:39.470
E vá em frente e faça isso, Carter, se puder.

01:04:39.470 --> 01:04:41.040
Eu não gosto disso.

01:04:41.040 --> 01:04:42.650
Você pode dar mais um passo?

01:04:42.650 --> 01:04:44.180
Isto é mau.

01:04:44.180 --> 01:04:48.800
O que há de errado com minha sequência de operações aqui onde atualizei a lista

01:04:48.800 --> 01:04:51.370
apontar para o meu novo nó?

01:04:51.370 --> 01:04:52.060
Sim.

01:04:52.060 --> 01:04:53.105
AUDIÊNCIA: Nós [INAUDÍVEL].

01:04:53.105 --> 01:04:53.980
DAVID J. MALAN: Sim.

01:04:53.980 --> 01:04:56.090
Perdemos o ponteiro para o outro nó.

01:04:56.090 --> 01:04:59.830
Então nem me importo com a ordem, dois um ou um dois.

01:04:59.830 --> 01:05:03.610
O maior problema agora, como sugere a falta de setas ali

01:05:03.610 --> 01:05:05.260
é que eu tenho um vazamento de memória.

01:05:05.260 --> 01:05:08.140
Eu tornei órfão meu nó original no sentido

01:05:08.140 --> 01:05:10.425
que nada mais aponta para ele.

01:05:10.425 --> 01:05:13.300
Agora, com certeza, eu poderia consertar isso adicionando algumas variáveis ​​temporárias.

01:05:13.300 --> 01:05:14.383
Eu poderia adicioná-lo à mistura.

01:05:14.383 --> 01:05:18.280
Mas, neste ponto da história, não tenho nenhuma lembrança desse tipo.

01:05:18.280 --> 01:05:19.450
Então deixe-me apoiar isso.

01:05:19.450 --> 01:05:20.930
E vamos adiante nos slides.

01:05:20.930 --> 01:05:22.660
Foi aqui que paramos há pouco.

01:05:22.660 --> 01:05:25.923
Acho que preciso levar em conta a ordem das operações.

01:05:25.923 --> 01:05:27.340
E eu vou manter isso simples.

01:05:27.340 --> 01:05:30.130
Não vou me importar com a ordem dos números por enquanto.

01:05:30.130 --> 01:05:33.260
Eu estou bem com uma lista que é dois e depois um.

01:05:33.260 --> 01:05:36.110
Então, com isso dito, deixe-me ir em frente e atualizar,

01:05:36.110 --> 01:05:39.800
Eu acho, esta caixa aqui para apontar para o meu nó original.

01:05:39.800 --> 01:05:42.280
Então, vamos ver como poderíamos fazer isso no código.

01:05:42.280 --> 01:05:43.820
n seta a seguir.

01:05:43.820 --> 01:05:48.945
Portanto, n, seta, próximo deve ser igual à lista atual.

01:05:48.945 --> 01:05:50.320
E isso é um pouco estranho novamente.

01:05:50.320 --> 01:05:51.670
Mas lembre-se do que é lista.

01:05:51.670 --> 01:05:54.070
Lista é este ponteiro aqui que contém apenas

01:05:54.070 --> 01:05:57.700
o endereço do endereço original da lista,

01:05:57.700 --> 01:06:01.370
ou equivalentemente, ele contém esta seta, seja lá o que estiver apontando.

01:06:01.370 --> 01:06:05.500
Então, o que isso significa nesta linha de código, n colchete próximo significa iniciar em n,

01:06:05.500 --> 01:06:07.900
siga a seta, acesse o próximo ponteiro,

01:06:07.900 --> 01:06:10.690
e defini-lo igual a qualquer lista igual.

01:06:10.690 --> 01:06:16.000
Portanto, se a lista estiver apontando para aqui, o próximo também deve apontar para lá.

01:06:16.000 --> 01:06:17.530
Isso, eu acho, é seguro.

01:06:17.530 --> 01:06:18.880
Porque agora temos redundância.

01:06:18.880 --> 01:06:21.700
Agora temos dois ponteiros apontando para a lista original.

01:06:21.700 --> 01:06:26.860
E agora acho que podemos fazer outra etapa em que atualizamos a lista para igual a n,

01:06:26.860 --> 01:06:29.150
mesma linha de código antes que nos colocasse em apuros.

01:06:29.150 --> 01:06:31.150
Mas estou fazendo isso em segundo lugar agora, em vez de primeiro.

01:06:31.150 --> 01:06:36.340
Quando executo list equals n, isso agora define list igual à mesma coisa

01:06:36.340 --> 01:06:37.570
que n é igual.

01:06:37.570 --> 01:06:41.650
E assim, agora inseri com sucesso meu novo nó

01:06:41.650 --> 01:06:44.440
contendo dois na lista.

01:06:44.440 --> 01:06:46.480
E de fato, se avançarmos mais um, podemos apenas

01:06:46.480 --> 01:06:48.940
limpe a bagunça, assuma que a variável temporária é

01:06:48.940 --> 01:06:50.080
sumiu da história.

01:06:50.080 --> 01:06:53.067
Agora temos uma lista vinculada em que a ordem está errada.

01:06:53.067 --> 01:06:54.400
É dois um em vez de um dois.

01:06:54.400 --> 01:06:56.260
Mas pelo menos está vinculado corretamente.

01:06:56.260 --> 01:07:00.630
E não fiquei órfão nem vazei nenhuma memória.

01:07:00.630 --> 01:07:04.440
Dúvidas sobre esta sequência de passos aqui?

01:07:04.440 --> 01:07:05.894
Sim, atrás.

01:07:05.894 --> 01:07:09.858
AUDIÊNCIA: Então [INAUDÍVEL] isso é tudo tipo [INAUDÍVEL], certo?

01:07:09.858 --> 01:07:11.945
[INAUDÍVEL]

01:07:11.945 --> 01:07:12.820
DAVID J. MALAN: Sim.

01:07:12.820 --> 01:07:13.460
No local.

01:07:13.460 --> 01:07:17.020
Portanto, isso se enquadraria nessa categoria de pilha, se você quiser.

01:07:17.020 --> 01:07:21.070
Embora eu não tenha chamado isso pelo nome porque apenas apertei o número dois

01:07:21.070 --> 01:07:22.780
nesta estrutura de dados, se você quiser.

01:07:22.780 --> 01:07:26.320
E, de fato, acabou no início da lista, e não no final.

01:07:26.320 --> 01:07:29.182
E aqui é onde vemos uma distinção entre dados abstratos

01:07:29.182 --> 01:07:30.640
estrutura, que é onde começamos.

01:07:30.640 --> 01:07:34.030
Uma pilha é uma coisa como a pilha de suéteres que só tem push e pop

01:07:34.030 --> 01:07:37.000
propriedades e acesso LIFO--

01:07:37.000 --> 01:07:39.040
ultimo a entrar primeiro a sair.

01:07:39.040 --> 01:07:41.320
Como você implementa algo assim na memória?

01:07:41.320 --> 01:07:45.310
Bem, parece que você poderia implementar a noção de uma pilha aqui

01:07:45.310 --> 01:07:48.350
não para blusas, mas para números usando uma lista encadeada.

01:07:48.350 --> 01:07:51.220
Contanto que você implemente a inserção, também conhecida como

01:07:51.220 --> 01:07:56.030
empurrando fingindo novos valores para a lista fingindo repetidamente.

01:07:56.030 --> 01:07:58.780
E se, Carter, você não se importar de bater no teclado mais uma vez.

01:07:58.780 --> 01:08:00.970
Se eu quisesse adicionar o número três agora, você

01:08:00.970 --> 01:08:03.610
poderia imaginar adicioná-lo à lista.

01:08:03.610 --> 01:08:04.310
Por que?

01:08:04.310 --> 01:08:07.520
Bem, honestamente, especialmente à medida que esta lista fica cada vez mais longa,

01:08:07.520 --> 01:08:10.780
Eu meio que gosto do apelo de anexar esses elementos.

01:08:10.780 --> 01:08:11.320
Por que?

01:08:11.320 --> 01:08:15.040
Porque mesmo que essa lista se torne louca por muito tempo, bem aqui,

01:08:15.040 --> 01:08:17.770
você não me notou seguindo todas as setas

01:08:17.770 --> 01:08:19.149
antes para fazer as inserções.

01:08:19.149 --> 01:08:22.569
Se eu quiser inserir um quarto número, um quinto número, um sexto número,

01:08:22.569 --> 01:08:24.880
tudo o que tenho a fazer é inseri-lo aqui, se você

01:08:24.880 --> 01:08:29.680
irá, aponte-o para o início original da lista e, em seguida, atualize este ponteiro,

01:08:29.680 --> 01:08:30.290
E feito.

01:08:30.290 --> 01:08:32.830
E eu diria que são dois passos, mais ou menos.

01:08:32.830 --> 01:08:35.200
Não vai ser n passos como seria

01:08:35.200 --> 01:08:39.050
se eu tivesse que acrescentar os novos nós ao final da lista.

01:08:39.050 --> 01:08:41.705
Agora, é claro, sacrificamos a ordem desses números.

01:08:41.705 --> 01:08:44.080
Eles estão literalmente na ordem oposta ou qualquer ordem

01:08:44.080 --> 01:08:45.140
em que foram inseridos.

01:08:45.140 --> 01:08:48.833
Mas isso pode muito bem ser bom, dependendo do objetivo em questão.

01:08:48.833 --> 01:08:50.750
Obrigado a Carter por passar por isso.

01:08:50.750 --> 01:08:52.479
E se agora quiséssemos traduzir isso--

01:08:52.479 --> 01:08:52.930
[APLAUSOS]

01:08:52.930 --> 01:08:53.430
Ah com certeza.

01:08:53.430 --> 01:08:55.480
Obrigado.

01:08:55.480 --> 01:08:59.240
[RISOS] É tudo para você, nada para mim neste exemplo.

01:08:59.240 --> 01:09:02.200
Então aqui temos talvez uma maneira de traduzir isso agora

01:09:02.200 --> 01:09:03.430
a algum código real.

01:09:03.430 --> 01:09:06.040
E este será o último do código intenso

01:09:06.040 --> 01:09:09.160
aqui apenas para dar uma ideia de como podemos traduzir essa ideia agora

01:09:09.160 --> 01:09:10.580
aos passos reais.

01:09:10.580 --> 01:09:13.189
Portanto, este é list.c no VS Code aqui.

01:09:13.189 --> 01:09:15.490
Deixe-me prosseguir e fazer algumas alterações no topo.

01:09:15.490 --> 01:09:16.420
Deixe-me ir em frente.

01:09:16.420 --> 01:09:22.120
E que tal declarar um nó usando typedef struct

01:09:22.120 --> 01:09:25.120
nó usando nosso novo enquadramento como antes.

01:09:25.120 --> 01:09:27.760
Vou dar um número a cada nó, como propus.

01:09:27.760 --> 01:09:31.390
E cada nó um ponteiro para o próximo elemento, que é

01:09:31.390 --> 01:09:33.850
será implementado como antes.

01:09:33.850 --> 01:09:36.380
E vou simplificar todo o nome como apenas node.

01:09:36.380 --> 01:09:40.300
Portanto, tudo isso é exatamente o mesmo typedef que propusemos anteriormente.

01:09:40.300 --> 01:09:44.830
Agora, deixe-me ir em frente e me livrar de todo esse código que escrevemos anteriormente.

01:09:44.830 --> 01:09:48.250
E lembre-se que esta foi a versão mais recente que não era uma lista encadeada.

01:09:48.250 --> 01:09:52.090
Este foi apenas um array que alocamos e depois realocamos.

01:09:52.090 --> 01:09:54.350
Portanto, esta é a velha maneira de fazer as coisas.

01:09:54.350 --> 01:09:58.210
Mas era ineficiente porque poderíamos ter que nos apoiar em um loop for

01:09:58.210 --> 01:10:00.760
ou apoie-se no realloc para copiar tudo ao seu redor.

01:10:00.760 --> 01:10:04.930
Agora vamos reimplementar a noção de uma lista como um link real

01:10:04.930 --> 01:10:07.670
lista, não como uma matriz.

01:10:07.670 --> 01:10:10.150
Portanto, minha função principal agora pode fazer algo assim.

01:10:10.150 --> 01:10:12.330
E eu vou apenas copiar as linhas de código

01:10:12.330 --> 01:10:14.080
que acabamos de passar no quadro.

01:10:14.080 --> 01:10:17.710
Então deixe-me dar a mim mesmo uma variável especial chamada lista.

01:10:17.710 --> 01:10:19.360
Isso será inicializado como nulo.

01:10:19.360 --> 01:10:22.540
E este é apenas o meu ponteiro, o quadrado no lado esquerdo da tela

01:10:22.540 --> 01:10:24.235
que representa o início da lista.

01:10:24.235 --> 01:10:26.110
E se for nulo, significa que a lista está vazia.

01:10:26.110 --> 01:10:26.830
Pronto.

01:10:26.830 --> 01:10:30.460
Terminei de implementar uma lista encadeada de tamanho zero.

01:10:30.460 --> 01:10:32.462
Bem, agora, como eu quero executar este código?

01:10:32.462 --> 01:10:34.420
Bem, deixe-me propor para o bem da discussão

01:10:34.420 --> 01:10:37.482
que esta versão do programa terá argumentos de linha de comando.

01:10:37.482 --> 01:10:39.440
Então eu quero ser capaz de fazer algo assim.

01:10:39.440 --> 01:10:43.060
Eu quero executar este programa e digitar três linhas de comando

01:10:43.060 --> 01:10:44.680
argumentos como este, um, dois, três.

01:10:44.680 --> 01:10:47.530
E eu quero meu programa em alguns minutos

01:10:47.530 --> 01:10:51.400
para alocar um, dois, três nós e juntá-los apenas

01:10:51.400 --> 01:10:54.070
como a visualização no quadro.

01:10:54.070 --> 01:10:55.290
Eu poderia usar get int.

01:10:55.290 --> 01:10:58.040
Mas será mais rápido se usarmos argumentos de linha de comando.

01:10:58.040 --> 01:11:00.550
Então, novamente, estou apenas pegando emprestados alguns conceitos da segunda semana.

01:11:00.550 --> 01:11:03.382
Mas nada disso é possível até que eu mude meu código aqui.

01:11:03.382 --> 01:11:04.090
Então vamos fazer isso.

01:11:04.090 --> 01:11:08.560
Int argc string argv.

01:11:08.560 --> 01:11:10.030
Mas você sabe o que?

01:11:10.030 --> 01:11:12.800
Sabemos que as cordas não são mais uma coisa.

01:11:12.800 --> 01:11:16.600
Assim, posso alterar minha definição de argumento de linha de comando para ser o que realmente é.

01:11:16.600 --> 01:11:18.040
É realmente char star.

01:11:18.040 --> 01:11:20.230
Mas é exatamente a mesma coisa que na segunda semana,

01:11:20.230 --> 01:11:23.500
apenas cordas não existem mais, pelo menos sem as rodinhas

01:11:23.500 --> 01:11:25.360
em mais como na semana passada.

01:11:25.360 --> 01:11:27.070
E agora deixe-me fazer isso.

01:11:27.070 --> 01:11:33.210
Para int i igual a um, i é menor que argc i plus, plus.

01:11:33.210 --> 01:11:34.960
Então, o que estou fazendo com esse loop é apenas

01:11:34.960 --> 01:11:36.918
deseja iterar sobre o argumento da linha de comando.

01:11:36.918 --> 01:11:39.820
Portanto, tenho um número de cada vez no prompt.

01:11:39.820 --> 01:11:42.980
O que mais eu quero fazer aqui?

01:11:42.980 --> 01:11:48.170
Bem, vamos em frente, e que tal fazer isso.

01:11:48.170 --> 01:11:49.730
Vamos pegar um número.

01:11:49.730 --> 01:11:53.140
Então int number é igual a argv colchete i.

01:11:53.140 --> 01:11:54.530
Então, algumas notas aqui.

01:11:54.530 --> 01:11:58.390
Um, estou começando o loop em um em vez de zero.

01:11:58.390 --> 01:11:59.890
Mas eu estou indo para argc.

01:11:59.890 --> 01:12:02.530
argc é a contagem de argumentos, quantas palavras estão no prompt.

01:12:02.530 --> 01:12:07.930
Por que estou começando em um em vez de zero, considerando meu objetivo?

01:12:07.930 --> 01:12:09.220
Por que estou começando um?

01:12:09.220 --> 01:12:10.610
Sim.

01:12:10.610 --> 01:12:15.805
AUDIÊNCIA: Porque [INAUDÍVEL] o primeiro valor [INAUDÍVEL]..

01:12:15.805 --> 01:12:16.680
DAVID J. MALAN: Sim.

01:12:16.680 --> 01:12:19.860
Portanto, o primeiro valor em argv é, na verdade, o nome do programa.

01:12:19.860 --> 01:12:21.130
Isso obviamente não é um número.

01:12:21.130 --> 01:12:22.493
Então eu quero o segundo valor.

01:12:22.493 --> 01:12:25.410
Vou começar a iterar sobre esses argumentos de linha de comando em i

01:12:25.410 --> 01:12:25.937
igual a um.

01:12:25.937 --> 01:12:26.520
Então isso é tudo.

01:12:26.520 --> 01:12:29.340
Eu só quero obter os números reais no prompt.

01:12:29.340 --> 01:12:33.910
Infelizmente, argv, colchete i, é uma string, também conhecida como

01:12:33.910 --> 01:12:34.410
char estrela.

01:12:34.410 --> 01:12:35.267
Isso não é um int.

01:12:35.267 --> 01:12:36.600
Portanto, esta linha de código não funcionará.

01:12:36.600 --> 01:12:39.690
Mas alguém pode pensar na segunda semana, onde

01:12:39.690 --> 01:12:43.560
tínhamos uma função para converter strings em inteiros?

01:12:43.560 --> 01:12:44.153
Qualquer um?

01:12:44.153 --> 01:12:44.820
AUDIÊNCIA: de a a i

01:12:44.820 --> 01:12:45.695
DAVID J. MALAN: Sim.

01:12:45.695 --> 01:12:47.820
Então a para i é uma função que converte ASCII

01:12:47.820 --> 01:12:50.820
para um inteiro assumindo o que você dá como um argumento parece

01:12:50.820 --> 01:12:52.590
como um número como um, ou dois, ou três.

01:12:52.590 --> 01:12:53.680
Então deixe-me consertar isso.

01:12:53.680 --> 01:12:55.170
Deixe-me realmente fazer a conversão.

01:12:55.170 --> 01:12:57.990
Se eu estivesse realmente sendo cuidadoso, verificaria o erro,

01:12:57.990 --> 01:13:01.260
certifique-se de que não haja dígitos, assim como você pode ter no conjunto de problemas dois.

01:13:01.260 --> 01:13:03.760
Mas para os propósitos de hoje, vou apenas assumir a honra

01:13:03.760 --> 01:13:07.800
sistema que o usuário, eu, vai rodar o programa corretamente.

01:13:07.800 --> 01:13:11.400
Agora que tenho uma variável contendo o número da linha de comando,

01:13:11.400 --> 01:13:12.910
vamos apenas alocar um nó para ele.

01:13:12.910 --> 01:13:16.950
Deixe-me fazer node star n, assim como fizemos na visualização.

01:13:16.950 --> 01:13:21.990
E vamos alocar espaço suficiente para o tamanho de um desses nós aqui.

01:13:21.990 --> 01:13:24.250
Agora preciso apenas estar super seguro.

01:13:24.250 --> 01:13:29.310
Então, se n é igual a nulo, como se eu estivesse sem memória, sabe de uma coisa?

01:13:29.310 --> 01:13:32.640
Deixe-me ir em frente e apenas retornar imediatamente um aqui.

01:13:32.640 --> 01:13:35.580
Caso contrário, se não for esse o caso, deixe-me

01:13:35.580 --> 01:13:41.880
vá em frente e atualize o campo numérico deste novo nó, que na linha 24

01:13:41.880 --> 01:13:44.050
existe porque não retornou nulo.

01:13:44.050 --> 01:13:46.140
Então não saí cedo com retorno.

01:13:46.140 --> 01:13:49.660
E deixe-me armazenar qualquer número que esse humano digitou primeiro.

01:13:49.660 --> 01:13:53.940
Portanto, o valor de retorno de a para i, que pela linha 17 está na minha variável

01:13:53.940 --> 01:13:54.750
número chamado.

01:13:54.750 --> 01:14:01.780
E então, deixe-me ir em frente e apenas adicionar isso à lista.

01:14:01.780 --> 01:14:08.730
Deixe-me ir em frente e dizer que este próximo campo primeiro tem um valor nulo conhecido,

01:14:08.730 --> 01:14:11.140
apenas para nos livrarmos desse segundo valor de lixo.

01:14:11.140 --> 01:14:13.930
E deixe-me ir em frente e agora adicioná-lo à lista.

01:14:13.930 --> 01:14:16.950
Então, se eu quiser antendê-lo, isso significa que este novo nó

01:14:16.950 --> 01:14:24.040
deve ter um próximo campo que aponte para o início atual da lista.

01:14:24.040 --> 01:14:26.730
E novamente, o objetivo aqui é preceder, preceder, preceder.

01:14:26.730 --> 01:14:28.980
Seja qual for a lista atual, vamos alterá-la

01:14:28.980 --> 01:14:33.030
para que este novo nó aponte para aquela lista existente.

01:14:33.030 --> 01:14:37.680
E agora, a segunda etapa, como antes, era atualizar a lista real

01:14:37.680 --> 01:14:39.330
para apontar para este nó.

01:14:39.330 --> 01:14:42.780
Então lembre-se em vermelho na tela antes, eu estraguei tudo originalmente.

01:14:42.780 --> 01:14:46.750
E só fiz esta linha movendo o ponteiro muito cedo, se preferir.

01:14:46.750 --> 01:14:49.290
Mas eu consertei isso uma vez que Carter me ajudou a rebobinar

01:14:49.290 --> 01:14:52.050
e nos livramos da linha vermelha, que indicava erro.

01:14:52.050 --> 01:14:56.790
E eu apenas faço a seta ao lado para alterar o próximo campo deste novo nó

01:14:56.790 --> 01:14:58.360
para apontar para a lista existente.

01:14:58.360 --> 01:15:00.510
Então não estou deixando nada órfão.

01:15:00.510 --> 01:15:06.962
Neste ponto da história, acho que meu código está correto, não rebatendo

01:15:06.962 --> 01:15:07.920
muito bem embora hoje.

01:15:07.920 --> 01:15:09.030
Mas acho que meu código está correto.

01:15:09.030 --> 01:15:11.200
Mas o programa não faz nada de interessante.

01:15:11.200 --> 01:15:14.940
Portanto, seria bom agora iterar sobre esta lista vinculada na memória, seja qual for

01:15:14.940 --> 01:15:16.990
sua ordem é e imprima as coisas.

01:15:16.990 --> 01:15:18.160
Bem, como fazemos isso?

01:15:18.160 --> 01:15:21.000
Bem, se você quiser iterar em uma lista encadeada,

01:15:21.000 --> 01:15:23.490
o paradigma geral é fazer algo assim.

01:15:23.490 --> 01:15:25.950
Para definir uma variável temporária, eu poderia chamá-la de temp.

01:15:25.950 --> 01:15:27.992
Mas outra convenção que você também pode ver

01:15:27.992 --> 01:15:30.120
é chamado de ponteiro, ptr para abreviar.

01:15:30.120 --> 01:15:31.870
Mas você pode chamá-lo do que quiser.

01:15:31.870 --> 01:15:33.930
E você pode ter um primeiro ponto de variável temporária

01:15:33.930 --> 01:15:35.700
no primeiro nó da lista.

01:15:35.700 --> 01:15:37.887
E então, em algum tipo de loop, como um loop while,

01:15:37.887 --> 01:15:39.720
você o aponta para o segundo nó da lista.

01:15:39.720 --> 01:15:40.980
E então você continua iterando.

01:15:40.980 --> 01:15:42.510
Você aponta para o último nó da lista.

01:15:42.510 --> 01:15:44.340
E então, eventualmente, você itera longe demais,

01:15:44.340 --> 01:15:46.800
efetivamente apontando para nulo, ponto em que

01:15:46.800 --> 01:15:49.000
seu loop while pode presumivelmente terminar.

01:15:49.000 --> 01:15:52.590
Então, como implemento essa ideia de alocar um ponteiro temporário que

01:15:52.590 --> 01:15:56.203
apenas aponta para cada nó na lista e me permite imprimir em última análise

01:15:56.203 --> 01:15:57.120
cada um desses números?

01:15:57.120 --> 01:15:59.040
Bem, vamos voltar ao meu código aqui.

01:15:59.040 --> 01:16:00.430
E deixe-me fazer isso.

01:16:00.430 --> 01:16:04.020
Deixe-me prosseguir e declarar este ponteiro temporário,

01:16:04.020 --> 01:16:05.680
que vai ser uma estrela nó também.

01:16:05.680 --> 01:16:06.180
Por que?

01:16:06.180 --> 01:16:07.530
Porque é o endereço de um nó.

01:16:07.530 --> 01:16:08.850
A primeira, a segunda, a terceira.

01:16:08.850 --> 01:16:11.892
E vou definir isso igual a qualquer que seja o início da lista.

01:16:11.892 --> 01:16:15.180
Isso será equivalente a esta versão da imagem

01:16:15.180 --> 01:16:19.570
aqui, onde o ponteiro está apenas apontando temporariamente para o primeiro nó da lista.

01:16:19.570 --> 01:16:21.870
Não está apontando para a lista em si, está apontando

01:16:21.870 --> 01:16:25.920
no primeiro nó da lista, cuja lista também está apontando para si mesma.

01:16:25.920 --> 01:16:28.050
Depois de fazer isso, acho que posso traduzir

01:16:28.050 --> 01:16:32.460
isso para codificar é um pouco novo-- mas é conceitualmente familiar talvez

01:16:32.460 --> 01:16:36.700
agora-- enquanto esse ponteiro não é igual a null.

01:16:36.700 --> 01:16:40.740
Então, enquanto eu tiver um ponteiro válido, como meu dedo ou aquela seta

01:16:40.740 --> 01:16:44.530
está apontando para um nó real na memória, bem, deixe-me ir em frente e imprimi-lo.

01:16:44.530 --> 01:16:46.920
Então deixe-me imprimir com porcentagem i barra invertida

01:16:46.920 --> 01:16:52.908
n o que quer que esteja no nó atual no campo de número dentro.

01:16:52.908 --> 01:16:55.200
E, novamente, isso terá o efeito, espero,

01:16:55.200 --> 01:16:57.180
da primeira impressão dos três.

01:16:57.180 --> 01:17:01.170
E acho que só preciso atualizar o ponteiro agora

01:17:01.170 --> 01:17:04.150
que na próxima iteração está apontando para o próximo valor.

01:17:04.150 --> 01:17:06.750
Então, se é aqui que está a história, como faço para

01:17:06.750 --> 01:17:10.150
atualizar ponteiro para apontar para o segundo elemento da lista?

01:17:10.150 --> 01:17:12.250
Bem, eu quero que o ponteiro aponte para os dois.

01:17:12.250 --> 01:17:14.760
E eu quero que o ponteiro aponte eventualmente para os três.

01:17:14.760 --> 01:17:16.020
Bem, como faço isso?

01:17:16.020 --> 01:17:19.230
Bem, a maneira como posso seguir essas setas no código é a seguinte.

01:17:19.230 --> 01:17:22.190
Se eu atualmente tenho ponteiro apontando para este nó

01:17:22.190 --> 01:17:27.570
mas eu quero apontá-lo para o próximo nó, posso pegar emprestado este ponteiro aqui.

01:17:27.570 --> 01:17:30.920
Portanto, qualquer que seja esse endereço no primeiro nó, também conhecido como

01:17:30.920 --> 01:17:33.770
o próximo campo, posso copiá-lo para o ponteiro.

01:17:33.770 --> 01:17:36.200
Porque então, o ponteiro apontará para qualquer coisa

01:17:36.200 --> 01:17:39.230
isso está apontando apenas definindo um igual ao outro.

01:17:39.230 --> 01:17:44.570
Assim que eu fizer isso, a imagem se tornará isso.

01:17:44.570 --> 01:17:47.420
E como traduzo isso para código?

01:17:47.420 --> 01:17:50.340
Bem, a nova sintaxe é surpreendentemente direta.

01:17:50.340 --> 01:17:53.060
Tudo o que preciso fazer é dizer ponteiro após a impressão

01:17:53.060 --> 01:18:00.300
é igual a qualquer ponteiro atualmente, mas pegue seu próximo campo.

01:18:00.300 --> 01:18:03.860
E este é um paradigma muito comum ao iterar em uma lista encadeada

01:18:03.860 --> 01:18:06.470
e você está usando alguma variável temporária como ponteiro,

01:18:06.470 --> 01:18:09.680
você pode simplesmente definir o ponteiro igual ao próximo ponteiro.

01:18:09.680 --> 01:18:12.330
E o que isso significa aqui é o seguinte.

01:18:12.330 --> 01:18:16.670
Se este é um ponteiro apontando daqui para baixo até aqui,

01:18:16.670 --> 01:18:20.160
ponteiro próximo é seguir a seta, pegue o próximo campo.

01:18:20.160 --> 01:18:22.550
Então, se você definir o ponteiro igual a esta coisa,

01:18:22.550 --> 01:18:26.570
é a mesma coisa que apontar para esta mesma caixa.

01:18:26.570 --> 01:18:29.862
E, de fato, se eu avançar para o próximo slide,

01:18:29.862 --> 01:18:31.820
mesmo que as setas estejam tecnicamente apontando

01:18:31.820 --> 01:18:34.730
em diferentes partes dos retângulos, isso é apenas uma questão gráfica,

01:18:34.730 --> 01:18:36.620
ponteiro agora está apontando para o segundo nó.

01:18:36.620 --> 01:18:39.650
E quando faço isso novamente na minha próxima iteração, aponta para isso.

01:18:39.650 --> 01:18:44.840
E então, esta última etapa, observe, quando eu continuo fazendo ponteiro igual a ponteiro próximo,

01:18:44.840 --> 01:18:47.570
isso se tornará eventualmente esse valor.

01:18:47.570 --> 01:18:50.620
Mas qual é esse valor nessa lista encadeada?

01:18:50.620 --> 01:18:51.910
É nulo, tecnicamente.

01:18:51.910 --> 01:18:55.180
Portanto, esta seta eventualmente assumirá este valor

01:18:55.180 --> 01:18:57.490
quando defino o ponteiro igual ao ponteiro seguinte.

01:18:57.490 --> 01:19:02.630
E nesse ponto ptr, meu ponteiro temporário será nulo.

01:19:02.630 --> 01:19:04.760
Portanto, pode muito bem parecer assim pictoricamente.

01:19:04.760 --> 01:19:07.630
E o que isso significa para o meu loop?

01:19:07.630 --> 01:19:11.530
Uma vez que o ponteiro é nulo, porque você saiu do final da lista encadeada,

01:19:11.530 --> 01:19:17.210
o que vai acontecer com esse loop aqui iniciado na linha 32?

01:19:17.210 --> 01:19:20.870
Alguma observação aqui?

01:19:20.870 --> 01:19:22.010
O que vai ser verdade?

01:19:22.010 --> 01:19:24.620
O que acontecerá agora assim que chegarmos ao final da lista?

01:19:24.620 --> 01:19:25.250
Sim, desculpe-me.

01:19:25.250 --> 01:19:26.810
AUDIÊNCIA: [INAUDÍVEL]

01:19:26.810 --> 01:19:28.040
DAVID J. MALAN: O loop vai estourar.

01:19:28.040 --> 01:19:28.540
Por que?

01:19:28.540 --> 01:19:30.830
Porque a linha 32, que está constantemente perguntando,

01:19:30.830 --> 01:19:32.570
bem, o ponteiro não é igual a null.

01:19:32.570 --> 01:19:36.590
Bem, se o ponteiro finalmente for nulo três etapas depois,

01:19:36.590 --> 01:19:38.400
o loop while está pronto.

01:19:38.400 --> 01:19:40.580
E assim, o que posso fazer no final deste programa

01:19:40.580 --> 01:19:43.103
depois de imprimir esses valores, bem, primeiro vamos em frente

01:19:43.103 --> 01:19:44.270
e abra a janela do meu terminal.

01:19:44.270 --> 01:19:46.220
Vamos fazer lista.

01:19:46.220 --> 01:19:47.840
Compilar lista de ponto e barra.

01:19:47.840 --> 01:19:51.080
E deixe-me tentar os mesmos valores, um, dois e três.

01:19:51.080 --> 01:19:55.130
Isso vai alocar novamente um nó, dois nós, três nós anexando,

01:19:55.130 --> 01:19:57.290
precedendo, anexando cada um desses valores.

01:19:57.290 --> 01:20:00.060
E então vai iterar sobre eles da esquerda para a direita.

01:20:00.060 --> 01:20:03.380
E assim, quando pressiono Enter agora, o que devo ver na tela

01:20:03.380 --> 01:20:04.445
se meu código está correto?

01:20:07.040 --> 01:20:07.910
O que vou ver?

01:20:07.910 --> 01:20:10.492
Sinta-se à vontade para apenas chamá-lo.

01:20:10.492 --> 01:20:11.575
AUDIÊNCIA: Três, dois, um.

01:20:11.575 --> 01:20:14.490
DAVID J. MALAN: Três, dois, um, porque presumivelmente anexei.

01:20:14.490 --> 01:20:15.630
E aqui vamos nós.

01:20:15.630 --> 01:20:17.250
Eu realmente vejo três, dois, um.

01:20:17.250 --> 01:20:18.510
Portanto, a lista está invertida.

01:20:18.510 --> 01:20:20.100
Mas todos os elementos estão lá.

01:20:20.100 --> 01:20:22.230
Agora, tecnicamente, se eu executar o Valgrind nisso,

01:20:22.230 --> 01:20:25.500
Valgrind não ficaria feliz porque eu nunca liberei nada da minha memória.

01:20:25.500 --> 01:20:27.930
Então eu provavelmente deveria ter um segundo loop aqui

01:20:27.930 --> 01:20:29.350
que faz algo assim.

01:20:29.350 --> 01:20:31.918
Deixe-me novamente definir o ponteiro igual à lista.

01:20:31.918 --> 01:20:33.960
Eu não preciso redeclará-lo porque eu já

01:20:33.960 --> 01:20:35.760
criou essa coisa na linha 31.

01:20:35.760 --> 01:20:38.552
Eu só quero redefini-lo para ser o começo da lista novamente.

01:20:38.552 --> 01:20:40.260
E agora, posso fazer o mesmo tipo de coisa.

01:20:40.260 --> 01:20:45.640
Embora prt not seja igual a null, vá em frente e faça isso.

01:20:45.640 --> 01:20:48.510
Bem, eu não quero apenas fazer ponteiro livre

01:20:48.510 --> 01:20:52.770
e, em seguida, o ponteiro obtém o próximo ponteiro.

01:20:52.770 --> 01:20:54.000
Por que?

01:20:54.000 --> 01:20:56.212
Meu objetivo é liberar toda a minha memória.

01:20:56.212 --> 01:20:58.170
Mas acho que isso vai me trazer problemas.

01:20:58.170 --> 01:21:00.587
Pointer equals list apenas me dá um ponteiro temporário que

01:21:00.587 --> 01:21:03.630
aponta para o três, e então eventualmente para o dois, e então para o um.

01:21:03.630 --> 01:21:04.140
Como?

01:21:04.140 --> 01:21:07.090
Bem, enquanto o ponteiro não for nulo, estou liberando o ponteiro.

01:21:07.090 --> 01:21:10.500
Isso é como dizer para malloc, libere esse nó, libere esse nó, libere

01:21:10.500 --> 01:21:11.460
esse nó.

01:21:11.460 --> 01:21:16.040
Mas qual é o problema com o que acabei de fazer aqui?

01:21:16.040 --> 01:21:18.030
Este código é tecnicamente bugado.

01:21:18.030 --> 01:21:18.530
Sim.

01:21:18.530 --> 01:21:21.613
AUDIÊNCIA: Depois de liberar o ponteiro, você não tem [INAUDÍVEL] o que vem a seguir

01:21:21.613 --> 01:21:22.260
[INAUDÍVEL].

01:21:22.260 --> 01:21:23.260
DAVID J. MALAN: Exatamente.

01:21:23.260 --> 01:21:27.180
Depois de chamar de graça no ponteiro, você está por contrato social

01:21:27.180 --> 01:21:30.240
com C não é mais permitido tocar no ponteiro.

01:21:30.240 --> 01:21:31.080
É inválido.

01:21:31.080 --> 01:21:32.580
Agora ainda vai ser um número.

01:21:32.580 --> 01:21:34.288
Ainda vai ser um padrão de bits.

01:21:34.288 --> 01:21:35.280
Mas é inválido.

01:21:35.280 --> 01:21:40.240
E muitas vezes você terá uma falha de segmentação se tentar o destino dessa maneira.

01:21:40.240 --> 01:21:43.920
Portanto, não posso liberar o ponteiro e usá-lo literalmente na próxima linha.

01:21:43.920 --> 01:21:47.220
A solução aqui, como a troca dos líquidos da última vez,

01:21:47.220 --> 01:21:49.480
era talvez ter apenas uma variável temporária.

01:21:49.480 --> 01:21:50.550
Então eu posso fazer um switcheroo.

01:21:50.550 --> 01:21:54.120
E assim, uma maneira comum de resolver esse problema para obter a ordem das operações

01:21:54.120 --> 01:21:55.890
certo seria fazer algo assim.

01:21:55.890 --> 01:21:59.790
Dê a si mesmo um ponteiro temporário como node star a seguir.

01:21:59.790 --> 01:22:05.220
Defina-o igual ao local que você deseja ir a seguir, para que estejamos um passo à frente.

01:22:05.220 --> 01:22:07.290
Agora você pode liberar o ponteiro.

01:22:07.290 --> 01:22:10.690
E então você pode atualizar o ponteiro para ser o próximo valor.

01:22:10.690 --> 01:22:12.900
Então, basicamente, você precisa de duas mãos agora.

01:22:12.900 --> 01:22:15.720
Você cria na linha 41 outro ponteiro que se este

01:22:15.720 --> 01:22:18.300
está apontando para o primeiro nó, o três,

01:22:18.300 --> 01:22:20.880
seu novo ponteiro está apontando para os dois temporariamente.

01:22:20.880 --> 01:22:24.960
Então agora você pode contar ao malloc de graça, libere essa memória.

01:22:24.960 --> 01:22:27.720
Mas não esqueci para onde quero ir a seguir.

01:22:27.720 --> 01:22:30.160
E assim, agora posso continuar.

01:22:30.160 --> 01:22:33.720
Portanto, um paradigma comum para apenas iterar sobre esses nós

01:22:33.720 --> 01:22:36.420
e depois liberá-los, algumas observações.

01:22:36.420 --> 01:22:38.850
A rigor, eu poderia ter consolidado isso.

01:22:38.850 --> 01:22:42.720
Não preciso de dois loops para imprimir os nós e depois liberar os nós.

01:22:42.720 --> 01:22:43.948
Eu poderia fazer isso de uma vez.

01:22:43.948 --> 01:22:46.740
Mas vamos supor que haja outras coisas de interesse em meu programa

01:22:46.740 --> 01:22:48.615
e não quero liberá-lo imediatamente.

01:22:48.615 --> 01:22:51.420
Há um outro bug que eu provavelmente deveria abordar aqui.

01:22:51.420 --> 01:22:54.120
Ainda há um vazamento de memória em potencial aqui.

01:22:54.120 --> 01:22:57.810
E este é super sutil, embora Valgrind o ajude a encontrá-lo.

01:22:57.810 --> 01:23:02.730
Observe que neste loop aqui quando estou chamando malloc, esta linha de código

01:23:02.730 --> 01:23:06.120
está bem se a primeira linha de malloc falhar e retornar

01:23:06.120 --> 01:23:08.440
null porque eu volto imediatamente e pronto.

01:23:08.440 --> 01:23:12.240
Mas e se a segunda chamada - mas não a primeira, ou a terceira chamada, mas não

01:23:12.240 --> 01:23:13.770
o primeiro ou o segundo falham?

01:23:13.770 --> 01:23:16.560
Esta linha de código me faz retornar imediatamente.

01:23:16.560 --> 01:23:19.840
Você realmente precisa fazer alguma coleta de lixo, por assim dizer,

01:23:19.840 --> 01:23:23.250
em que você realmente precisa entrar e liberar todos os nós que você

01:23:23.250 --> 01:23:25.110
alocou com sucesso anteriormente.

01:23:25.110 --> 01:23:26.370
Honestamente, isso vai ser uma dor no pescoço.

01:23:26.370 --> 01:23:27.450
Não faremos isso aqui.

01:23:27.450 --> 01:23:30.840
Mas provavelmente o que eu gostaria de fazer é escrever uma função chamada lista livre

01:23:30.840 --> 01:23:33.180
ou algo assim e chamar essa função

01:23:33.180 --> 01:23:35.950
para liberar todos os nós que eu havia criado anteriormente.

01:23:35.950 --> 01:23:37.960
Portanto, não está exatamente na linha de chegada.

01:23:37.960 --> 01:23:41.160
Mas os blocos de construção estão realmente aqui.

01:23:41.160 --> 01:23:44.550
Dúvidas sobre este código?

01:23:44.550 --> 01:23:48.360
E acho que posso prometer que não vai piorar ainda mais

01:23:48.360 --> 01:23:50.880
a partir desse.

01:23:50.880 --> 01:23:54.760
Perguntas sobre isso?

01:23:54.760 --> 01:23:55.630
Não?

01:23:55.630 --> 01:23:58.130
Bem, deixe-me mostrar uma alternativa que você pode preferir.

01:23:58.130 --> 01:24:00.005
E tenho certeza de que isso não é uma escalada,

01:24:00.005 --> 01:24:01.600
é apenas uma formulação alternativa.

01:24:01.600 --> 01:24:05.060
Outra maneira de iterar sobre nós em uma lista pode ser esta.

01:24:05.060 --> 01:24:07.203
Em vez de um loop while, por exemplo, deixe

01:24:07.203 --> 01:24:09.370
na verdade, mostro a você uma outra parte da sintaxe aqui.

01:24:09.370 --> 01:24:10.930
Você poderia tecnicamente usar um loop for.

01:24:10.930 --> 01:24:15.580
Você pode fornecer a si mesmo um ponteiro de nó aqui que é inicializado na lista.

01:24:15.580 --> 01:24:18.530
Você pode então verificar em seu loop for que não é igual a null.

01:24:18.530 --> 01:24:21.310
E então, você pode fazer sua atualização normalmente assim.

01:24:21.310 --> 01:24:23.360
Qualquer um deles é equivalente.

01:24:23.360 --> 01:24:25.480
Mesmo que este, eu suspeito, pareça mais assustador,

01:24:25.480 --> 01:24:28.840
está fazendo exatamente a mesma coisa em uma linha em vez de duas.

01:24:28.840 --> 01:24:32.230
Mas não há razão para não usarmos loops for em vez de loops while

01:24:32.230 --> 01:24:33.490
para alcançar a mesma ideia.

01:24:33.490 --> 01:24:35.320
Mas vou deixar esses dois como demonstrações

01:24:35.320 --> 01:24:36.580
de uma abordagem ou de outra.

01:24:36.580 --> 01:24:39.340
Mas é como na primeira semana, loops for, loops while,

01:24:39.340 --> 01:24:41.860
o que quer que pareça mais simples para você.

01:24:41.860 --> 01:24:46.460
Mesmo que nenhum deles provavelmente pareça super limpo.

01:24:46.460 --> 01:24:49.660
Então, vamos levar as coisas de volta para coisas mais conceituais aqui.

01:24:49.660 --> 01:24:52.900
Até agora, inserimos elementos nesta lista encadeada

01:24:52.900 --> 01:24:54.580
anexando-os.

01:24:54.580 --> 01:24:58.070
Vamos considerar qual é o tempo de execução dessas operações.

01:24:58.070 --> 01:25:01.423
Então, se eu tiver uma lista encadeada de tamanho três ou tamanho n de forma mais geral,

01:25:01.423 --> 01:25:03.340
o tempo passou e eu adicionei um monte de coisas

01:25:03.340 --> 01:25:06.400
para isso, qual vai ser o tempo de execução, por exemplo, de busca

01:25:06.400 --> 01:25:08.590
uma lista encadeada por algum valor?

01:25:08.590 --> 01:25:10.510
E já te digo, não é log n.

01:25:10.510 --> 01:25:15.040
Porque, novamente, a pesquisa binária está fora de questão antes do intervalo.

01:25:15.040 --> 01:25:20.080
Então, qual pode ser o tempo de execução da pesquisa em uma lista vinculada por algum valor,

01:25:20.080 --> 01:25:23.350
como dois, ou três, ou um, ou 50?

01:25:23.350 --> 01:25:26.545
Qual pode ser o tempo de execução?

01:25:26.545 --> 01:25:27.420
AUDIÊNCIA: [INAUDÍVEL]

01:25:27.420 --> 01:25:28.310
DAVID J. MALAN: De--

01:25:28.310 --> 01:25:28.970
Eu ouvi isso aqui.

01:25:28.970 --> 01:25:29.600
O de n.

01:25:29.600 --> 01:25:30.260
E porque?

01:25:30.260 --> 01:25:30.862
Quem era aquele?

01:25:30.862 --> 01:25:31.820
Oh, aqui no meio?

01:25:31.820 --> 01:25:33.421
Quem O de n?

01:25:33.421 --> 01:25:37.260
AUDIÊNCIA: Porque você é um item [INAUDÍVEL] na lista [INAUDÍVEL].

01:25:37.260 --> 01:25:38.260
DAVID J. MALAN: Exatamente.

01:25:38.260 --> 01:25:40.030
Você vai ter que passar por cada [? item ?] na lista

01:25:40.030 --> 01:25:42.550
começando da esquerda desde o começo, que é como estamos

01:25:42.550 --> 01:25:44.175
desenhando coisas e ligando os pontos.

01:25:44.175 --> 01:25:47.092
E, na pior das hipóteses, o elemento pode muito bem estar bem no final.

01:25:47.092 --> 01:25:48.430
Então vai ser grande O de n.

01:25:48.430 --> 01:25:49.990
E a inserção?

01:25:49.990 --> 01:25:52.810
Quantos passos em termos de grande notação O

01:25:52.810 --> 01:25:55.780
está demorando para inserir elementos no link

01:25:55.780 --> 01:25:59.692
lista usando este design de prefixo?

01:25:59.692 --> 01:26:00.540
AUDIÊNCIA: Um.

01:26:00.540 --> 01:26:01.415
DAVID J. MALAN: Sim.

01:26:01.415 --> 01:26:03.900
Portanto, é um tempo tecnicamente constante, grande O de um.

01:26:03.900 --> 01:26:06.197
E, novamente, um é apenas representativo de qualquer constante.

01:26:06.197 --> 01:26:08.280
Pode ser tecnicamente duas etapas ou três etapas,

01:26:08.280 --> 01:26:10.240
ou mesmo 10 passos, ou 100 passos.

01:26:10.240 --> 01:26:13.950
Mas se é sempre finito e fixo, então

01:26:13.950 --> 01:26:16.080
na verdade, você pode dizer que está em grande O de um.

01:26:16.080 --> 01:26:17.080
Agora, por que isso?

01:26:17.080 --> 01:26:19.950
Bem, de novo, não importa quanto tempo essa lista fique, tanto tempo

01:26:19.950 --> 01:26:24.240
como há memória disponível para mim, posso apenas criar uma pequena emenda

01:26:24.240 --> 01:26:27.570
no início da lista para colocar no novo nó, atualizar a lista original,

01:26:27.570 --> 01:26:28.410
e estou a caminho.

01:26:28.410 --> 01:26:31.618
E continua ficando mais longo, mesmo que não esteja espalhado na memória.

01:26:31.618 --> 01:26:34.650
Tão grande O de um é possível com essas listas encadeadas

01:26:34.650 --> 01:26:36.690
se eu realmente preceder as coisas.

01:26:36.690 --> 01:26:39.300
Claro, se eu antecipo as coisas, tudo fica

01:26:39.300 --> 01:26:40.920
vai ficar fora de ordem potencialmente.

01:26:40.920 --> 01:26:43.590
E teremos talvez a propriedade stack em vez de uma propriedade queue.

01:26:43.590 --> 01:26:45.715
Portanto, podemos querer fazer as coisas de maneira um pouco diferente.

01:26:45.715 --> 01:26:49.620
Então, em vez de fazer isso, pelo qual continuamos anexando,

01:26:49.620 --> 01:26:53.890
prepending, prepending, suponha que, em vez disso, acrescentamos ao final da lista.

01:26:53.890 --> 01:26:56.190
Então, se agora inserirmos o um, o dois e o três

01:26:56.190 --> 01:26:59.640
como podemos querer para uma fila, para manter essa propriedade de equidade,

01:26:59.640 --> 01:27:01.230
podemos começar com uma lista vazia.

01:27:01.230 --> 01:27:02.580
Podemos adicionar um.

01:27:02.580 --> 01:27:05.820
Podemos acrescentar os dois, acrescentar os três.

01:27:05.820 --> 01:27:08.263
E assim, é apresentado de forma diferente na memória.

01:27:08.263 --> 01:27:10.180
E novamente, se eu puder ir até você no meio,

01:27:10.180 --> 01:27:12.180
qual é o tempo de execução da pesquisa, novamente,

01:27:12.180 --> 01:27:15.592
quando a lista vinculada usa essa implementação de acréscimo?

01:27:15.592 --> 01:27:16.830
AUDIÊNCIA: Ainda grande O de n.

01:27:16.830 --> 01:27:17.190
DAVID J. MALAN: Sim.

01:27:17.190 --> 01:27:17.898
Ainda grande O de n.

01:27:17.898 --> 01:27:21.065
Porque na pior das hipóteses, você vai ter que passar por toda a lista

01:27:21.065 --> 01:27:21.960
apenas para encontrá-lo.

01:27:21.960 --> 01:27:25.380
E observe, não importa se você tem uma intuição agora que quanto maior

01:27:25.380 --> 01:27:27.420
os números podem muito bem estar no final.

01:27:27.420 --> 01:27:29.520
Você não tem como pular para o final.

01:27:29.520 --> 01:27:33.120
Você não tem como pular para o meio ou fazer qualquer coisa parecida com a pesquisa binária.

01:27:33.120 --> 01:27:38.025
Toda pesquisa deve começar da esquerda e seguir as setas repetidamente.

01:27:38.025 --> 01:27:39.900
Então eu não acho que fizemos melhor lá.

01:27:39.900 --> 01:27:43.500
E, de fato, o que é tempo de execução de inserções agora em grande O

01:27:43.500 --> 01:27:45.690
quando estamos anexando à lista dessa maneira,

01:27:45.690 --> 01:27:49.230
como poderíamos implementar uma fila em vez de uma pilha?

01:27:49.230 --> 01:27:53.670
Qual é o tempo de execução da inserção de um novo valor?

01:27:53.670 --> 01:27:55.397
Grande O de?

01:27:55.397 --> 01:27:55.980
AUDIÊNCIA: Um.

01:27:55.980 --> 01:28:00.030
DAVID J. MALAN: Portanto, não o grande O de um neste caso, mas o grande O de n.

01:28:00.030 --> 01:28:02.610
Porque se estou anexando, por definição eu

01:28:02.610 --> 01:28:06.130
tem que começar aqui e percorrer a coisa toda procurando o fim.

01:28:06.130 --> 01:28:08.010
Agora, isso é um pouco exagerado.

01:28:08.010 --> 01:28:09.900
Você obviamente poderia otimizar isso um pouco

01:28:09.900 --> 01:28:14.220
talvez adicionando outra variável que sempre aponta para o último elemento, classifique

01:28:14.220 --> 01:28:17.460
de uma folha de dicas ou um atalho que leva você até o fim.

01:28:17.460 --> 01:28:18.293
Tudo bem.

01:28:18.293 --> 01:28:20.752
Não é... realmente não se encaixa na definição tradicional

01:28:20.752 --> 01:28:21.810
de uma lista encadeada individualmente.

01:28:21.810 --> 01:28:25.330
Mas há soluções de engenharia absolutamente inteligentes para esses tipos de problemas.

01:28:25.330 --> 01:28:27.570
Mas, conforme planejado, seria de fato um grande evento O

01:28:27.570 --> 01:28:30.480
para inserir se você tiver que ir até o fim

01:28:30.480 --> 01:28:34.260
e você não está usando um pouco de memória extra para chegar lá rapidamente.

01:28:34.260 --> 01:28:38.160
Bem, e se quisermos dar um último passo e não apenas acrescentar

01:28:38.160 --> 01:28:41.160
cegamente, porque mesmo que eu inseri um, dois, três,

01:28:41.160 --> 01:28:44.910
se eu os inserisse em ordem aleatória, eles acabariam em ordem aleatória.

01:28:44.910 --> 01:28:48.660
E se você quiser manter uma lista classificada do menor para o maior?

01:28:48.660 --> 01:28:51.090
Bem, então você pode querer inserir números como este.

01:28:51.090 --> 01:28:54.420
Começando com uma lista vazia, podemos ter dois,

01:28:54.420 --> 01:28:56.640
então podemos tentar inserir um.

01:28:56.640 --> 01:28:57.930
Mas queremos mantê-lo organizado.

01:28:57.930 --> 01:29:00.450
Então agora vamos preceder em nosso código.

01:29:00.450 --> 01:29:02.820
Mas então você pode querer inserir um quatro.

01:29:02.820 --> 01:29:05.400
Então você acrescentaria os quatro porque você provavelmente está

01:29:05.400 --> 01:29:07.440
vai procurar o lugar certo para inseri-lo.

01:29:07.440 --> 01:29:09.110
Então vamos inserir um três.

01:29:09.110 --> 01:29:10.860
E este está ficando um pouco chato.

01:29:10.860 --> 01:29:14.910
Porque agora você tem que percorrer a lista, procurar o lugar certo,

01:29:14.910 --> 01:29:17.760
e, em seguida, faça uma emenda um pouco mais inteligente.

01:29:17.760 --> 01:29:18.773
Mas é possível.

01:29:18.773 --> 01:29:20.940
Mas você não quer deixar os quatro órfãos, por exemplo.

01:29:20.940 --> 01:29:24.060
E então, finalmente, voltamos a esta questão.

01:29:24.060 --> 01:29:26.640
Qual seria o desempenho da sua lista encadeada

01:29:26.640 --> 01:29:30.090
se você está tentando manter a ordem classificada?

01:29:30.090 --> 01:29:34.410
Bem, acho que a pesquisa será grande de n pelas mesmas razões de antes.

01:29:34.410 --> 01:29:37.170
E a inserção?

01:29:37.170 --> 01:29:44.120
Big O de quê para inserir em uma lista encadeada classificada?

01:29:44.120 --> 01:29:45.590
Sim, no pior dos casos?

01:29:45.590 --> 01:29:46.460
AUDIÊNCIA: Grande O de n

01:29:46.460 --> 01:29:46.850
DAVID J. MALAN: Sim.

01:29:46.850 --> 01:29:48.050
Ainda é um grande O de n.

01:29:48.050 --> 01:29:51.410
Portanto, não é pior do que, mas não é realmente melhor do que anexar.

01:29:51.410 --> 01:29:55.040
Mas ganhamos a propriedade adicional de manter uma lista ordenada, que

01:29:55.040 --> 01:29:58.070
pode muito bem ser útil se você estiver classificando seus contatos em seu telefone

01:29:58.070 --> 01:30:01.850
ou algo assim onde faz sentido manter a ordem classificada.

01:30:01.850 --> 01:30:04.280
Agora, no código para online hoje, se você der uma olhada

01:30:04.280 --> 01:30:09.203
em algumas das versões finais do código, como lista 6.c e lista 5.c

01:30:09.203 --> 01:30:11.120
como vamos postar no site, você pode realmente

01:30:11.120 --> 01:30:14.660
veja o código que resolverá todos esses três problemas, a versão anexada

01:30:14.660 --> 01:30:17.360
que escrevemos ao vivo, a versão anexada sobre a qual conversamos,

01:30:17.360 --> 01:30:19.220
bem como esta ordem classificada.

01:30:19.220 --> 01:30:22.197
Mas acho que vou evitar mostrar ao vivo só porque eu faço

01:30:22.197 --> 01:30:23.780
acho que isso começa a aumentar rapidamente.

01:30:23.780 --> 01:30:25.697
Mas acho que temos blocos de construção suficientes

01:30:25.697 --> 01:30:29.660
se estivermos confortáveis ​​em adiantar pelo menos para resolver alguns problemas do mundo real

01:30:29.660 --> 01:30:31.970
com essas listas encadeadas.

01:30:31.970 --> 01:30:37.520
Perguntas então em listas encadeadas que agora deixaremos para trás por conta própria

01:30:37.520 --> 01:30:44.630
mas agora use essa técnica para resolver problemas mais sofisticados, mas muito menos código.

01:30:44.630 --> 01:30:47.630
Dúvidas sobre listas encadeadas?

01:30:47.630 --> 01:30:52.160
Então, para recapitular, evitamos a lista vinculada.

01:30:52.160 --> 01:30:56.180
Temos esse dinamismo agora onde podemos aumentar e diminuir nossos pedaços de memória

01:30:56.180 --> 01:30:59.150
sem superalocar ou acidentalmente subalocar

01:30:59.150 --> 01:31:00.620
como no mundo de um array.

01:31:00.620 --> 01:31:03.580
Não precisamos nos preocupar em copiar valores infinitamente

01:31:03.580 --> 01:31:06.830
porque uma vez que você aloca o nó, ele pode ficar onde quer que esteja na memória.

01:31:06.830 --> 01:31:08.390
E você pode apenas manter--

01:31:08.390 --> 01:31:10.190
você pode apenas costurá-lo de alguma forma.

01:31:10.190 --> 01:31:13.220
Mas, infelizmente, sacrificamos o que começamos a aula

01:31:13.220 --> 01:31:16.550
com na semana zero, que foi busca binária, dividir e conquistar, que

01:31:16.550 --> 01:31:19.550
foi como nos deu aquele log e tempo de execução, que

01:31:19.550 --> 01:31:23.870
foi realmente atraente se você pensar nas demonstrações e nos visuais.

01:31:23.870 --> 01:31:26.060
Podemos obter o melhor dos dois mundos?

01:31:26.060 --> 01:31:30.920
Podemos obter a velocidade da pesquisa binária, algo logarítmico,

01:31:30.920 --> 01:31:33.660
mas o dinamismo de algo como uma lista encadeada?

01:31:33.660 --> 01:31:35.600
Bem, podemos, na verdade, acho, se começarmos

01:31:35.600 --> 01:31:39.690
pensar não em uma única dimensão, apenas no eixo x, se preferir,

01:31:39.690 --> 01:31:42.410
mas duas dimensões, de modo que nossas estruturas de dados

01:31:42.410 --> 01:31:45.120
pode talvez agora ter largura e altura, se você quiser.

01:31:45.120 --> 01:31:47.600
E assim, uma árvore é talvez o termo certo aqui.

01:31:47.600 --> 01:31:51.290
Muito parecido com uma árvore genealógica, se você tiver os mais velhos aqui na árvore

01:31:51.290 --> 01:31:54.260
e então os galhos abaixo deles para seus filhos e netos

01:31:54.260 --> 01:31:54.890
e similar.

01:31:54.890 --> 01:31:56.598
Isso é realmente o que um cientista da computação

01:31:56.598 --> 01:31:59.840
significa quando eles falam sobre árvores, não uma árvore que cresce assim,

01:31:59.840 --> 01:32:02.510
mas realmente um que normalmente é retratado crescendo.

01:32:02.510 --> 01:32:05.520
Embora esta seja apenas a representação de um artista, não importa o quê.

01:32:05.520 --> 01:32:09.080
Mas existem certos tipos de árvores no mundo chamadas busca binária

01:32:09.080 --> 01:32:14.090
árvores que são estruturadas no papel e visualmente como uma árvore genealógica.

01:32:14.090 --> 01:32:16.850
Mas eles têm uma propriedade especial que se presta

01:32:16.850 --> 01:32:19.470
exatamente para esse recurso de pesquisa binária.

01:32:19.470 --> 01:32:22.580
Por exemplo, aqui está um array da segunda semana.

01:32:22.580 --> 01:32:26.450
E eu classifiquei um monte de números aqui de um a sete.

01:32:26.450 --> 01:32:29.540
Sabemos que podemos fazer pesquisa binária nesta estrutura

01:32:29.540 --> 01:32:31.640
se for implementado como uma matriz.

01:32:31.640 --> 01:32:37.490
Mas que recurso as matrizes, para ser claro, não têm que as listas vinculadas?

01:32:37.490 --> 01:32:38.720
Hoje é uma espécie de gangorra.

01:32:38.720 --> 01:32:45.486
O que acabamos de ganhar adicionando listas encadeadas que os arrays não permitem Sim.

01:32:45.486 --> 01:32:47.755
AUDIÊNCIA: [INAUDÍVEL]

01:32:47.755 --> 01:32:48.630
DAVID J. MALAN: Sim.

01:32:48.630 --> 01:32:51.330
Você pode inserir mais elementos sem precisar copiar

01:32:51.330 --> 01:32:52.890
ou movendo tudo ao redor.

01:32:52.890 --> 01:32:57.330
Agora, nesta única dimensão, se esses valores à esquerda e/ou à direita

01:32:57.330 --> 01:32:59.810
já são usados, então você tem que mover tudo.

01:32:59.810 --> 01:33:01.560
E foi aí que começamos a história de hoje.

01:33:01.560 --> 01:33:03.450
Assim, os arrays meio que colocam você em um canto.

01:33:03.450 --> 01:33:06.990
Porque você tem que, por definição, decidir antecipadamente o tamanho deles.

01:33:06.990 --> 01:33:09.390
Bem, não poderíamos ter algum tipo de matriz

01:33:09.390 --> 01:33:12.780
que ainda pode crescer, mas ainda é contíguo, então

01:33:12.780 --> 01:33:15.190
pode fazer pesquisa binária de alguma forma?

01:33:15.190 --> 01:33:19.440
Bem, sim, se repensarmos como implementamos a pesquisa binária.

01:33:19.440 --> 01:33:24.660
Deixe-me propor que isso, eu escolhi esses sete elementos na matriz

01:33:24.660 --> 01:33:29.910
muito parecido com os armários da segunda semana para serem ordenados do menor para o maior.

01:33:29.910 --> 01:33:33.040
Destaquei agora em amarelo os elementos do meio aqui.

01:33:33.040 --> 01:33:36.210
E se estivéssemos contando a história da segunda semana indo para a esquerda ou indo para a direita,

01:33:36.210 --> 01:33:39.090
deixe-me destacar em vermelho os elementos do meio

01:33:39.090 --> 01:33:40.890
da metade esquerda e da metade direita.

01:33:40.890 --> 01:33:42.960
E então, deixe-me destacar ainda mais em verde

01:33:42.960 --> 01:33:45.840
os outros elementos entre eles.

01:33:45.840 --> 01:33:48.778
E na verdade há um padrão aqui, como você pode notar.

01:33:48.778 --> 01:33:50.820
Em que há um amarelo no meio e depois

01:33:50.820 --> 01:33:52.830
há os dois vermelhos e os quatro verdes.

01:33:52.830 --> 01:33:55.380
Há uma estrutura implícita aí, se você quiser.

01:33:55.380 --> 01:33:57.840
E se eu começar a pensar em duas dimensões,

01:33:57.840 --> 01:34:03.210
e em vez de colocar uma série de armários como este apenas no eixo x,

01:34:03.210 --> 01:34:09.450
e se eu deslizar o quatro para cima e puxar o um, o três, o cinco para baixo

01:34:09.450 --> 01:34:13.210
e desenhar isso em duas dimensões?

01:34:13.210 --> 01:34:17.490
Bem, deixe-me fazer isso, separando essas coisas assim.

01:34:17.490 --> 01:34:20.610
De tal forma que, agora, deixe-me propor que cada um desses quadrados

01:34:20.610 --> 01:34:22.770
talvez não precise ser contíguo.

01:34:22.770 --> 01:34:24.990
Pode estar em qualquer lugar na memória do computador.

01:34:24.990 --> 01:34:27.810
Mas não posso ter essas lacunas malucas entre eles.

01:34:27.810 --> 01:34:32.100
Como eu poderia talvez manter essas coisas conectadas conceitualmente?

01:34:32.100 --> 01:34:34.050
O que devo acrescentar à imagem, se você quiser?

01:34:36.615 --> 01:34:37.115
Sim.

01:34:37.115 --> 01:34:37.992
AUDIÊNCIA: Filiais?

01:34:37.992 --> 01:34:39.075
DAVID J. MALAN: Diga de novo?

01:34:39.075 --> 01:34:39.410
PÚBLICO: Ramos.

01:34:39.410 --> 01:34:41.500
DAVID J. MALAN: Então ramifica metaforicamente aqui.

01:34:41.500 --> 01:34:44.410
E mais tecnicamente na linguagem C, talvez apenas

01:34:44.410 --> 01:34:46.420
algumas setas, alguns ponteiros.

01:34:46.420 --> 01:34:49.090
Portanto, não vou me incomodar em desenhar coisas como retângulos constantemente.

01:34:49.090 --> 01:34:51.940
Deixe-me propor que agora estamos apenas abstraindo o que é um nó.

01:34:51.940 --> 01:34:54.550
Mas deixe-me afirmar que cada um desses quadrados agora é um nó.

01:34:54.550 --> 01:34:55.900
E um nó pode ter um número.

01:34:55.900 --> 01:34:57.400
Mas também pode ter um ponteiro.

01:34:57.400 --> 01:34:59.950
Caramba, talvez até dois ou mais ponteiros.

01:34:59.950 --> 01:35:01.240
E deixe-me desenhá-los agora.

01:35:01.240 --> 01:35:04.970
Não me importo mais com endereços como 0x123, 456, 789.

01:35:04.970 --> 01:35:07.210
Vamos apenas desenhar nossos ponteiros com setas.

01:35:07.210 --> 01:35:10.570
Mas agora, deixe-me propor que poderíamos muito bem pensar

01:35:10.570 --> 01:35:17.860
sobre isso como uma árvore armazenando o que antes eram dados de matriz.

01:35:17.860 --> 01:35:21.670
Mas agora, cada um desses nós pode estar em qualquer lugar da memória.

01:35:21.670 --> 01:35:24.040
E além disso, embora eu tenha me pintado

01:35:24.040 --> 01:35:26.290
em um canto visualmente na tela, tanto tempo

01:35:26.290 --> 01:35:30.620
como tem mais memória no computador, eu poderia colocar o número zero aqui.

01:35:30.620 --> 01:35:32.720
Eu poderia colocar o número oito aqui.

01:35:32.720 --> 01:35:35.290
E se eu for inteligente, provavelmente poderia, se eu quisesse

01:35:35.290 --> 01:35:39.310
para inserir outros números, como 2,5 ou 1,54 valores intermediários,

01:35:39.310 --> 01:35:43.660
Aposto que poderíamos abrir espaço girando as coisas e apenas

01:35:43.660 --> 01:35:47.330
pendurar as coisas nesses galhos de maneira ligeiramente diferente.

01:35:47.330 --> 01:35:49.060
E então, o que isso me ganha?

01:35:49.060 --> 01:35:52.690
Bem, se eu começar a modelar meus dados não unidimensionalmente

01:35:52.690 --> 01:35:56.170
mas em duas dimensões, e conecto esses nós

01:35:56.170 --> 01:35:59.050
com esses ponteiros, o que posso fazer agora?

01:35:59.050 --> 01:36:01.280
Acho que acabei de me devolver a pesquisa binária.

01:36:01.280 --> 01:36:01.780
Por que?

01:36:01.780 --> 01:36:03.530
Suponha que eu esteja procurando o número cinco.

01:36:03.530 --> 01:36:04.505
Como posso encontrá-lo?

01:36:04.505 --> 01:36:06.880
Bem, como em uma árvore genealógica onde você pode visualizar

01:36:06.880 --> 01:36:09.100
comece a ler de cima para baixo, estou sempre

01:36:09.100 --> 01:36:11.990
vai começar a partir da chamada raiz de uma árvore de busca binária.

01:36:11.990 --> 01:36:16.000
Isso é como o ponteiro da lista que inicia toda a lista encadeada

01:36:16.000 --> 01:36:16.660
processo.

01:36:16.660 --> 01:36:18.610
Esta é a chamada raiz.

01:36:18.610 --> 01:36:19.930
Aqui estou no número quatro.

01:36:19.930 --> 01:36:21.760
Quero encontrar o número cinco.

01:36:21.760 --> 01:36:25.120
Que decisão posso tomar quando vejo que estou atualmente no número quatro,

01:36:25.120 --> 01:36:27.550
assim como a lista telefônica da semana zero?

01:36:27.550 --> 01:36:30.790
Onde está o cinco não?

01:36:30.790 --> 01:36:32.480
Não é à esquerda.

01:36:32.480 --> 01:36:35.140
E se eu tivesse construído um móbile aqui ou algo assim

01:36:35.140 --> 01:36:38.890
poderíamos cortar dramaticamente este galho, este [RISOS]

01:36:38.890 --> 01:36:40.640
é uma animação de baixo orçamento.

01:36:40.640 --> 01:36:43.130
Esses nós podem cair no chão.

01:36:43.130 --> 01:36:45.850
E ficamos com metade de, essencialmente, uma árvore.

01:36:45.850 --> 01:36:47.050
Mas o que eu sei agora?

01:36:47.050 --> 01:36:48.667
É obviamente o cinco à direita.

01:36:48.667 --> 01:36:49.750
Então deixe-me ir para a direita.

01:36:49.750 --> 01:36:52.070
Seis obviamente não é o que estou procurando.

01:36:52.070 --> 01:36:53.890
Mas o que sei agora sobre os cinco?

01:36:53.890 --> 01:36:56.140
Bem, cinco é menor que seis.

01:36:56.140 --> 01:37:00.850
Então eu posso cortar isso aqui porque eu sei que não vai ser lá embaixo.

01:37:00.850 --> 01:37:02.830
E posso seguir a seta restante aqui.

01:37:02.830 --> 01:37:04.533
E pronto, acabei de encontrar.

01:37:04.533 --> 01:37:06.700
E agora, sem entrar no mato da matemática,

01:37:06.700 --> 01:37:08.770
Eu tenho aqui o quê, sete elementos.

01:37:08.770 --> 01:37:10.610
São aproximadamente oito se eu arredondar para cima.

01:37:10.610 --> 01:37:13.480
E se eu fizer algum log base dois, eu na verdade-- um, dois, três

01:37:13.480 --> 01:37:14.890
é o detalhe chave aqui.

01:37:14.890 --> 01:37:17.770
A altura desta árvore é três.

01:37:17.770 --> 01:37:20.290
Porque peguei uma lista de tamanho sete e a dividi pela metade,

01:37:20.290 --> 01:37:24.040
e eu o cortei ao meio para deixá-lo balançar nessas duas dimensões,

01:37:24.040 --> 01:37:25.930
mais ou menos um para arredondamento.

01:37:25.930 --> 01:37:27.280
Então, o que eu recebo de volta?

01:37:27.280 --> 01:37:29.770
Agora tenho pesquisa binária.

01:37:29.770 --> 01:37:32.710
Mas não é como o meio do meio do meio.

01:37:32.710 --> 01:37:35.720
Agora sigo essas setas em uma das duas direções.

01:37:35.720 --> 01:37:37.960
Então, cada um desses nós agora tem um int e talvez

01:37:37.960 --> 01:37:40.023
um ponteiro esquerdo e um ponteiro direito.

01:37:40.023 --> 01:37:41.690
Mas você pode chamá-los do que quiser.

01:37:41.690 --> 01:37:45.220
E assim, recuperei a busca binária e o dinamismo.

01:37:45.220 --> 01:37:48.580
Porque se você quiser somar zero, ou oito, ou nove, ou 10,

01:37:48.580 --> 01:37:52.400
podemos apenas balançá-los na parte inferior da árvore de pesquisa binária.

01:37:52.400 --> 01:37:54.070
Então, como isso ficaria no código?

01:37:54.070 --> 01:37:56.380
Mas não vamos realmente implementá-lo linha por linha.

01:37:56.380 --> 01:38:01.330
Bem, aqui estava nossa definição anterior de um nó para uma lista encadeada, que

01:38:01.330 --> 01:38:02.800
era unidimensional, se você quiser.

01:38:02.800 --> 01:38:05.050
Mesmo que possa saltar para cima e para baixo na tela.

01:38:05.050 --> 01:38:07.550
Ainda era apenas uma linha, se você quiser.

01:38:07.550 --> 01:38:10.600
Bem, deixe-me me livrar do único ponteiro na lista encadeada.

01:38:10.600 --> 01:38:13.060
Deixe-me abrir um pouco de espaço aqui neste typedef.

01:38:13.060 --> 01:38:16.570
E deixe-me propor que apenas adicionemos dois ponteiros, cada um dos quais

01:38:16.570 --> 01:38:18.130
é uma estrela do nó struct.

01:38:18.130 --> 01:38:20.230
Um será chamado de esquerda por convenção.

01:38:20.230 --> 01:38:22.870
Um será chamado certo por convenção.

01:38:22.870 --> 01:38:26.200
E assim, desde que alguém, não eu, não hoje, não na aula,

01:38:26.200 --> 01:38:29.920
escreve o código que une essa estrutura de dados também,

01:38:29.920 --> 01:38:32.710
lidando com o filho esquerdo e o filho direito, por assim dizer,

01:38:32.710 --> 01:38:37.040
Acho que podemos realmente costurar essa estrutura bidimensional.

01:38:37.040 --> 01:38:39.970
Além disso, uma vez que você tenha isso na memória,

01:38:39.970 --> 01:38:44.170
você pode traduzir elegantemente para codificar a própria pesquisa binária

01:38:44.170 --> 01:38:47.530
usando um princípio sobre o qual falamos recentemente também.

01:38:47.530 --> 01:38:50.530
Aqui está, por exemplo, uma função que eu vou

01:38:50.530 --> 01:38:54.820
escreva apenas clicando nas etapas chamadas de pesquisa cujo objetivo na vida

01:38:54.820 --> 01:38:55.840
é retornar um booleano.

01:38:55.840 --> 01:38:59.620
Verdadeiro ou falso, o número que procuro está na árvore?

01:38:59.620 --> 01:39:01.930
Esta função de pesquisa, portanto, leva dois argumentos,

01:39:01.930 --> 01:39:04.780
o número que estou procurando número chamado e, em seguida,

01:39:04.780 --> 01:39:07.970
um ponteiro para a árvore, a chamada raiz da árvore.

01:39:07.970 --> 01:39:10.690
Agora, como posso implementar a pesquisa binária no código?

01:39:10.690 --> 01:39:13.520
Bem, lembre-se de nossa breve discussão sobre recursão.

01:39:13.520 --> 01:39:16.210
Acontece que a recursão é uma bela técnica.

01:39:16.210 --> 01:39:18.130
E honestamente, técnica mais óbvia quando

01:39:18.130 --> 01:39:22.060
você tem estruturas bidimensionais, que finalmente depois de mais de cinco semanas

01:39:22.060 --> 01:39:22.990
nós agora fazemos.

01:39:22.990 --> 01:39:25.390
Aqui está talvez minha primeira linha de código aqui.

01:39:25.390 --> 01:39:27.848
Se a árvore for nula, obviamente retorne false.

01:39:27.848 --> 01:39:29.140
Você me entregou uma árvore vazia.

01:39:29.140 --> 01:39:30.160
Não há nada acontecendo.

01:39:30.160 --> 01:39:32.868
Obviamente, o número que você está procurando não estará aqui.

01:39:32.868 --> 01:39:35.170
Então, esse é o meu caso base seguro para garantir que eu não

01:39:35.170 --> 01:39:37.420
estragar e recursivo infinitamente.

01:39:37.420 --> 01:39:39.050
Bem, o que mais pode ser o caso?

01:39:39.050 --> 01:39:44.680
Bem, se o número que estou procurando for menor que o número da própria árvore.

01:39:44.680 --> 01:39:46.710
E agora, lembre-se de que a árvore é uma estrela nodal.

01:39:46.710 --> 01:39:48.460
Embora eu a chame de árvore, é

01:39:48.460 --> 01:39:51.350
realmente o nó atual que foi passado.

01:39:51.350 --> 01:39:55.990
Portanto, se o número que estou procurando for menor que o número do nó atual,

01:39:55.990 --> 01:39:59.650
então devo saber que o número que estou procurando está à esquerda,

01:39:59.650 --> 01:40:00.400
por assim dizer.

01:40:00.400 --> 01:40:01.700
Então, como posso resolver isso?

01:40:01.700 --> 01:40:03.610
Bem, é aqui que entra a mágica da recursão.

01:40:03.610 --> 01:40:09.670
Basta retornar qualquer que seja a resposta para chamar a pesquisa novamente, mas em uma subárvore,

01:40:09.670 --> 01:40:10.300
Se você for.

01:40:10.300 --> 01:40:13.060
Isso é o equivalente a cortar metade da árvore.

01:40:13.060 --> 01:40:17.470
Passe na subárvore esquerda, se desejar, com o mesmo número.

01:40:17.470 --> 01:40:19.600
Caso contrário, se o número que você está procurando não for

01:40:19.600 --> 01:40:22.360
menor que o número do nó atual, mas maior que,

01:40:22.360 --> 01:40:24.890
cortar a outra subárvore em vez disso.

01:40:24.890 --> 01:40:29.710
E apenas retorne qualquer pesquisa que diga que encontra na subárvore correta aqui.

01:40:29.710 --> 01:40:31.520
E então, há um quarto e último caso.

01:40:31.520 --> 01:40:34.264
O que mais poderia ser verdade logicamente?

01:40:34.264 --> 01:40:35.220
sim.

01:40:35.220 --> 01:40:37.710
AUDIÊNCIA: O número é igual ao número [INAUDÍVEL]?

01:40:37.710 --> 01:40:38.710
DAVID J. MALAN: Perfeito.

01:40:38.710 --> 01:40:43.240
Se o número que você está procurando for igual ao número neste nó,

01:40:43.240 --> 01:40:45.310
então eu só vou retornar true.

01:40:45.310 --> 01:40:49.600
E você deve se lembrar de nossas discussões recorrentes sobre design,

01:40:49.600 --> 01:40:51.820
Eu não preciso estritamente perguntar isso explicitamente.

01:40:51.820 --> 01:40:54.580
Ou não tem nó, está à esquerda, está à direita,

01:40:54.580 --> 01:40:55.580
ou você encontrou.

01:40:55.580 --> 01:40:59.170
Então, posso reduzir isso, como de costume, a outra pessoa.

01:40:59.170 --> 01:41:01.130
E isso agora retorna meu verdadeiro.

01:41:01.130 --> 01:41:04.180
Aqui também, é aqui que a recursão, uma vez que você se familiarize com ela,

01:41:04.180 --> 01:41:06.970
começar fica bem elegante e legal no sentido

01:41:06.970 --> 01:41:09.340
que, uau, mesmo que haja muitas falas aqui,

01:41:09.340 --> 01:41:11.620
Quero dizer, há apenas algumas linhas interessantes.

01:41:11.620 --> 01:41:13.448
Muitas delas são chaves nisso, o que

01:41:13.448 --> 01:41:14.990
estritamente falando, eu poderia me livrar.

01:41:14.990 --> 01:41:17.470
E assim, a recursão se presta à elegância

01:41:17.470 --> 01:41:20.980
quando se trata de percorrer esses dados bidimensionais

01:41:20.980 --> 01:41:22.280
estruturas também.

01:41:22.280 --> 01:41:27.940
Portanto, é no código que você pode implementar algo como search.

01:41:27.940 --> 01:41:32.290
Perguntas então sobre essas árvores?

01:41:32.290 --> 01:41:33.220
Temos dinamismo.

01:41:33.220 --> 01:41:34.900
Podemos inserir mais nós para eles.

01:41:34.900 --> 01:41:37.150
Eles são mais rápidos porque nós melhoramos sua pesquisa de volta.

01:41:37.150 --> 01:41:39.250
Mas, mas, mas, tem que haver um preço pago.

01:41:39.250 --> 01:41:41.488
Alguma desvantagem, ou dúvida, ou desvantagem?

01:41:41.488 --> 01:41:42.280
AUDIÊNCIA: Pergunta.

01:41:42.280 --> 01:41:44.863
DAVID J. MALAN: OK, deixe-me voltar a isso e só um segundo.

01:41:44.863 --> 01:41:47.290
Desvantagem, porém, que preço pagamos por esse dinamismo

01:41:47.290 --> 01:41:50.530
e para esta busca binária?

01:41:50.530 --> 01:41:53.867
Mesmo que eu tenha abstraído na foto?

01:41:53.867 --> 01:41:54.907
AUDIÊNCIA: [INAUDÍVEL]

01:41:54.907 --> 01:41:55.990
DAVID J. MALAN: Diga de novo?

01:41:55.990 --> 01:41:56.990
AUDIÊNCIA: [INAUDÍVEL]

01:41:56.990 --> 01:41:58.880
DAVID J. MALAN: Estamos usando muita memória.

01:41:58.880 --> 01:42:01.790
Estou enganando você agora porque estou apenas desenhando esses pequenos quadrados

01:42:01.790 --> 01:42:02.690
com os números simples.

01:42:02.690 --> 01:42:04.490
Mas na verdade há três coisas lá.

01:42:04.490 --> 01:42:09.020
Um inteiro de quatro bytes, um ponteiro esquerdo de oito bytes, um ponteiro direito de oito bytes.

01:42:09.020 --> 01:42:12.740
Então já estamos com 16, 20 bytes agora para armazenar INTs individuais.

01:42:12.740 --> 01:42:15.320
Provavelmente está tudo bem, se a memória for relativamente

01:42:15.320 --> 01:42:18.000
barato e volumoso como é hoje em dia.

01:42:18.000 --> 01:42:20.270
Mas esses são os tipos de trade-offs.

01:42:20.270 --> 01:42:24.050
E aqui, também, você vê uma dica de por que algumas pessoas ainda gostam,

01:42:24.050 --> 01:42:26.720
e você vê-- e de fato, é tão onipresente.

01:42:26.720 --> 01:42:29.125
Porque quando você tem C, você pode realmente ajustar

01:42:29.125 --> 01:42:32.000
quanta memória está sendo usada para melhor ou para pior sob o capô.

01:42:32.000 --> 01:42:35.630
À medida que fizermos a transição para o Python, essas decisões serão tomadas para você.

01:42:35.630 --> 01:42:39.140
E você tem muito, muito menos controle sobre quanta memória

01:42:39.140 --> 01:42:42.500
está sendo usado pelo seu programa porque outra pessoa tomou as decisões de design

01:42:42.500 --> 01:42:43.380
para você.

01:42:43.380 --> 01:42:44.030
Pergunta.

01:42:44.030 --> 01:42:46.890
AUDIÊNCIA: [INAUDÍVEL]

01:42:46.890 --> 01:42:49.740
DAVID J. MALAN: É ruim se não fizermos o nó pai?

01:42:49.740 --> 01:42:50.670
Não necessariamente.

01:42:50.670 --> 01:42:54.820
Não há razão para que você precise ter ponteiros em ambas as direções.

01:42:54.820 --> 01:42:57.210
No entanto, isso pode se prestar à eficiência.

01:42:57.210 --> 01:42:59.970
Ao gastar mais espaço e fazer com que as setas subam para

01:42:59.970 --> 01:43:03.360
você pode realmente economizar mais tempo ao pesquisar a árvore e outros contextos.

01:43:03.360 --> 01:43:06.810
Essa seria a maneira canônica, a maneira típica de implementá-lo.

01:43:06.810 --> 01:43:09.150
Mas absolutamente, assim como uma lista duplamente encadeada,

01:43:09.150 --> 01:43:12.630
isso poderia ajudá-lo a resolver outros problemas também.

01:43:12.630 --> 01:43:16.740
Acontece que estou exagerando nas árvores de busca binária.

01:43:16.740 --> 01:43:21.000
Existem perversões deles, por assim dizer, em que eles realmente não

01:43:21.000 --> 01:43:22.410
comportar-se como anunciado.

01:43:22.410 --> 01:43:24.700
Por exemplo, aqui está uma boa situação.

01:43:24.700 --> 01:43:27.090
Suponha que você tenha uma árvore vazia inicialmente.

01:43:27.090 --> 01:43:28.498
E você insere o número dois.

01:43:28.498 --> 01:43:29.790
Bem, tem que ir a algum lugar.

01:43:29.790 --> 01:43:32.490
Portanto, também pode se tornar a raiz dessa árvore de pesquisa binária.

01:43:32.490 --> 01:43:34.823
E vamos supor que alguém escreveu o código para fazer isso.

01:43:34.823 --> 01:43:36.990
Agora você deseja inserir o número um e você

01:43:36.990 --> 01:43:39.520
deseja manter a capacidade de pesquisa desta árvore.

01:43:39.520 --> 01:43:44.400
Bem, é importante observar que a árvore de pesquisa binária é diferente da árvore.

01:43:44.400 --> 01:43:46.320
Se você acabou de ter uma árvore na memória, há

01:43:46.320 --> 01:43:49.500
não há contrato social com onde os números precisam ir.

01:43:49.500 --> 01:43:51.810
Eles podem ser completamente aleatórios em todo o lugar.

01:43:51.810 --> 01:43:55.320
Árvore de pesquisa binária significa que você pode fazer pesquisa binária,

01:43:55.320 --> 01:43:59.460
significa que qualquer nó aqui vai ser maior do que cada nó aqui

01:43:59.460 --> 01:44:01.770
e menos do que cada nó aqui.

01:44:01.770 --> 01:44:03.308
E isso é uma definição.

01:44:03.308 --> 01:44:05.100
É uma definição estrutural recursiva que

01:44:05.100 --> 01:44:08.850
deve ser verdadeiro para ser uma árvore de pesquisa binária ou BST.

01:44:08.850 --> 01:44:12.060
Portanto, se mantivermos essa propriedade nós mesmos, deixe-me inserir dois,

01:44:12.060 --> 01:44:13.140
deixe-me inserir um.

01:44:13.140 --> 01:44:15.060
Um pertence lá por essa definição.

01:44:15.060 --> 01:44:16.590
Deixe-me inserir três.

01:44:16.590 --> 01:44:18.540
Três pertence lá por essa definição.

01:44:18.540 --> 01:44:21.390
Mas eu meio que tive sorte porque eu na história

01:44:21.390 --> 01:44:25.020
inseriu dois e depois um e depois três.

01:44:25.020 --> 01:44:28.230
Deixe-me propor uma espécie de perversão do algoritmo em que apenas

01:44:28.230 --> 01:44:33.360
tenha azar, deixe-me propor que insiramos um primeiro.

01:44:33.360 --> 01:44:34.830
E então, inserimos dois.

01:44:34.830 --> 01:44:35.850
Bem, para onde vão dois?

01:44:35.850 --> 01:44:38.700
Bem, logicamente, vai para a direita porque é maior.

01:44:38.700 --> 01:44:40.620
Agora, o usuário insere três.

01:44:40.620 --> 01:44:42.760
Onde isso vai?

01:44:42.760 --> 01:44:44.310
Vai lá, logicamente.

01:44:44.310 --> 01:44:46.110
E como essa história se desenrola?

01:44:46.110 --> 01:44:48.270
O usuário insere quatro, cinco, seis.

01:44:48.270 --> 01:44:51.180
É maravilhosamente classificado com antecedência por sorte.

01:44:51.180 --> 01:44:56.040
Mas isso é uma perversão da estrutura em que sentido?

01:44:56.040 --> 01:44:59.080
Ainda é tecnicamente uma árvore de pesquisa binária.

01:44:59.080 --> 01:45:02.970
Mas o que é mais parecido?

01:45:02.970 --> 01:45:06.430
Realmente está evoluindo, se você quiser, em uma lista encadeada.

01:45:06.430 --> 01:45:09.720
E assim, se você, o programador, não implementar uma pesquisa binária

01:45:09.720 --> 01:45:13.980
árvore com algum tipo de reparo em andamento, de modo que assim que algo

01:45:13.980 --> 01:45:17.440
fica, uau, um pouco longo e pegajoso, acho que posso consertar isso.

01:45:17.440 --> 01:45:20.523
Vai ser uma linha irritante-- várias linhas de código, que estamos

01:45:20.523 --> 01:45:22.110
não vai escrever aqui ou em um P-set.

01:45:22.110 --> 01:45:24.630
Mas poderíamos girar essa coisa.

01:45:24.630 --> 01:45:28.590
E poderíamos apenas refazer as coisas para que os dois se tornem a nova raiz.

01:45:28.590 --> 01:45:30.053
Aquele se torna o filho esquerdo.

01:45:30.053 --> 01:45:31.470
Os três se tornam o filho certo.

01:45:31.470 --> 01:45:33.970
Mas é isso, duas, mais três linhas de código.

01:45:33.970 --> 01:45:34.560
É possível.

01:45:34.560 --> 01:45:35.280
É factível.

01:45:35.280 --> 01:45:36.660
Mas é um trabalho extra.

01:45:36.660 --> 01:45:37.620
É um código extra.

01:45:37.620 --> 01:45:42.570
Então, a menos que você escreva esse código e mantenha o equilíbrio dessas árvores,

01:45:42.570 --> 01:45:46.110
só porque é uma árvore de busca binária não significa que sua altura é

01:45:46.110 --> 01:45:47.520
vai ser log base 2 de n.

01:45:47.520 --> 01:45:52.450
A altura pode ser n, caso em que você não obtém essas propriedades.

01:45:52.450 --> 01:45:56.310
Portanto, quando se trata de procurar em uma árvore de pesquisa binária balanceada, sim,

01:45:56.310 --> 01:45:57.180
é log n.

01:45:57.180 --> 01:46:00.990
Mas se estiver desequilibrado, se você não adicionar essa lógica adicional nesses reparos

01:46:00.990 --> 01:46:04.320
por assim dizer, poderia se transformar em grande O de n.

01:46:04.320 --> 01:46:07.343
E esta é toda uma categoria de algoritmos e fantasia

01:46:07.343 --> 01:46:10.260
que você exploraria em um curso de nível superior sobre algoritmos e dados

01:46:10.260 --> 01:46:10.760
estruturas.

01:46:10.760 --> 01:46:13.410
Há muitas maneiras de fazer esse tipo de conserto que estou aludindo

01:46:13.410 --> 01:46:17.800
to na foto ali na tela.

01:46:17.800 --> 01:46:20.080
Algumas outras estruturas de dados, se preferir,

01:46:20.080 --> 01:46:23.110
em direção ao fim de uma espécie de Santo Graal da ciência da computação.

01:46:23.110 --> 01:46:27.970
Portanto, log n é repetidamente um bom lugar para terminar.

01:46:27.970 --> 01:46:30.190
Começamos na semana zero e obtivemos log n.

01:46:30.190 --> 01:46:33.280
Perdemos isso hoje cedo ao introduzir a lista encadeada,

01:46:33.280 --> 01:46:37.190
mas acabamos de recuperá-lo, embora ao preço de gastar mais espaço.

01:46:37.190 --> 01:46:39.850
Mas o Santo Graal, por assim dizer, quando se trata de algoritmos

01:46:39.850 --> 01:46:41.710
não seria grande O de n, certamente.

01:46:41.710 --> 01:46:45.220
Definitivamente, não é n ao quadrado como nossos tipos de bolha e tipos de seleção.

01:46:45.220 --> 01:46:47.110
E nem mesmo grande O de log n.

01:46:47.110 --> 01:46:50.870
O que é melhor do que tudo isso?

01:46:50.870 --> 01:46:53.223
Apenas grande O de um, tempo constante.

01:46:53.223 --> 01:46:54.140
Esse é o Santo Graal.

01:46:54.140 --> 01:46:56.270
Porque se pudéssemos armazenar grandes quantidades de dados

01:46:56.270 --> 01:46:59.330
mas encontre-o instantaneamente em uma etapa, ou duas etapas,

01:46:59.330 --> 01:47:01.070
ou diabos, até 10 ou 20 passos.

01:47:01.070 --> 01:47:05.063
Mas, independentemente do tamanho da estrutura de dados, isso é bastante poderoso.

01:47:05.063 --> 01:47:07.730
Quero dizer, esse é o ingrediente secreto do Google e dos Twitters

01:47:07.730 --> 01:47:11.150
do mundo tentando obter resultados muito, muito rápido.

01:47:11.150 --> 01:47:15.165
Bem, acontece que outro tipo de dados abstrato ou estrutura de dados abstrata

01:47:15.165 --> 01:47:16.790
pode ser algo chamado dicionário.

01:47:16.790 --> 01:47:19.010
Assim como o Merriam-Webster Oxford English

01:47:19.010 --> 01:47:23.387
dicionários que você pode saber que associam, digamos, palavras com definições.

01:47:23.387 --> 01:47:25.970
Bem, você pode pensar em um dicionário de forma tão abstrata assim.

01:47:25.970 --> 01:47:28.505
Duas colunas talvez em uma espécie de planilha

01:47:28.505 --> 01:47:31.130
onde a coluna da esquerda representa algo e a coluna da direita

01:47:31.130 --> 01:47:32.240
representa outra coisa.

01:47:32.240 --> 01:47:34.820
A palavra está à esquerda e sua definição está à direita.

01:47:34.820 --> 01:47:37.470
E isso é quase literalmente o que é um dicionário no papel.

01:47:37.470 --> 01:47:40.400
Você tem todas as palavras e todas as definições ao lado dele.

01:47:40.400 --> 01:47:44.120
Mas, de forma mais geral, na computação, um dicionário

01:47:44.120 --> 01:47:46.100
realmente não tem palavras e definições

01:47:46.100 --> 01:47:48.363
per se, mas pares chave-valor.

01:47:48.363 --> 01:47:49.280
Este é um termo de arte.

01:47:49.280 --> 01:47:51.822
E veremos isso de novo e de novo, especialmente quando

01:47:51.822 --> 01:47:54.320
transição para programação web, chaves e valores.

01:47:54.320 --> 01:47:57.290
Chave é o que você usa para procurar algo.

01:47:57.290 --> 01:48:01.650
O valor é o que você encontra por meio dessa chave.

01:48:01.650 --> 01:48:03.110
Então esse é o termo genérico aqui.

01:48:03.110 --> 01:48:05.590
Já vimos pares de chave-valor no passado.

01:48:05.590 --> 01:48:07.340
Na semana zero conversamos sobre seus contatos

01:48:07.340 --> 01:48:10.040
e seu iPhone ou telefone Android sendo um aplicativo

01:48:10.040 --> 01:48:13.250
que tem um monte de contatos presumivelmente em ordem alfabética pelo primeiro nome,

01:48:13.250 --> 01:48:14.600
ou sobrenome, ou algo parecido.

01:48:14.600 --> 01:48:17.270
Bem, um desses cartões de contato finalmente

01:48:17.270 --> 01:48:20.730
tem o número de alguém, por exemplo, como John Harvard neste caso.

01:48:20.730 --> 01:48:23.450
Nesse tipo de aplicativo, as chaves são

01:48:23.450 --> 01:48:26.810
o nome, como John Harvard que você usa para encontrar informações.

01:48:26.810 --> 01:48:30.020
E o valor é o número que você encontra aí.

01:48:30.020 --> 01:48:32.270
Ou se houver mais informações como onde ele mora

01:48:32.270 --> 01:48:35.360
e endereço de e-mail e afins, todo o cartão de contato

01:48:35.360 --> 01:48:37.490
pode ser o seu valor.

01:48:37.490 --> 01:48:39.860
A chave é o que você usa para procurar John Harvard.

01:48:39.860 --> 01:48:41.780
Agora, na semana zero--

01:48:41.780 --> 01:48:45.200
oh, e melhor, a tabela correspondente então se desenharmos isso em duas colunas

01:48:45.200 --> 01:48:47.780
não seria palavra e definição ou valor de chave genericamente,

01:48:47.780 --> 01:48:50.100
seria nome e número, por exemplo.

01:48:50.100 --> 01:48:52.010
Estamos apenas aplicando uma nova terminologia

01:48:52.010 --> 01:48:53.760
sobre este antigo problema de contatos.

01:48:53.760 --> 01:48:56.660
Bem, esta é a imagem que desenhamos na semana zero,

01:48:56.660 --> 01:49:00.480
pelo que afirmo que log de n foi muito, muito bom.

01:49:00.480 --> 01:49:02.420
E de fato foi e tem sido desde então.

01:49:02.420 --> 01:49:04.970
Mas o Santo Graal seria de fato algo mais

01:49:04.970 --> 01:49:08.180
assim nesta linha verde tracejada constante de tempo.

01:49:08.180 --> 01:49:11.300
E talvez não literalmente um passo, mas um número fixo de passos que mesmo

01:49:11.300 --> 01:49:15.890
à medida que o problema se torna enorme e você vai muito, muito à direita do eixo x,

01:49:15.890 --> 01:49:19.850
o problema não depende do tamanho--

01:49:19.850 --> 01:49:24.080
o tempo para resolver o problema não depende em nada

01:49:24.080 --> 01:49:26.400
do tamanho do problema em si.

01:49:26.400 --> 01:49:29.300
Você pode ter 1.000 contatos ou 100.000 contatos,

01:49:29.300 --> 01:49:32.960
tempo constante significa que leva o mesmo número de passos, não importa o quê.

01:49:32.960 --> 01:49:34.980
Bem, como podemos chegar a esse ponto?

01:49:34.980 --> 01:49:37.260
Bem, há alguns blocos de construção finais hoje.

01:49:37.260 --> 01:49:38.660
E há um chamado hashing.

01:49:38.660 --> 01:49:40.743
E isso é algo que se repetirá algumas vezes.

01:49:40.743 --> 01:49:45.680
Mas, por enquanto, o hash é sobre tomar como entrada algum valor

01:49:45.680 --> 01:49:49.550
e produzindo uma versão mais simples do mesmo.

01:49:49.550 --> 01:49:52.520
Então, por exemplo, aqui está um baralho grande gratuitamente

01:49:52.520 --> 01:49:56.510
de cartões, que são ainda mais visíveis como resultado. E em um baralho de cartas,

01:49:56.510 --> 01:50:00.200
normalmente você tem o quê, 52 cartas mais talvez os curingas e outros enfeites.

01:50:00.200 --> 01:50:03.530
E cada uma dessas cartas tem vários tipos e um naipe.

01:50:03.530 --> 01:50:06.260
E aqui estão literalmente quatro baldes no palco.

01:50:06.260 --> 01:50:08.840
E como devo proceder para classificar esses cartões?

01:50:08.840 --> 01:50:10.730
Não apenas por número, mas também por naipe.

01:50:10.730 --> 01:50:14.180
Bem, você certamente poderia espalhar todos eles e fazer uma bagunça

01:50:14.180 --> 01:50:17.180
e apenas raciocine e coloque tudo em ordem

01:50:17.180 --> 01:50:19.090
de acordo com o naipe e de acordo com o número.

01:50:19.090 --> 01:50:21.590
Mas a maioria de nós, mesmo que não tenha quatro baldes em casa,

01:50:21.590 --> 01:50:24.470
provavelmente farão algo um pouco mais intuitivo,

01:50:24.470 --> 01:50:25.730
parece uma otimização.

01:50:25.730 --> 01:50:28.460
Onde se eu encontrar o nove de copas, eu vou

01:50:28.460 --> 01:50:30.012
para colocar isso no balde de corações.

01:50:30.012 --> 01:50:32.720
O rei de espadas, vou colocá-lo no balde de espadas.

01:50:32.720 --> 01:50:34.970
O valete de ouros aqui.

01:50:34.970 --> 01:50:39.170
E farei isso com a rainha de ouros e o ás de paus aqui,

01:50:39.170 --> 01:50:41.630
e os três aqui, e os 10 aqui.

01:50:41.630 --> 01:50:45.560
E mesmo que ainda sejam 52 passos, por que eu... e talvez em casa,

01:50:45.560 --> 01:50:49.610
por que você faria esta etapa primeiro?

01:50:49.610 --> 01:50:53.040
Qual é o valor de agrupar os valores dessa maneira?

01:50:53.040 --> 01:50:55.720
E isso realmente é um termo de arte.

01:50:55.720 --> 01:50:58.950
Qual é o valor de fazer isso primeiro antes de filtrar e tentar

01:50:58.950 --> 01:51:00.120
classificar os números?

01:51:00.120 --> 01:51:01.076
Sim.

01:51:01.076 --> 01:51:03.875
AUDIÊNCIA: É mais fácil garantir que você não seja [INAUDÍVEL].

01:51:03.875 --> 01:51:04.750
DAVID J. MALAN: Sim.

01:51:04.750 --> 01:51:06.958
É mais fácil garantir que você não está perdendo nada.

01:51:06.958 --> 01:51:09.580
E está pegando um problema de tamanho 52 e diminuindo

01:51:09.580 --> 01:51:12.230
em quatro problemas de tamanho 13, se preferir.

01:51:12.230 --> 01:51:14.642
E assim, isso apenas ajuda a simplificar as coisas, talvez

01:51:14.642 --> 01:51:16.600
reduz a probabilidade de erros e afins.

01:51:16.600 --> 01:51:18.808
E o que estou fazendo aqui, para dar um termo técnico,

01:51:18.808 --> 01:51:20.590
é que estou fazendo hash dos valores.

01:51:20.590 --> 01:51:22.570
Estou tomando como entrada um cartão como este.

01:51:22.570 --> 01:51:26.950
E estou reduzindo de forma mais simples a partir de um domínio maior

01:51:26.950 --> 01:51:29.600
para um intervalo muito menor, se você quiser.

01:51:29.600 --> 01:51:32.680
Então aqui está um domínio de 52 possibilidades.

01:51:32.680 --> 01:51:35.980
Eu quero mapear isso para um intervalo de quatro resultados possíveis--

01:51:35.980 --> 01:51:39.830
os ouros, os paus, os corações ou as espadas aqui.

01:51:39.830 --> 01:51:42.665
E ao fazer isso, estou apenas diminuindo o tamanho do problema.

01:51:42.665 --> 01:51:43.540
Então hash faz isso.

01:51:43.540 --> 01:51:45.790
É literalmente um arranjo do tipo f de x

01:51:45.790 --> 01:51:50.300
por meio do qual você passa algo e recebe de volta um valor conhecido mais simples.

01:51:50.300 --> 01:51:54.940
Bem, uma função hash mais tecnicamente é o algoritmo, ou mesmo a matemática,

01:51:54.940 --> 01:51:58.180
ou mesmo o código que implementa essa ideia, convertendo

01:51:58.180 --> 01:52:03.040
algo maior para algo menor para este intervalo de valores realmente finito.

01:52:03.040 --> 01:52:10.090
E acontece que as tabelas de hash são uma aplicação maravilhosa de arrays

01:52:10.090 --> 01:52:14.080
e listas vinculadas para tentar aproveitar o melhor dos dois mundos.

01:52:14.080 --> 01:52:18.740
O objetivo é teoricamente alcançar o Santo Graal do tempo constante.

01:52:18.740 --> 01:52:20.740
E isso vai ser um pouco exagerado

01:52:20.740 --> 01:52:22.990
porque nem sempre você vai alcançá-lo exatamente.

01:52:22.990 --> 01:52:25.420
Mas pelo menos podemos chegar um pouco mais perto lá também.

01:52:25.420 --> 01:52:28.510
Então, com tabelas hash, você tem algo parecido com isto.

01:52:28.510 --> 01:52:29.860
Isso é apenas uma matriz.

01:52:29.860 --> 01:52:33.700
Esta é a versão de um artista desenhando verticalmente em vez de horizontalmente.

01:52:33.700 --> 01:52:36.310
Mas isso é apenas um detalhe graficamente.

01:52:36.310 --> 01:52:40.960
E esse array, por exemplo, talvez seja de tamanho 26.

01:52:40.960 --> 01:52:42.470
E onde quero chegar com isso?

01:52:42.470 --> 01:52:46.990
Bem, como a Apple, como o Google armazena seu contexto em ordem alfabética

01:52:46.990 --> 01:52:49.510
em seu telefone e procurar coisas rapidamente?

01:52:49.510 --> 01:52:52.630
Bem, eles podem-- eles provavelmente colocam em ordem alfabética pelo menos em inglês

01:52:52.630 --> 01:52:55.210
de A a Z. Ou se convertermos isso em números

01:52:55.210 --> 01:52:56.920
é como o que, 65 através de qualquer coisa.

01:52:56.920 --> 01:52:59.380
Ou, na verdade, de zero a 25 é suficiente.

01:52:59.380 --> 01:53:02.710
Se estivermos usando um array de tamanho 26, começamos a contar do zero

01:53:02.710 --> 01:53:04.180
e contamos até 25.

01:53:04.180 --> 01:53:06.830
Mas vamos abstrair isso apenas como letras do alfabeto.

01:53:06.830 --> 01:53:09.670
Então, talvez o que o Google e a Apple estão fazendo em seu telefone

01:53:09.670 --> 01:53:12.670
está armazenando todos os A's lá em cima, todos os Z's lá embaixo,

01:53:12.670 --> 01:53:14.810
e tudo mais no meio.

01:53:14.810 --> 01:53:16.610
E então, isso funciona muito bem se você começar

01:53:16.610 --> 01:53:18.110
adicionando seus amigos e sua família.

01:53:18.110 --> 01:53:21.970
Então, por exemplo-- e vou me livrar da carta para não distrair.

01:53:21.970 --> 01:53:25.750
Alvis pode ir para o primeiro lugar porque A, você subtrai 65,

01:53:25.750 --> 01:53:26.530
mapeia para zero.

01:53:26.530 --> 01:53:29.020
Então o colocamos no primeiro balde, o balde A.

01:53:29.020 --> 01:53:31.450
Talvez Zacharias acabe lá no final.

01:53:31.450 --> 01:53:33.580
E então no meio pode estar aqui Hermione.

01:53:33.580 --> 01:53:36.580
E se fizermos esse ponto, ponto, ponto, você continua adicionando todos os seus colegas de classe,

01:53:36.580 --> 01:53:41.500
você pode obter um banco de dados de contatos que contém todos esses dados aqui.

01:53:41.500 --> 01:53:44.530
Agora, cada um desses nós, eles são desenhados de forma diferente

01:53:44.530 --> 01:53:46.450
porque esta é apenas outra versão do artista.

01:53:46.450 --> 01:53:49.870
Esses retângulos, esses retângulos longos representam um cartão de contato,

01:53:49.870 --> 01:53:53.200
como o de John Harvard que tem o nome, talvez e-mail, definitivamente telefone

01:53:53.200 --> 01:53:54.950
número, e coisas assim.

01:53:54.950 --> 01:53:57.460
Então isso parece ótimo.

01:53:57.460 --> 01:53:58.120
Por que?

01:53:58.120 --> 01:54:00.100
Como posso encontrar Alvis?

01:54:00.100 --> 01:54:01.300
Bem, eu vou para o balde A.

01:54:01.300 --> 01:54:02.380
Como encontro Zacarias?

01:54:02.380 --> 01:54:03.582
Eu vou para o balde Z.

01:54:03.582 --> 01:54:04.540
Como faço para encontrar Hermione?

01:54:04.540 --> 01:54:06.010
Eu vou para o balde H.

01:54:06.010 --> 01:54:09.730
Mas, mas, mas, eu fiz isso deliberadamente.

01:54:09.730 --> 01:54:14.710
Que problema surgirá eventualmente, supondo que você tenha colegas de classe suficientes?

01:54:14.710 --> 01:54:16.462
AUDIÊNCIA: [INAUDÍVEL]

01:54:17.885 --> 01:54:18.760
DAVID J. MALAN: Sim.

01:54:18.760 --> 01:54:21.100
Haverá muitas pessoas, muitos contatos para todos

01:54:21.100 --> 01:54:23.860
dos espaços disponíveis na matriz.

01:54:23.860 --> 01:54:25.540
Ainda há espaço aqui.

01:54:25.540 --> 01:54:29.440
Mas tenho certeza de que, se pensar nessa classe em particular,

01:54:29.440 --> 01:54:34.090
não temos Hermione, mas também Harry, que também é um H. Hagrid, que é

01:54:34.090 --> 01:54:36.430
também um H. Então, onde colocá-los?

01:54:36.430 --> 01:54:40.010
Eu poderia colocá-los arbitrariamente em qualquer um dos espaços abertos.

01:54:40.010 --> 01:54:43.450
Mas então você perde o imediatismo de pular direto para o H, direto para o A,

01:54:43.450 --> 01:54:44.290
direito ao Z.

01:54:44.290 --> 01:54:47.590
Mas agora que temos listas vinculadas, podemos combinar essas ideias.

01:54:47.590 --> 01:54:51.530
Use uma matriz para chegar à primeira letra do nome de seu interesse.

01:54:51.530 --> 01:54:56.300
E então, se você tiver uma colisão, por assim dizer, em que alguém já está lá,

01:54:56.300 --> 01:54:58.360
você não faz algo estúpido como colocar Harry

01:54:58.360 --> 01:55:01.270
aqui embaixo só porque está disponível, ou talvez Hagrid aqui embaixo

01:55:01.270 --> 01:55:03.228
só porque está disponível porque então você está

01:55:03.228 --> 01:55:04.870
perdendo o imediatismo da pesquisa.

01:55:04.870 --> 01:55:08.890
Por que você simplesmente não os une em uma lista de links?

01:55:08.890 --> 01:55:10.220
Agora, o que isso significa.

01:55:10.220 --> 01:55:14.398
Isso significa que, para a maioria dos personagens aqui, você tem uma pesquisa de tempo constante.

01:55:14.398 --> 01:55:15.940
Você procura Alvis, bum, acabou.

01:55:15.940 --> 01:55:17.230
Zacharias, bum, acabou.

01:55:17.230 --> 01:55:22.400
OK, Harry, Hermione, Hagrid, pode ser um, dois ou três passos.

01:55:22.400 --> 01:55:24.760
Então isso está se transformando em algo linear.

01:55:24.760 --> 01:55:28.000
Mas aqui fazemos uma distinção hoje entre tempos de execução teóricos,

01:55:28.000 --> 01:55:31.750
sobre o qual continuamos falando, e honestamente, um relógio na parede

01:55:31.750 --> 01:55:34.090
tempos de execução com os quais os humanos reais se importam.

01:55:34.090 --> 01:55:38.290
Isso é muito mais rápido do que uma lista encadeada porque você

01:55:38.290 --> 01:55:40.120
não precisa pesquisar todos os nomes.

01:55:40.120 --> 01:55:44.890
É ainda mais rápido que um array porque você não precisa fazer busca binária.

01:55:44.890 --> 01:55:49.600
Você pode literalmente, para a maioria dos nomes, encontrá-los em tempo constante--

01:55:49.600 --> 01:55:50.590
um passo.

01:55:50.590 --> 01:55:53.020
E novamente, não é teoricamente constante porque estes--

01:55:53.020 --> 01:55:55.210
se você só fizer amizade com pessoas que têm nomes H,

01:55:55.210 --> 01:55:57.550
vai ser uma longa lista encadeada louca de qualquer maneira.

01:55:57.550 --> 01:56:01.840
Então, novamente, realmente depende de qual é a natureza dos dados aqui.

01:56:01.840 --> 01:56:04.650
Mas isso é muito próximo do tempo constante.

01:56:04.650 --> 01:56:06.400
E de fato, como poderíamos nos aproximar ainda mais?

01:56:06.400 --> 01:56:08.980
Como poderíamos reduzir a probabilidade de colisões

01:56:08.980 --> 01:56:12.220
para os H's ou quaisquer outras letras?

01:56:12.220 --> 01:56:14.830
Como poderíamos evitar colocar muitos nomes H juntos?

01:56:14.830 --> 01:56:16.802
AUDIÊNCIA: [INAUDÍVEL]

01:56:18.240 --> 01:56:19.740
DAVID J. MALAN: Fale um pouco mais alto.

01:56:19.740 --> 01:56:22.626
AUDIÊNCIA: [INAUDÍVEL]

01:56:24.538 --> 01:56:25.580
DAVID J. MALAN: OK, sim.

01:56:25.580 --> 01:56:27.360
Então poderíamos adicionar outra dimensão, se você quiser.

01:56:27.360 --> 01:56:29.193
Mas não vamos adicionar uma terceira dimensão, por si só.

01:56:29.193 --> 01:56:32.150
Mas vamos realmente olhar não apenas para a primeira letra do nome de todos

01:56:32.150 --> 01:56:33.650
mas o primeiro e o segundo.

01:56:33.650 --> 01:56:37.310
E, de fato, vamos ver se isso nos leva um pouco mais adiante.

01:56:37.310 --> 01:56:40.310
Então deixe-me ir em frente e propor, se você passar por todo o Harry Potter

01:56:40.310 --> 01:56:42.977
universo, na verdade há muitas colisões se continuarmos.

01:56:42.977 --> 01:56:45.950
E assim, temos os L's aqui, os R's, os S's, e assim por diante.

01:56:45.950 --> 01:56:47.510
Bem, vamos limpar isso aqui.

01:56:47.510 --> 01:56:50.240
Hermione originalmente foi para o local H.

01:56:50.240 --> 01:56:54.230
Mas vamos diminuir a probabilidade de colisões ali e em qualquer outro lugar.

01:56:54.230 --> 01:56:58.050
Em vez de colocar Hermione, Harry e Hagrid todos juntos,

01:56:58.050 --> 01:56:59.750
vamos em frente e fazer isso em vez disso.

01:56:59.750 --> 01:57:02.840
Em vez de rotular esses baldes de A a Z,

01:57:02.840 --> 01:57:04.620
vamos nos dar mais baldes.

01:57:04.620 --> 01:57:07.940
Na verdade, isso pode ser H. Bem, em vez de H, talvez isso deva ser HA,

01:57:07.940 --> 01:57:11.870
e então deve ser HB, HC, HD, HE, HF.

01:57:11.870 --> 01:57:14.000
Agora, alguns deles são um pouco sem sentido

01:57:14.000 --> 01:57:16.460
porque não consigo pensar em nomes que correspondam à maioria deles.

01:57:16.460 --> 01:57:18.170
Mas é determinístico.

01:57:18.170 --> 01:57:20.820
Pelo menos sabemos que o balde estará lá,

01:57:20.820 --> 01:57:22.680
o que é importante mesmo que esteja vazio.

01:57:22.680 --> 01:57:24.560
E agora, podemos colocar Hermione aqui.

01:57:24.560 --> 01:57:25.760
Podemos colocar Harry aqui.

01:57:25.760 --> 01:57:26.480
Mas oh-oh.

01:57:26.480 --> 01:57:28.190
Não fizemos isso perfeitamente bem.

01:57:28.190 --> 01:57:29.420
Hagrid ainda colidem.

01:57:29.420 --> 01:57:30.620
Então deixe-me voltar para você.

01:57:30.620 --> 01:57:33.788
Como podemos reduzir a probabilidade de colisão entre Harry e Hagrid?

01:57:33.788 --> 01:57:35.330
AUDIÊNCIA: [INAUDÍVEL] outra carta?

01:57:35.330 --> 01:57:35.630
DAVID J. MALAN: Sim.

01:57:35.630 --> 01:57:37.250
Assim, podemos olhar para a terceira carta.

01:57:37.250 --> 01:57:38.240
Então deixe-me tentar isso.

01:57:38.240 --> 01:57:44.030
Em vez de HA, vejamos HAA, HAB, HAC, ponto, ponto, ponto, HAQ, ponto, ponto, ponto,

01:57:44.030 --> 01:57:47.610
HEQ, HER, HES e assim por diante.

01:57:47.610 --> 01:57:50.870
E agora, acho que esses nomes e provavelmente todos os outros que vimos

01:57:50.870 --> 01:57:54.630
agora são distribuídos de forma muito mais limpa.

01:57:54.630 --> 01:57:57.140
Há uma probabilidade muito menor de colisões

01:57:57.140 --> 01:58:01.040
a menos que duas pessoas tenham quase os mesmos nomes ou uma seja o prefixo da outra.

01:58:01.040 --> 01:58:06.140
Mas, mas, mas, embora agora estejamos mais perto do que nunca do tempo constante

01:58:06.140 --> 01:58:09.470
porque as chances de sofrermos uma colisão e termos que evoluir para uma lista encadeada

01:58:09.470 --> 01:58:11.990
são muito mais baixos, qual é a desvantagem disso

01:58:11.990 --> 01:58:16.840
não é completamente óbvio de como eu descrevi isso na tela?

01:58:16.840 --> 01:58:18.400
Qual é o preço que estou pagando aqui?

01:58:18.400 --> 01:58:18.910
Sim.

01:58:18.910 --> 01:58:19.960
AUDIÊNCIA: Tanta memória.

01:58:19.960 --> 01:58:22.330
DAVID J. MALAN: Esta é uma enorme quantidade de memória.

01:58:22.330 --> 01:58:26.560
O número de células aqui na matriz é agora o quê, 26 vezes 26 vezes

01:58:26.560 --> 01:58:30.730
26 para o primeiro, segundo e terceiro caracteres possíveis

01:58:30.730 --> 01:58:32.500
todos combinados combinatoriamente aqui.

01:58:32.500 --> 01:58:33.100
Isso é muito.

01:58:33.100 --> 01:58:34.100
Eu nem os desenhei.

01:58:34.100 --> 01:58:36.830
Eu tenho o ponto, ponto, ponto. [? Você poderia?] evocar isso?

01:58:36.830 --> 01:58:38.260
Isso é uma enorme quantidade de memória.

01:58:38.260 --> 01:58:40.390
Este é um conjunto de dados muito esparso agora.

01:58:40.390 --> 01:58:43.120
E as chances são de que você vai desperdiçar muita memória,

01:58:43.120 --> 01:58:47.623
mesmo para nomes como HAE, HA, HEQ.

01:58:47.623 --> 01:58:48.790
Não consigo nem pensar em nomes.

01:58:48.790 --> 01:58:50.860
Muitos desses baldes estarão vazios,

01:58:50.860 --> 01:58:55.400
para não mencionar o AAA e o ZZZ e tudo mais.

01:58:55.400 --> 01:58:56.500
Então é uma troca.

01:58:56.500 --> 01:58:58.387
E pode ser uma troca muito cara.

01:58:58.387 --> 01:59:00.220
E assim, você pode ter que tolerar algo

01:59:00.220 --> 01:59:03.040
como as colisões que tivemos anteriormente, em que, embora possam

01:59:03.040 --> 01:59:09.520
muito bem acontecer, pelo menos você está diminuindo a probabilidade talvez

01:59:09.520 --> 01:59:10.940
ter mais baldes como este.

01:59:10.940 --> 01:59:13.910
E, de fato, se eu voltar agora para onde poderíamos ter ido com isso,

01:59:13.910 --> 01:59:17.500
aqui está como podemos representar esses nós na árvore.

01:59:17.500 --> 01:59:19.810
Anteriormente, no passado, tivemos uma pessoa

01:59:19.810 --> 01:59:23.230
que tinha um nome de string e um número de string, também conhecido como char star.

01:59:23.230 --> 01:59:27.250
E então, aqui agora pode ser como nesta tabela de hash

01:59:27.250 --> 01:59:31.630
representamos o nome e o número de alguém, bem como um ponteiro

01:59:31.630 --> 01:59:33.610
para o próximo elemento da lista.

01:59:33.610 --> 01:59:35.380
Deixe-me voltar apenas para a imagem aqui.

01:59:35.380 --> 01:59:38.140
Continuamos desenhando formas diferentes, porque, novamente, são abstrações.

01:59:38.140 --> 01:59:39.932
Quem realmente se importa se eles estão em escala agora.

01:59:39.932 --> 01:59:42.568
Temos espaço suficiente para o nome da pessoa, não retratado

01:59:42.568 --> 01:59:44.110
na tela está o número de Hermione.

01:59:44.110 --> 01:59:45.910
Mas isso está em algum lugar neste retângulo.

01:59:45.910 --> 01:59:48.100
Mas sim, retratado aqui nesta pracinha

01:59:48.100 --> 01:59:50.860
é um ponteiro para o próximo nó na lista.

01:59:50.860 --> 01:59:54.640
Armazenando o nome e o número, talvez o endereço dela, talvez o endereço de correspondência,

01:59:54.640 --> 01:59:58.360
seja qual for, além de um ponteiro permite que cada um desses nós

01:59:58.360 --> 02:00:01.750
para ser conectável como os nós na lista encadeada.

02:00:01.750 --> 02:00:04.160
Mas onde eles estão começando é em uma matriz.

02:00:04.160 --> 02:00:06.580
Então o array nos dá 126--

02:00:06.580 --> 02:00:10.630
ou nos pega-- reduz o problema do tamanho 26 para um,

02:00:10.630 --> 02:00:12.520
nos leva à lista encadeada em questão.

02:00:12.520 --> 02:00:16.520
Esperançosamente, é uma única pessoa ou talvez tenha mais do que isso.

02:00:16.520 --> 02:00:19.210
Enquanto isso, qual é a própria tabela de hash -

02:00:19.210 --> 02:00:22.960
a tabela de hash, a coisa toda é literalmente apenas uma matriz.

02:00:22.960 --> 02:00:25.990
Eu codifiquei a versão mais simples do tamanho 26

02:00:25.990 --> 02:00:29.470
mas o que cada uma dessas caixas na matriz vertical

02:00:29.470 --> 02:00:33.520
representam apenas um ponteiro para potencialmente um nó, um nó em uma lista encadeada.

02:00:33.520 --> 02:00:36.130
E se não houver ninguém lá, se não houver ninguém no local y,

02:00:36.130 --> 02:00:38.530
ou x, ou algo parecido nesse universo, bem, é

02:00:38.530 --> 02:00:41.890
apenas um ponteiro nulo significando que não há ninguém lá.

02:00:41.890 --> 02:00:45.790
Mas se houver, será um ponteiro para um nó válido do qual

02:00:45.790 --> 02:00:48.135
pode chegar a qualquer um dos outros também.

02:00:48.135 --> 02:00:50.260
E aquela chamada função hash, assim como a

02:00:50.260 --> 02:00:52.120
eu fiz com os cartões, bem, é

02:00:52.120 --> 02:00:55.780
apenas uma caixa preta, se preferir, mas implementada em algum lugar no código,

02:00:55.780 --> 02:01:00.850
como em C. E então, se você passar em Albus, qual é o valor de hash de Albus?

02:01:00.850 --> 02:01:05.260
Bem, na primeira versão da história com 26 baldes, deveria ser um zero.

02:01:05.260 --> 02:01:07.900
Se passar em Zacarias, deve ser 25.

02:01:07.900 --> 02:01:11.980
E assim, assim como minhas cartas estavam sendo divididas em um de um, dois, três,

02:01:11.980 --> 02:01:16.780
quatro valores, agora esses nomes estão sendo divididos em uma das 26 possibilidades,

02:01:16.780 --> 02:01:22.420
ou 26 vezes 26, ou 26 elevado à terceira potência se você tiver mais e mais granularidade

02:01:22.420 --> 02:01:24.620
do que isso.

02:01:24.620 --> 02:01:31.850
Dúvidas sobre essa implementação agora dessa ideia de tabela hash?

02:01:31.850 --> 02:01:38.090
AUDIÊNCIA: Devemos [INAUDÍVEL] o valor nulo e depois [INAUDÍVEL]?

02:01:41.470 --> 02:01:43.570
DAVID J. MALAN: Se você--

02:01:43.570 --> 02:01:45.173
dizer isso de novo com o nulo?

02:01:45.173 --> 02:01:46.840
AUDIÊNCIA: Você poderia ser [INAUDÍVEL]?

02:01:55.190 --> 02:01:56.690
DAVID J. MALAN: Ah, uma boa pergunta.

02:01:56.690 --> 02:01:58.398
Portanto, se há tanta escassez, há

02:01:58.398 --> 02:02:00.160
todas essas células vazias na matriz.

02:02:00.160 --> 02:02:03.040
Você não poderia simplesmente entrar e libertá-los, ou apagá-los, ou apenas

02:02:03.040 --> 02:02:07.690
encolher a matriz e não ter AAA, AAB e AAC apenas

02:02:07.690 --> 02:02:10.240
têm os prefixos, dois ou três caracteres

02:02:10.240 --> 02:02:12.970
que você precisa, você absolutamente poderia fazer isso.

02:02:12.970 --> 02:02:16.780
Mas agora, o que você perde é o benefício aritmético de ser

02:02:16.780 --> 02:02:22.480
capaz de mapear cada letra para um número se você começar a liberar espaço não utilizado,

02:02:22.480 --> 02:02:26.347
você não sabe que Zacharias está necessariamente no local 25.

02:02:26.347 --> 02:02:28.180
Albus ainda estará na localização zero.

02:02:28.180 --> 02:02:30.760
Mas se você excluiu alguns dos elementos no meio,

02:02:30.760 --> 02:02:33.460
Zacharias pode estar em 24 se você deletou um,

02:02:33.460 --> 02:02:35.510
23 se você excluiu outro.

02:02:35.510 --> 02:02:37.900
E assim, você não tem esse imediatismo aritmético

02:02:37.900 --> 02:02:41.620
que você precisa para indexar na matriz com tempo constante.

02:02:41.620 --> 02:02:45.420
E o mesmo acontecerá se forem duas letras ou três letras.

02:02:45.420 --> 02:02:47.920
Você precisa ser capaz de confiar que pode fazer algumas contas rápidas

02:02:47.920 --> 02:02:50.890
e salte para o índice correto em tempo constante.

02:02:50.890 --> 02:02:53.000
E esse é, novamente, o apelo dessas matrizes.

02:02:53.000 --> 02:02:57.370
Portanto, quando se trata do tempo de execução de uma tabela de hash, inserindo valores nela,

02:02:57.370 --> 02:03:00.200
procurando valores nela, no final das contas,

02:03:00.200 --> 02:03:01.990
é tecnicamente grande O de n.

02:03:01.990 --> 02:03:06.580
Porque no caso mais louco, você pode ter uma enorme tabela de hash sofisticada.

02:03:06.580 --> 02:03:09.490
Mas todos no universo têm um nome que começa com H.

02:03:09.490 --> 02:03:12.370
E então, ele evolui para uma lista encadeada realmente longa

02:03:12.370 --> 02:03:14.870
assim como uma árvore de busca binária poderia fazer o mesmo.

02:03:14.870 --> 02:03:17.620
Mas se você escolher uma função de hash mais inteligente, talvez atenue isso

02:03:17.620 --> 02:03:19.570
e você não confia apenas na primeira letra

02:03:19.570 --> 02:03:23.860
mas no segundo, ou no terceiro também, ou alguma outra combinação dessa entrada

02:03:23.860 --> 02:03:26.260
e tornar sua função de hash mais inteligente, probabilidades

02:03:26.260 --> 02:03:30.520
se você obtiver uma boa função de hash, deseja que ela seja mais da ordem de n

02:03:30.520 --> 02:03:33.620
dividido por k, onde k significa constante matematicamente.

02:03:33.620 --> 02:03:35.510
E assim, k é o número de baldes.

02:03:35.510 --> 02:03:38.140
Então, idealmente, você deseja uma distribuição uniforme.

02:03:38.140 --> 02:03:41.180
Você quer tantas pessoas aqui, tantas pessoas aqui.

02:03:41.180 --> 02:03:43.600
Você não quer que haja algumas ou nenhuma pessoa.

02:03:43.600 --> 02:03:45.965
Você quer uma distribuição estatística uniforme.

02:03:45.965 --> 02:03:48.340
E talvez você consiga isso dos nomes humanos, talvez não.

02:03:48.340 --> 02:03:50.680
Mas esse é o desafio de uma função hash.

02:03:50.680 --> 02:03:53.290
Claro, grande O de n sobre k não é uma coisa

02:03:53.290 --> 02:03:56.050
porque sempre jogamos fora constantes como k.

02:03:56.050 --> 02:03:58.240
Então ainda é grande O de n.

02:03:58.240 --> 02:04:00.970
Mas, novamente, a distinção hoje é que, OK, sim,

02:04:00.970 --> 02:04:03.640
academicamente você aprendeu no CS50 que, com certeza, é grande O de n.

02:04:03.640 --> 02:04:08.000
Mas meu Deus, é 26 vezes mais rápido se você fizer bem a função hash

02:04:08.000 --> 02:04:10.600
e você espalha todos sobre a mesa de hash.

02:04:10.600 --> 02:04:14.200
E esse é o apelo desses tipos de estruturas.

02:04:14.200 --> 02:04:16.960
E temos mais um para você, se me permite.

02:04:16.960 --> 02:04:20.180
E isso é algo agora conhecido como tentativa.

02:04:20.180 --> 02:04:23.500
Acontece que uma tentativa é ainda mais legal,

02:04:23.500 --> 02:04:29.560
se você gosta desse tipo de coisa, na medida em que não se transforma em grande O de n.

02:04:29.560 --> 02:04:31.707
É um tempo verdadeiramente constante.

02:04:31.707 --> 02:04:33.040
Mas haverá um preço.

02:04:33.040 --> 02:04:34.360
Vai haver uma pegadinha.

02:04:34.360 --> 02:04:38.230
Um tri é uma espécie de árvore mais sofisticada.

02:04:38.230 --> 02:04:41.200
E é a abreviação de recuperação, mas pronuncia-se tri

02:04:41.200 --> 02:04:42.670
por estranhas razões históricas.

02:04:42.670 --> 02:04:47.980
Mas um tri é uma árvore, cada um de cujos nós é uma matriz.

02:04:47.980 --> 02:04:49.427
Então, isso é tudo uma mistura maluca agora.

02:04:49.427 --> 02:04:52.510
As pessoas começaram a inventar estruturas de dados apenas combinando estruturas diferentes.

02:04:52.510 --> 02:04:54.677
Então, infelizmente, muitas das boas ideias são tomadas.

02:04:54.677 --> 02:04:59.643
Mas você só tem benefícios de certos aspectos dessas estruturas de dados.

02:04:59.643 --> 02:05:02.810
E combiná-los, idealmente, oferece o melhor dos dois mundos, por assim dizer.

02:05:02.810 --> 02:05:04.940
Aqui pode estar a raiz de um tri.

02:05:04.940 --> 02:05:06.850
É literalmente um grande nó, um grande retângulo.

02:05:06.850 --> 02:05:08.480
Mas na verdade é um array.

02:05:08.480 --> 02:05:11.540
Portanto, há 26 locais nesta foto aqui.

02:05:11.540 --> 02:05:14.920
E aqui está como você usa um tri, por exemplo, os nomes das lojas

02:05:14.920 --> 02:05:17.410
assim como a tabela de hash.

02:05:17.410 --> 02:05:20.680
Você trata cada um dos elementos dessa matriz nesse nó

02:05:20.680 --> 02:05:22.100
como uma letra do alfabeto.

02:05:22.100 --> 02:05:24.590
Então A a Z ou zero a 25.

02:05:24.590 --> 02:05:28.910
E se você quiser armazenar o nome de alguém aqui, faça da seguinte maneira.

02:05:28.910 --> 02:05:34.270
Se você deseja armazenar um H, indexe no local H.

02:05:34.270 --> 02:05:37.990
E se você quiser armazenar a segunda letra do nome de alguém, como um A,

02:05:37.990 --> 02:05:40.180
bem, você adiciona outro nó abaixo dele.

02:05:40.180 --> 02:05:40.750
E tal.

02:05:40.750 --> 02:05:42.190
Um está ligado ao outro.

02:05:42.190 --> 02:05:45.130
E então você identifica o A nessa matriz.

02:05:45.130 --> 02:05:49.240
E então você continua e talvez coloque um G se o objetivo for armazenar-- spoiler agora--

02:05:49.240 --> 02:05:51.730
Hagrid nesta estrutura de dados.

02:05:51.730 --> 02:05:54.782
E então o R, e o I, e então o D.

02:05:54.782 --> 02:05:56.740
Mas quando você chega ao D, o final do nome,

02:05:56.740 --> 02:06:00.070
você tem que sinalizar de alguma forma que este é o fim de um nome

02:06:00.070 --> 02:06:02.380
que incorporamos a essa estrutura de dados.

02:06:02.380 --> 02:06:04.780
Então, enquanto todos esses são chamados em branco apenas

02:06:04.780 --> 02:06:06.910
para tornar óbvio o que estamos conectando a quê,

02:06:06.910 --> 02:06:09.460
verde tem que ser como um bool isso é verdade

02:06:09.460 --> 02:06:11.830
apenas indica que o dinheiro para aqui.

02:06:11.830 --> 02:06:15.160
D é a última letra do nome real de alguém.

02:06:15.160 --> 02:06:18.820
E o que é legal agora sobre um tri é

02:06:18.820 --> 02:06:21.260
que podemos repetir isso para outros nomes também.

02:06:21.260 --> 02:06:24.770
Então, por exemplo, aqui é onde podemos colocar Harry também.

02:06:24.770 --> 02:06:30.100
E observe, eles compartilham um prefixo comum, HA para Hagrid, HA para Harry.

02:06:30.100 --> 02:06:33.430
Estamos reutilizando alguns desses nós, alguns desses arrays.

02:06:33.430 --> 02:06:36.820
Podemos até colocar Hermione aqui também, pegando emprestado apenas o H.

02:06:36.820 --> 02:06:39.790
Mas ela pega o H, depois o E, depois o R...

02:06:39.790 --> 02:06:42.650
RMIONE, e assim por diante.

02:06:42.650 --> 02:06:46.360
E marcamos no final do nome dela também que ela está lá.

02:06:46.360 --> 02:06:48.440
Agora, qual é a lição aqui?

02:06:48.440 --> 02:06:51.670
Bem, qual é o tempo de execução de um tri?

02:06:51.670 --> 02:06:55.820
Quantas etapas são necessárias para encontrar alguém nessa estrutura de dados?

02:06:55.820 --> 02:06:59.150
E deixe-me diminuir o zoom para que de repente se torne um enorme volume de dados

02:06:59.150 --> 02:07:01.070
estrutura com ainda mais.

02:07:01.070 --> 02:07:02.780
Talvez pareça... desculpe.

02:07:02.780 --> 02:07:04.040
Não, vou mantê-lo neste.

02:07:04.040 --> 02:07:07.040
Talvez pareça algo assim com apenas esses três nomes.

02:07:07.040 --> 02:07:12.560
Mas quantos passos são necessários para encontrar Hagrid, ou Harry, ou Hermione,

02:07:12.560 --> 02:07:15.230
não importa quantos nomes estão nesta estrutura de dados?

02:07:15.230 --> 02:07:16.820
No momento são três.

02:07:16.820 --> 02:07:18.230
Mas é preciso o quê?

02:07:18.230 --> 02:07:23.390
HAGRID, então seis passos para encontrar Hagrid.

02:07:23.390 --> 02:07:26.660
HARRY, cinco passos para encontrar Harry.

02:07:26.660 --> 02:07:31.760
HERMIONE, oito passos para encontrar Hermione.

02:07:31.760 --> 02:07:35.180
Mas observe que essas etapas dependem apenas do que

02:07:35.180 --> 02:07:37.130
os comprimentos dos nomes humanos.

02:07:37.130 --> 02:07:41.180
E vamos supor que ninguém terá um nome infinitamente longo.

02:07:41.180 --> 02:07:42.830
Vai atingir o máximo em quanto, oito?

02:07:42.830 --> 02:07:44.870
Não, talvez 18, talvez 20, 30.

02:07:44.870 --> 02:07:47.270
Na verdade, existem alguns nomes humanos bem longos por aí.

02:07:47.270 --> 02:07:49.080
Mas será finito.

02:07:49.080 --> 02:07:50.660
Você sabe que é um limite.

02:07:50.660 --> 02:07:54.360
Considerando que a maioria dos contextos pode crescer para sempre.

02:07:54.360 --> 02:07:57.530
Então, o que é atraente aqui é se você assumir que o nome mais longo é,

02:07:57.530 --> 02:08:00.170
Não sei, 50 por questão de tema aqui,

02:08:00.170 --> 02:08:03.080
então você sabe que encontrar alguém nesta estrutura de dados

02:08:03.080 --> 02:08:05.180
levará mais de 50 passos.

02:08:05.180 --> 02:08:10.520
50 é, portanto, uma constante, o que significa que você tem um grande O de um tempo de execução.

02:08:10.520 --> 02:08:13.190
Não importa se há um milhão de pessoas nesta lista telefônica

02:08:13.190 --> 02:08:14.990
ou um bilhão de pessoas nesta lista telefônica.

02:08:14.990 --> 02:08:17.010
Isso definitivamente adicionará mais nós a ele.

02:08:17.010 --> 02:08:18.940
Mas ainda vai levar você HAR--

02:08:18.940 --> 02:08:22.880
Sinto muito-- HAGRID, seis passos para encontrar Hagrid.

02:08:22.880 --> 02:08:28.250
HARRY, cinco passos para encontrar Harry mesmo que haja um bilhão de outras pessoas

02:08:28.250 --> 02:08:29.820
nessa estrutura de dados.

02:08:29.820 --> 02:08:32.978
Agora, na verdade, parece que temos um tempo constante

02:08:32.978 --> 02:08:36.020
se você assumir que haverá um limite no comprimento do nome.

02:08:36.020 --> 02:08:38.960
Por que não usamos tentativas para tudo então?

02:08:38.960 --> 02:08:41.660
Qual é o preço que estamos pagando por essa estrutura de dados

02:08:41.660 --> 02:08:44.630
mesmo que tenhamos representado apenas três personagens aqui?

02:08:44.630 --> 02:08:45.200
Sim.

02:08:45.200 --> 02:08:46.860
AUDIÊNCIA: [INAUDÍVEL]

02:08:46.860 --> 02:08:48.580
DAVID J. MALAN: É muita memória.

02:08:48.580 --> 02:08:49.080
Sim.

02:08:49.080 --> 02:08:51.330
E você pode ver até mesmo com esses três nomes, a maioria

02:08:51.330 --> 02:08:55.500
dos quadrados na tela estão vazios, bytes e bits que estão lá

02:08:55.500 --> 02:08:56.460
e são alocados.

02:08:56.460 --> 02:08:58.210
E eles precisam estar lá porque você precisa

02:08:58.210 --> 02:09:01.297
poder fazer aquela coisa aritmética disso ser zero, isso ser 25.

02:09:01.297 --> 02:09:04.380
Então você pode pular de bum, bum, bum, bum, com base em cada uma das letras.

02:09:04.380 --> 02:09:07.770
Mas é uma estrutura de dados extremamente esparsa, o que significa

02:09:07.770 --> 02:09:10.060
ocupa uma quantidade absurda de memória.

02:09:10.060 --> 02:09:12.865
Agora, talvez isso seja tolerável, especialmente para nomes curtos.

02:09:12.865 --> 02:09:14.740
Mas isso vai ser o trade-off também.

02:09:14.740 --> 02:09:16.470
E isso é uma grande tensão na computação.

02:09:16.470 --> 02:09:19.410
Quase sempre que você quiser melhorar o tempo,

02:09:19.410 --> 02:09:22.560
você quer acelerar a eficiência, a velocidade do seu algoritmo,

02:09:22.560 --> 02:09:23.880
você vai gastar espaço.

02:09:23.880 --> 02:09:27.270
Se, por outro lado, você quiser diminuir a quantidade de espaço,

02:09:27.270 --> 02:09:30.150
você pode muito bem ter que aumentar o tempo de execução.

02:09:30.150 --> 02:09:32.470
E é de fato, essa gangorra para frente e para trás.

02:09:32.470 --> 02:09:34.500
E você, seus colegas, sua empresa precisam

02:09:34.500 --> 02:09:36.990
para decidir qual recurso é o mais precioso.

02:09:36.990 --> 02:09:40.590
Caramba, pode ser muito mais difícil codificar uma dessas estruturas de dados

02:09:40.590 --> 02:09:41.190
do que outro.

02:09:41.190 --> 02:09:41.880
Você é um humano.

02:09:41.880 --> 02:09:42.990
Seu tempo é valioso.

02:09:42.990 --> 02:09:46.170
Você realmente quer passar horas implementando um tri quando,

02:09:46.170 --> 02:09:49.680
ei, em 30 minutos eu posso criar um array hoje em dia ou até mesmo uma lista encadeada.

02:09:49.680 --> 02:09:52.800
Lá também, o tempo de desenvolvimento será mais um recurso e por que

02:09:52.800 --> 02:09:57.000
às vezes há código bom ou código ruim, depende do que você está priorizando.

02:09:57.000 --> 02:09:59.880
Então, como cada um desses nós se parece em um tri?

02:09:59.880 --> 02:10:01.380
Bem, podemos continuar chamando de nó.

02:10:01.380 --> 02:10:04.710
Este é um termo muito genérico para apenas um contêiner nessas estruturas de dados.

02:10:04.710 --> 02:10:10.080
Nesta história, porém, deixe-me afirmar que todo mundo tem um número, como um telefone

02:10:10.080 --> 02:10:12.840
número, uma string, também conhecido como char star.

02:10:12.840 --> 02:10:18.330
Cada nó tem 26 filhos, ou tecnicamente uma matriz de tamanho 26

02:10:18.330 --> 02:10:20.520
que podem apontar para mais desses nós.

02:10:20.520 --> 02:10:25.020
Observe que não preciso armazenar o nome de alguém em um try

02:10:25.020 --> 02:10:28.330
porque está implícito no caminho que você percorre para encontrá-los.

02:10:28.330 --> 02:10:29.670
Portanto, essa é uma otimização menor.

02:10:29.670 --> 02:10:31.330
Mas isso nos poupa algum espaço.

02:10:31.330 --> 02:10:33.750
Mas isso seria apenas uma estrutura de dados diferente

02:10:33.750 --> 02:10:37.740
poderíamos usar para resolver esse problema também,

02:10:37.740 --> 02:10:39.570
embora a um custo muito caro.

02:10:39.570 --> 02:10:42.480
E o que precisamos que nossa variável seja para armazenar o try?

02:10:42.480 --> 02:10:44.880
Assim como antes, só precisamos de um único ponteiro

02:10:44.880 --> 02:10:48.000
que se agarra à raiz desta estrutura que é

02:10:48.000 --> 02:10:52.790
null se estiver vazio ou não nulo se estiver realmente apontando para algo.

02:10:52.790 --> 02:10:56.210
Alguma dúvida sobre as tentativas?

02:10:56.210 --> 02:10:59.420
E se está parecendo muito, o hidrante, é.

02:10:59.420 --> 02:11:03.350
Começamos com arrays, depois listas encadeadas e tentativas.

02:11:03.350 --> 02:11:06.230
Mas perguntas sobre como acabamos de montar a partir dessas construções básicas

02:11:06.230 --> 02:11:06.730
blocos?

02:11:06.730 --> 02:11:07.326
Sim.

02:11:07.326 --> 02:11:10.122
AUDIÊNCIA: Por que a tônica de tri não é [INAUDÍVEL]??

02:11:10.122 --> 02:11:11.520
Por que isso importa?

02:11:11.520 --> 02:11:12.853
DAVID J. MALAN: Uma boa pergunta.

02:11:12.853 --> 02:11:14.820
Por que não é tamanho 26?

02:11:14.820 --> 02:11:19.380
É como na lista encadeada antes, apenas

02:11:19.380 --> 02:11:23.550
tende a estar no código conveniente para ter um ponteiro adicional separado que é

02:11:23.550 --> 02:11:26.220
small que apenas aponta para o início da estrutura de dados.

02:11:26.220 --> 02:11:29.010
Porque dessa forma, pode ser nulo, indicando claramente

02:11:29.010 --> 02:11:30.030
não há nós.

02:11:30.030 --> 02:11:31.380
Toda a estrutura está vazia.

02:11:31.380 --> 02:11:35.095
Se você alocasse um desses nós, com certeza poderia.

02:11:35.095 --> 02:11:37.470
Mas então você estaria apenas desperdiçando espaço, mesmo que estivesse vazio.

02:11:37.470 --> 02:11:38.980
E isso cria uma ambiguidade.

02:11:38.980 --> 02:11:41.370
Então, basta ter um único ponteiro vinculado ao início

02:11:41.370 --> 02:11:44.320
de todas essas coisas é uma coisa boa.

02:11:44.320 --> 02:11:52.750
Outras perguntas agora sobre tentativas, árvores, tabelas de hash ou matrizes?

02:11:52.750 --> 02:11:55.450
Então, quais problemas podem surgir?

02:11:55.450 --> 02:11:57.520
Bem, aqui está um contra-exemplo.

02:11:57.520 --> 02:12:00.385
Que nomes se manifestam neste tri aqui?

02:12:03.330 --> 02:12:04.580
Sinta-se à vontade para apenas chamá-lo.

02:12:08.333 --> 02:12:09.000
O que você vê?

02:12:09.000 --> 02:12:10.320
AUDIÊNCIA: Danielle.

02:12:10.320 --> 02:12:13.360
DAVID J. MALAN: Danielle e Daniel.

02:12:13.360 --> 02:12:16.530
Então presumivelmente, se estes são dois nomes aqui, um dos quais

02:12:16.530 --> 02:12:19.680
é um prefixo de outro, observe que a estrutura de dados ainda funciona.

02:12:19.680 --> 02:12:22.830
E eu escolhi o nome de um amigo e acrescentei mais alguns caracteres

02:12:22.830 --> 02:12:26.790
para isso também é um nome porque temos aqui DANIEL.

02:12:26.790 --> 02:12:30.255
E o verde é tecnicamente implementado como um bool ou algo assim

02:12:30.255 --> 02:12:31.950
que indica que uma palavra pára aqui.

02:12:31.950 --> 02:12:35.130
Mas não queremos impedir o armazenamento de Danielle também, que está

02:12:35.130 --> 02:12:37.440
uma supercorda, se preferir, de Daniel.

02:12:37.440 --> 02:12:41.250
E então, tudo bem também, contanto que a estrutura permita que os ponteiros

02:12:41.250 --> 02:12:41.860
para continuar.

02:12:41.860 --> 02:12:46.000
Portanto, até isso funciona bem, embora de outra forma não funcionasse.

02:12:46.000 --> 02:12:49.170
E em termos de tempo de execução, só para ficar claro, no final do dia,

02:12:49.170 --> 02:12:55.890
tentativas fornecem tempo real constante para inserções, pesquisas, exclusões,

02:12:55.890 --> 02:13:00.210
e similares porque depende apenas do comprimento da entrada, a chave,

02:13:00.210 --> 02:13:05.100
se você quiser, e não quantas outras pessoas estão em seu telefone ou endereço

02:13:05.100 --> 02:13:06.060
livro.

02:13:06.060 --> 02:13:08.760
E pensei em concluir com um visual.

02:13:08.760 --> 02:13:13.140
Se você saiu na praça, alguém reconhece isso?

02:13:13.140 --> 02:13:15.120
Sweet Green, um local de saladas.

02:13:15.120 --> 02:13:18.427
O que estamos vendo aqui e qual é a sua conexão hoje?

02:13:18.427 --> 02:13:20.760
Você está prestes a se tornar o mais geek do mundo real

02:13:20.760 --> 02:13:24.300
porque você começará a ver estruturas de dados em todos os lugares.

02:13:24.300 --> 02:13:25.680
O que é isso?

02:13:25.680 --> 02:13:29.460
Ou como isso funciona, talvez na forma de salada?

02:13:29.460 --> 02:13:32.287
Quem já esteve em Sweet Green.

02:13:32.287 --> 02:13:32.870
Qualquer um de vocês.

02:13:32.870 --> 02:13:34.145
Então, como isso funciona?

02:13:34.145 --> 02:13:35.422
[RISADA]

02:13:35.422 --> 02:13:40.713
AUDIÊNCIA: [INAUDÍVEL] Eles farão seu pedido [INAUDÍVEL]

02:13:40.713 --> 02:13:42.568
seu nome [INAUDÍVEL] L.

02:13:42.568 --> 02:13:43.610
DAVID J. MALAN: OK, bom.

02:13:43.610 --> 02:13:46.400
Então, se você pedir uma salada para alguém chamado L, quando estiver pronto,

02:13:46.400 --> 02:13:48.810
eles colocam na seção L aqui.

02:13:48.810 --> 02:13:51.680
E assim, este é um conjunto de pares chave-valor, certo?

02:13:51.680 --> 02:13:55.710
Se L for a primeira letra do nome de alguém, espera-se que o valor seja a salada.

02:13:55.710 --> 02:13:58.880
E então, o que você tem aqui é um dicionário, pares de valores-chave,

02:13:58.880 --> 02:14:00.500
onde não são palavras e definições.

02:14:00.500 --> 02:14:02.300
São nomes e saladas.

02:14:02.300 --> 02:14:04.550
E você pode pensar nisso também como uma espécie de tabela de hash.

02:14:04.550 --> 02:14:05.050
Por que?

02:14:05.050 --> 02:14:07.940
Mesmo que na verdade não caiba em uma longa prateleira

02:14:07.940 --> 02:14:10.520
porque a loja é tão grande, isso é realmente uma matriz.

02:14:10.520 --> 02:14:13.580
E, aparentemente, A está faltando ou talvez esteja ao virar da esquina.

02:14:13.580 --> 02:14:16.440
Mas essa matriz simplesmente envolve várias linhas.

02:14:16.440 --> 02:14:18.680
Mas ainda é conceitualmente uma única dimensão.

02:14:18.680 --> 02:14:20.960
Mas suponha que duas pessoas tenham o nome L?

02:14:20.960 --> 02:14:23.102
O que eles fazem normalmente?

02:14:23.102 --> 02:14:26.300
AUDIÊNCIA: Eles apenas colocaram uma segunda letra [INAUDÍVEL] [INAUDÍVEL]..

02:14:26.300 --> 02:14:27.175
DAVID J. MALAN: Sim.

02:14:27.175 --> 02:14:29.870
Então talvez eles-- se eles quiserem colocar tanto esforço nisso.

02:14:29.870 --> 02:14:31.850
Eles podem olhar para a segunda letra e depois para a terceira.

02:14:31.850 --> 02:14:35.270
As probabilidades são de que este não seja um problema tão interessante para resolver de maneira otimizada dessa maneira.

02:14:35.270 --> 02:14:39.000
Mas eles provavelmente começam a empilhar as saladas umas sobre as outras

02:14:39.000 --> 02:14:41.040
ou talvez escová-lo um pouco.

02:14:41.040 --> 02:14:42.390
E então, o que você tem aí?

02:14:42.390 --> 02:14:45.770
Bem, agora, se você começar a ver a lente através dos óculos CS50,

02:14:45.770 --> 02:14:46.820
OK, você tem uma matriz.

02:14:46.820 --> 02:14:49.140
E então você tem essas listas vinculadas que estão crescendo aqui.

02:14:49.140 --> 02:14:50.490
Mas mesmo assim você se depara com um problema.

02:14:50.490 --> 02:14:50.780
Por que?

02:14:50.780 --> 02:14:52.070
Porque não é realmente uma lista encadeada.

02:14:52.070 --> 02:14:54.612
Porque em algum momento você vai atingir o limite aqui.

02:14:54.612 --> 02:14:57.320
Então é como um array de arrays porque você só pode encaixar,

02:14:57.320 --> 02:14:59.400
o que, três ou quatro saladas aqui.

02:14:59.400 --> 02:15:01.370
E assim, resumindo, começamos hoje

02:15:01.370 --> 02:15:04.610
falando deliberadamente sobre coisas do mundo real, como pilhas e filas.

02:15:04.610 --> 02:15:07.910
E mesmo que tenha escalado rapidamente para árvores de busca binárias,

02:15:07.910 --> 02:15:11.362
e tabelas de hash e tentativas, mesmo essas coisas estão por toda parte.

02:15:11.362 --> 02:15:13.070
Mesmo que eles não os chamem como tal,

02:15:13.070 --> 02:15:14.612
estas são apenas soluções para problemas.

02:15:14.612 --> 02:15:16.910
E agora, com esta última semana de C em seu currículo,

02:15:16.910 --> 02:15:19.310
você tem ainda mais um kit de ferramentas técnicas

02:15:19.310 --> 02:15:21.500
para implementar essas coisas no código.

02:15:21.500 --> 02:15:25.310
Na próxima semana, poderemos confiar que outra pessoa resolveu todos esses problemas.

02:15:25.310 --> 02:15:26.450
Apresentaremos o Python.

02:15:26.450 --> 02:15:30.083
E linhas de código como essa finalmente se tornarão linhas de código como essa.

02:15:30.083 --> 02:15:31.250
Então essa é a promessa adiante.

02:15:31.250 --> 02:15:32.510
E nos vemos na próxima.

02:15:32.510 --> 02:15:33.710
[APLAUSOS]

02:15:33.710 --> 02:15:36.460
[MÚSICA, TOCANDO]