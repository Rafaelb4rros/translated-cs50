WEBVTT

00:00:01.996 --> 00:00:07.485
[MÚSICA, TOCANDO]

00:01:13.297 --> 00:01:14.380
DAVID J. MALAN: Tudo bem.

00:01:14.380 --> 00:01:15.940
Este é CS50.

00:01:15.940 --> 00:01:17.260
E esta é a quarta semana.

00:01:17.260 --> 00:01:19.872
E se você pensar em algumas semanas atrás, na semana zero,

00:01:19.872 --> 00:01:21.580
começamos a falar sobre o que são imagens,

00:01:21.580 --> 00:01:25.690
e falamos sobre representação de imagens como essa grade de pixels.

00:01:25.690 --> 00:01:28.923
E cada pixel tem algum padrão de bits que define sua cor.

00:01:28.923 --> 00:01:31.840
Bem, acontece que hoje, vamos dar uma olhada mais profunda sob o capô

00:01:31.840 --> 00:01:34.360
em como coisas como imagens e muito mais,

00:01:34.360 --> 00:01:37.240
é realmente implementado usando apenas esses zeros e uns,

00:01:37.240 --> 00:01:40.300
e como agora, como programador, você pode realmente

00:01:40.300 --> 00:01:43.750
aproveitar isso, para o bem ou para o mal, para melhor compreender e

00:01:43.750 --> 00:01:46.090
manipular o que está acontecendo dentro da memória de um computador

00:01:46.090 --> 00:01:47.590
usando uma linguagem como C.

00:01:47.590 --> 00:01:50.200
Na verdade, mesmo essa tigela de bolas de estresse que continuamos acontecendo

00:01:50.200 --> 00:01:51.567
é apenas uma fotografia, claro.

00:01:51.567 --> 00:01:54.400
Mas se você pensar na semana zero, se você meio que melhorar, melhorar,

00:01:54.400 --> 00:01:56.860
realçam esta imagem, como fazem nos filmes,

00:01:56.860 --> 00:02:00.310
na verdade, não funciona da maneira que você pensaria em Hollywood.

00:02:00.310 --> 00:02:04.900
Enquanto continuo a aumentar o zoom, aumentar o zoom e aumentar o zoom em uma tela como esta,

00:02:04.900 --> 00:02:06.470
você vai ver que sim, fica maior.

00:02:06.470 --> 00:02:09.190
Mas se ficar muito grande, o que você começa a notar?

00:02:09.190 --> 00:02:10.539
A chamada pixelização.

00:02:10.539 --> 00:02:12.550
E, de fato, você pode ver os pontos individuais.

00:02:12.550 --> 00:02:16.810
Então, da próxima vez que você assistir a algum programa ou filme na TV

00:02:16.810 --> 00:02:19.030
que tem esse tipo de noção de aprimoramento,

00:02:19.030 --> 00:02:20.680
há realmente um limite finito lá.

00:02:20.680 --> 00:02:23.680
Você só pode melhorar na medida em que realmente há informações lá.

00:02:23.680 --> 00:02:27.487
Mas uma vez que você aumenta o zoom para um certo nível como este, é tudo o que está lá.

00:02:27.487 --> 00:02:30.070
Você não vai ver o brilho do suspeito em algum crime

00:02:30.070 --> 00:02:33.260
drama em seus olhos só porque você aprimorou a imagem.

00:02:33.260 --> 00:02:36.130
Há apenas uma quantidade finita de informações realmente lá.

00:02:36.130 --> 00:02:39.085
Mas veremos hoje também que ao entender

00:02:39.085 --> 00:02:40.960
o que está acontecendo dentro da memória de um computador

00:02:40.960 --> 00:02:43.150
podemos começar a representar e até criar e codificar

00:02:43.150 --> 00:02:44.180
coisas mais interessantes.

00:02:44.180 --> 00:02:49.060
Então, por exemplo, aqui está um bitmap, se você quiser, que é um termo de arte.

00:02:49.060 --> 00:02:51.037
Um bitmap é um tipo de imagem.

00:02:51.037 --> 00:02:52.870
E é um mapa de bits no sentido de que você

00:02:52.870 --> 00:02:54.912
tem este sistema de coordenadas de cima, baixo, esquerda,

00:02:54.912 --> 00:02:57.530
certo pelo menos na representação desse artista aqui.

00:02:57.530 --> 00:03:02.050
E suponha que talvez todos nós decidamos como o mundo

00:03:02.050 --> 00:03:05.080
que um representará a cor branca e zero

00:03:05.080 --> 00:03:06.850
deve representar a cor preta.

00:03:06.850 --> 00:03:12.160
O que esse mapa de bits, esse bitmap, pode realmente ser?

00:03:12.160 --> 00:03:13.330
Você pode ver através dele?

00:03:13.330 --> 00:03:13.830
Sim.

00:03:13.830 --> 00:03:14.740
AUDIÊNCIA: [INAUDÍVEL]

00:03:14.740 --> 00:03:16.900
DAVID J. MALAN: É realmente um rosto sorridente.

00:03:16.900 --> 00:03:18.070
Então, um olho incrível.

00:03:18.070 --> 00:03:21.430
Se eu realmente transformar todos em branco apenas para visualizar isso,

00:03:21.430 --> 00:03:23.595
você verá de fato, isso é o que estava embutido lá.

00:03:23.595 --> 00:03:25.720
Mas é claro, em nossos monitores de computador e telefones,

00:03:25.720 --> 00:03:28.390
nós temos essa grade de quadrados, essa grade de pixels.

00:03:28.390 --> 00:03:30.970
Então, de fato, se você realmente visse na sua tela

00:03:30.970 --> 00:03:34.152
um rosto sorridente, como um preto e branco nisso, o que provavelmente está acontecendo

00:03:34.152 --> 00:03:36.610
sob o capô é apenas um padrão de zeros e uns,

00:03:36.610 --> 00:03:39.520
e talvez bits únicos, um bit de cor, se preferir,

00:03:39.520 --> 00:03:43.210
onde um aqui representa branco e zero representa preto.

00:03:43.210 --> 00:03:45.370
Então, se você gosta dessa coisa, acontece

00:03:45.370 --> 00:03:49.150
você pode fazer muito bonito, muito interessante, muito artisticamente

00:03:49.150 --> 00:03:50.150
coisas inclinadas.

00:03:50.150 --> 00:03:53.568
Se você acessar esta URL quando quiser, cs50.ly.art,

00:03:53.568 --> 00:03:56.860
na verdade, ele o redirecionará para uma planilha do Google que criamos com antecedência.

00:03:56.860 --> 00:03:58.870
E meio que reduzimos as linhas e colunas

00:03:58.870 --> 00:04:02.470
para se assemelhar a uma grade de pixels, minúsculos quadrados, todos os quais

00:04:02.470 --> 00:04:06.010
são brancos por padrão, não muito diferente deste cavalete aqui

00:04:06.010 --> 00:04:08.500
que temos alguns voluntários trabalhando.

00:04:08.500 --> 00:04:10.875
Na verdade, vocês gostariam de se apresentar por um momento

00:04:10.875 --> 00:04:13.040
e dizer um alô rápido antes de voltarmos para você?

00:04:13.040 --> 00:04:13.630
DANIELE: Olá.

00:04:13.630 --> 00:04:14.530
Meu nome é Daniel.

00:04:14.530 --> 00:04:15.542
Eu sou de Chicago.

00:04:15.542 --> 00:04:16.959
DAVID J. MALAN: Bem-vindo a Daniel.

00:04:16.959 --> 00:04:17.320
E--

00:04:17.320 --> 00:04:18.112
ADAM: Olá a todos.

00:04:18.112 --> 00:04:19.000
Eu sou Adão.

00:04:19.000 --> 00:04:20.950
E eu sou de Trinidad e Tobago.

00:04:20.950 --> 00:04:21.250
DAVID J. MALAN: Legal.

00:04:21.250 --> 00:04:22.333
Bem, bem-vindos a vocês dois.

00:04:22.333 --> 00:04:23.020
Obrigado.

00:04:23.020 --> 00:04:24.880
Você verá que em suas mãos estão realmente

00:04:24.880 --> 00:04:27.922
um monte de pixels, post-its que entregamos com antecedência.

00:04:27.922 --> 00:04:30.713
Então, se você não se importa, retornaremos em alguns minutos

00:04:30.713 --> 00:04:33.640
e veja o que eles criaram, por favor, nesta grade de papel branco

00:04:33.640 --> 00:04:35.890
muito parecido com o que você pode criar nesta planilha do Google.

00:04:35.890 --> 00:04:39.790
Na verdade, sinta-se à vontade para nos enviar suas criações, se desejar, por meio do URL

00:04:39.790 --> 00:04:42.400
você obterá em cs50.ly/art.

00:04:42.400 --> 00:04:45.700
Agora vamos voltar à semana zero, onde definimos alguns dos edifícios

00:04:45.700 --> 00:04:46.480
blocos para imagens.

00:04:46.480 --> 00:04:49.240
Falamos sobre RGB, que é apenas vermelho, verde, azul.

00:04:49.240 --> 00:04:51.550
E é apenas um dos sistemas, um sistema popular,

00:04:51.550 --> 00:04:53.890
através do qual você pode representar qualquer cor do arco-íris

00:04:53.890 --> 00:04:57.950
usando alguma combinação de vermelho, verde e azul.

00:04:57.950 --> 00:05:00.190
E se algum de vocês tem inclinação artística

00:05:00.190 --> 00:05:02.920
ou já usou o Photoshop ou programas similares,

00:05:02.920 --> 00:05:05.560
você pode normalmente ter alguns meios de selecionar

00:05:05.560 --> 00:05:07.460
uma cor através de alguma grade como esta.

00:05:07.460 --> 00:05:09.910
Mas aqui embaixo, observe que há menções explícitas

00:05:09.910 --> 00:05:11.800
dos tipos de sistemas de cores em uso.

00:05:11.800 --> 00:05:13.150
RGB.

00:05:13.150 --> 00:05:15.820
E de fato, aqui, você vê zero, zero, zero.

00:05:15.820 --> 00:05:18.460
E aqui em Novo, você vê a cor preta.

00:05:18.460 --> 00:05:21.340
E isso implica que se você não tem vermelho, nem verde, nem azul, bem,

00:05:21.340 --> 00:05:24.340
que de fato representaria por convenção a cor preta.

00:05:24.340 --> 00:05:27.910
Por outro lado, se brincarmos com o Photoshop ou qualquer programa semelhante,

00:05:27.910 --> 00:05:31.360
se você tem muito vermelho, muito verde e muito azul,

00:05:31.360 --> 00:05:36.880
por exemplo, 255, 255, 255, aumente até o valor máximo,

00:05:36.880 --> 00:05:40.720
você pode representar com 8 bits por semana zero, bem, então acontece

00:05:40.720 --> 00:05:42.490
você tem a cor branca aqui.

00:05:42.490 --> 00:05:44.650
E podemos brincar com esses números infinitamente.

00:05:44.650 --> 00:05:50.290
Por exemplo, se usarmos 255 de vermelho, mas zero verde e zero azul,

00:05:50.290 --> 00:05:54.100
não é de surpreender que o quadrado na parte superior da tela fique vermelho

00:05:54.100 --> 00:05:57.020
inteiramente porque é tudo vermelho e nada de verde, nada de azul.

00:05:57.020 --> 00:06:01.790
Se mudarmos para 255 para verde, mas zero para vermelho e azul, é claro,

00:06:01.790 --> 00:06:02.500
ficamos verdes.

00:06:02.500 --> 00:06:06.130
E, finalmente, se aumentarmos o azul, mas deixarmos vermelho e verde como zero,

00:06:06.130 --> 00:06:07.360
é claro que ficamos azuis.

00:06:07.360 --> 00:06:09.730
Mas todo esse tempo, aqui em destaque

00:06:09.730 --> 00:06:12.210
é algo que talvez alguns de vocês já tenham visto antes,

00:06:12.210 --> 00:06:14.250
como uma combinação de números e letras.

00:06:14.250 --> 00:06:18.130
Se algum de vocês criou páginas da Web pessoais ou usou programas como o Photoshop,

00:06:18.130 --> 00:06:20.130
você pode ter usado esses chamados códigos de cores.

00:06:20.130 --> 00:06:25.290
Então, de fato, o mundo tem essa convenção segundo a qual usar seis dígitos, ou às vezes

00:06:25.290 --> 00:06:29.170
três, você pode representar um pouco mais sucintamente alguma quantidade de vermelho,

00:06:29.170 --> 00:06:30.330
azul esverdeado.

00:06:30.330 --> 00:06:34.840
E você verá aqui, talvez por inferência, que se RGB for zero,

00:06:34.840 --> 00:06:38.430
zero, 255 respectivamente, talvez para onde estamos indo com isso

00:06:38.430 --> 00:06:43.200
é que zero, zero, zero, zero, FF é apenas uma forma alternativa de expressar

00:06:43.200 --> 00:06:44.250
exatamente a mesma ideia.

00:06:44.250 --> 00:06:46.710
Sem vermelho, sem verde e muito azul.

00:06:46.710 --> 00:06:48.210
Mas por que isso?

00:06:48.210 --> 00:06:51.390
E, de fato, faremos um círculo completo aqui para apresentar algo

00:06:51.390 --> 00:06:53.220
que poderíamos ter feito na semana zero, mas realmente não

00:06:53.220 --> 00:06:54.240
resolver um problema então.

00:06:54.240 --> 00:06:57.900
Mas hoje, ao nos concentrarmos mais nas imagens e na própria memória,

00:06:57.900 --> 00:07:00.520
Acontece que entender esses padrões é bastante útil.

00:07:00.520 --> 00:07:03.390
Então, na semana zero, conversamos, é claro, sobre binário.

00:07:03.390 --> 00:07:07.560
E binário, implicando dois, fornece apenas dois dígitos, zero e um.

00:07:07.560 --> 00:07:10.530
Você e eu, como humanos, quase sempre usamos o sistema decimal

00:07:10.530 --> 00:07:12.810
em uma conversa normal, dec significa 10.

00:07:12.810 --> 00:07:15.270
Portanto, temos de zero a nove.

00:07:15.270 --> 00:07:20.340
Se um humano como nós quer contar até 10, ou 11, ou 12,

00:07:20.340 --> 00:07:23.220
não temos um dígito per se para 10, 11 e 12.

00:07:23.220 --> 00:07:24.850
Começamos a reutilizar dígitos.

00:07:24.850 --> 00:07:27.580
Então é um zero, um um, um dois e assim por diante.

00:07:27.580 --> 00:07:30.960
Mas em outros sistemas, não binários, não decimais,

00:07:30.960 --> 00:07:34.950
mas sistemas chamados hexadecimais, hex implicando 16,

00:07:34.950 --> 00:07:39.240
na verdade, existem mais dígitos do que esses, o que pode ser uma surpresa.

00:07:39.240 --> 00:07:42.403
Não são pares de dígitos, como em decimais, dígitos únicos.

00:07:42.403 --> 00:07:44.820
E, francamente, realmente não importa quais são os dígitos.

00:07:44.820 --> 00:07:46.020
Porque no final do dia, estes são apenas

00:07:46.020 --> 00:07:49.080
símbolos que você e eu associamos imediatamente a alguma noção de matemática,

00:07:49.080 --> 00:07:52.980
mas apenas traços na tela que representam alguns--

00:07:52.980 --> 00:07:54.670
representam algum valor real.

00:07:54.670 --> 00:07:58.680
Acontece que, por convenção, quando você quer mais de nove...

00:07:58.680 --> 00:08:01.380
10 dígitos, de zero a nove, você começa a usar

00:08:01.380 --> 00:08:06.090
letras do alfabeto inglês, A, B, C, D, E e F.

00:08:06.090 --> 00:08:07.770
E você pode representá-los em letras minúsculas.

00:08:07.770 --> 00:08:08.820
Não diferencia maiúsculas de minúsculas.

00:08:08.820 --> 00:08:09.690
Então isso realmente não importa.

00:08:09.690 --> 00:08:11.482
Você pode vê-lo em letras maiúsculas ou minúsculas.

00:08:11.482 --> 00:08:14.190
Mas é assim que você pode contar além de nove não

00:08:14.190 --> 00:08:17.490
usando decimal, mas usando de fato algo chamado hexadecimal.

00:08:17.490 --> 00:08:20.700
Se formos realmente técnicos, isso também é conhecido como base-16.

00:08:20.700 --> 00:08:22.410
E é a mesma ideia da semana zero onde

00:08:22.410 --> 00:08:25.770
em vez de usar base dois para binário, base 10 para decimal,

00:08:25.770 --> 00:08:28.500
você usa 16 como base para hexadecimal.

00:08:28.500 --> 00:08:31.740
E então, se analisarmos apenas alguns exemplos simples aqui

00:08:31.740 --> 00:08:35.789
no mundo do hexadecimal, suas colunas são apenas potências de 16.

00:08:35.789 --> 00:08:40.419
16 elevado a 0, 16 elevado a 1, 16 elevado a 2 e assim por diante.

00:08:40.419 --> 00:08:43.919
Mas no mundo do hex, geralmente, pelo menos até agora, e hoje, vamos

00:08:43.919 --> 00:08:45.760
veja apenas pares de dígitos como este.

00:08:45.760 --> 00:08:49.260
Aqui, por exemplo, está a coluna das unidades e a coluna dos 16

00:08:49.260 --> 00:08:50.500
se multiplicarmos isso.

00:08:50.500 --> 00:08:52.560
Então, se você quiser representar o número que você

00:08:52.560 --> 00:08:56.820
e eu sei no mundo real como zero em hexadecimal,

00:08:56.820 --> 00:08:58.530
seria apenas zero, zero.

00:08:58.530 --> 00:09:01.500
Se você quiser representar o número um, seria zero um.

00:09:01.500 --> 00:09:05.466
E a partir daí, obtemos zero dois, zero três, zero quatro, zero cinco, zero seis,

00:09:05.466 --> 00:09:10.230
zero sete, zero oito, zero nove, agora as coisas ficam potencialmente interessantes.

00:09:10.230 --> 00:09:12.330
Em decimal, obviamente se tornaria 10.

00:09:12.330 --> 00:09:17.010
Mas em hexadecimal, torna-se apenas zero a, em seguida, zero

00:09:17.010 --> 00:09:19.980
b, ou seja, se eu retroceder, depois das nove

00:09:19.980 --> 00:09:23.160
vem em hexadecimal, se eu pronunciar em decimal,

00:09:23.160 --> 00:09:24.930
é assim que você representaria 10.

00:09:24.930 --> 00:09:30.450
É assim que você representaria 11, 12, 13, 14 e, por último, em hexadecimal,

00:09:30.450 --> 00:09:35.950
o 16º valor é F, que sempre representará 15.

00:09:35.950 --> 00:09:39.210
Então, onde-- como conectamos isso a algumas das matemáticas anteriores?

00:09:39.210 --> 00:09:42.150
Bem, quando chegar a zero F, em hexadecimal,

00:09:42.150 --> 00:09:45.060
se F é o mais alto que você pode contar, assim como em decimal,

00:09:45.060 --> 00:09:48.780
nove é o máximo que você pode contar, o que vem a seguir?

00:09:48.780 --> 00:09:53.250
Se isso é 15 eu reivindico, como represento 16 em hexadecimal,

00:09:53.250 --> 00:09:56.520
com que padrão de símbolos?

00:09:56.520 --> 00:09:58.600
Qual padrão de símbolos para hexadecimal?

00:09:58.600 --> 00:09:59.100
Sim.

00:09:59.100 --> 00:09:59.892
AUDIÊNCIA: Um zero.

00:09:59.892 --> 00:10:02.760
DAVID J. MALAN: Então, um zero, não 10, mesmo que você possa ler

00:10:02.760 --> 00:10:04.080
assim como um ser humano típico.

00:10:04.080 --> 00:10:05.400
Mas um zero.

00:10:05.400 --> 00:10:06.207
Por que porque?

00:10:06.207 --> 00:10:08.040
Bem, mesmo que isso seja completamente novo para você,

00:10:08.040 --> 00:10:11.340
todo o sistema de colunas, os lugares, são exatamente os mesmos intuitivamente.

00:10:11.340 --> 00:10:15.360
Então você precisa de um na casa dos 16 e um zero na casa das unidades.

00:10:15.360 --> 00:10:17.612
E não vamos contar até 255,

00:10:17.612 --> 00:10:19.320
mas contamos se contarmos um pouco mais alto,

00:10:19.320 --> 00:10:24.180
isso seria um zero, também conhecido como 16 em decimal, isso seria um um,

00:10:24.180 --> 00:10:30.510
AKA 17 em decimal e depois 18, 19, 20 e assim por diante, ponto, ponto, ponto.

00:10:30.510 --> 00:10:33.300
E podemos contar até FF.

00:10:33.300 --> 00:10:36.180
Porque se F é o maior dígito em hexadecimal,

00:10:36.180 --> 00:10:38.610
FF é de fato o mais alto que podemos contar.

00:10:38.610 --> 00:10:42.570
E se cada F representa 15, bem, vamos fazer as contas como na semana zero.

00:10:42.570 --> 00:10:48.510
Então 16 vezes f mais 1 vezes f é como todos nós aprendemos a fazer matemática na escola primária,

00:10:48.510 --> 00:10:50.250
mesmo que não seja em hexadecimal.

00:10:50.250 --> 00:10:54.480
Isso é claro, 16 vezes 15 mais 1 vezes 15.

00:10:54.480 --> 00:10:57.810
Multiplique isso, você obtém 240, mais 15.

00:10:57.810 --> 00:11:04.887
E, portanto, você pode contar até 255 usando dois dígitos hexadecimais.

00:11:04.887 --> 00:11:06.720
Agora, este não é o tipo de coisa em que este

00:11:06.720 --> 00:11:09.930
vai ser um exercício interessante mentalmente para converter em sua cabeça.

00:11:09.930 --> 00:11:12.740
Geralmente, você se acostumará com o fato de que depois das nove vem

00:11:12.740 --> 00:11:15.063
A e o maior dígito é F. E você apenas

00:11:15.063 --> 00:11:17.480
começar a ver padrões como este no mundo do Photoshop,

00:11:17.480 --> 00:11:19.520
páginas da web em algumas semanas e além.

00:11:19.520 --> 00:11:22.760
Mas por que o hexadecimal é útil?

00:11:22.760 --> 00:11:25.670
Por que estamos complicando o mundo e adicionando

00:11:25.670 --> 00:11:27.690
em cima de decimais algo mais?

00:11:27.690 --> 00:11:30.260
Bem, acontece que um único dígito decimal, como F,

00:11:30.260 --> 00:11:32.960
o maior por exemplo, é 15.

00:11:32.960 --> 00:11:35.360
E aqui, deixe-me propor um pouco de matemática mental.

00:11:35.360 --> 00:11:41.270
Quantos bits você precisa para representar o número 15 em binário?

00:11:41.270 --> 00:11:45.630
Se você tiver as unidades, as duas, as 4 e assim por diante,

00:11:45.630 --> 00:11:47.166
quantos bits no total?

00:11:47.166 --> 00:11:47.980
AUDIÊNCIA: Cinco.

00:11:47.980 --> 00:11:51.610
DAVID J. MALAN: Portanto, menos de cinco para contar até 15, eu acho.

00:11:51.610 --> 00:11:53.350
Mas perto.

00:11:53.350 --> 00:11:55.960
Alguém?

00:11:55.960 --> 00:11:56.720
Estou vendo uma mão.

00:11:56.720 --> 00:11:57.220
Sim.

00:11:57.220 --> 00:11:57.845
AUDIÊNCIA: Quatro.

00:11:57.845 --> 00:12:00.340
DAVID J. MALAN: Acho que quatro bits são suficientes.

00:12:00.340 --> 00:12:04.000
Porque se você quiser contar até F, ou seja, 15,

00:12:04.000 --> 00:12:06.910
Eu acho que se você tiver quatro bits, você pode fazer isso.

00:12:06.910 --> 00:12:10.280
Porque se aqui é o lugar da semana zero para binário,

00:12:10.280 --> 00:12:13.750
este é o lugar dos dois, este é o quarto colocado, este é o oitavo lugar.

00:12:13.750 --> 00:12:14.710
Faça algumas contas rápidas.

00:12:14.710 --> 00:12:19.370
Então 8 mais 4 é 12, mais 2 é 14, mais 1 é 15.

00:12:19.370 --> 00:12:22.690
Acontece que, por conveniência, os dígitos hexadecimais

00:12:22.690 --> 00:12:26.360
pode apenas ser representado consistentemente com quatro bits ou menos.

00:12:26.360 --> 00:12:27.190
Mas quatro.

00:12:27.190 --> 00:12:29.140
E quatro, é claro, é metade de oito.

00:12:29.140 --> 00:12:32.270
E oito está em toda parte, como 8 bits é um byte, que é, novamente,

00:12:32.270 --> 00:12:33.590
apenas uma convenção que vimos.

00:12:33.590 --> 00:12:36.940
E então a razão pela qual você vê hexadecimal no mundo do Photoshop,

00:12:36.940 --> 00:12:39.910
e, eventualmente, páginas da web, são apenas mapas

00:12:39.910 --> 00:12:43.330
muito bem para expressar números binários mais

00:12:43.330 --> 00:12:45.800
sucintamente com um número fixo de dígitos.

00:12:45.800 --> 00:12:52.677
Por exemplo, sempre que você vir 11111111 no mundo como binário,

00:12:52.677 --> 00:12:53.260
Você sabe o que?

00:12:53.260 --> 00:12:55.600
Isso é um pouco tedioso para dizer e escrever.

00:12:55.600 --> 00:13:02.230
Você pode representar de forma mais sucinta qualquer grupo de quatro bits 1 de forma mais sucinta

00:13:02.230 --> 00:13:09.310
em hexadecimal como apenas F. Então 11111111 em binário de forma mais sucinta e mais

00:13:09.310 --> 00:13:13.000
comumente agora no mundo do Photoshop, memória, imagens e afins

00:13:13.000 --> 00:13:14.950
é representado mais sucintamente como FF.

00:13:14.950 --> 00:13:18.350
E é por isso que mapeia muito bem para 4 bits.

00:13:18.350 --> 00:13:20.630
E assim podemos ser um pouco mais sucintos.

00:13:20.630 --> 00:13:23.710
Qualquer dúvida sobre hexadecimal, que é apenas

00:13:23.710 --> 00:13:27.110
outra maneira de representar informações, mas usando a mesma escola

00:13:27.110 --> 00:13:27.610
abordagem?

00:13:27.610 --> 00:13:28.110
Sim.

00:13:28.110 --> 00:13:28.780
AUDIÊNCIA: Então...

00:13:28.780 --> 00:13:30.030
DAVID J. MALAN: Boa pergunta.

00:13:30.030 --> 00:13:33.130
Se você representar 15 com F, usaria 4 bits.

00:13:33.130 --> 00:13:37.450
Portanto, os sistemas básicos são apenas uma maneira para nós, humanos, no papel ou nas telas

00:13:37.450 --> 00:13:38.830
para representar informações.

00:13:38.830 --> 00:13:42.820
Se F representa o número decimal 15, o computador sob o capô

00:13:42.820 --> 00:13:45.610
tem que usar 4 bits para representá-lo.

00:13:45.610 --> 00:13:48.700
Portanto, um dígito hexadecimal por convenção sempre

00:13:48.700 --> 00:13:51.160
implica 4 bits sob o capô.

00:13:51.160 --> 00:13:53.680
Portanto, se você tiver dois dígitos hexadecimais,

00:13:53.680 --> 00:13:57.430
como zero, zero, isso significa oito bits zero sob o capô

00:13:57.430 --> 00:13:59.200
como para vermelho ou para verde.

00:13:59.200 --> 00:14:03.460
Se você vir FF, agora sabemos que são 4 bits um e outros 4 bits um.

00:14:03.460 --> 00:14:05.650
E se fizermos as contas, são 255.

00:14:05.650 --> 00:14:14.320
É por isso que no Photoshop, 0000FF significa sem vermelho, sem verde e 255 de azul.

00:14:14.320 --> 00:14:17.050
E é muito mais sucinto do que escrever o quê, 8 mais 8,

00:14:17.050 --> 00:14:19.090
mais 8, 24 zeros e uns.

00:14:19.090 --> 00:14:21.370
E é mais limpo do que usar decimal

00:14:21.370 --> 00:14:25.273
quando você está usando unidades de oito, que novamente os computadores usam em todos os lugares.

00:14:25.273 --> 00:14:26.440
Portanto, é apenas outro sistema.

00:14:26.440 --> 00:14:28.273
Não é algo que você precise insistir muito.

00:14:28.273 --> 00:14:32.110
Mas, novamente, não é fundamentalmente diferente de binário ou decimal.

00:14:32.110 --> 00:14:34.977
Estamos apenas usando uma base ligeiramente diferente.

00:14:34.977 --> 00:14:35.560
Agora tudo bem.

00:14:35.560 --> 00:14:37.720
Bem, nós tínhamos essa tela em branco aqui.

00:14:37.720 --> 00:14:40.600
E eu penso, vocês dois talvez estejam prontos para revelar

00:14:40.600 --> 00:14:42.140
para o mundo o que você criou?

00:14:42.140 --> 00:14:43.348
Você quer ir em frente e--

00:14:43.348 --> 00:14:45.170
Vou girá-lo para você.

00:14:45.170 --> 00:14:45.670
Tudo bem.

00:14:45.670 --> 00:14:46.180
Aqui vamos nós.

00:14:46.180 --> 00:14:46.870
Grande revelação.

00:14:46.870 --> 00:14:51.760
E a pixel art de hoje, uma salva de palmas se pudéssemos.

00:14:54.280 --> 00:14:55.325
Muito bem feito.

00:14:55.325 --> 00:14:56.200
Bem, obrigado a ambos.

00:14:56.200 --> 00:14:58.600
Se você quiser subir depois, arrancar isso e trazer para casa,

00:14:58.600 --> 00:15:00.430
você é bem-vindo e guarde os post-its também.

00:15:00.430 --> 00:15:02.140
Bem, obrigado aos nossos voluntários lá.

00:15:02.140 --> 00:15:05.793
Vamos agora traduzir isso para um mundo realmente mais técnico

00:15:05.793 --> 00:15:07.960
onde vamos ver e considerar com mais frequência.

00:15:07.960 --> 00:15:10.570
Porque, na verdade, às vezes, quando você recebe mensagens de erro

00:15:10.570 --> 00:15:13.000
nas últimas semanas de clang, o compilador,

00:15:13.000 --> 00:15:15.483
você pode até ter visto evidências de hexadecimal.

00:15:15.483 --> 00:15:16.400
Nós não o denunciamos.

00:15:16.400 --> 00:15:17.980
Não era útil saber na época.

00:15:17.980 --> 00:15:21.880
Mas acontece que muitos programas usam e muito código,

00:15:21.880 --> 00:15:25.490
usa hexadecimal por motivos mais precisos--

00:15:25.490 --> 00:15:26.930
representação mais sucinta.

00:15:26.930 --> 00:15:28.840
Então, por exemplo, onde mais poderíamos vê-lo?

00:15:28.840 --> 00:15:31.990
Bem, aqui está aquela foto que continuamos puxando da memória do nosso computador.

00:15:31.990 --> 00:15:34.330
E cada um desses quadrados nesta grade representa

00:15:34.330 --> 00:15:37.210
um byte, do canto superior esquerdo para o canto inferior direito da memória do computador.

00:15:37.210 --> 00:15:39.730
Mas, novamente, apenas a representação de um artista.

00:15:39.730 --> 00:15:43.570
Algumas semanas atrás, afirmei que cada um desses bytes pode ser numerado, é claro.

00:15:43.570 --> 00:15:46.300
Como este é o byte 0 no canto superior esquerdo, depois o byte um, depois

00:15:46.300 --> 00:15:49.760
byte dois, então byte dois bilhões se você tiver 2 gigabytes de memória.

00:15:49.760 --> 00:15:54.760
E então poderíamos numerá-los assim, de zero a 15 em diante.

00:15:54.760 --> 00:15:56.480
16, 17, 18 e assim por diante.

00:15:56.480 --> 00:16:00.500
Mas pelas razões anteriores, é apenas mais comum em sistemas de computador

00:16:00.500 --> 00:16:03.340
e no software para realmente usar hexadecimal apenas

00:16:03.340 --> 00:16:07.030
para descrever as localizações, os endereços, das coisas na memória.

00:16:07.030 --> 00:16:10.120
Em vez disso, um programador típico, ou um cientista da computação,

00:16:10.120 --> 00:16:14.230
chamaria esses primeiros 16 bytes de zero a F apenas porque.

00:16:14.230 --> 00:16:17.000
Mas isso é porque é um número previsível de bits.

00:16:17.000 --> 00:16:21.670
Então, se continuarmos indo além disso, você obterá não 10, não 11, não 12,

00:16:21.670 --> 00:16:25.900
mas em hexadecimal, um, zero, um, um, um, dois e assim por diante,

00:16:25.900 --> 00:16:30.520
todo o caminho na tela para um F. E se eu reduzisse isso ou tivesse

00:16:30.520 --> 00:16:34.450
um monitor maior, veríamos eventualmente 255 bytes depois

00:16:34.450 --> 00:16:37.400
desde o início 255 também.

00:16:37.400 --> 00:16:40.840
Mas há um problema potencial aqui com o uso de hexadecimal dessa maneira.

00:16:40.840 --> 00:16:42.730
Há uma ambiguidade.

00:16:42.730 --> 00:16:49.180
Alguém pode imaginar o que pode dar errado se usarmos hex para simplesmente descrever

00:16:49.180 --> 00:16:52.960
locais na memória como este?

00:16:52.960 --> 00:16:53.650
Sim.

00:16:53.650 --> 00:16:55.285
AUDIÊNCIA: Um zero também pode ser 10.

00:16:55.285 --> 00:16:56.160
DAVID J. MALAN: Sim.

00:16:56.160 --> 00:16:57.960
Um zero também pode ser 10.

00:16:57.960 --> 00:17:01.090
E talvez se você for realmente minucioso, OK, espere um minuto.

00:17:01.090 --> 00:17:02.950
Não pode ser 10 porque aqui está F aqui.

00:17:02.950 --> 00:17:04.200
Então obviamente não é decimal.

00:17:04.200 --> 00:17:07.079
Mas por que criar confusão potencial, especialmente quando você está colaborando,

00:17:07.079 --> 00:17:08.412
construir algo com alguém?

00:17:08.412 --> 00:17:09.760
Queremos evitar essa ambiguidade.

00:17:09.760 --> 00:17:12.359
E assim a convenção que os humanos decidiram anos atrás

00:17:12.359 --> 00:17:16.380
é que se você quiser deixar claro que um número está em hexadecimal apenas

00:17:16.380 --> 00:17:20.790
por convenção, você prefixa todos os dígitos com 0x.

00:17:20.790 --> 00:17:22.950
O X não é outro caractere.

00:17:22.950 --> 00:17:24.720
Não é um 17º personagem.

00:17:24.720 --> 00:17:29.700
É apenas uma convenção humana de colocar 0x para implicar, aqui vem o hexadecimal.

00:17:29.700 --> 00:17:31.020
E agora é inequívoco.

00:17:31.020 --> 00:17:35.760
Então agora vemos que 0x10 obviamente não é 10 como o conhecemos em decimal.

00:17:35.760 --> 00:17:39.060
Mas sim é o número que vem depois de um único F.

00:17:39.060 --> 00:17:41.430
Então é realmente o número no decimal 16.

00:17:41.430 --> 00:17:46.620
Então, 0x, sempre que você vê, é apenas uma dica visual de que o que está por vir

00:17:46.620 --> 00:17:48.940
é realmente hexadecimal.

00:17:48.940 --> 00:17:52.480
Então, vamos agora começar a brincar com essas informações.

00:17:52.480 --> 00:17:54.750
Aqui está uma linha de código super simples da primeira semana

00:17:54.750 --> 00:17:59.445
onde estou apenas declarando uma variável n e definindo-a como o valor 50.

00:17:59.445 --> 00:18:00.570
E isso está fora de contexto.

00:18:00.570 --> 00:18:02.612
Provavelmente precisamos de uma função principal e tudo isso.

00:18:02.612 --> 00:18:05.820
Mas vamos voltar para a primeira semana em que realmente vimos um código como este

00:18:05.820 --> 00:18:08.530
e fazer algo útil com uma linha de código como esta.

00:18:08.530 --> 00:18:10.500
Então deixe-me passar aqui para o VS Code.

00:18:10.500 --> 00:18:14.070
E no VS Code, vou criar um programa chamado, que tal endereços?

00:18:14.070 --> 00:18:15.900
Já que o objetivo deste--

00:18:15.900 --> 00:18:20.310
o objetivo aqui é apenas brincar, em última análise, com uma variável como n.

00:18:20.310 --> 00:18:21.750
E deixe-me ir em frente e fazer isso.

00:18:21.750 --> 00:18:24.510
Vou incluir, que tal I/Oh padrão?

00:18:24.510 --> 00:18:25.770
Vou fazer int main void.

00:18:25.770 --> 00:18:28.260
Portanto, sem argumentos de linha de comando por enquanto.

00:18:28.260 --> 00:18:30.090
Int n obtém 50.

00:18:30.090 --> 00:18:32.950
E agora, para que possamos fazer algo levemente útil com ele,

00:18:32.950 --> 00:18:37.950
vamos usar printf e imprimir com %i e então uma nova linha qualquer

00:18:37.950 --> 00:18:38.970
esse valor de n é.

00:18:38.970 --> 00:18:41.020
Portanto, isso não será interessante por si só.

00:18:41.020 --> 00:18:43.620
É apenas uma semana em que estou definindo uma variável

00:18:43.620 --> 00:18:45.610
e imprimi-lo na tela.

00:18:45.610 --> 00:18:49.290
Então deixe-me ir até a janela do meu terminal e fazer endereços.

00:18:49.290 --> 00:18:50.405
Sem erros.

00:18:50.405 --> 00:18:51.030
Então isso é bom.

00:18:51.030 --> 00:18:52.440
Vou fazer endereços de ponto e barra.

00:18:52.440 --> 00:18:55.500
E, claro, devo ver o número 50 aqui.

00:18:55.500 --> 00:18:57.360
Agora, o que está acontecendo debaixo do capô?

00:18:57.360 --> 00:19:00.900
Vamos traduzir agora o código para realmente o que está acontecendo

00:19:00.900 --> 00:19:03.430
sob o capô do computador.

00:19:03.430 --> 00:19:05.793
Então, se esta é a nossa grade de memória, eu não necessariamente

00:19:05.793 --> 00:19:07.710
sei como o programador, e eu definitivamente não

00:19:07.710 --> 00:19:10.440
cuidado como programador, onde exatamente está terminando na memória.

00:19:10.440 --> 00:19:11.670
Esse é o objetivo de usar código.

00:19:11.670 --> 00:19:13.140
Deixe o computador descobrir isso.

00:19:13.140 --> 00:19:17.430
Mas, pelo menos conceitualmente, sei que ao declarar uma linha de código como essa,

00:19:17.430 --> 00:19:21.250
o número 50 acaba em algum lugar da memória do computador.

00:19:21.250 --> 00:19:25.980
E é atribuído o nome n, um símbolo n, pelo qual eu, o programador,

00:19:25.980 --> 00:19:26.890
pode se referir a ele.

00:19:26.890 --> 00:19:33.810
E eu usei deliberadamente quatro desses quadrados por qual motivo?

00:19:33.810 --> 00:19:37.260
Qual pode ser a razão para usar quatro quadrados especificamente?

00:19:37.260 --> 00:19:38.100
Sim.

00:19:38.100 --> 00:19:39.660
Sim, então um número inteiro é de 4 bytes.

00:19:39.660 --> 00:19:42.870
Pelo menos na maioria das vezes em sistemas modernos, um inteiro tem 4 bytes.

00:19:42.870 --> 00:19:44.760
Em um computador mais antigo, ele pode usar apenas um.

00:19:44.760 --> 00:19:46.890
Ou talvez até 2 bytes.

00:19:46.890 --> 00:19:49.710
Mas aqui, por convenção, quase sempre veremos 4 bytes.

00:19:49.710 --> 00:19:51.190
Não sei se vai parar aqui.

00:19:51.190 --> 00:19:52.330
Pode acabar aqui.

00:19:52.330 --> 00:19:53.550
Mas por enquanto, quem se importa?

00:19:53.550 --> 00:19:56.340
Só sei que o computador pode armazenar as informações

00:19:56.340 --> 00:19:58.450
desta forma sob o capô.

00:19:58.450 --> 00:20:01.560
Então, vamos agora introduzir outro recurso de C

00:20:01.560 --> 00:20:04.260
que ainda não tivemos a oportunidade de usar isso é

00:20:04.260 --> 00:20:07.560
vai nos permitir começar a vasculhar a memória do computador

00:20:07.560 --> 00:20:08.640
por bem ou por mal.

00:20:08.640 --> 00:20:10.348
E esta é uma daquelas situações em que

00:20:10.348 --> 00:20:14.850
você está prestes a aprender, adquirir uma habilidade, um poder, que pode realmente voltar

00:20:14.850 --> 00:20:15.420
para te morder.

00:20:15.420 --> 00:20:18.510
Porque uma vez que você sabe como começar a vasculhar a memória de um computador,

00:20:18.510 --> 00:20:20.050
você pode fazer coisas muito poderosas.

00:20:20.050 --> 00:20:22.920
E na próxima semana, veremos o que você pode construir na memória de um computador,

00:20:22.920 --> 00:20:24.997
mas você também pode estragar facilmente e causar

00:20:24.997 --> 00:20:28.080
mais dessas falhas de segmentação que alguns de vocês já sofreram.

00:20:28.080 --> 00:20:31.350
Então, com isso dito, vamos apenas estipular que você sabe o que?

00:20:31.350 --> 00:20:34.510
Não me importo necessariamente onde o 50 está na memória.

00:20:34.510 --> 00:20:37.230
Mas sei que existe em algum endereço da memória.

00:20:37.230 --> 00:20:39.300
E só assim eu tenho um endereço fácil de pronunciar,

00:20:39.300 --> 00:20:42.060
vamos supor que viva em 0x123.

00:20:42.060 --> 00:20:45.180
Então esse é o endereço na memória em hexadecimal por convenção.

00:20:45.180 --> 00:20:48.730
E acontece que é onde termina quando escrevo essa linha de código.

00:20:48.730 --> 00:20:52.770
Mas acontece que C tem alguns outros operadores que podemos usar.

00:20:52.770 --> 00:20:55.290
Quando vimos o asterisco antes, a estrela, e vimos

00:20:55.290 --> 00:20:56.588
usou para multiplicação.

00:20:56.588 --> 00:20:59.130
Mas hoje vamos usá-lo para algo mais poderoso.

00:20:59.130 --> 00:21:01.338
E também vamos introduzir um e comercial, que

00:21:01.338 --> 00:21:02.970
nos permite fazer algo também.

00:21:02.970 --> 00:21:06.270
O operador e comercial nos permitirá

00:21:06.270 --> 00:21:11.970
para obter o endereço de um dado na memória, como literalmente colocando

00:21:11.970 --> 00:21:14.520
e comercial antes do nome de uma variável, C

00:21:14.520 --> 00:21:18.210
vai nos dizer, dizer a você, em que endereço essa variável mora.

00:21:18.210 --> 00:21:20.730
Talvez seja 0x123, talvez seja 0x456.

00:21:20.730 --> 00:21:21.270
Quem sabe?

00:21:21.270 --> 00:21:23.610
Mas isso lhe dará de volta a resposta.

00:21:23.610 --> 00:21:25.360
A estrela faz o contrário.

00:21:25.360 --> 00:21:26.710
Isso meio que significa, vá lá.

00:21:26.710 --> 00:21:30.090
Portanto, usando a estrela, também conhecida como operador de referência,

00:21:30.090 --> 00:21:33.000
Na verdade, posso ir a um endereço específico, se quiser.

00:21:33.000 --> 00:21:35.230
E veremos o que isso significa no código.

00:21:35.230 --> 00:21:39.510
Então, como posso aproveitar isso de uma maneira levemente interessante

00:21:39.510 --> 00:21:40.470
para começar a bisbilhotar?

00:21:40.470 --> 00:21:44.650
Mas, eventualmente, usaremos esse primitivo para construir coisas mais interessantes.

00:21:44.650 --> 00:21:47.520
Então, deixe-me voltar para dizer, VS Code aqui.

00:21:47.520 --> 00:21:49.350
E deixe-me ir em frente e fazer isso.

00:21:49.350 --> 00:21:51.210
Vou limpar meu terminal para começar de novo.

00:21:51.210 --> 00:21:55.430
E apresentarei outro código de formato para printf, %p.

00:21:55.430 --> 00:21:59.630
E, por enquanto, acredite que é %p porque.

00:21:59.630 --> 00:22:05.420
Mas %p vai me permitir imprimir o endereço de uma variável se eu adicionalmente

00:22:05.420 --> 00:22:08.150
diga a C, obtenha o endereço de n.

00:22:08.150 --> 00:22:10.340
Então, estou mudando %i para %p.

00:22:10.340 --> 00:22:13.700
E isso é apenas algo que você precisa fazer ao imprimir endereços por enquanto.

00:22:13.700 --> 00:22:17.310
Mas preciso alterar um na frente do nome da variável.

00:22:17.310 --> 00:22:19.220
Então eu não imprimo n, o número 50.

00:22:19.220 --> 00:22:21.178
Eu imprimo algo como 0x123.

00:22:21.178 --> 00:22:22.970
E não vai ser tão simples assim.

00:22:22.970 --> 00:22:24.970
Veremos na tela onde realmente

00:22:24.970 --> 00:22:27.090
acabou na memória do meu espaço de código.

00:22:27.090 --> 00:22:28.490
Aqui vamos nos.

00:22:28.490 --> 00:22:32.720
Ponto-- para baixo no meu terminal, faça endereços novamente para recompilar.

00:22:32.720 --> 00:22:37.610
E agora, os endereços de ponto e barra não devem revelar o valor de 50,

00:22:37.610 --> 00:22:40.310
mas o endereço de 50.

00:22:40.310 --> 00:22:41.570
E aí está.

00:22:41.570 --> 00:22:42.890
É bem longo.

00:22:42.890 --> 00:22:45.230
Não é tão simples e bonito quanto 0x123.

00:22:45.230 --> 00:22:47.720
Mas há o 0x, o que significa que aqui está um endereço hexadecimal.

00:22:47.720 --> 00:22:52.070
E é 7ffcc784a04c.

00:22:52.070 --> 00:22:55.310
Basta dizer que seu espaço de código e até mesmo seus Macs e PCs hoje em dia,

00:22:55.310 --> 00:22:56.760
ter muita memória.

00:22:56.760 --> 00:23:00.320
É por isso que, em parte, esse endereço é tão grande, não tão pequeno

00:23:00.320 --> 00:23:02.040
como a coisa no meu slide.

00:23:02.040 --> 00:23:05.840
Portanto, isso no momento ainda não é tão útil.

00:23:05.840 --> 00:23:09.800
Mas nos apresenta um conceito que agora chamaremos de ponteiros.

00:23:09.800 --> 00:23:14.420
E os ponteiros são reconhecidamente um dos aspectos mais desafiadores de C.

00:23:14.420 --> 00:23:18.643
E se na vida futura você contar aos amigos que, ah, eu fiz uma aula chamada CS50,

00:23:18.643 --> 00:23:20.810
e aprendemos C, você provavelmente vai dar uma olhada

00:23:20.810 --> 00:23:22.460
para pessoas como, por que você aprendeu C?

00:23:22.460 --> 00:23:23.900
Ou tipo, oh, C era difícil.

00:23:23.900 --> 00:23:27.380
E é em grande parte por causa deste tema, que

00:23:27.380 --> 00:23:30.812
não quer dizer que seja tão difícil entender.

00:23:30.812 --> 00:23:32.270
Mas é definitivamente muito diferente.

00:23:32.270 --> 00:23:36.080
E não é um recurso que você pode aproveitar em linguagens de nível superior

00:23:36.080 --> 00:23:39.800
que veremos na aula dois, como Python, Java e similares.

00:23:39.800 --> 00:23:42.290
C é o mais próximo do hardware do computador,

00:23:42.290 --> 00:23:45.350
por assim dizer, que você pode obter antes que as coisas fiquem realmente assustadoras,

00:23:45.350 --> 00:23:48.770
a chamada linguagem assembly que vimos na segunda semana quando eu tinha um link,

00:23:48.770 --> 00:23:50.900
e compilar e montar, e tudo isso.

00:23:50.900 --> 00:23:52.100
Isso torna o nível muito baixo.

00:23:52.100 --> 00:23:55.310
E você realmente tem que ser um especialista com a CPU do computador, ou cérebro,

00:23:55.310 --> 00:23:56.340
para entender isso.

00:23:56.340 --> 00:23:59.730
Mas com C, você pode realmente vasculhar a memória do computador

00:23:59.730 --> 00:24:01.130
e fazer coisas poderosas com isso.

00:24:01.130 --> 00:24:03.470
Mas, novamente, com grande poder vem a responsabilidade.

00:24:03.470 --> 00:24:07.670
É muito fácil quebrar programas usando mal a memória ou apenas tendo um bug

00:24:07.670 --> 00:24:11.220
que toca a memória de alguma forma que você não pretende.

00:24:11.220 --> 00:24:16.370
Portanto, os ponteiros, no final das contas, são basicamente o que acabamos de ver.

00:24:16.370 --> 00:24:22.910
Um ponteiro é realmente apenas uma variável que contém o endereço de algum valor.

00:24:22.910 --> 00:24:25.790
Um ponteiro é uma variável que contém o endereço de algum valor,

00:24:25.790 --> 00:24:28.280
ou, mais simplesmente, não há problema em pensar nisso como um endereço.

00:24:28.280 --> 00:24:31.650
Um ponteiro é um endereço de algo na memória do computador.

00:24:31.650 --> 00:24:35.880
Agora, o que podemos fazer para atualizar isso?

00:24:35.880 --> 00:24:37.440
Bem, aqui estão duas linhas de código.

00:24:37.440 --> 00:24:41.600
Acontece que, usando nossos dois novos operadores hoje, posso declarar um int,

00:24:41.600 --> 00:24:45.770
chame-o de n e atribua a ele um valor como 50, como antes.

00:24:45.770 --> 00:24:49.400
Se eu quiser armazenar o endereço de n em uma variável,

00:24:49.400 --> 00:24:51.680
e não apenas imprimi-lo imediatamente via printf,

00:24:51.680 --> 00:24:54.458
Posso declarar uma variável, por exemplo, chamada p.

00:24:54.458 --> 00:24:56.750
Mas eu poderia chamá-lo do que quiser, como qualquer variável.

00:24:56.750 --> 00:24:59.960
Mas porque é um endereço, não é int p.

00:24:59.960 --> 00:25:03.410
Tem que ser int star p, por assim dizer.

00:25:03.410 --> 00:25:06.590
E a estrela aqui do lado esquerdo do sinal de igual

00:25:06.590 --> 00:25:10.790
é apenas uma pista para ver que significa que p será um ponteiro.

00:25:10.790 --> 00:25:13.520
Ou seja, p vai ser o endereço de quê?

00:25:13.520 --> 00:25:15.450
O endereço de um número inteiro.

00:25:15.450 --> 00:25:17.540
Agora, tecnicamente, ainda é um número inteiro em si

00:25:17.540 --> 00:25:21.230
porque um endereço é apenas um número, seja 1, 2, 3 ou 0x123.

00:25:21.230 --> 00:25:23.310
Portanto, esta é realmente apenas uma diferença semântica.

00:25:23.310 --> 00:25:26.450
Então int star p significa apenas que esta variável não

00:25:26.450 --> 00:25:28.580
conter qualquer número antigo, como 50.

00:25:28.580 --> 00:25:33.570
Ele contém especificamente um número que é o endereço de outra coisa.

00:25:33.570 --> 00:25:35.670
Então, como posso usar isso agora?

00:25:35.670 --> 00:25:37.400
Bem, deixe-me voltar ao VS Code.

00:25:37.400 --> 00:25:41.670
E deixe-me propor que adicionemos uma linha de código como essa.

00:25:41.670 --> 00:25:44.220
Então, em vez de apenas imprimir diretamente esse valor,

00:25:44.220 --> 00:25:48.170
vamos definir uma segunda variável chamada p que é do tipo int

00:25:48.170 --> 00:25:53.480
estrela p, defina-o igual a e comercial n e, desta vez,

00:25:53.480 --> 00:25:55.460
não vamos apenas imprimir e comercial n.

00:25:55.460 --> 00:25:57.530
Vamos realmente imprimir o valor de p.

00:25:57.530 --> 00:25:59.810
Então, as duas únicas coisas novas aqui se eu aumentar o zoom

00:25:59.810 --> 00:26:04.160
são eu usei não apenas o e comercial à direita para obter o endereço de n.

00:26:04.160 --> 00:26:07.130
Agora estou usando a estrela à esquerda para dizer C

00:26:07.130 --> 00:26:10.190
que p ainda é uma variável como sempre.

00:26:10.190 --> 00:26:11.450
Mas é um ponteiro.

00:26:11.450 --> 00:26:14.897
É o endereço de algum outro valor como este.

00:26:14.897 --> 00:26:17.480
E ainda vou imprimi-lo com o mesmo código de formato, %p.

00:26:17.480 --> 00:26:18.660
Então isso não muda.

00:26:18.660 --> 00:26:24.680
Então, deixe-me ir em frente e diminuir o zoom e criar endereços e ./addresses.

00:26:24.680 --> 00:26:27.620
E aí está, exatamente a mesma coisa.

00:26:27.620 --> 00:26:30.500
Agora por si só, ainda não é tão útil.

00:26:30.500 --> 00:26:34.280
Mas o fato de que agora você pode acessar os endereços das coisas na memória

00:26:34.280 --> 00:26:38.360
significa que seremos capazes de construir coisas, e construir coisas, e ligar

00:26:38.360 --> 00:26:41.690
coisas juntos sabendo onde eles moram, por assim dizer.

00:26:41.690 --> 00:26:44.570
Então, alguma dúvida sobre esta técnica até agora?

00:26:44.570 --> 00:26:45.511
Sim.

00:26:45.511 --> 00:26:48.767
AUDIÊNCIA: Acho que estou um pouco confuso sobre o [INAUDÍVEL].

00:26:48.767 --> 00:26:50.100
DAVID J. MALAN: Uma boa pergunta.

00:26:50.100 --> 00:26:52.320
Na linha seis, deve ser asterisco pe e comercial?

00:26:52.320 --> 00:26:54.210
E neste caso, sim.

00:26:54.210 --> 00:26:55.290
Porque o que estou fazendo?

00:26:55.290 --> 00:26:58.050
À esquerda, e vou me livrar do sinal de igual por enquanto,

00:26:58.050 --> 00:27:02.640
isso me daria uma variável chamada p que não é um inteiro per se,

00:27:02.640 --> 00:27:04.710
mas esse é o endereço de um número inteiro.

00:27:04.710 --> 00:27:08.110
Mas sem o sinal de igual, não estou armazenando nada nessa variável.

00:27:08.110 --> 00:27:12.390
Portanto, adicionando o sinal de igual e, em seguida, o e comercial n,

00:27:12.390 --> 00:27:16.650
Estou explicitamente descobrindo com e comercial qual é o endereço de n

00:27:16.650 --> 00:27:20.100
é, que já existe por linha cinco e guardando-o

00:27:20.100 --> 00:27:23.310
nesta nova variável chamada p.

00:27:23.310 --> 00:27:24.100
Outras perguntas?

00:27:24.100 --> 00:27:24.600
Sim.

00:27:24.600 --> 00:27:26.570
AUDIÊNCIA: [INAUDÍVEL]

00:27:26.570 --> 00:27:27.820
DAVID J. MALAN: Boa pergunta.

00:27:27.820 --> 00:27:30.695
Toda vez que executo o programa, ele usa um pedaço diferente de memória?

00:27:30.695 --> 00:27:31.770
Resposta curta, sim.

00:27:31.770 --> 00:27:33.628
Os computadores, porém, para encurtar a história, também

00:27:33.628 --> 00:27:35.170
tem algo chamado memória virtual.

00:27:35.170 --> 00:27:37.337
Então, se você executá-lo repetidamente, você pode realmente

00:27:37.337 --> 00:27:40.590
veja os mesmos endereços no mesmo Mac, ou PC, ou servidor baseado em nuvem.

00:27:40.590 --> 00:27:44.580
Mas veremos daqui a pouco onde em alto nível é apresentado.

00:27:44.580 --> 00:27:47.447
Mas sempre existirá em algum endereço.

00:27:47.447 --> 00:27:48.030
Boa pergunta.

00:27:48.030 --> 00:27:48.530
Sim.

00:27:48.530 --> 00:27:50.120
AUDIÊNCIA: [INAUDÍVEL]

00:27:50.120 --> 00:27:51.120
DAVID J. MALAN: Correto.

00:27:51.120 --> 00:27:52.980
E comercial n é o endereço de n.

00:27:52.980 --> 00:27:57.660
E int star p é um ponteiro chamado p.

00:27:57.660 --> 00:28:02.550
E honestamente, em um mundo ideal, se C fosse feito hoje e não décadas atrás

00:28:02.550 --> 00:28:05.030
quando os humanos começaram a criar línguas,

00:28:05.030 --> 00:28:08.220
idealmente, teríamos apenas um tipo de dados chamado ponteiro.

00:28:08.220 --> 00:28:11.370
E então isso seria um pouco menos complicado porque literalmente

00:28:11.370 --> 00:28:12.480
seja o que diz.

00:28:12.480 --> 00:28:14.290
Os humanos que inventaram C não fizeram isso.

00:28:14.290 --> 00:28:15.580
Mas esta é a ideia.

00:28:15.580 --> 00:28:18.060
Portanto, ponteiro não é uma palavra legítima no código.

00:28:18.060 --> 00:28:20.070
É um termo de R em inglês.

00:28:20.070 --> 00:28:21.780
Mas esta é realmente apenas a ideia.

00:28:21.780 --> 00:28:25.140
Mas a maneira como você expressa o ponteiro como um tipo de dados

00:28:25.140 --> 00:28:29.530
é um pouco mais enigmático como int star p aqui.

00:28:29.530 --> 00:28:34.643
Mas observe na linha sete, quando imprimo p, não uso asterisco.

00:28:34.643 --> 00:28:35.685
Eu não uso um e comercial.

00:28:35.685 --> 00:28:36.090
Por que?

00:28:36.090 --> 00:28:38.040
Eu literalmente só quero imprimir o valor de p.

00:28:38.040 --> 00:28:39.748
E temos feito isso desde a primeira semana.

00:28:39.748 --> 00:28:42.930
Se você quiser imprimir uma variável, basta descrevê-la pelo nome.

00:28:42.930 --> 00:28:44.400
Nenhuma sintaxe especial.

00:28:44.400 --> 00:28:46.690
Alguma outra pergunta sobre isso até agora?

00:28:46.690 --> 00:28:48.148
AUDIÊNCIA: [INAUDÍVEL]

00:28:48.148 --> 00:28:50.440
DAVID J. MALAN: Qual é a vantagem de usar ponteiros?

00:28:50.440 --> 00:28:53.560
Com ponteiros, veremos hoje algumas aplicações deles,

00:28:53.560 --> 00:28:55.572
realmente a ideia vai dar certo

00:28:55.572 --> 00:28:57.280
na próxima semana, quando vamos criar o que

00:28:57.280 --> 00:29:01.330
são chamados de estruturas de dados na memória, onde podemos construir não apenas,

00:29:01.330 --> 00:29:04.548
por exemplo, estruturas de dados unidimensionais como uma matriz.

00:29:04.548 --> 00:29:06.340
Veremos na próxima semana, podemos realmente criar

00:29:06.340 --> 00:29:08.500
o equivalente a estruturas de dados bidimensionais,

00:29:08.500 --> 00:29:10.250
ou mesmo estruturas de dados tridimensionais,

00:29:10.250 --> 00:29:12.852
usando esses endereços e meio que ligando as coisas.

00:29:12.852 --> 00:29:14.810
E veremos o início disso esta semana.

00:29:14.810 --> 00:29:18.160
Mas, por enquanto, concentre-se pelo menos por agora apenas na sintaxe

00:29:18.160 --> 00:29:20.485
e o que esses blocos de construção podem fazer por nós.

00:29:20.485 --> 00:29:22.960
AUDIÊNCIA: O ponteiro p tem que ser um número inteiro?

00:29:22.960 --> 00:29:25.150
DAVID J. MALAN: O p inteiro--

00:29:25.150 --> 00:29:27.922
o ponteiro p tem que ser um-- apontar para um número inteiro?

00:29:27.922 --> 00:29:28.630
Resposta curta, não.

00:29:28.630 --> 00:29:29.500
E nós vamos voltar a isso.

00:29:29.500 --> 00:29:31.250
Por enquanto, para fins de discussão, estamos

00:29:31.250 --> 00:29:33.460
lidando apenas com inteiros como o número 50.

00:29:33.460 --> 00:29:35.410
Você mencionou strings ou caracteres.

00:29:35.410 --> 00:29:36.010
Absolutamente.

00:29:36.010 --> 00:29:38.060
Estamos prestes a ir para lá em breve.

00:29:38.060 --> 00:29:41.510
Então você pode usar o endereço de qualquer coisa que você quiser na memória do computador.

00:29:41.510 --> 00:29:44.643
Na verdade, vamos traduzir isso agora para a mesma imagem apenas

00:29:44.643 --> 00:29:47.560
para ajudá-lo a entender o que essas duas linhas de código realmente

00:29:47.560 --> 00:29:49.000
fundamentalmente estão fazendo.

00:29:49.000 --> 00:29:51.460
Então, se eu voltar à minha grade de memória aqui,

00:29:51.460 --> 00:29:54.910
vamos colocar o número 50 na variável n no canto inferior direito,

00:29:54.910 --> 00:29:56.000
como era antes.

00:29:56.000 --> 00:29:58.040
Portanto, esta é a primeira linha de código como antes.

00:29:58.040 --> 00:30:03.080
Mas com a nova segunda linha de código, assim que crio p, o que faço?

00:30:03.080 --> 00:30:07.177
Bem, primeiro, lembre-se de que n reside em algum lugar da memória do computador.

00:30:07.177 --> 00:30:09.010
Normalmente, não me importo exatamente onde está.

00:30:09.010 --> 00:30:10.885
Mas, para fins de discussão, vamos supor

00:30:10.885 --> 00:30:14.480
está em 0x123, o que é mais fácil de dizer do que onde realmente acabou.

00:30:14.480 --> 00:30:15.820
E agora o que é p?

00:30:15.820 --> 00:30:17.630
Bem, p é apenas outra variável.

00:30:17.630 --> 00:30:19.280
E variáveis ​​vivem na memória também.

00:30:19.280 --> 00:30:22.550
Deixe-me apenas supor que p vive aqui.

00:30:22.550 --> 00:30:28.630
E acontece que p uma vez atribuído, o valor do e comercial n

00:30:28.630 --> 00:30:32.110
significa que C vai dar uma olhada na variável n,

00:30:32.110 --> 00:30:37.240
perceba, ah ele vive em 0x123, e o que vai no valor de p

00:30:37.240 --> 00:30:39.550
é literalmente 0x123.

00:30:39.550 --> 00:30:42.440
Então, novamente, ainda é um número inteiro, o que é confuso.

00:30:42.440 --> 00:30:45.520
Mas é tecnicamente um número inteiro sendo usado como endereço.

00:30:45.520 --> 00:30:49.960
E agora apenas um prompt aqui, observe que este ponteiro é muito grande.

00:30:49.960 --> 00:30:51.940
É como oito quadrados.

00:30:51.940 --> 00:30:53.350
Qual é a implicação disso?

00:30:53.350 --> 00:30:55.000
Porque eu fiz isso deliberadamente.

00:30:55.000 --> 00:30:59.205
Qual deve ser o tamanho de um ponteiro aparentemente na maioria dos sistemas modernos, você diria?

00:30:59.205 --> 00:31:00.080
AUDIÊNCIA: [INAUDÍVEL]

00:31:00.080 --> 00:31:00.490
DAVID J. MALAN: OK, bom.

00:31:00.490 --> 00:31:01.480
Os computadores hoje são muito grandes.

00:31:01.480 --> 00:31:03.310
Você tem gigabytes de RAM em seu computador.

00:31:03.310 --> 00:31:05.477
Portanto, você precisa de ponteiros grandes para poder apontar,

00:31:05.477 --> 00:31:07.640
e memória que está conceitualmente muito distante.

00:31:07.640 --> 00:31:10.840
Então, para ser claro, quantos bytes um ponteiro aparentemente ocupa?

00:31:10.840 --> 00:31:12.820
Bem, parece ocupar 8 no total.

00:31:12.820 --> 00:31:15.280
Inteiros por convenção hoje em dia são geralmente 4.

00:31:15.280 --> 00:31:18.393
Os ponteiros, embora hoje em dia, sejam tipicamente 8 neste caso.

00:31:18.393 --> 00:31:20.810
Então estou desenhando de uma forma consistente com a realidade,

00:31:20.810 --> 00:31:23.260
mesmo que no final do dia, não seja tão interessante

00:31:23.260 --> 00:31:24.590
quais são os valores aqui.

00:31:24.590 --> 00:31:27.012
Na verdade, vamos emergir dessas ervas daninhas.

00:31:27.012 --> 00:31:28.720
Eu realmente não me importo com o que mais está acontecendo

00:31:28.720 --> 00:31:31.012
na memória do meu computador no momento porque eu só

00:31:31.012 --> 00:31:34.450
tenho aquelas duas linhas de código suculento definindo n e definindo p.

00:31:34.450 --> 00:31:36.370
Então, vamos esconder todos os outros quadrados.

00:31:36.370 --> 00:31:39.190
E, honestamente, falo sério quando digo que os programadores

00:31:39.190 --> 00:31:43.490
precisa saber que uma variável existe em algum lugar na memória,

00:31:43.490 --> 00:31:46.660
e precisa ser capaz de obter esse endereço usando o e comercial,

00:31:46.660 --> 00:31:50.680
mas você nunca imprimirá como eu fiz, o endereço real.

00:31:50.680 --> 00:31:53.680
Geralmente não é interessante, a menos que você esteja depurando seu código.

00:31:53.680 --> 00:31:57.250
Mas você não vai começar a digitar números 0x malucos em seu código

00:31:57.250 --> 00:31:58.370
para mover as coisas.

00:31:58.370 --> 00:32:01.720
Você só precisa saber que o computador pode descobrir onde as coisas estão.

00:32:01.720 --> 00:32:05.800
Então, francamente, por essa lógica, quem se importa se é 0x123?

00:32:05.800 --> 00:32:08.510
Amanhã, pode ser 0x456 ou outra coisa.

00:32:08.510 --> 00:32:12.610
Portanto, uma das maneiras de pensar em um ponteiro é literalmente como

00:32:12.610 --> 00:32:15.890
uma variável que aponta para outra coisa.

00:32:15.890 --> 00:32:19.750
E de fato, neste caso, p, sim, tecnicamente tem um endereço.

00:32:19.750 --> 00:32:22.030
E sim, tecnicamente é 0x123 nesta história.

00:32:22.030 --> 00:32:23.140
Mas honestamente, quem se importa?

00:32:23.140 --> 00:32:28.900
Eu só preciso saber que usando p, posso chegar ao valor n.

00:32:28.900 --> 00:32:30.370
E então, quais são esses endereços?

00:32:30.370 --> 00:32:33.430
E, de fato, se Carter não se importasse de se juntar a mim aqui por um momento,

00:32:33.430 --> 00:32:34.480
quais são esses endereços?

00:32:34.480 --> 00:32:36.760
Bem, assim como em nosso mundo humano, temos caixas de correio,

00:32:36.760 --> 00:32:39.260
mesmo que você não verifique com muita frequência hoje em dia,

00:32:39.260 --> 00:32:43.060
mas para receber correspondência física, cada casa, cada empresa tem um endereço único.

00:32:43.060 --> 00:32:47.080
O Complexo de Ciência e Engenharia fica na 150 Western Avenue Allston,

00:32:47.080 --> 00:32:49.930
Massachusetts, 02134 EUA.

00:32:49.930 --> 00:32:53.830
E teoricamente, isso identifica exclusivamente aquele edifício no mundo.

00:32:53.830 --> 00:32:56.170
Bem, aqui temos duas caixas de correio.

00:32:56.170 --> 00:33:00.160
Aqui, temos um valor n que passa a viver, vou reivindicar,

00:33:00.160 --> 00:33:01.960
no endereço 0x123.

00:33:01.960 --> 00:33:07.092
E então aqui, afirmo que há outro endereço chamado pelo nome p.

00:33:07.092 --> 00:33:10.300
Na verdade, não me importo onde está, embora definitivamente exista em algum lugar

00:33:10.300 --> 00:33:11.540
na memória do computador.

00:33:11.540 --> 00:33:16.090
Mas se este é p, que é uma variável, e aquele é n, outra variável,

00:33:16.090 --> 00:33:18.178
idealmente, esta caixa de correio seria duas vezes maior

00:33:18.178 --> 00:33:19.720
por causa do número de bytes usando.

00:33:19.720 --> 00:33:22.060
Mas a Home Depot só tinha caixas de correio de tamanhos idênticos.

00:33:22.060 --> 00:33:23.830
Mas aqui está p, uma variável.

00:33:23.830 --> 00:33:25.690
Existe n, outra variável.

00:33:25.690 --> 00:33:30.790
Se eu abrir esta caixa de correio, o que devo encontrar dentro dela

00:33:30.790 --> 00:33:33.250
baseado em nossa história até agora?

00:33:33.250 --> 00:33:36.970
Que valor retirarei dramaticamente em apenas um momento?

00:33:36.970 --> 00:33:37.810
Sim eu acho.

00:33:37.810 --> 00:33:39.640
0x123.

00:33:39.640 --> 00:33:42.160
Agora, usando isso, você pode pensar nisso como X

00:33:42.160 --> 00:33:44.770
marca o local, sem trocadilhos, onde agora posso

00:33:44.770 --> 00:33:48.737
percorrer a memória do computador e encontrar o caminho para esse local

00:33:48.737 --> 00:33:50.320
meio que seguindo o mapa do tesouro.

00:33:50.320 --> 00:33:53.770
Ou se eu quiser mais dramaticamente, graças à nossa pequena espuma Yale

00:33:53.770 --> 00:33:58.385
dedo aqui, você pode pensar nisso de forma mais abstrata, pois p está apenas apontando para n.

00:33:58.385 --> 00:33:59.510
Isso não está indo bem.

00:33:59.510 --> 00:34:01.177
Então, vamos mudar para Harvard.

00:34:01.177 --> 00:34:02.775
Então p está apontando--

00:34:02.775 --> 00:34:03.400
AUDIÊNCIA: Uau.

00:34:06.100 --> 00:34:07.740
DAVID J. MALAN: Então p está apontando para n.

00:34:07.740 --> 00:34:10.620
E assim descobrimos que seremos capazes de escrever código agora

00:34:10.620 --> 00:34:13.252
isso fará o equivalente a eu caminhar até n.

00:34:13.252 --> 00:34:15.960
Mas por enquanto, Carter, se quiser revelar o que há na caixa de correio,

00:34:15.960 --> 00:34:19.170
deveríamos ver de fato o número 50.

00:34:19.170 --> 00:34:20.878
Então isso é realmente tudo isso--

00:34:20.878 --> 00:34:22.170
Carter está esperando por aplausos.

00:34:22.170 --> 00:34:24.300
Então, realmente, bem feito.

00:34:28.270 --> 00:34:28.929
Obrigado.

00:34:28.929 --> 00:34:31.900
Isso é apenas uma metáfora física do que está acontecendo aqui.

00:34:31.900 --> 00:34:33.760
Em uma variável, temos um endereço.

00:34:33.760 --> 00:34:36.070
E essa variável por convenção é chamada de ponteiro.

00:34:36.070 --> 00:34:39.550
Na outra variável por semana, temos apenas um valor como n.

00:34:39.550 --> 00:34:43.105
E você pode, sim, seguir o mapa e caminhar sozinho

00:34:43.105 --> 00:34:44.230
para aquele endereço específico.

00:34:44.230 --> 00:34:45.772
E veremos como fazer isso no código.

00:34:45.772 --> 00:34:49.389
Mas o que é realmente interessante é essa abstração, que os ponteiros literalmente,

00:34:49.389 --> 00:34:54.310
ou realmente acho, figurativamente, apontar para algum outro valor na memória.

00:34:54.310 --> 00:34:56.658
Tudo bem, perguntas, então, sobre ponteiros neste formulário.

00:34:56.658 --> 00:34:58.450
AUDIÊNCIA: Os ponteiros podem apontar uns para os outros?

00:34:58.450 --> 00:34:59.990
DAVID J. MALAN: Os ponteiros podem apontar uns para os outros?

00:34:59.990 --> 00:35:00.790
Então sim.

00:35:00.790 --> 00:35:02.590
Existem coisas chamadas ponteiros duplos.

00:35:02.590 --> 00:35:04.298
Não vamos vê-los tão cedo.

00:35:04.298 --> 00:35:08.380
Mas usando estrela, estrela, você pode expressar um endereço de um endereço.

00:35:08.380 --> 00:35:10.370
Mas não veremos isso ainda.

00:35:10.370 --> 00:35:13.920
Outras perguntas sobre ponteiros?

00:35:13.920 --> 00:35:15.401
Sim, na frente.

00:35:15.401 --> 00:35:18.630
AUDIÊNCIA: [INAUDÍVEL]

00:35:18.630 --> 00:35:21.900
DAVID J. MALAN: Arrays-- para resumir, arrays são ponteiros?

00:35:21.900 --> 00:35:23.767
Então, resposta curta, há um relacionamento.

00:35:23.767 --> 00:35:25.600
E voltaremos a isso daqui a pouco.

00:35:25.600 --> 00:35:28.020
Mas matrizes são tecnicamente diferentes de ponteiros.

00:35:28.020 --> 00:35:30.965
Mas seremos capazes de desfocar um pouco as linhas usando um

00:35:30.965 --> 00:35:31.590
como o outro.

00:35:31.590 --> 00:35:34.090
Mas deixe-me voltar a isso daqui a pouco.

00:35:34.090 --> 00:35:34.590
Tudo bem.

00:35:34.590 --> 00:35:38.350
Então, se tivermos agora este modelo mental, se você quiser,

00:35:38.350 --> 00:35:41.460
do que um ponteiro está na memória, acho que

00:35:41.460 --> 00:35:45.000
pode começar a descascar uma camada de simplificação

00:35:45.000 --> 00:35:47.700
que assumimos nas últimas semanas desde a primeira semana.

00:35:47.700 --> 00:35:50.380
Portanto, uma string, lembre-se, é uma sequência de caracteres.

00:35:50.380 --> 00:35:52.380
E então, se você quiser criar uma string que diz,

00:35:52.380 --> 00:35:54.870
oi, em letras maiúsculas e ponto de exclamação,

00:35:54.870 --> 00:35:57.480
fazemos string s igual a aspas sem aspas "oi".

00:35:57.480 --> 00:36:00.070
E podemos codificar assim, ou podemos usar get string.

00:36:00.070 --> 00:36:01.903
Mas, por enquanto, suponha que eu o codifiquei

00:36:01.903 --> 00:36:06.097
no meu código para sempre dizer, oi, em letras maiúsculas com um ponto de exclamação.

00:36:06.097 --> 00:36:08.430
Bem, como fica isso na memória do computador?

00:36:08.430 --> 00:36:10.650
Bem, vamos parar de olhar para toda a memória

00:36:10.650 --> 00:36:12.630
e vamos nos concentrar no que realmente está acontecendo.

00:36:12.630 --> 00:36:17.430
Depois de criar uma string chamada S e armazenar nela hi,

00:36:17.430 --> 00:36:19.740
você sabe que algumas coisas estão acontecendo.

00:36:19.740 --> 00:36:24.030
H, e I, e o ponto de exclamação estão acabando na memória do computador.

00:36:24.030 --> 00:36:29.670
Sabemos desde a segunda semana que essa coisa, o chamado personagem NUL, NUL, AKA

00:36:29.670 --> 00:36:32.632
barra invertida zero, também está sendo adicionado para você.

00:36:32.632 --> 00:36:33.840
E está em algum lugar na memória.

00:36:33.840 --> 00:36:36.360
No momento, eu realmente não me importo onde desenhei no canto inferior direito.

00:36:36.360 --> 00:36:37.435
Sim, tem endereço.

00:36:37.435 --> 00:36:39.060
Mas, por enquanto, acaba em algum lugar.

00:36:39.060 --> 00:36:43.470
E, de fato, aqui está uma pequena dica visual de como isso acontece.

00:36:43.470 --> 00:36:47.370
Em C, sempre que você usa aspas duplas para fornecer uma string,

00:36:47.370 --> 00:36:50.580
você pode imaginar que as aspas duplas são como uma pista

00:36:50.580 --> 00:36:55.200
para não apenas armazenar o ponto de exclamação HI, mas também colocar o caractere NUL lá

00:36:55.200 --> 00:36:55.720
para você.

00:36:55.720 --> 00:36:59.670
E isso contrasta com quais caracteres, se você quiser caracteres individuais, quais

00:36:59.670 --> 00:37:01.545
sintaxe usamos em vez disso?

00:37:01.545 --> 00:37:02.420
AUDIÊNCIA: [INAUDÍVEL]

00:37:02.420 --> 00:37:03.795
DAVID J. MALAN: Aspas simples.

00:37:03.795 --> 00:37:06.190
As aspas simples não adicionam magicamente um zero de barra invertida.

00:37:06.190 --> 00:37:08.000
Eles literalmente armazenam apenas um caractere.

00:37:08.000 --> 00:37:10.167
Então, novamente, as cordas sempre foram um pouco especiais.

00:37:10.167 --> 00:37:11.110
Você ganha algum extra--

00:37:11.110 --> 00:37:13.720
um byte extra de graça para que você saiba onde

00:37:13.720 --> 00:37:17.270
a string termina e funções como STR compare podem encontrar seu caminho até lá.

00:37:17.270 --> 00:37:20.630
Então, na memória, pode realmente parecer um pouco com isso.

00:37:20.630 --> 00:37:24.068
E se assumirmos que haverá algum lugar na memória,

00:37:24.068 --> 00:37:26.110
essas coisas estarão em algum lugar na memória,

00:37:26.110 --> 00:37:29.270
podemos abordá-los por semana dois por meio do nome da variável.

00:37:29.270 --> 00:37:31.578
Portanto, se S é o nome da variável, S colchete 0

00:37:31.578 --> 00:37:33.370
é como você se referiria à primeira letra.

00:37:33.370 --> 00:37:34.630
Suporte S 1, Suporte S 2.

00:37:34.630 --> 00:37:39.100
E se você realmente quiser, o colchete S 3 o levaria ao caractere NUL

00:37:39.100 --> 00:37:40.370
bem no final.

00:37:40.370 --> 00:37:41.830
Mas o que é S?

00:37:41.830 --> 00:37:45.430
Então, tecnicamente, nesta linha de código aqui, não apenas

00:37:45.430 --> 00:37:51.150
é o computador que está fornecendo memória para HI ponto de exclamação barra invertida zero, nós--

00:37:51.150 --> 00:37:54.430
verifica-se que o próprio S deve ocupar uma certa quantidade de espaço

00:37:54.430 --> 00:37:55.570
porque S é a variável.

00:37:55.570 --> 00:37:57.778
E toda vez que falamos sobre variáveis ​​até agora,

00:37:57.778 --> 00:38:00.980
Dei a você um retângulo na tela para armazenar seu valor.

00:38:00.980 --> 00:38:05.650
Então, vamos supor para fins de discussão que o H está em 0x123

00:38:05.650 --> 00:38:09.520
e eu está em 0x124 ponto de exclamação está em 0x125,

00:38:09.520 --> 00:38:11.740
e o caractere NUL está em 0x126.

00:38:11.740 --> 00:38:13.390
Bem, então o que é S?

00:38:13.390 --> 00:38:16.107
Bem, s será apenas outra variável.

00:38:16.107 --> 00:38:18.940
E vou desenhá-lo um tanto abstratamente sem todas as outras caixas,

00:38:18.940 --> 00:38:19.630
aqui em cima.

00:38:19.630 --> 00:38:22.270
E direi que o nome dessa variável é s.

00:38:22.270 --> 00:38:25.000
Mas acontece, o que é realmente?

00:38:25.000 --> 00:38:27.130
Como as cordas realmente funcionam?

00:38:27.130 --> 00:38:30.640
Bem, s é uma variável desde a primeira semana.

00:38:30.640 --> 00:38:33.730
Mas quando você o define, o que o computador está fazendo por você automaticamente

00:38:33.730 --> 00:38:36.940
é quando ele sabe que você deseja armazenar o ponto de exclamação HI,

00:38:36.940 --> 00:38:38.440
ele coloca isso em algum lugar na memória.

00:38:38.440 --> 00:38:40.720
O computador então descobre para você, o que é

00:38:40.720 --> 00:38:42.880
o endereço do primeiro caractere?

00:38:42.880 --> 00:38:46.120
E armazena esse endereço, e apenas esse endereço,

00:38:46.120 --> 00:38:50.080
na variável que você criou no lado esquerdo do sinal de igual.

00:38:50.080 --> 00:38:51.370
E isso é o suficiente.

00:38:51.370 --> 00:38:55.120
Para representar uma string com três letras do alfabeto ou pontuação,

00:38:55.120 --> 00:38:57.590
você não precisa de três variáveis.

00:38:57.590 --> 00:38:58.450
Você só precisa de um.

00:38:58.450 --> 00:39:02.050
Você só precisa saber o início da string.

00:39:02.050 --> 00:39:02.810
Por que?

00:39:02.810 --> 00:39:06.790
Por que é suficiente para uma variável armazenar apenas o endereço do primeiro byte,

00:39:06.790 --> 00:39:09.456
e nem todos os endereços dos bytes?

00:39:09.456 --> 00:39:11.380
AUDIÊNCIA: [INAUDÍVEL]

00:39:11.380 --> 00:39:12.380
DAVID J. MALAN: Exatamente.

00:39:12.380 --> 00:39:17.360
Por causa do design de strings por semana dois, nós sempre terminamos com NUL.

00:39:17.360 --> 00:39:20.013
Portanto, basta lembrar apenas o endereço do primeiro byte.

00:39:20.013 --> 00:39:22.430
Porque a partir daí, você pode seguir as migalhas de pão

00:39:22.430 --> 00:39:23.690
byte, após byte, após byte.

00:39:23.690 --> 00:39:27.140
E até você ver a nova linha, desculpe, o caractere NUL,

00:39:27.140 --> 00:39:31.230
você sabe que todos esses caracteres aparentemente fazem parte da mesma string.

00:39:31.230 --> 00:39:35.600
Então é isso que está acontecendo na memória do computador desde a primeira semana.

00:39:35.600 --> 00:39:37.430
E, de fato, se abstrairmos isso, você

00:39:37.430 --> 00:39:42.590
pode realmente pensar em S como sendo apenas isso, realmente um ponteiro

00:39:42.590 --> 00:39:44.400
para aquele pedaço de memória.

00:39:44.400 --> 00:39:46.920
Então, de fato, o que temos aqui?

00:39:46.920 --> 00:39:51.360
Bem, à esquerda para recapitular o código aqui, na string do lado esquerdo,

00:39:51.360 --> 00:39:54.170
é isso que garante que seremos realmente capazes de armazenar

00:39:54.170 --> 00:39:55.880
uma string em uma variável chamada s.

00:39:55.880 --> 00:39:59.760
Nós vamos ter no lado direito, porém, o valor real.

00:39:59.760 --> 00:40:01.460
Então, deixe-me voltar para o VS Code aqui.

00:40:01.460 --> 00:40:04.490
E deixe-me mudar meu código para não envolver mais números inteiros sozinhos.

00:40:04.490 --> 00:40:09.260
Vou adicionar a biblioteca CS50 apenas para

00:40:09.260 --> 00:40:11.000
que eu posso usar alguns atalhos lá.

00:40:11.000 --> 00:40:11.783
CS50.h.

00:40:11.783 --> 00:40:14.450
E então, na minha função principal, vou seguir em frente e fazer isso.

00:40:14.450 --> 00:40:18.270
String s é igual a aspas sem aspas "HI" em letras maiúsculas, ponto de exclamação.

00:40:18.270 --> 00:40:22.220
E então vou imprimir usando %S como sempre barra invertida n

00:40:22.220 --> 00:40:23.270
o valor de s.

00:40:23.270 --> 00:40:25.530
Portanto, este programa no momento não é nada interessante.

00:40:25.530 --> 00:40:29.690
É apenas uma semana de material novamente. ./addresses realmente imprime hi.

00:40:29.690 --> 00:40:33.380
Mas acontece que agora que eu sei disso,

00:40:33.380 --> 00:40:36.530
o que realmente está acontecendo debaixo do capô todo esse tempo?

00:40:36.530 --> 00:40:40.640
Bem, aqui está a mesma linha de código que define a variável chamada S.

00:40:40.640 --> 00:40:46.880
E acontece que alguém quer adivinhar de que string é realmente um sinônimo?

00:40:46.880 --> 00:40:50.540
String, ao que parece, é uma mentira inocente que contamos desde a primeira semana.

00:40:50.540 --> 00:40:55.190
Não existe string como uma palavra-chave em C.

00:40:55.190 --> 00:40:57.110
É tecnicamente uma coisa CS50.

00:40:57.110 --> 00:40:57.650
Sim.

00:40:57.650 --> 00:40:58.733
AUDIÊNCIA: [INAUDÍVEL]

00:40:58.733 --> 00:41:00.650
DAVID J. MALAN: É um ponteiro para um personagem.

00:41:00.650 --> 00:41:03.410
Então, realmente, todo esse tempo, nós meio que mentimos para você.

00:41:03.410 --> 00:41:05.510
Não há "string" entre aspas.

00:41:05.510 --> 00:41:07.430
Na verdade, é char star.

00:41:07.430 --> 00:41:12.890
E se eu puder dramaticamente aqui, vá, as rodinhas.

00:41:12.890 --> 00:41:14.310
Isso não caiu muito bem.

00:41:14.310 --> 00:41:16.490
Então, o que temos feito?

00:41:16.490 --> 00:41:19.310
Bem, acontece que string é uma maneira muito mais fácil conceitualmente

00:41:19.310 --> 00:41:21.227
para pensar sobre o que é uma string de caracteres.

00:41:21.227 --> 00:41:24.053
Meu Deus, se tivéssemos começado na primeira semana fazendo você digitar char star,

00:41:24.053 --> 00:41:25.220
Sim, você pode superar isso.

00:41:25.220 --> 00:41:28.300
Mas isso é uma sintaxe muito feia, não é intelectualmente interessante

00:41:28.300 --> 00:41:28.800
de forma alguma.

00:41:28.800 --> 00:41:30.020
Então nós o abstraímos.

00:41:30.020 --> 00:41:33.740
O que era uma estrela char na primeira semana de C, contando a você

00:41:33.740 --> 00:41:35.210
na verdade, é chamado de string.

00:41:35.210 --> 00:41:37.400
Agora string é um termo de programadores R.C,

00:41:37.400 --> 00:41:39.800
programadores em qualquer linguagem usarão a palavra string

00:41:39.800 --> 00:41:41.430
para significar uma sequência de caracteres.

00:41:41.430 --> 00:41:45.510
Mas em C, não é tecnicamente uma palavra em si.

00:41:45.510 --> 00:41:49.080
É antes um sinônimo que nós mesmos criamos de alguma forma.

00:41:49.080 --> 00:41:50.960
Então, de fato, como fizemos isso?

00:41:50.960 --> 00:41:52.550
Bem, pense na semana passada.

00:41:52.550 --> 00:41:54.830
Na semana passada, propus que seria muito bom

00:41:54.830 --> 00:41:58.040
se tivéssemos um tipo de dados pessoa, que os criadores de C

00:41:58.040 --> 00:41:59.617
não pensava em décadas atrás.

00:41:59.617 --> 00:42:00.200
Mas tudo bem.

00:42:00.200 --> 00:42:01.520
Podemos defini-lo nós mesmos.

00:42:01.520 --> 00:42:02.940
O que fizemos aqui?

00:42:02.940 --> 00:42:05.400
Bem, estamos usando uma sintaxe assim.

00:42:05.400 --> 00:42:08.210
Lembre-se de que definimos uma pessoa como sendo o quê?

00:42:08.210 --> 00:42:09.800
Ser esta estrutura.

00:42:09.800 --> 00:42:12.080
Essa estrutura, usando a nova palavra-chave na semana passada,

00:42:12.080 --> 00:42:14.600
struct, significa que uma pessoa é apenas um nome e um número.

00:42:14.600 --> 00:42:16.100
E pode ter sido outras coisas.

00:42:16.100 --> 00:42:17.180
Nós apenas mantivemos as coisas simples.

00:42:17.180 --> 00:42:22.640
Mas como associei a pessoa a essa estrutura?

00:42:22.640 --> 00:42:25.070
Bem, nós afirmamos que era esse valor aqui,

00:42:25.070 --> 00:42:28.770
typedef, que como você pode esperar, define um tipo de dados.

00:42:28.770 --> 00:42:33.020
Então, o que fizemos como CS50 na primeira semana sem contar a você?

00:42:33.020 --> 00:42:36.950
Bem, poderíamos ter feito algo assim.

00:42:36.950 --> 00:42:38.318
Int em si é um pouco enigmático.

00:42:38.318 --> 00:42:41.360
E talvez devêssemos manter as coisas ainda mais simples, disse, ei, pessoal.

00:42:41.360 --> 00:42:44.990
Acontece que você pode definir números inteiros em C. E se você quiser fazer isso, bem,

00:42:44.990 --> 00:42:47.700
se você quiser criar a palavra-chave inteiro como um tipo de dados,

00:42:47.700 --> 00:42:49.760
você pode apenas typedef para int.

00:42:49.760 --> 00:42:53.570
Então typedef cria a palavra na extrema direita, integer,

00:42:53.570 --> 00:42:57.320
e cria um sinônimo para ele neste caso chamado int.

00:42:57.320 --> 00:43:00.590
Então, o que fizemos na primeira semana sem contar a você?

00:43:00.590 --> 00:43:04.490
Temos uma linha de código como esta na biblioteca CS50

00:43:04.490 --> 00:43:10.490
que associa entre aspas "string" com estrela mais criptográfica.

00:43:10.490 --> 00:43:15.110
E é por isso que, a partir da primeira semana, sempre que você usar a biblioteca CS50,

00:43:15.110 --> 00:43:18.297
você pode escrever a palavra string como se fosse um tipo de dados C real.

00:43:18.297 --> 00:43:21.380
E isso porque queríamos ter essa abstração, esses treinamentos

00:43:21.380 --> 00:43:23.060
roda nas primeiras semanas, então não

00:43:23.060 --> 00:43:25.393
tem que entrar no mato de toda essa coisa maluca de memória.

00:43:25.393 --> 00:43:27.740
Podemos falar sobre strings em um nível mais alto.

00:43:27.740 --> 00:43:29.120
Mas isso é tudo que eles são.

00:43:29.120 --> 00:43:31.970
Strings são o endereço do primeiro caractere

00:43:31.970 --> 00:43:34.760
nessa sequência de caracteres.

00:43:34.760 --> 00:43:38.220
Dúvidas agora sobre algum desses detalhes?

00:43:38.220 --> 00:43:38.720
Sim.

00:43:38.720 --> 00:43:41.460
AUDIÊNCIA: E as bibliotecas de strings que [INAUDÍVEL]??

00:43:41.460 --> 00:43:42.710
DAVID J. MALAN: Boa pergunta.

00:43:42.710 --> 00:43:45.910
E a biblioteca de strings, que usamos?

00:43:45.910 --> 00:43:46.600
Não relacionado.

00:43:46.600 --> 00:43:48.520
Portanto, não define a palavra string.

00:43:48.520 --> 00:43:51.430
Tudo lá realmente se relaciona com estrelas char.

00:43:51.430 --> 00:43:56.320
E então, de fato, se você usou o manual do CS50, que é apenas

00:43:56.320 --> 00:44:00.340
nossa versão amigável das páginas de manual reais para o idioma oficial,

00:44:00.340 --> 00:44:03.820
C, você verá isso agora se começar a bisbilhotar ou desligar

00:44:03.820 --> 00:44:05.830
modo menos confortável, você realmente verá

00:44:05.830 --> 00:44:08.350
que mudamos todas as menções de char star

00:44:08.350 --> 00:44:10.690
na documentação oficial para essas primeiras semanas

00:44:10.690 --> 00:44:12.610
para apenas string para simplificá-lo.

00:44:12.610 --> 00:44:17.350
Mas sob o capô, C não conhece a palavra string per se como uma palavra-chave.

00:44:17.350 --> 00:44:21.320
Mas é absolutamente um conceito que todos os programas do mundo conhecem.

00:44:21.320 --> 00:44:23.750
E de fato, em outras linguagens, em Python por exemplo,

00:44:23.750 --> 00:44:26.227
haverá realmente uma string adequada, embora não seja

00:44:26.227 --> 00:44:27.310
vai ser chamado de string.

00:44:27.310 --> 00:44:30.340
Vai se chamar STR, STR para abreviar.

00:44:30.340 --> 00:44:33.470
Perguntas sobre essas cordas aqui.

00:44:33.470 --> 00:44:36.520
Bem, deixe-me propor que há outro recurso dessa sintaxe

00:44:36.520 --> 00:44:38.960
que agora podemos aproveitar da seguinte maneira.

00:44:38.960 --> 00:44:43.060
Deixe-me propor que, se voltarmos à versão anterior do meu código

00:44:43.060 --> 00:44:46.760
aqui, em que, deixe-me voltar para o VS Code em apenas um momento,

00:44:46.760 --> 00:44:51.800
Vou retroceder no VS Code para a versão inteira do meu código anterior.

00:44:51.800 --> 00:44:55.540
E, mais recentemente, parecia assim, antes, quando estávamos usando números inteiros

00:44:55.540 --> 00:44:58.570
apenas e não, de fato, strings.

00:44:58.570 --> 00:45:01.270
Deixe-me propor que há esse outro recurso de C

00:45:01.270 --> 00:45:04.360
que podemos usar que realmente nos permite ir a um endereço.

00:45:04.360 --> 00:45:07.090
Então, no momento, deixe-me apenas rebobinar e fazer, fazer endereços,

00:45:07.090 --> 00:45:10.660
para lembrá-lo do que este programa fazia quando estava usando inteiros sozinhos.

00:45:10.660 --> 00:45:12.010
E tem esse endereço.

00:45:12.010 --> 00:45:12.670
Por que?

00:45:12.670 --> 00:45:15.880
Porque na linha sete, observe, estou imprimindo

00:45:15.880 --> 00:45:17.710
o valor de p, que é um ponteiro.

00:45:17.710 --> 00:45:20.060
Então, é claro, vai se parecer com um endereço.

00:45:20.060 --> 00:45:22.660
Mas deixe-me diminuir o zoom agora e fazer uma alteração.

00:45:22.660 --> 00:45:27.730
Em vez de imprimir p, como posso usar o segundo novo operador de hoje,

00:45:27.730 --> 00:45:32.020
não o e comercial, mas a estrela, para realmente ir para esse endereço?

00:45:32.020 --> 00:45:35.170
Bem, o que posso realmente fazer nesta linha de código é isso.

00:45:35.170 --> 00:45:39.250
Se eu quiser imprimir o inteiro real 50 que está nessa variável,

00:45:39.250 --> 00:45:44.858
ou equivalentemente nesse endereço, posso ir para p aqui e não imprimir p literalmente,

00:45:44.858 --> 00:45:46.150
porque é apenas um endereço.

00:45:46.150 --> 00:45:48.910
Agora posso dizer, estrela p.

00:45:48.910 --> 00:45:51.310
E estrela p significa ir lá.

00:45:51.310 --> 00:45:53.200
Mais tecnicamente, desreferenciar p.

00:45:53.200 --> 00:45:56.560
Ou seja, siga o mapa do tesouro até o endereço real e faça o que Carter fez.

00:45:56.560 --> 00:46:00.260
Abra a caixa de correio e imprima o que estiver na caixa de correio, que lembra,

00:46:00.260 --> 00:46:02.380
era o número real 50.

00:46:02.380 --> 00:46:03.680
Então deixe-me tentar isso.

00:46:03.680 --> 00:46:05.270
Deixe-me recompilar o código.

00:46:05.270 --> 00:46:08.020
Então faça endereços.

00:46:08.020 --> 00:46:09.520
OK, deixe-me limpar a janela do meu terminal.

00:46:09.520 --> 00:46:10.510
Endereços de ponto e barra.

00:46:10.510 --> 00:46:12.640
Desta vez, não devo ver o 0x nada.

00:46:12.640 --> 00:46:16.550
Eu deveria ver apenas o número 50 neste caso.

00:46:16.550 --> 00:46:19.990
E aqui também é uma decisão de design infeliz, certamente

00:46:19.990 --> 00:46:23.290
pedagogicamente eu diria em C. Se eu ampliar este código,

00:46:23.290 --> 00:46:26.335
infelizmente, a estrela está sendo usada de duas maneiras diferentes.

00:46:26.335 --> 00:46:28.960
Em um mundo ideal, eles teriam usado três símbolos diferentes

00:46:28.960 --> 00:46:30.550
para tornar isso mais claro semanticamente.

00:46:30.550 --> 00:46:32.030
Mas é com isso que estamos presos.

00:46:32.030 --> 00:46:35.370
Então, na linha seis, quando você declara um ponteiro,

00:46:35.370 --> 00:46:37.120
que é uma variável que armazena um endereço,

00:46:37.120 --> 00:46:39.520
você coloca o tipo de variável que você quer

00:46:39.520 --> 00:46:42.865
para apontar, então uma estrela só porque, e então o nome da variável.

00:46:42.865 --> 00:46:44.740
E então, no lado direito, você realmente

00:46:44.740 --> 00:46:47.590
obtenha o endereço de qualquer coisa usando e comercial.

00:46:47.590 --> 00:46:51.790
Mas quando você quer ir para um endereço, você quer desreferenciar um ponteiro,

00:46:51.790 --> 00:46:53.380
você não usa int novamente.

00:46:53.380 --> 00:46:54.640
E nunca fizemos isso.

00:46:54.640 --> 00:46:57.100
Depois de declarar uma variável, você nunca mais menciona o tipo de dados.

00:46:57.100 --> 00:46:58.975
Mas no mundo dos ponteiros agora, se você quiser

00:46:58.975 --> 00:47:03.340
para não imprimir p, mas ir para qualquer endereço que p esteja armazenando,

00:47:03.340 --> 00:47:05.180
você usa estrela p aqui.

00:47:05.180 --> 00:47:07.570
Portanto, um bom indicador visual seria quando você

00:47:07.570 --> 00:47:10.850
declare um ponteiro, ou seja, faça-o existir em seu programa,

00:47:10.850 --> 00:47:13.900
você tem que declarar o tipo de dados com a estrela.

00:47:13.900 --> 00:47:16.405
Mas quando você usa um ponteiro, usa apenas a estrela.

00:47:16.405 --> 00:47:19.030
Em um mundo ideal, este seria um símbolo completamente diferente.

00:47:19.030 --> 00:47:21.310
Mas, novamente, é isso que temos.

00:47:21.310 --> 00:47:23.920
Perguntas agora sobre essa sintaxe.

00:47:23.920 --> 00:47:25.077
Sim.

00:47:25.077 --> 00:47:27.850
AUDIÊNCIA: [INAUDÍVEL]

00:47:27.850 --> 00:47:30.850
DAVID J. MALAN: Por que não podemos apenas fazer o e comercial aqui, você está dizendo?

00:47:30.850 --> 00:47:32.260
Ainda estava um pouco quieto.

00:47:32.260 --> 00:47:34.600
Portanto, estritamente falando, não precisamos da linha seis.

00:47:34.600 --> 00:47:36.730
Portanto, é realmente por uma questão pedagógica que eu

00:47:36.730 --> 00:47:41.320
estou definindo uma variável p separada e, em seguida, imprimindo-a.

00:47:41.320 --> 00:47:44.500
Neste ponto, porém, estou meio que andando em círculos, se você quiser.

00:47:44.500 --> 00:47:46.480
Porque mais simples teria sido o que eu

00:47:46.480 --> 00:47:49.150
teria feito na primeira semana, o que seria se livrar de p

00:47:49.150 --> 00:47:52.660
completamente, livre-se de p aqui e apenas imprima n.

00:47:52.660 --> 00:47:56.710
Mas hoje, estamos apenas dando a você este novo bloco de construção, esta nova sintaxe,

00:47:56.710 --> 00:47:59.170
através do qual você pode descobrir o endereço de algo,

00:47:59.170 --> 00:48:04.450
e, em seguida, inverta o processo mais tarde e vá para ele também.

00:48:04.450 --> 00:48:08.200
Outras questões sobre o que fizemos aqui com esses ponteiros.

00:48:08.200 --> 00:48:08.700
Tudo bem.

00:48:08.700 --> 00:48:10.770
Bem, vamos mudar o contexto de volta para a string

00:48:10.770 --> 00:48:15.780
agora e veja o que mais podemos fazer com isso aqui no caso de nossas strings

00:48:15.780 --> 00:48:16.800
aqui.

00:48:16.800 --> 00:48:22.710
Deixe-me refinar isso para diminuir o zoom, deixe-me excluir o código relacionado a números inteiros aqui,

00:48:22.710 --> 00:48:27.480
deixe-me fazer string s igual a aspas sem aspas "HI" em maiúsculas, deixe-me ir em frente

00:48:27.480 --> 00:48:30.930
e por enquanto inclua CS50.h no topo

00:48:30.930 --> 00:48:36.390
para que eu possa usar a palavra-chave s, string em vez disso, e deixe-me prosseguir agora

00:48:36.390 --> 00:48:38.500
e fazer algo mais do que fiz da última vez.

00:48:38.500 --> 00:48:43.020
Da última vez, imprimi %s barra invertida n e, em seguida, imprimi s.

00:48:43.020 --> 00:48:45.990
E, novamente, vou recompilar isso apenas para maior clareza, criar endereços,

00:48:45.990 --> 00:48:46.920
endereços ponto barra.

00:48:46.920 --> 00:48:47.920
Isso apenas imprime oi.

00:48:47.920 --> 00:48:49.450
Então, isso é, novamente, material da primeira semana.

00:48:49.450 --> 00:48:52.260
Mas agora que temos essa outra parte da sintaxe,

00:48:52.260 --> 00:48:54.630
podemos fazer algumas coisas interessantes também.

00:48:54.630 --> 00:48:58.440
Então, por exemplo, suponha que eu queira imprimir o próprio not s,

00:48:58.440 --> 00:49:00.870
mas e se eu quiser imprimir o endereço de s?

00:49:00.870 --> 00:49:03.210
Em que local de memória está s?

00:49:03.210 --> 00:49:07.350
Bem, posso mudar meu %s para %p, que agora sabemos que p é para ponteiro.

00:49:07.350 --> 00:49:10.200
Então %p significa imprimir o valor de um ponteiro.

00:49:10.200 --> 00:49:11.280
Isso é um endereço.

00:49:11.280 --> 00:49:15.150
E aqui, eu posso realmente imprimir o próprio s.

00:49:15.150 --> 00:49:17.200
Mas por que isso acontece, veremos em um momento.

00:49:17.200 --> 00:49:19.200
Deixe-me fazer isso.

00:49:19.200 --> 00:49:20.850
Aqui vão as rodinhas.

00:49:20.850 --> 00:49:25.350
String não existe tecnicamente, mas existe se eu estiver usando a biblioteca CS50.

00:49:25.350 --> 00:49:28.380
Mas se eu me livrar da biblioteca CS50, como metaforicamente

00:49:28.380 --> 00:49:31.690
fazendo tirando as rodinhas, não consigo mais usar a palavra barbante.

00:49:31.690 --> 00:49:33.773
E, de fato, deixe-me cometer esse erro deliberadamente

00:49:33.773 --> 00:49:35.880
como você pode ter acidentalmente nas últimas semanas.

00:49:35.880 --> 00:49:40.470
Aqui está a mensagem de erro que recebo se eu esquecer a biblioteca CS50, use

00:49:40.470 --> 00:49:42.420
de string de identificador não declarado.

00:49:42.420 --> 00:49:43.830
Será que quis dizer padrão?

00:49:43.830 --> 00:49:46.872
Está tentando ser útil, mas não é porque eu não quis dizer o padrão n.

00:49:46.872 --> 00:49:48.870
Então, de fato, esta é a confirmação de que C não

00:49:48.870 --> 00:49:51.780
saiba que a palavra string existe, pelo menos como uma palavra-chave.

00:49:51.780 --> 00:49:54.130
Existe como um conceito, mas não como uma palavra-chave.

00:49:54.130 --> 00:49:57.515
Então, eu poderia consertar isso adicionando de volta a biblioteca CS50.

00:49:57.515 --> 00:50:00.390
Mas isso é meio que um retrocesso, educacionalmente, em vez de um passo

00:50:00.390 --> 00:50:00.930
avançar.

00:50:00.930 --> 00:50:05.605
O que eu poderia fazer para consertar isso agora, se as rodinhas estiverem desligadas?

00:50:05.605 --> 00:50:06.105
Sim.

00:50:06.105 --> 00:50:09.210
AUDIÊNCIA: [INAUDÍVEL]

00:50:09.210 --> 00:50:10.210
DAVID J. MALAN: Exatamente.

00:50:10.210 --> 00:50:13.808
Substitua "string" entre aspas por char star.

00:50:13.808 --> 00:50:15.850
Então, vou mudar isso para char.

00:50:15.850 --> 00:50:18.280
Tecnicamente, você pode colocar a estrela literal aqui,

00:50:18.280 --> 00:50:21.310
o asterisco, ou você pode colocá-lo lá, ou você pode colocá-lo aqui.

00:50:21.310 --> 00:50:23.710
Por convenção é fazer o que eu fiz desde o início,

00:50:23.710 --> 00:50:28.180
coloque a estrela ao lado do nome da variável em oposição a qualquer outro lugar.

00:50:28.180 --> 00:50:29.930
Deixe-me ir em frente agora e--

00:50:29.930 --> 00:50:30.447
ou desculpe.

00:50:30.447 --> 00:50:31.780
Eu pretendia adicionar os espaços lá.

00:50:31.780 --> 00:50:32.560
Você poderia fazer isso também.

00:50:32.560 --> 00:50:34.480
Mas esta seria a convenção mais normal.

00:50:34.480 --> 00:50:35.590
Então agora vamos fazer isso.

00:50:35.590 --> 00:50:39.850
Faça endereços, compila OK agora, endereços ponto-barra.

00:50:39.850 --> 00:50:40.990
O que devo ver?

00:50:40.990 --> 00:50:44.660
Oi ou algo mais?

00:50:44.660 --> 00:50:45.970
Sinta-se à vontade para apenas chamá-lo.

00:50:45.970 --> 00:50:46.918
AUDIÊNCIA: [INAUDÍVEL]

00:50:46.918 --> 00:50:48.460
DAVID J. MALAN: Então ainda oi, você diz?

00:50:48.460 --> 00:50:50.307
Alguém?

00:50:50.307 --> 00:50:51.390
AUDIÊNCIA: Localização da memória?

00:50:51.390 --> 00:50:52.410
DAVID J. MALAN: Um local de memória.

00:50:52.410 --> 00:50:54.510
Tudo bem, então pode ser uma das duas opções.

00:50:54.510 --> 00:50:57.552
Ou vou ver a string ou vou ver um endereço de memória.

00:50:57.552 --> 00:50:59.400
Embora eu veja, de fato, um endereço de memória.

00:50:59.400 --> 00:51:01.608
E este é bem diferente do inteiro.

00:51:01.608 --> 00:51:04.950
Mas alguém agora quer explicar por que você estava correto?

00:51:04.950 --> 00:51:09.000
Por que estou vendo o endereço aqui embaixo e não oi?

00:51:09.000 --> 00:51:09.640
É sutil.

00:51:09.640 --> 00:51:10.140
Sim.

00:51:10.140 --> 00:51:12.500
AUDIÊNCIA: [INAUDÍVEL]

00:51:12.500 --> 00:51:13.500
DAVID J. MALAN: Exatamente.

00:51:13.500 --> 00:51:17.490
Porque deixei meu %p lá, o que significa, ei, printf, mostre-me um ponteiro.

00:51:17.490 --> 00:51:21.030
Mas é aqui que printf é inteligente e tem sido inteligente desde a semana zero.

00:51:21.030 --> 00:51:26.475
Humanos que inventaram printf décadas atrás escreveram um código que percebe que OK,

00:51:26.475 --> 00:51:31.590
%s significa tratar o seguinte valor, não apenas como um endereço per se que obtém

00:51:31.590 --> 00:51:34.890
impresso literalmente, mas imprima como na demonstração da caixa de correio,

00:51:34.890 --> 00:51:39.300
como uma espécie de mapa do tesouro que leva você ao endereço de um personagem.

00:51:39.300 --> 00:51:42.750
Então, simplesmente mudando um caractere, %p para %s,

00:51:42.750 --> 00:51:45.840
e se eu agora fizer endereços novamente e endereços de ponto e barra,

00:51:45.840 --> 00:51:49.710
isso agora é idêntico à primeira semana, mas espero que faça sentido.

00:51:49.710 --> 00:51:56.100
Porque %s é apenas uma pista para printf que significa, vá para este endereço em s.

00:51:56.100 --> 00:52:00.990
Imprima todos os caracteres lá e daí em diante até ver, o quê?

00:52:00.990 --> 00:52:01.890
O caractere NUL.

00:52:01.890 --> 00:52:04.060
E então pare de imprimir mais alguma coisa.

00:52:04.060 --> 00:52:07.050
E é por isso que oi é impresso desde a primeira semana.

00:52:07.050 --> 00:52:09.690
Hoje, podemos ver o endereço %p.

00:52:09.690 --> 00:52:13.920
Mas essa combinação de ter acesso a endereços e ao terminador NUL

00:52:13.920 --> 00:52:16.740
é toda a informação que printf precisa para realmente fazer algo mais

00:52:16.740 --> 00:52:21.180
útil imprimindo as strings reais.

00:52:21.180 --> 00:52:26.250
Alguma pergunta agora sobre esta abordagem para %s?

00:52:26.250 --> 00:52:28.102
Sim, atrás.

00:52:28.102 --> 00:52:29.363
AUDIÊNCIA: [INAUDÍVEL]

00:52:29.363 --> 00:52:32.280
DAVID J. MALAN: Ah, então por que é tradicionalmente usado dessa maneira?

00:52:32.280 --> 00:52:34.662
Honestamente, a palavra string existe há décadas.

00:52:34.662 --> 00:52:37.620
Não é uma palavra-chave que você deve ser capaz de digitar em C, a menos que esteja usando

00:52:37.620 --> 00:52:39.450
uma biblioteca como a do CS50.

00:52:39.450 --> 00:52:41.190
E então s significa apenas string.

00:52:41.190 --> 00:52:45.060
Portanto, embora não exista como uma palavra-chave, %s conota string.

00:52:45.060 --> 00:52:48.250
E os humanos décadas atrás, como hoje, meio que sabem o que isso significa.

00:52:48.250 --> 00:52:50.458
Então eles poderiam ter escolhido qualquer letra do alfabeto.

00:52:50.458 --> 00:52:52.420
Mas s meio que faz mais sentido.

00:52:52.420 --> 00:52:52.920
Tudo bem.

00:52:52.920 --> 00:52:54.150
Bem, vamos-- lá atrás.

00:52:54.150 --> 00:52:54.930
Outra questão?

00:52:54.930 --> 00:52:56.310
AUDIÊNCIA: [INAUDÍVEL]

00:52:56.310 --> 00:52:57.560
DAVID J. MALAN: Boa pergunta.

00:52:57.560 --> 00:52:58.560
Antes-- deixe-me aumentar o zoom.

00:52:58.560 --> 00:53:01.010
Eu não usei uma estrela antes do s.

00:53:01.010 --> 00:53:01.760
Por que?

00:53:01.760 --> 00:53:03.290
Bem, é sutil aqui.

00:53:03.290 --> 00:53:07.340
Mas printf foi inventado anos atrás para saber,

00:53:07.340 --> 00:53:11.430
dado um endereço como na variável s, printf sabe que deve ir para lá.

00:53:11.430 --> 00:53:14.810
Então, se olharmos para o código-fonte que algum humano escreveu anos atrás para C,

00:53:14.810 --> 00:53:18.620
provavelmente veríamos o asterisco real ao qual você está se referindo.

00:53:18.620 --> 00:53:21.650
Printf está assumindo a responsabilidade de ir para s.

00:53:21.650 --> 00:53:26.510
Se você fosse fazer star s aqui, um asterisco e um s,

00:53:26.510 --> 00:53:29.570
isso agora seria literalmente um personagem.

00:53:29.570 --> 00:53:33.345
Porque se eu disser star s, isso significa ir para o endereço em s.

00:53:33.345 --> 00:53:35.720
E tudo o que você vai encontrar lá é um único personagem.

00:53:35.720 --> 00:53:39.680
O que printf quer saber não é, qual é o caractere aí?

00:53:39.680 --> 00:53:41.430
Qual é o endereço desse personagem?

00:53:41.430 --> 00:53:41.930
Por que?

00:53:41.930 --> 00:53:45.890
Porque printf precisa percorrer o restante desses caracteres

00:53:45.890 --> 00:53:48.770
procurando o caractere NUL final.

00:53:48.770 --> 00:53:51.140
E, de fato, deixe-me ver, com um pouco mais de sintaxe,

00:53:51.140 --> 00:53:52.830
se pudermos destacar isso um pouco mais.

00:53:52.830 --> 00:53:53.570
Deixe-me fazer isso.

00:53:53.570 --> 00:53:56.930
Além de imprimir s, vamos testar nossa sintaxe de outra maneira.

00:53:56.930 --> 00:54:01.040
Deixe-me imprimir com %s que tal não estar aqui,

00:54:01.040 --> 00:54:05.840
mas vamos imprimir alguns endereços. %s barra invertida n, aspas fechadas,

00:54:05.840 --> 00:54:08.030
e então vamos imprimir, que tal isso?

00:54:08.030 --> 00:54:12.440
O primeiro caractere na string s seria chamado de s colchete 0.

00:54:12.440 --> 00:54:16.425
Mas como obtenho o endereço do primeiro caractere em s?

00:54:16.425 --> 00:54:18.800
Bem, eu poderia tecnicamente usar o novo primitivo de hoje.

00:54:18.800 --> 00:54:19.967
Posso apenas adicionar um e comercial.

00:54:19.967 --> 00:54:22.620
Isso sempre me dá o endereço de algum valor.

00:54:22.620 --> 00:54:27.200
Então, quando eu terminar esse pensamento e limpar a janela do meu terminal

00:54:27.200 --> 00:54:29.660
e execute make address, ainda compila, quando

00:54:29.660 --> 00:54:32.090
Eu corro endereços em apenas um momento, qualquer palpite

00:54:32.090 --> 00:54:34.950
quanto ao que vou ver linha por linha?

00:54:34.950 --> 00:54:37.083
Isso imprimirá duas coisas.

00:54:37.083 --> 00:54:39.500
E você não precisa se lembrar qual era o número real.

00:54:39.500 --> 00:54:42.440
Mas em alto nível, o que será impresso agora?

00:54:42.440 --> 00:54:44.120
A mesma coisa duas vezes.

00:54:44.120 --> 00:54:44.700
Por que?

00:54:44.700 --> 00:54:48.080
Bem, quando eu executo isso, o que estou imprimindo aqui, e deixe-me ampliar na parte inferior,

00:54:48.080 --> 00:54:50.780
Na verdade, vejo dois endereços muito longos.

00:54:50.780 --> 00:54:52.100
Mas eles são, de fato, os mesmos.

00:54:52.100 --> 00:54:52.650
Por que?

00:54:52.650 --> 00:54:57.830
Bem, isso porque, novamente, se s é o endereço de um personagem, como está implícito agora

00:54:57.830 --> 00:55:02.750
pela string de palavras CS50 ou pela frase real char star, bem,

00:55:02.750 --> 00:55:04.370
então s é apenas um endereço.

00:55:04.370 --> 00:55:09.050
Em contraste, por semana dois, s colchete 0 é um char.

00:55:09.050 --> 00:55:11.230
Sempre foi um char, char específico.

00:55:11.230 --> 00:55:14.105
Mas se você quiser o endereço desse caractere, basta adicionar o e comercial.

00:55:14.105 --> 00:55:18.198
Bem, acontece que strings, de acordo com a definição que continuamos enfatizando,

00:55:18.198 --> 00:55:20.490
é apenas o endereço do primeiro caractere em uma string.

00:55:20.490 --> 00:55:23.550
Então, é claro, se você fizer isso, verá exatamente a mesma coisa.

00:55:23.550 --> 00:55:26.450
E se eu fizer isso um pouco mais, geralmente você não vai querer copiar e colar.

00:55:26.450 --> 00:55:28.940
Mas isso é apenas para fins de visualização.

00:55:28.940 --> 00:55:30.440
Deixe-me imprimir todos os caracteres.

00:55:30.440 --> 00:55:32.330
Então outro, outro, outro.

00:55:32.330 --> 00:55:36.200
E deixe-me mudar isso para imprimir o endereço do colchete um, colchete

00:55:36.200 --> 00:55:37.520
dois e parêntese três.

00:55:37.520 --> 00:55:40.310
Portanto, todos os quatro caracteres, H, I, ponto de exclamação,

00:55:40.310 --> 00:55:41.480
e o caractere NUL.

00:55:41.480 --> 00:55:43.920
Observe que estou usando %p para todos eles.

00:55:43.920 --> 00:55:47.330
Então, se eu agora fizer endereços e endereços de ponto e barra,

00:55:47.330 --> 00:55:49.590
agora observe, e isso é bem legal.

00:55:49.590 --> 00:55:51.530
Os dois primeiros são de fato ainda os mesmos.

00:55:51.530 --> 00:55:54.575
Mas o que é notável sobre os outros valores na tela?

00:55:57.180 --> 00:55:58.380
Sim, são consecutivos.

00:55:58.380 --> 00:55:59.822
Cada um deles está a apenas 1 byte de distância.

00:55:59.822 --> 00:56:03.030
Mesmo que você ainda não seja bom em hexadecimal e haja um número absurdo de dígitos aqui,

00:56:03.030 --> 00:56:03.670
quem se importa?

00:56:03.670 --> 00:56:07.420
Eles são todos iguais, exceto os últimos, quatro, quatro e depois cinco,

00:56:07.420 --> 00:56:07.920
seis sete.

00:56:07.920 --> 00:56:11.280
E isso confirma o que venho afirmando há semanas é que em uma matriz,

00:56:11.280 --> 00:56:16.380
todos os caracteres estão lado a lado contíguos a 1 byte de distância.

00:56:16.380 --> 00:56:18.960
Então, com apenas este e comercial, com apenas esta estrela,

00:56:18.960 --> 00:56:21.000
na verdade, é uma ferramenta muito legal no kit de ferramentas

00:56:21.000 --> 00:56:24.630
ter Porque você pode começar a bisbilhotar o que realmente está acontecendo

00:56:24.630 --> 00:56:27.220
dentro da memória do computador.

00:56:27.220 --> 00:56:31.710
E, de fato, se fizermos isso, posso apresentar outro truque legal aqui,

00:56:31.710 --> 00:56:32.490
Se você for.

00:56:32.490 --> 00:56:38.160
Deixe-me propor que agora podemos fazer aritmética com ponteiros.

00:56:38.160 --> 00:56:39.090
E você não precisa.

00:56:39.090 --> 00:56:40.780
Você verá uma maneira mais simples de fazer isso.

00:56:40.780 --> 00:56:44.790
Mas agora que você talvez tenha essa compreensão subjacente de onde

00:56:44.790 --> 00:56:46.710
as coisas estão na memória e são apenas endereços,

00:56:46.710 --> 00:56:48.850
podemos realmente fazer algo legal.

00:56:48.850 --> 00:56:50.950
Podemos fazer algo assim.

00:56:50.950 --> 00:56:55.470
Deixe-me voltar para a versão em string disso com hi.

00:56:55.470 --> 00:56:57.120
E deixe-me fazer isso em seu lugar.

00:56:57.120 --> 00:57:01.390
Deixe-me limpar isso um pouco, me livrar de algumas dessas linhas de código.

00:57:01.390 --> 00:57:02.290
E deixe-me fazer isso.

00:57:02.290 --> 00:57:04.975
Deixe-me imprimir %c, %c, %c.

00:57:04.975 --> 00:57:06.600
Deixe-me me livrar de todos esses e comerciais.

00:57:06.600 --> 00:57:09.210
Vamos reverter para as coisas da segunda semana.

00:57:09.210 --> 00:57:13.110
Só para esclarecer, quando compilo e executo esta versão do programa,

00:57:13.110 --> 00:57:17.100
e eu aumentar o zoom, o que deve ser impresso na tela?

00:57:17.100 --> 00:57:19.380
Este é apenas o material da segunda semana agora.

00:57:19.380 --> 00:57:20.864
Sem ponteiros em si.

00:57:20.864 --> 00:57:21.364
Sim.

00:57:21.364 --> 00:57:23.800
AUDIÊNCIA: [INAUDÍVEL]

00:57:23.800 --> 00:57:26.290
DAVID J. MALAN: Apenas HI ponto de exclamação, um por linha,

00:57:26.290 --> 00:57:28.040
porque eu tenho todas essas barras invertidas n's.

00:57:28.040 --> 00:57:29.150
Então deixe-me fazer isso.

00:57:29.150 --> 00:57:32.285
Deixe-me descer aqui, fazer endereços, entrar.

00:57:32.285 --> 00:57:32.960
OK, muito bom.

00:57:32.960 --> 00:57:33.980
Endereços de ponto e barra.

00:57:33.980 --> 00:57:36.140
E de fato HI ponto de exclamação.

00:57:36.140 --> 00:57:38.468
Mas agora, se você está ficando um pouco mais confortável,

00:57:38.468 --> 00:57:41.510
e tudo bem se você ainda não estiver hoje, mas nas próximas semanas,

00:57:41.510 --> 00:57:45.050
conforme você fica um pouco mais confortável com a equivalência de endereços

00:57:45.050 --> 00:57:48.720
com nossa definição no passado de arrays e strings, e tudo isso,

00:57:48.720 --> 00:57:50.180
você pode começar a brincar.

00:57:50.180 --> 00:57:51.680
E eu posso fazer isso em vez disso.

00:57:51.680 --> 00:57:56.060
Se eu quiser imprimir o primeiro caractere na string,

00:57:56.060 --> 00:57:58.023
Eu poderia fazer, como na segunda semana, s colchete 0.

00:57:58.023 --> 00:57:58.940
Isso sempre funcionará.

00:57:58.940 --> 00:57:59.960
E você pode continuar usando isso.

00:57:59.960 --> 00:58:00.960
Isso não é coisa do CS50.

00:58:00.960 --> 00:58:05.570
É apenas uma conveniência em C. Mas eu poderia tecnicamente imprimir not s,

00:58:05.570 --> 00:58:07.650
porque s é um endereço.

00:58:07.650 --> 00:58:13.240
Mas qual seria a sintaxe que eu poderia usar para dizer, imprima o caractere em s?

00:58:13.240 --> 00:58:15.070
Algum instinto?

00:58:15.070 --> 00:58:19.050
Como posso dizer, vá para o endereço em s?

00:58:19.050 --> 00:58:21.840
É uma das duas respostas possíveis hoje.

00:58:21.840 --> 00:58:24.030
Então, dos nossos dois novos--

00:58:24.030 --> 00:58:27.300
dos nossos dois novos operadores hoje, temos o e comercial e a estrela.

00:58:27.300 --> 00:58:30.405
Qual deles nos levará ao que está em um endereço?

00:58:30.405 --> 00:58:31.540
AUDIÊNCIA: [INAUDÍVEL]

00:58:31.540 --> 00:58:32.707
DAVID J. MALAN: Então a estrela.

00:58:32.707 --> 00:58:37.200
Na verdade, se eu quiser imprimir, o que está no endereço zero, no endereço s,

00:58:37.200 --> 00:58:39.390
Eu posso apenas fazer star s.

00:58:39.390 --> 00:58:42.060
E se você realmente quer ser chique, como você imprime

00:58:42.060 --> 00:58:45.300
o segundo caractere imediatamente à direita dele, por assim dizer?

00:58:45.300 --> 00:58:48.424
Bem, você pode ir, com o operador de referência -

00:58:48.424 --> 00:58:49.882
e você quer responder a esta?

00:58:49.882 --> 00:58:50.826
AUDIÊNCIA: [INAUDÍVEL]

00:58:50.826 --> 00:58:52.380
DAVID J. MALAN: S mais 1.

00:58:52.380 --> 00:58:54.300
Portanto, aritmética de ponteiros.

00:58:54.300 --> 00:58:56.430
Você pode fazer matemática, adição simples, subtração,

00:58:56.430 --> 00:58:58.140
seja o que for, em ponteiros, se você quiser.

00:58:58.140 --> 00:58:59.850
E você pode fazer isso aqui também.

00:58:59.850 --> 00:59:01.980
Então estrela, se você quiser arrancar este também,

00:59:01.980 --> 00:59:04.914
como faço para imprimir o último caractere, o terceiro?

00:59:04.914 --> 00:59:05.870
AUDIÊNCIA: s mais 2?

00:59:05.870 --> 00:59:07.227
DAVID J. MALAN: s mais 2.

00:59:07.227 --> 00:59:09.560
Porque se você sabe e entende que uma string é apenas

00:59:09.560 --> 00:59:11.935
uma sequência de caracteres, cada caractere é apenas um byte,

00:59:11.935 --> 00:59:14.160
e esses bytes estão de costas um para o outro,

00:59:14.160 --> 00:59:17.160
você pode ir onde quiser na memória do computador.

00:59:17.160 --> 00:59:20.150
E aqui, posso fazer endereços de novo, endereços de ponto e barra.

00:59:20.150 --> 00:59:23.030
E pronto, agora temos oi ponto de exclamação.

00:59:23.030 --> 00:59:25.100
Portanto, não imprimimos nada de novo.

00:59:25.100 --> 00:59:28.430
Mas, novamente, apenas usando esses dois novos operadores, o e comercial e a estrela,

00:59:28.430 --> 00:59:30.360
você pode descobrir o endereço de algo,

00:59:30.360 --> 00:59:33.020
e você pode ir para o endereço de alguma coisa.

00:59:33.020 --> 00:59:34.250
OK, pergunta atrás.

00:59:34.250 --> 00:59:35.352
AUDIÊNCIA: [INAUDÍVEL]

00:59:35.352 --> 00:59:36.310
DAVID J. MALAN: De fato.

00:59:36.310 --> 00:59:37.770
Acaba sendo exatamente o mesmo.

00:59:37.770 --> 00:59:39.520
E então eu poderia ter usado esse termo antes.

00:59:39.520 --> 00:59:41.890
A técnica do e comercial... desculpe.

00:59:41.890 --> 00:59:45.625
A técnica do colchete onde você faz s colchete zero, s colchete um,

00:59:45.625 --> 00:59:49.240
s colchete dois, isso é realmente o que chamaríamos de açúcar sintático.

00:59:49.240 --> 00:59:49.780
Funciona.

00:59:49.780 --> 00:59:50.572
E você pode usá-lo.

00:59:50.572 --> 00:59:51.322
Você deve usá-lo.

00:59:51.322 --> 00:59:52.210
É bom e simples.

00:59:52.210 --> 00:59:55.090
Mas a notação de colchetes sob o capô

00:59:55.090 --> 00:59:58.107
está essencialmente sendo convertido para isso, o que não é divertido.

00:59:58.107 --> 01:00:00.190
É quando você quer se exibir para seus amigos,

01:00:00.190 --> 01:00:01.773
você sabe como fazer coisas legais no código.

01:00:01.773 --> 01:00:05.313
Mas isso não é tão legível quanto apenas colchetes zero, um e dois.

01:00:05.313 --> 01:00:07.480
Mas isso é tudo o que está acontecendo sob o capô.

01:00:07.480 --> 01:00:09.745
E, novamente, é por isso que no CS50 gastamos tempo

01:00:09.745 --> 01:00:11.620
em alguns desses blocos de construção de nível inferior.

01:00:11.620 --> 01:00:14.290
Porque se você assumir que de fato a memória do seu computador é apenas

01:00:14.290 --> 01:00:19.510
esta grade de bytes e agora você tem a capacidade de código no código para obter um endereço

01:00:19.510 --> 01:00:22.600
e vá para um endereço, você pode começar a fazer o que quiser.

01:00:22.600 --> 01:00:25.210
E você pode vasculhar a memória de um computador em qualquer local.

01:00:25.210 --> 01:00:26.950
E aqui reside o perigo.

01:00:26.950 --> 01:00:28.660
Estou meio que no sistema de honra agora

01:00:28.660 --> 01:00:32.140
que se minha string for oi ponto de exclamação, é bom para mim

01:00:32.140 --> 01:00:34.930
para ir para o primeiro byte, o segundo e o terceiro.

01:00:34.930 --> 01:00:36.910
Mas eu poderia ficar meio louco agora.

01:00:36.910 --> 01:00:40.090
E se eu quiser ver o que está acontecendo na memória do computador, quero dizer,

01:00:40.090 --> 01:00:43.570
não há nada que me impeça de fazer como s mais 50.

01:00:43.570 --> 01:00:44.780
E vamos ver o que há.

01:00:44.780 --> 01:00:49.540
Portanto, faça endereços, endereços de ponto e barra, oi e, em seguida, OK, nada parece.

01:00:49.540 --> 01:00:51.522
Bem, que tal 5.000 bytes de distância?

01:00:51.522 --> 01:00:52.480
Vamos apenas bisbilhotar.

01:00:52.480 --> 01:00:54.105
O que há dentro da memória do computador?

01:00:54.105 --> 01:00:59.020
Portanto, crie endereços novamente, crie endereços, endereços de ponto e barra, Enter.

01:00:59.020 --> 01:01:00.400
OK, ainda nada lá.

01:01:00.400 --> 01:01:02.470
Vamos tentar 50.000.

01:01:02.470 --> 01:01:03.190
Tudo bem.

01:01:03.190 --> 01:01:05.860
Faça endereços, endereços de ponto e barra.

01:01:05.860 --> 01:01:07.530
OK, aí vemos.

01:01:07.530 --> 01:01:09.280
Provavelmente vocês já fizeram isso, alguns de vocês,

01:01:09.280 --> 01:01:12.322
por acidente porque você provavelmente foi muito longe para a esquerda ou para a direita

01:01:12.322 --> 01:01:14.710
em uma matriz tocando a memória que você não deveria.

01:01:14.710 --> 01:01:19.180
Basta dizer que não devo tocar cegamente em 50.000 bytes de distância.

01:01:19.180 --> 01:01:20.650
Porque quem sabe o que está lá?

01:01:20.650 --> 01:01:23.320
E, de fato, em seu computador, quando um programa está sendo executado,

01:01:23.320 --> 01:01:26.810
o computador o segmenta em diferentes segmentos de memória.

01:01:26.810 --> 01:01:30.790
E se você ficar um pouco ganancioso e tocar em outro segmento da memória

01:01:30.790 --> 01:01:34.510
que tecnicamente não foi alocado a você pelo Mac OS, Windows ou Linux,

01:01:34.510 --> 01:01:36.820
ou o sistema operacional, coisas ruins acontecem.

01:01:36.820 --> 01:01:38.320
E você obtém uma falha de segmentação.

01:01:38.320 --> 01:01:40.040
E isso significa que é um bug no seu código.

01:01:40.040 --> 01:01:41.500
Então agora você pode fazer isso.

01:01:41.500 --> 01:01:44.410
E isso significa que os hackers também podem fazer coisas assim.

01:01:44.410 --> 01:01:47.440
Se eles puderem de alguma forma injetar código em seu programa C,

01:01:47.440 --> 01:01:50.240
talvez eles possam vasculhar a memória do computador.

01:01:50.240 --> 01:01:52.360
E, de fato, esse é o tipo de técnica pela qual

01:01:52.360 --> 01:01:55.990
talvez um hacker realmente sofisticado possa saltar para esta memória, esta memória,

01:01:55.990 --> 01:01:58.780
esta memória procurando por algo como sua senha,

01:01:58.780 --> 01:02:01.960
ou suas informações financeiras, ou qualquer coisa que esteja no programa

01:02:01.960 --> 01:02:03.280
mas em algum outro endereço.

01:02:03.280 --> 01:02:06.520
Não há nada que impeça um adversário, pelo menos agora,

01:02:06.520 --> 01:02:09.610
de bisbilhotar se eles podem executar código em seu computador

01:02:09.610 --> 01:02:11.120
de fazer esse tipo de coisa.

01:02:11.120 --> 01:02:13.750
Portanto, existe novamente o poder de C, mas também o perigo.

01:02:13.750 --> 01:02:16.910
E você certamente sofrerá mais falhas de segmentação nos próximos dias.

01:02:16.910 --> 01:02:19.240
Mas, em última análise, o objetivo será ajudá-lo

01:02:19.240 --> 01:02:22.490
resolva-os em última análise e conserte as coisas.

01:02:22.490 --> 01:02:27.170
Mas, por enquanto, acho que foi um pouco.

01:02:27.170 --> 01:02:30.640
Então, deixe-me propor que continuemos e façamos uma pausa mais longa aqui,

01:02:30.640 --> 01:02:33.730
talvez 10 minutos, e comemos algumas tortas de whoopie no transepto.

01:02:33.730 --> 01:02:35.710
Estaremos de volta em 10.

01:02:35.710 --> 01:02:37.090
Tudo bem.

01:02:37.090 --> 01:02:38.470
Então estamos de volta.

01:02:38.470 --> 01:02:42.760
E para recapitular de onde paramos, agora você tem esse novo recurso no código

01:02:42.760 --> 01:02:45.220
para fazer aritmética de ponteiro como endereços de tratamento

01:02:45.220 --> 01:02:47.320
como números, que na verdade estão em hexadecimal

01:02:47.320 --> 01:02:49.720
ou não, e adicioná-los juntos e tipo

01:02:49.720 --> 01:02:51.440
de vasculhar a memória de um computador.

01:02:51.440 --> 01:02:55.180
E foi perguntado durante o intervalo, na verdade, como poderíamos promover

01:02:55.180 --> 01:02:56.980
aproveite isso no contexto de string.

01:02:56.980 --> 01:02:59.650
Portanto, não alterei o código que escrevemos antes do intervalo.

01:02:59.650 --> 01:03:04.960
Lembre-se de que quebramos o programa pela última vez verificando bytes a 50.000 bytes de distância.

01:03:04.960 --> 01:03:06.070
Mas não vamos fazer isso.

01:03:06.070 --> 01:03:09.760
E vamos tentar imprimir caracteres não individuais, como eu fiz,

01:03:09.760 --> 01:03:14.710
por %c, mas por que não tentamos imprimir strings e substrings

01:03:14.710 --> 01:03:15.290
Se você for?

01:03:15.290 --> 01:03:16.810
Então deixe-me limpar a janela do meu terminal.

01:03:16.810 --> 01:03:21.490
Deixe-me mudar todos esses %cs para %s, %s, %s.

01:03:21.490 --> 01:03:24.520
E então deixe-me voltar ao que estamos fazendo desde a primeira semana

01:03:24.520 --> 01:03:26.930
com strings, que é apenas imprimi-las,

01:03:26.930 --> 01:03:28.720
por exemplo, com aquela primeira linha.

01:03:28.720 --> 01:03:31.592
E a única diferença no momento é que agora, eu

01:03:31.592 --> 01:03:32.800
tirou as rodinhas.

01:03:32.800 --> 01:03:38.950
Eu me livrei de CS50.h onde string é typedef para char star para você.

01:03:38.950 --> 01:03:39.920
Livrei-me disso.

01:03:39.920 --> 01:03:42.640
Agora, na linha cinco, estou declarando s como sendo um char star, que

01:03:42.640 --> 01:03:44.223
significa apenas o endereço de um personagem.

01:03:44.223 --> 01:03:46.720
E printf é inteligente o suficiente para saber que o final de uma string

01:03:46.720 --> 01:03:48.560
é onde quer que o caractere NUL esteja.

01:03:48.560 --> 01:03:50.740
Mas agora que posso fazer aritmética de ponteiros,

01:03:50.740 --> 01:03:52.910
observe que eu poderia fazer algo assim.

01:03:52.910 --> 01:03:55.390
Se eu quiser imprimir s, apenas imprimo s.

01:03:55.390 --> 01:04:02.080
Suponha que eu faça s mais 1 aqui e s mais 2 aqui, novamente, depois de mudar %c para %s.

01:04:02.080 --> 01:04:10.240
Qualquer intuição sobre o que este código agora imprimirá na tela linha por linha.

01:04:10.240 --> 01:04:11.180
Sim, pensamentos?

01:04:11.180 --> 01:04:12.260
AUDIÊNCIA: [INAUDÍVEL]

01:04:12.260 --> 01:04:14.010
DAVID J. MALAN: OK, conjectura razoável.

01:04:14.010 --> 01:04:17.500
Talvez o endereço de memória de h, o de i, o do ponto de exclamação.

01:04:17.500 --> 01:04:18.550
Mas outros pensamentos?

01:04:18.550 --> 01:04:20.105
AUDIÊNCIA: [INAUDÍVEL]

01:04:20.105 --> 01:04:20.980
DAVID J. MALAN: Sim.

01:04:20.980 --> 01:04:22.510
Eu acho que vai realmente fazer o último.

01:04:22.510 --> 01:04:24.430
Vai imprimir, oi, da maneira usual.

01:04:24.430 --> 01:04:28.900
Porque, honestamente, a linha cinco é esta - em vez disso, a linha seis é a mesma da semana um

01:04:28.900 --> 01:04:31.240
coisas, exceto que tiramos a roda de treinamento da corda

01:04:31.240 --> 01:04:32.620
e estamos chamando de estrela char.

01:04:32.620 --> 01:04:35.770
Mas acho que a linha sete vai realmente imprimir i.

01:04:35.770 --> 01:04:38.440
E a linha oito vai imprimir

01:04:38.440 --> 01:04:40.480
porque será apenas o ponto de exclamação.

01:04:40.480 --> 01:04:45.040
Printf ainda será inteligente o suficiente para saber onde cada uma dessas substrings,

01:04:45.040 --> 01:04:47.860
partes das strings, terminam pela mesma lógica de sempre.

01:04:47.860 --> 01:04:51.370
Mas deixe-me ir em frente e diminuir o zoom, executar criar endereços, Enter,

01:04:51.370 --> 01:04:53.950
compila OK, endereços de ponto e barra.

01:04:53.950 --> 01:04:57.340
E agora, de fato, isso é tudo que uma string é.

01:04:57.340 --> 01:05:00.340
É uma sequência de caracteres identificados pelo seu primeiro byte.

01:05:00.340 --> 01:05:03.550
Se você começar a bisbilhotar e dizer printf

01:05:03.550 --> 01:05:06.505
para imprimir o que está no próximo byte, ou no próximo, próximo byte,

01:05:06.505 --> 01:05:08.380
vai fazer a mesma coisa, imprimindo

01:05:08.380 --> 01:05:12.500
esse caractere e tudo depois dele até aquele caractere NUL.

01:05:12.500 --> 01:05:14.810
Então, novamente, mesmo que haja muita coisa acontecendo,

01:05:14.810 --> 01:05:16.630
introduzimos esses dois novos operadores,

01:05:16.630 --> 01:05:19.840
não há nada que esteja acontecendo hoje que não esteja acontecendo há semanas.

01:05:19.840 --> 01:05:23.367
Mas espero que, durante esta semana, a palestra desta semana, o problema desta semana

01:05:23.367 --> 01:05:25.450
definido e além, você começará a perceber que agora,

01:05:25.450 --> 01:05:28.570
você só tem mais ferramentas para aproveitar os mais baixos

01:05:28.570 --> 01:05:30.680
detalhes de implementação de nível.

01:05:30.680 --> 01:05:34.420
Então, na segunda semana, lembre-se de outro detalhe de implementação.

01:05:34.420 --> 01:05:39.250
Eu afirmei que você não poderia comparar duas strings tão facilmente quanto poderia

01:05:39.250 --> 01:05:42.820
comparar dois números inteiros, por exemplo.

01:05:42.820 --> 01:05:45.850
E eu disse para você usar uma função diferente

01:05:45.850 --> 01:05:49.540
que você provavelmente usou uma ou mais vezes com o conjunto de problemas anterior.

01:05:49.540 --> 01:05:52.395
Como você deve comparar strings aparentemente?

01:05:52.395 --> 01:05:53.270
AUDIÊNCIA: [INAUDÍVEL]

01:05:53.270 --> 01:05:54.260
DAVID J. MALAN: Sim, então compare as strings.

01:05:54.260 --> 01:05:54.825
STR Comp.

01:05:54.825 --> 01:05:57.950
Essa função adicional que dissemos, eh, você só precisa usá-la por enquanto.

01:05:57.950 --> 01:06:00.590
Mas você pode ter um pouco de intuição já

01:06:00.590 --> 01:06:03.410
por que temos que usar a comparação STR e não podemos simplesmente

01:06:03.410 --> 01:06:06.170
use equals equals para comparar strings.

01:06:06.170 --> 01:06:07.970
Alguma intuição para isso já?

01:06:07.970 --> 01:06:10.190
Por que a comparação STR foi necessária na semana passada?

01:06:10.190 --> 01:06:11.380
AUDIÊNCIA: [INAUDÍVEL]

01:06:11.380 --> 01:06:12.380
DAVID J. MALAN: Perfeito.

01:06:12.380 --> 01:06:14.600
Iguais, iguais comparariam literalmente as duas memórias

01:06:14.600 --> 01:06:18.080
endereços em vez das strings reais caractere por caractere.

01:06:18.080 --> 01:06:21.180
E a menos que os endereços de memória sejam literalmente os mesmos,

01:06:21.180 --> 01:06:24.260
então você compara exatamente o mesmo endereço de memória,

01:06:24.260 --> 01:06:26.240
duas strings diferentes provavelmente não vão

01:06:26.240 --> 01:06:29.640
para serem considerados iguais, mesmo que nós, humanos, eles de fato pareçam iguais.

01:06:29.640 --> 01:06:30.570
Então vamos ver isso.

01:06:30.570 --> 01:06:32.750
Deixe-me ir em frente e fechar os endereços.c.

01:06:32.750 --> 01:06:35.150
E, na verdade, antes de fazer uma última menção,

01:06:35.150 --> 01:06:39.120
uma das coisas poderosas sobre aritmética de ponteiro, como um aparte,

01:06:39.120 --> 01:06:42.560
é que C, e realmente o compilador, é inteligente o suficiente

01:06:42.560 --> 01:06:45.958
para saber quantos bytes continuar adicionando e adicionando.

01:06:45.958 --> 01:06:47.000
E com isso, quero dizer isso.

01:06:47.000 --> 01:06:49.875
No momento, tivemos sorte porque uma string é uma sequência de caracteres.

01:06:49.875 --> 01:06:52.220
E, por definição, cada caractere é um único byte.

01:06:52.220 --> 01:06:56.270
Você pode bisbilhotar e fazer s mais 1 para obter o próximo byte, s mais 2

01:06:56.270 --> 01:06:58.040
para obter o terceiro byte.

01:06:58.040 --> 01:07:00.020
No entanto, se não estivéssemos lidando com strings,

01:07:00.020 --> 01:07:03.350
suponha que estivéssemos lidando com números inteiros que estavam em uma matriz

01:07:03.350 --> 01:07:06.800
costas com costas, se você quiser chegar ao próximo inteiro,

01:07:06.800 --> 01:07:10.077
você ainda pode fazer mais 1 ou mais 2 para obter

01:07:10.077 --> 01:07:11.660
no próximo ou no próximo inteiro.

01:07:11.660 --> 01:07:16.310
Você não começaria a entrar no mato de fazer mais 4 e depois mais 8.

01:07:16.310 --> 01:07:19.460
Você não precisa saber ou se importar com o tamanho dos tipos de dados no computador.

01:07:19.460 --> 01:07:21.652
C e o compilador descobrirá isso para você

01:07:21.652 --> 01:07:23.110
com base no tipo de dados em questão.

01:07:23.110 --> 01:07:27.510
Portanto, lembre-se disso se fizer isso em um tipo de dados diferente de chars.

01:07:27.510 --> 01:07:29.510
Tudo bem, então deixe-me ir em frente e abrir um arquivo

01:07:29.510 --> 01:07:31.850
que eu escrevi com antecedência a maioria.

01:07:31.850 --> 01:07:34.380
E deixe-me esconder minha janela de terminal e mostrar isso.

01:07:34.380 --> 01:07:37.160
Aqui está um programa chamado compare.c, cujo objetivo na vida

01:07:37.160 --> 01:07:39.200
é comparar duas strings.

01:07:39.200 --> 01:07:41.032
Voltei a usar a biblioteca CS50.

01:07:41.032 --> 01:07:43.490
Porque pelo menos por agora, e provavelmente mais algumas semanas,

01:07:43.490 --> 01:07:47.390
é muito mais fácil obter informações do usuário usando a função do CS50,

01:07:47.390 --> 01:07:47.930
obter int.

01:07:47.930 --> 01:07:51.480
Mas vamos concluir hoje tirando essas rodinhas também.

01:07:51.480 --> 01:07:55.280
Assim, você pode ver como pode realmente obter entrada do usuário sem nada específico do CS50.

01:07:55.280 --> 01:07:57.890
Então linha seis e sete, muito chato.

01:07:57.890 --> 01:07:58.820
Coisas da primeira semana.

01:07:58.820 --> 01:08:01.190
Obtenha um int chamado i, obtenha um int chamado j,

01:08:01.190 --> 01:08:03.710
e armazená-los em duas variáveis, i e j, respectivamente.

01:08:03.710 --> 01:08:07.235
Se i é igual a j, imprima o mesmo, senão imprima

01:08:07.235 --> 01:08:08.360
fora que eles são diferentes.

01:08:08.360 --> 01:08:11.750
Deixe-me estipular por uma questão de tempo, tenho certeza de que este código está correto.

01:08:11.750 --> 01:08:13.550
Isso obterá dois números inteiros do humano.

01:08:13.550 --> 01:08:15.800
Ele irá compará-los e me dizer corretamente

01:08:15.800 --> 01:08:17.450
se são iguais ou diferentes.

01:08:17.450 --> 01:08:23.180
E vou provar isso executando make compare dot slash compare.

01:08:23.180 --> 01:08:25.910
E vou digitar 50 para i, 50 para j.

01:08:25.910 --> 01:08:27.029
E eles são os mesmos.

01:08:27.029 --> 01:08:30.859
E agora vou fazer, que tal 50, digamos 13.

01:08:30.859 --> 01:08:31.920
E esses são diferentes.

01:08:31.920 --> 01:08:34.189
Então, deixe-me apenas estipular que este código está realmente correto.

01:08:34.189 --> 01:08:37.370
Teria funcionado na primeira semana, também funciona agora na quarta semana.

01:08:37.370 --> 01:08:40.310
Mas deixe-me agora alterá-lo para comparar não dois números inteiros,

01:08:40.310 --> 01:08:43.620
mas, como sugeri, talvez duas cordas.

01:08:43.620 --> 01:08:46.220
Então deixe-me ir em frente e mudar esta linha de código

01:08:46.220 --> 01:08:52.220
talvez seja string s igual a get string, pedindo s ao usuário.

01:08:52.220 --> 01:08:55.223
Então vamos mudar esta segunda linha aqui para ser string t,

01:08:55.223 --> 01:08:57.140
apenas para manter os nomes das variáveis ​​curtos por enquanto.

01:08:57.140 --> 01:09:00.680
E t é uma boa escolha depois de s para algo assim.

01:09:00.680 --> 01:09:02.960
Obtenha a corda, peça ao humano para t.

01:09:02.960 --> 01:09:06.890
E então vamos mudar nosso i e j aqui para fazer a coisa errada,

01:09:06.890 --> 01:09:08.450
pela intuição anterior.

01:09:08.450 --> 01:09:11.720
Se s é igual a t, imprima o mesmo,

01:09:11.720 --> 01:09:13.399
caso contrário, imprima que eles são diferentes.

01:09:13.399 --> 01:09:16.274
Agora, se eu quiser, posso tirar pelo menos algumas das rodinhas.

01:09:16.274 --> 01:09:17.689
Eu poderia mudar isso para char star.

01:09:17.689 --> 01:09:19.430
Eu poderia mudar isso para char star.

01:09:19.430 --> 01:09:20.055
Qualquer um está bom.

01:09:20.055 --> 01:09:22.805
Eu ainda preciso da biblioteca CS50 porque estou usando get string,

01:09:22.805 --> 01:09:25.880
porque é realmente difícil, como veremos hoje, obter strings manualmente

01:09:25.880 --> 01:09:26.930
sem usar uma biblioteca.

01:09:26.930 --> 01:09:30.470
Mas vou mantê-lo usando string apenas por enquanto com a biblioteca.

01:09:30.470 --> 01:09:33.890
Tudo bem, compare novamente, ponto barra compare.

01:09:33.890 --> 01:09:38.240
E agora deixe-me prosseguir e digitar, por exemplo, oi, ponto de exclamação, Enter,

01:09:38.240 --> 01:09:40.220
e oi, ponto de exclamação, Enter.

01:09:40.220 --> 01:09:42.640
E oh, eles são diferentes.

01:09:42.640 --> 01:09:44.390
Tudo bem, eles obviamente não são visualmente.

01:09:44.390 --> 01:09:45.765
Mas eles estão sob o capô.

01:09:45.765 --> 01:09:47.840
E você provavelmente tem a intuição para isso

01:09:47.840 --> 01:09:50.660
já, pelo que o que está acontecendo sob o capô

01:09:50.660 --> 01:09:54.149
é que estamos comparando acidentalmente os dois endereços de memória.

01:09:54.149 --> 01:09:55.400
Então, na verdade, vamos lá.

01:09:55.400 --> 01:09:56.848
Vamos considerar a memória.

01:09:56.848 --> 01:09:59.640
E deixe-me diminuir o zoom agora para que eu possa ter mais bytes para brincar.

01:09:59.640 --> 01:10:03.020
Assim, os quadrados são um pouco menores do que antes, para que possamos colocar mais neles.

01:10:03.020 --> 01:10:08.950
E deixe-me propor que quando eu declarar s no que era a linha seis um momento atrás,

01:10:08.950 --> 01:10:11.450
acaba em algum lugar na memória como o canto superior esquerdo

01:10:11.450 --> 01:10:13.010
da minha foto para fins de discussão?

01:10:13.010 --> 01:10:18.930
E quando executo a mesma linha de código e a string é chamada,

01:10:18.930 --> 01:10:21.560
e eu digito oi ponto de exclamação, nós sabemos

01:10:21.560 --> 01:10:24.990
a partir da primeira semana, obter a string a coloca em algum lugar da memória do computador.

01:10:24.990 --> 01:10:28.580
E vou propor que esteja no canto inferior esquerdo da tela aqui.

01:10:28.580 --> 01:10:29.970
O que acontece depois disso?

01:10:29.970 --> 01:10:32.120
Bem, eu sei, embora geralmente não me importe,

01:10:32.120 --> 01:10:34.730
que H, I, ponto de exclamação e o caractere NUL

01:10:34.730 --> 01:10:40.310
existem em algum endereço, como 0x123, 124, 125, 126 para fins de discussão.

01:10:40.310 --> 01:10:41.480
E o que há em s?

01:10:41.480 --> 01:10:44.600
O mesmo que antes do intervalo, 0x123.

01:10:44.600 --> 01:10:48.080
Isso é tudo o que está acontecendo novamente na linha seis, que

01:10:48.080 --> 01:10:51.170
é praticamente o mesmo de quando estávamos recebendo um s antes.

01:10:51.170 --> 01:10:55.030
Mas observe agora com a linha sete, quando recebo uma segunda variável chamada t

01:10:55.030 --> 01:10:56.830
e chamo get string novamente.

01:10:56.830 --> 01:10:59.980
E por coincidência, como humano, digito a mesma coisa.

01:10:59.980 --> 01:11:02.530
Bem, o que acontece aqui? t obtém seu próprio pedaço de memória,

01:11:02.530 --> 01:11:04.120
talvez no canto superior direito.

01:11:04.120 --> 01:11:07.643
Essa segunda versão do hi fica em outro lugar na memória.

01:11:07.643 --> 01:11:10.060
O computador pode ser inteligente e perceber que é a mesma coisa.

01:11:10.060 --> 01:11:11.970
Mas C geralmente não faz isso por você.

01:11:11.970 --> 01:11:13.720
Ele simplesmente o coloca em outro lugar da memória.

01:11:13.720 --> 01:11:18.873
E talvez esteja no endereço 0x456, 457, 458, 459 ou qualquer outro lugar.

01:11:18.873 --> 01:11:21.040
Mas talvez você possa ver onde isso já está indo.

01:11:21.040 --> 01:11:23.770
t agora, é claro, contém o endereço desse primeiro byte.

01:11:23.770 --> 01:11:29.530
E assim, no meu código, na linha nove, quando comparo s e t para igualdade,

01:11:29.530 --> 01:11:33.190
basta dizer que não são iguais pela forma como

01:11:33.190 --> 01:11:36.460
as strings são colocadas na memória do computador,

01:11:36.460 --> 01:11:38.960
de fato parece o mesmo, os mesmos valores estão lá.

01:11:38.960 --> 01:11:43.990
Mas se abstrairmos ainda mais, você pode realmente ver que s e t não são a mesma coisa

01:11:43.990 --> 01:11:45.290
eles mesmos.

01:11:45.290 --> 01:11:46.870
E então, como consertamos isso?

01:11:46.870 --> 01:11:50.125
Ou realmente, como evitamos esta última semana sem derramar o feijão

01:11:50.125 --> 01:11:52.000
e descer por essa toca de coelho explicando

01:11:52.000 --> 01:11:53.890
por que você tem que usar o STR compare?

01:11:53.890 --> 01:11:57.760
Bem, se eu voltar ao meu código aqui, vamos fazer agora do jeito certo.

01:11:57.760 --> 01:12:00.640
Deixe-me prosseguir e incluir uma linha de código

01:12:00.640 --> 01:12:04.480
que diz comparação de string de s vírgula, ambos como entradas.

01:12:04.480 --> 01:12:08.530
E então, se você se lembra, o que o STR compara o retorno

01:12:08.530 --> 01:12:10.040
quando duas strings são iguais?

01:12:10.040 --> 01:12:11.625
Há três valores de retorno possíveis.

01:12:11.625 --> 01:12:12.500
AUDIÊNCIA: [INAUDÍVEL]

01:12:12.500 --> 01:12:13.500
DAVID J. MALAN: Então zero.

01:12:13.500 --> 01:12:17.120
Portanto, um é para saber se vem em ordem alfabética ou ASCIIabeticamente primeiro ou segundo.

01:12:17.120 --> 01:12:18.700
Mas por enquanto, eu só quero zero.

01:12:18.700 --> 01:12:22.450
Se eu quiser usar a comparação STR, preciso de string.h.

01:12:22.450 --> 01:12:24.130
Então string.h existe.

01:12:24.130 --> 01:12:25.390
Isso não é coisa do CS50.

01:12:25.390 --> 01:12:28.000
Não há string de palavra-chave como tipo de dados.

01:12:28.000 --> 01:12:29.080
Isso é coisa do CS50.

01:12:29.080 --> 01:12:30.620
Mas string.h existe.

01:12:30.620 --> 01:12:34.030
Acho que agora com essa mudança na linha 10, se eu fizer

01:12:34.030 --> 01:12:38.320
compare e compare com ponto e barra e, em seguida, execute novamente,

01:12:38.320 --> 01:12:42.162
digite novamente, oi ponto de exclamação, oi ponto de exclamação,

01:12:42.162 --> 01:12:43.370
Acho que agora são iguais.

01:12:43.370 --> 01:12:48.760
E apenas como uma segunda verificação, HI em letras maiúsculas, talvez hi em minúsculas,

01:12:48.760 --> 01:12:50.440
esses são, de fato, diferentes.

01:12:50.440 --> 01:12:51.110
Por que?

01:12:51.110 --> 01:12:54.400
Bem, comparação STR, que foi escrita por algumas outras décadas humanas

01:12:54.400 --> 01:12:59.890
ago é inteligente o suficiente para saber que deve ir para s e ir para t,

01:12:59.890 --> 01:13:04.450
comece a compará-los da esquerda para a direita, parando assim que atingir um ou ambos NUL

01:13:04.450 --> 01:13:07.720
caracteres e retornar zero somente se tudo em s

01:13:07.720 --> 01:13:11.140
e em t são exatamente iguais.

01:13:11.140 --> 01:13:15.580
Há alguma dúvida sobre isso aqui?

01:13:15.580 --> 01:13:18.680
Alguma dúvida sobre por que estamos usando a comparação STR?

01:13:18.680 --> 01:13:19.180
Tudo bem.

01:13:19.180 --> 01:13:20.530
Se não-- sim, oh.

01:13:20.530 --> 01:13:22.120
No meio.

01:13:22.120 --> 01:13:24.270
AUDIÊNCIA: Por que números inteiros [INAUDÍVEL]?

01:13:24.270 --> 01:13:25.437
Por que [INAUDÍVEL]?

01:13:25.437 --> 01:13:26.270
DAVID J. MALAN: Sim.

01:13:26.270 --> 01:13:28.610
Então porque-- porque não é o caso com números inteiros?

01:13:28.610 --> 01:13:30.920
Acontece que não é o caso dos números inteiros,

01:13:30.920 --> 01:13:35.060
com floats, com bools, com doubles, com longs.

01:13:35.060 --> 01:13:37.790
Literalmente, todos os outros tipos de dados funcionam corretamente.

01:13:37.790 --> 01:13:39.530
Strings, porém, são especiais.

01:13:39.530 --> 01:13:42.500
Eles são bastante úteis na programação e têm sido usados ​​por décadas

01:13:42.500 --> 01:13:44.900
que os autores de printf e os autores de STR

01:13:44.900 --> 01:13:47.840
comparar e várias outras funções, strlen para esse assunto,

01:13:47.840 --> 01:13:51.650
apenas um tipo de tratamento especial porque são apenas úteis.

01:13:51.650 --> 01:13:54.660
Nós, humanos, interagimos usando a linguagem, seja o inglês ou qualquer outra coisa.

01:13:54.660 --> 01:13:58.040
E então é útil ter na linguagem C

01:13:58.040 --> 01:14:02.900
apenas uma espécie de suporte de primeira classe para essa noção de strings de texto humano.

01:14:02.900 --> 01:14:05.330
Portanto, a resposta curta é apenas porque.

01:14:05.330 --> 01:14:08.300
É apenas necessário - strings são diferentes.

01:14:08.300 --> 01:14:11.480
Eles são implementados com este endereço e o caractere NUL.

01:14:11.480 --> 01:14:14.060
Todo o resto, porém, é apenas um valor.

01:14:14.060 --> 01:14:15.680
Mas uma corda novamente é uma mentira branca.

01:14:15.680 --> 01:14:16.490
É um endereço.

01:14:16.490 --> 01:14:19.550
Não é uma coisa em si.

01:14:19.550 --> 01:14:20.180
Boa pergunta.

01:14:20.180 --> 01:14:21.020
Sim, na frente.

01:14:21.020 --> 01:14:23.333
AUDIÊNCIA: Como é que [INAUDÍVEL]?

01:14:23.333 --> 01:14:25.000
DAVID J. MALAN: Muito boa pergunta.

01:14:25.000 --> 01:14:30.310
Então, no meu código aqui no VS Code, e se eu fizer isso?

01:14:30.310 --> 01:14:33.600
Em vez de STR, compare e em vez de if s equals

01:14:33.600 --> 01:14:39.060
é igual a t, e se eu começar a brincar usando star s e start t?

01:14:39.060 --> 01:14:41.020
Caso realmente interessante a se considerar.

01:14:41.020 --> 01:14:43.330
Vamos voltar ao nosso tipo de lógica dedutiva aqui.

01:14:43.330 --> 01:14:46.720
Então estrela, o operador asterisco hoje, significa ir para lá.

01:14:46.720 --> 01:14:49.860
Então, quando eu digito HI uma vez e depois HI novamente,

01:14:49.860 --> 01:14:53.850
ambas maiúsculas, por exemplo, o que está no endereço s literalmente?

01:14:53.850 --> 01:14:56.410
Alguém.

01:14:56.410 --> 01:14:57.640
O que há no endereço s?

01:14:57.640 --> 01:14:59.080
Sim.

01:14:59.080 --> 01:15:00.100
Então não é bem assim.

01:15:00.100 --> 01:15:01.645
No endereço.

01:15:01.645 --> 01:15:02.830
Então não, qual é o endereço?

01:15:02.830 --> 01:15:04.535
O que há no endereço 0x123?

01:15:04.535 --> 01:15:05.410
AUDIÊNCIA: [INAUDÍVEL]

01:15:05.410 --> 01:15:06.340
DAVID J. MALAN: h.

01:15:06.340 --> 01:15:08.590
E o que está no endereço 0x456?

01:15:08.590 --> 01:15:09.550
AUDIÊNCIA: [INAUDÍVEL]

01:15:09.550 --> 01:15:10.690
DAVID J. MALAN: h também.

01:15:10.690 --> 01:15:12.850
E então aqui, você está meio que trapaceando.

01:15:12.850 --> 01:15:17.800
Você está comparando o primeiro caractere de ambas as strings, mas não todos os outros.

01:15:17.800 --> 01:15:19.570
Agora você pode ser realmente pedante.

01:15:19.570 --> 01:15:22.510
E aqui, novamente, este não é um bom uso do código.

01:15:22.510 --> 01:15:23.600
Mas você poderia fazer isso.

01:15:23.600 --> 01:15:26.480
Se isso, e quanto a essa loucura?

01:15:26.480 --> 01:15:32.140
Então star s mais 1 é igual a star t mais 1.

01:15:32.140 --> 01:15:34.420
E você pode fazer isso para cada personagem manualmente.

01:15:34.420 --> 01:15:35.960
Mas é por isso que a comparação STR existe.

01:15:35.960 --> 01:15:37.130
Ele faz tudo isso para você.

01:15:37.130 --> 01:15:37.798
Mas é por isso.

01:15:37.798 --> 01:15:38.840
E essa é a intuição.

01:15:38.840 --> 01:15:41.965
Então eu gostaria de encorajar você também, sempre que houver algo meio estranho acontecendo

01:15:41.965 --> 01:15:42.670
em, há--

01:15:42.670 --> 01:15:45.160
Eu percebo que podemos estar forçando a credibilidade agora,

01:15:45.160 --> 01:15:46.990
não contamos tantas mentiras inocentes.

01:15:46.990 --> 01:15:50.140
E quase tudo o que vimos até agora

01:15:50.140 --> 01:15:53.350
pode explicar praticamente todo o comportamento até agora

01:15:53.350 --> 01:15:56.830
da primeira semana em C. Deixe-me reverter isso para o caminho certo.

01:15:56.830 --> 01:15:59.830
Se s STR comparar de s e t igual a zero,

01:15:59.830 --> 01:16:01.608
esta agora é a versão correta do código.

01:16:01.608 --> 01:16:03.400
E agora aqui é, novamente, onde você pode jogar.

01:16:03.400 --> 01:16:04.250
Então deixe-me fazer isso.

01:16:04.250 --> 01:16:07.690
Deixe-me limpar a janela do meu terminal apenas para arrumar as coisas.

01:16:07.690 --> 01:16:09.670
Deixe-me me livrar de todas essas coisas de comparação.

01:16:09.670 --> 01:16:12.795
E vamos ver o que está acontecendo, como você é bem-vindo em seu próprio código.

01:16:12.795 --> 01:16:14.800
Vamos imprimir, por exemplo, como poderíamos

01:16:14.800 --> 01:16:18.850
tenha na primeira semana, o valor de s em uma nova linha, vírgula s.

01:16:18.850 --> 01:16:21.460
E então vamos apenas imprimir t apenas para ter certeza de que ele compila

01:16:21.460 --> 01:16:22.910
e não estou fazendo nada de errado.

01:16:22.910 --> 01:16:24.785
Mas isso não vai ser tão interessante.

01:16:24.785 --> 01:16:27.820
E, francamente, não preciso mais de string.h

01:16:27.820 --> 01:16:29.320
porque não estou usando a comparação STR.

01:16:29.320 --> 01:16:34.660
Então faça endereços ponto barra endereços, aqui está o meu--

01:16:34.660 --> 01:16:35.290
Oh, desculpe.

01:16:35.290 --> 01:16:36.430
Isto é engraçado.

01:16:36.430 --> 01:16:39.130
Não %t, %s aqui também.

01:16:39.130 --> 01:16:39.797
Ignore isso.

01:16:39.797 --> 01:16:40.630
Vamos fazer isso de novo.

01:16:40.630 --> 01:16:43.720
Faça um-- oh, e esse é o programa errado.

01:16:43.720 --> 01:16:47.770
Ponto barra-- vamos comparar ponto barra comparar.

01:16:47.770 --> 01:16:49.990
E vamos digitar oi de novo e oi de novo.

01:16:49.990 --> 01:16:51.490
E agora vemos apenas as duas cordas.

01:16:51.490 --> 01:16:52.360
Eu não estou comparando.

01:16:52.360 --> 01:16:54.160
Mas agora podemos meio que brincar.

01:16:54.160 --> 01:16:57.850
Em vez de imprimir %s, que imprime a string,

01:16:57.850 --> 01:17:01.960
como faço para imprimir o endereço em s?

01:17:01.960 --> 01:17:04.240
Só preciso fazer uma pequena alteração.

01:17:04.240 --> 01:17:09.400
Se eu quiser ver não o que está em s, mas quero ver s, o endereço--

01:17:09.400 --> 01:17:10.356
Sim.

01:17:10.356 --> 01:17:13.050
AUDIÊNCIA: Alterar %s para %p?

01:17:13.050 --> 01:17:14.050
DAVID J. MALAN: Perfeito.

01:17:14.050 --> 01:17:17.500
Então mude %s em ambos os lugares aqui para %p.

01:17:17.500 --> 01:17:20.522
Agora, printf irá tratá-lo literalmente como um endereço.

01:17:20.522 --> 01:17:22.480
Não vai fazer nenhuma fantasia isso com um loop

01:17:22.480 --> 01:17:24.522
da esquerda para a direita procurando o caractere NUL.

01:17:24.522 --> 01:17:26.140
Vai apenas imprimir s e t.

01:17:26.140 --> 01:17:29.170
Então deixe-me limpar meu terminal, executar make compare, uau.

01:17:29.170 --> 01:17:31.450
Vamos comparar ponto barra comparar.

01:17:31.450 --> 01:17:32.050
Digitar.

01:17:32.050 --> 01:17:34.100
Digite oi, digite oi de novo.

01:17:34.100 --> 01:17:37.618
E agora você vê, oh, então isso é interessante.

01:17:37.618 --> 01:17:40.660
Não é tão direto quanto os outros valores que eram leves -

01:17:40.660 --> 01:17:41.950
1 byte de distância.

01:17:41.950 --> 01:17:43.220
Eles são quase os mesmos.

01:17:43.220 --> 01:17:44.950
Mas este termina em b0.

01:17:44.950 --> 01:17:46.540
Este termina em f0.

01:17:46.540 --> 01:17:49.630
Então eles estão realmente separados por algum número

01:17:49.630 --> 01:17:51.430
de bytes, não apenas um, mas alguns.

01:17:51.430 --> 01:17:54.000
Porque essas cordas são realmente mais longas.

01:17:54.000 --> 01:17:54.500
Tudo bem.

01:17:54.500 --> 01:17:58.240
Depois de ver isso aqui, como podemos aproveitar

01:17:58.240 --> 01:18:00.250
isso para resolver outros problemas?

01:18:00.250 --> 01:18:01.880
Bem, deixe-me propor que façamos isso.

01:18:01.880 --> 01:18:05.770
Deixe-me diminuir o zoom aqui, deixe-me fechar a comparação.

01:18:05.770 --> 01:18:10.150
E deixe-me abrir outro programa do qual escrevi parte antecipadamente, chamado copy.c.

01:18:10.150 --> 01:18:14.230
Portanto, copy.c, em teoria, faz uma cópia de uma string.

01:18:14.230 --> 01:18:14.920
Como?

01:18:14.920 --> 01:18:17.920
Na linha oito, estou fazendo a mesma coisa de antes.

01:18:17.920 --> 01:18:22.360
Obtenha a string, armazenando-a em uma string ou char star e solicitando-a ao usuário.

01:18:22.360 --> 01:18:24.980
Então eu não estou pedindo para obter string novamente.

01:18:24.980 --> 01:18:30.610
Estou apenas fazendo uma cópia supersimples com a linha 10 aqui, a string t é igual a s.

01:18:30.610 --> 01:18:33.820
Agora, intuitivamente, acho que é assim que eu copiaria uma variável.

01:18:33.820 --> 01:18:37.090
É assim que copiamos variáveis ​​todas as semanas até agora em C.

01:18:37.090 --> 01:18:39.160
Mas algo vai dar errado.

01:18:39.160 --> 01:18:41.830
Na linha 12, em inglês, does someone want

01:18:41.830 --> 01:18:44.470
para explicar o que você acha que a linha 12 faz?

01:18:44.470 --> 01:18:46.450
Não se preocupe em encontrar bugs ou erros.

01:18:46.450 --> 01:18:50.290
Mas o que a linha 12 parece estar fazendo usando duas letras superiores, que

01:18:50.290 --> 01:18:54.080
é graças à biblioteca de tipos C, para a qual incluí o arquivo de cabeçalho?

01:18:54.080 --> 01:18:54.580
Sim.

01:18:54.580 --> 01:18:56.593
AUDIÊNCIA: [INAUDÍVEL]

01:18:56.593 --> 01:18:57.760
DAVID J. MALAN: Sim, certo?

01:18:57.760 --> 01:18:59.350
É como uma sintaxe feia.

01:18:59.350 --> 01:19:02.710
Mas isso parece estar colocando em maiúscula a primeira letra de t

01:19:02.710 --> 01:19:04.880
especificamente e apenas alterá-lo.

01:19:04.880 --> 01:19:07.720
Portanto, temos t colchete 0 aqui, porque queremos salvar a alteração.

01:19:07.720 --> 01:19:10.430
E estamos passando para dois maiúsculos, o primeiro caractere aqui.

01:19:10.430 --> 01:19:12.460
Então era assim que fazíamos letras maiúsculas no passado.

01:19:12.460 --> 01:19:16.930
E agora imprimo s e t respectivamente usando %s.

01:19:16.930 --> 01:19:18.460
Parece que deve funcionar.

01:19:18.460 --> 01:19:21.790
Copiei s e armazenei em t na linha 10.

01:19:21.790 --> 01:19:25.450
E então eu mudo t e apenas t na linha 12.

01:19:25.450 --> 01:19:27.970
Mas talvez você possa, se estiver confortável até agora,

01:19:27.970 --> 01:19:32.860
veja onde isso vai dar se eu fizer cópia, cópia ponto barra.

01:19:32.860 --> 01:19:37.220
E deixe-me digitar em letras minúsculas oi ponto de exclamação desta vez, apenas uma vez.

01:19:37.220 --> 01:19:38.410
Então, vou apertar Enter.

01:19:38.410 --> 01:19:43.510
E observe o que vemos para o valor de s e t.

01:19:43.510 --> 01:19:48.640
O novo valor de s e t no final do meu programa parece ser o quê?

01:19:48.640 --> 01:19:52.030
Parece ser o mesmo.

01:19:52.030 --> 01:19:54.165
Oi é capitalizado ambas as vezes.

01:19:54.165 --> 01:19:56.620
Então, qual é a intuição para isso?

01:19:56.620 --> 01:20:00.100
Por que isso aconteceu?

01:20:00.100 --> 01:20:01.030
Sim, atrás.

01:20:01.030 --> 01:20:02.582
AUDIÊNCIA: [INAUDÍVEL]

01:20:02.582 --> 01:20:05.290
DAVID J. MALAN: Sim, atribuí s e t ao mesmo endereço de memória.

01:20:05.290 --> 01:20:07.590
Então ele copiou s em t.

01:20:07.590 --> 01:20:09.540
Mas C leva isso muito literalmente.

01:20:09.540 --> 01:20:10.073
O que é s?

01:20:10.073 --> 01:20:10.740
É um endereço.

01:20:10.740 --> 01:20:11.280
O que é isso?

01:20:11.280 --> 01:20:12.790
É uma cópia desse endereço.

01:20:12.790 --> 01:20:15.990
Se você quiser copiar toda a string como um humano normal esperaria,

01:20:15.990 --> 01:20:18.180
ei, você ou alguém tem que fazer muito mais trabalho.

01:20:18.180 --> 01:20:21.690
Você tem que ir naquele endereço, copiar este personagem, este, este,

01:20:21.690 --> 01:20:24.390
este e copie-o para um novo local e memória.

01:20:24.390 --> 01:20:26.745
Isso não acontece automaticamente aqui para você em C.

01:20:26.745 --> 01:20:28.620
Ele faz em alguns outros idiomas, aqueles de vocês

01:20:28.620 --> 01:20:30.660
que programaram em certas linguagens de nível superior.

01:20:30.660 --> 01:20:32.090
Isso funciona como você esperaria.

01:20:32.090 --> 01:20:34.590
E esse é um dos benefícios do Python e de outras linguagens

01:20:34.590 --> 01:20:35.520
que veremos em breve.

01:20:35.520 --> 01:20:38.880
Mas, por enquanto, leva literalmente pelo valor de face o que é isso.

01:20:38.880 --> 01:20:40.800
Copie o endereço para este endereço.

01:20:40.800 --> 01:20:44.470
E deixarei isso mais claro eliminando a palavra-chave string, que,

01:20:44.470 --> 01:20:45.960
novamente, é apenas um typedef.

01:20:45.960 --> 01:20:47.890
Este é tecnicamente um endereço aqui.

01:20:47.890 --> 01:20:49.570
Este é tecnicamente um endereço aqui.

01:20:49.570 --> 01:20:54.090
O que está sendo copiado é o valor desse endereço, não todos os caracteres

01:20:54.090 --> 01:20:55.750
isso pode muito bem segui-lo.

01:20:55.750 --> 01:20:58.530
Portanto, devo fazer uma observação aqui também.

01:20:58.530 --> 01:21:01.290
vou começar a adquirir mais o hábito de tentar

01:21:01.290 --> 01:21:05.070
para evitar falhas de segmentação porque as coisas podem dar errado aqui.

01:21:05.070 --> 01:21:09.930
Por exemplo, na linha 12 anterior, eu estava meio que cegamente, ingenuamente,

01:21:09.930 --> 01:21:14.265
assumindo perigosamente que haverá pelo menos um caractere em s ou t.

01:21:14.265 --> 01:21:15.390
Isso pode não ser o caso.

01:21:15.390 --> 01:21:18.390
Se o usuário apenas pressionar Enter, não haverá caracteres para letras maiúsculas.

01:21:18.390 --> 01:21:21.720
E então isso é imprudente da minha parte e teoricamente poderia criar uma falha de segmentação.

01:21:21.720 --> 01:21:25.510
Então eu provavelmente deveria começar a ser mais inteligente e dizer algo assim.

01:21:25.510 --> 01:21:29.130
Se o comprimento de t for maior que zero, OK,

01:21:29.130 --> 01:21:32.310
agora é seguro colocar a primeira letra em maiúscula.

01:21:32.310 --> 01:21:36.270
E isso diminuirá a probabilidade agora dessas falhas de segmentação

01:21:36.270 --> 01:21:40.050
simplesmente não fazendo suposições sobre o que o humano faz.

01:21:40.050 --> 01:21:43.770
Quase sempre, seus programas travam quando você comete um erro,

01:21:43.770 --> 01:21:49.210
sim, mas o usuário fornece uma entrada que você mesmo não esperava.

01:21:49.210 --> 01:21:51.060
Então, como tudo isso se parece na memória?

01:21:51.060 --> 01:21:53.370
Bem, vamos voltar para a grade grande, desta vez

01:21:53.370 --> 01:21:55.210
focando na cópia de valores.

01:21:55.210 --> 01:21:56.040
E vamos fazer isso.

01:21:56.040 --> 01:22:01.110
Aqui está como neste novo programa que acabou de ser declarado uma estrela char.

01:22:01.110 --> 01:22:04.560
Aqui é onde minhas letras minúsculas podem ter ido parar na memória do computador.

01:22:04.560 --> 01:22:08.860
Isso provavelmente está em 0x123, 124, 125, seja o que for, algo assim.

01:22:08.860 --> 01:22:12.180
E isso é, claro, o que acaba em s como um valor.

01:22:12.180 --> 01:22:16.860
Quando declaro t, obtenho uma segunda variável chamada t exatamente como antes.

01:22:16.860 --> 01:22:21.330
Mas quando eu copio s em t, o que acontece?

01:22:21.330 --> 01:22:24.150
É realmente apenas literalmente 0x123.

01:22:24.150 --> 01:22:27.060
Qualquer que seja o valor de s, agora também é o valor de t.

01:22:27.060 --> 01:22:29.160
E se abstrairmos isso em alto nível,

01:22:29.160 --> 01:22:33.240
livrar-se de todos esses quadrados extras, isso é o que s e t agora são.

01:22:33.240 --> 01:22:36.090
Eles são de fato cópias, mas cópias um do outro, não

01:22:36.090 --> 01:22:38.070
cópias dos caracteres subjacentes.

01:22:38.070 --> 01:22:41.160
E se você seguir essas setas e tentar

01:22:41.160 --> 01:22:43.930
para imprimir os dois depois de colocar um ou outro em maiúscula,

01:22:43.930 --> 01:22:47.790
você vai infelizmente acabar capitalizando não apenas um deles, s,

01:22:47.790 --> 01:22:50.310
mas ambos, s e t.

01:22:50.310 --> 01:22:52.830
Porque, literalmente, é o mesmo endereço.

01:22:52.830 --> 01:22:56.130
Alguma pergunta, então, sobre esta visualização?

01:22:56.130 --> 01:22:56.730
Sim.

01:22:56.730 --> 01:22:58.330
AUDIÊNCIA: [INAUDÍVEL]

01:22:58.330 --> 01:22:59.580
DAVID J. MALAN: Boa pergunta.

01:22:59.580 --> 01:23:01.200
Isso é passado por referência?

01:23:01.200 --> 01:23:07.170
Não vimos em detalhes um exemplo como esse.

01:23:07.170 --> 01:23:09.102
No momento, você está copiando por valor.

01:23:09.102 --> 01:23:10.560
Mas as referências entrarão em jogo.

01:23:10.560 --> 01:23:12.852
E me lembre daqui a pouco se ainda não usei esse termo.

01:23:12.852 --> 01:23:14.925
Mas isso é apenas copiar coisas por--

01:23:14.925 --> 01:23:17.370
que poderia ter terminado mal, valor.

01:23:17.370 --> 01:23:19.840
Outras perguntas.

01:23:19.840 --> 01:23:20.390
Não?

01:23:20.390 --> 01:23:25.960
Tudo bem, com isso em mente, como podemos realmente copiar as coisas corretamente?

01:23:25.960 --> 01:23:28.340
Para isso, na verdade, precisamos de outro bloco de construção.

01:23:28.340 --> 01:23:30.080
Então, hoje, damos a você duas funções.

01:23:30.080 --> 01:23:32.860
Um dos quais é chamado malloc, um dos quais é chamado de livre.

01:23:32.860 --> 01:23:35.590
E estes são usados ​​o tempo todo por como cada peça

01:23:35.590 --> 01:23:38.460
de software que você e eu usamos em nossos Macs, PCs e telefones,

01:23:38.460 --> 01:23:40.960
se está escrito em C ou alguma outra linguagem equivalente.

01:23:40.960 --> 01:23:43.360
Malloc é para alocação de memória.

01:23:43.360 --> 01:23:47.960
É uma função que você pode usar para perguntar ao sistema operacional, MacOS, Linux,

01:23:47.960 --> 01:23:51.250
Windows, qualquer coisa, para algum número de bytes, 1 byte, 100

01:23:51.250 --> 01:23:52.600
bytes, um gigabyte de memória.

01:23:52.600 --> 01:23:55.750
Você pode solicitar ao malloc a quantidade de memória que desejar com antecedência.

01:23:55.750 --> 01:24:00.340
Ele retornará para você o endereço do primeiro byte de memória

01:24:00.340 --> 01:24:02.110
que encontrou grátis para você.

01:24:02.110 --> 01:24:04.940
Ao contrário de uma string, ela não é terminada em NUL.

01:24:04.940 --> 01:24:07.960
E então o perigo com malloc é que está no sistema de honra.

01:24:07.960 --> 01:24:12.220
Se você pedir 1 byte ou 10 bytes, você, o programador, em uma variável,

01:24:12.220 --> 01:24:16.090
tem que lembrar quantos bytes você solicitou, 1 ou 10, ou algo parecido.

01:24:16.090 --> 01:24:19.032
As cordas fazem isso por você, não quando estamos chegando a esse nível baixo.

01:24:19.032 --> 01:24:22.240
Malloc só vai lhe dar um pouco de memória e cabe a você gerenciá-la.

01:24:22.240 --> 01:24:23.500
Grátis faz o oposto.

01:24:23.500 --> 01:24:24.790
Quando você terminar com algum pedaço de memória,

01:24:24.790 --> 01:24:28.090
você pode liberá-lo passando no mesmo endereço e apenas devolvê-lo ao Mac

01:24:28.090 --> 01:24:30.230
SO, Windows ou Linux, e dizer que terminei com isso,

01:24:30.230 --> 01:24:33.130
você pode me deixar usar isso para outra coisa mais tarde.

01:24:33.130 --> 01:24:38.198
Como um aparte, se o seu computador já congelou ou travou,

01:24:38.198 --> 01:24:40.240
a coisa toda talvez apenas reinicie espontaneamente,

01:24:40.240 --> 01:24:42.280
mais uma razão para um bug como esse pode

01:24:42.280 --> 01:24:46.300
ser se você escrever um programa com um bug que continua malocando, malocando,

01:24:46.300 --> 01:24:49.360
malocing que está pedindo mais e mais e mais memória,

01:24:49.360 --> 01:24:51.850
mas você comete um erro e nunca o liberta,

01:24:51.850 --> 01:24:54.742
bem, eventualmente, o computador vai literalmente ficar sem memória

01:24:54.742 --> 01:24:56.200
e algo vai dar errado.

01:24:56.200 --> 01:24:58.825
E é frequentemente quando os computadores congelam.

01:24:58.825 --> 01:24:59.950
Eles estão apenas sem memória.

01:24:59.950 --> 01:25:03.430
Tem a memória lá, mas o programa estava tentando usar muito dela

01:25:03.430 --> 01:25:04.150
infinitamente.

01:25:04.150 --> 01:25:06.160
Portanto, isso também será um erro que alguns de nós

01:25:06.160 --> 01:25:07.820
certamente fará nas próximas semanas.

01:25:07.820 --> 01:25:09.890
Mas espero que agora você veja a solução.

01:25:09.890 --> 01:25:12.820
Então, deixe-me voltar ao VS Code aqui.

01:25:12.820 --> 01:25:15.120
E deixe-me propor que façamos o seguinte.

01:25:15.120 --> 01:25:16.870
Vou esconder minha janela de terminal por um momento.

01:25:16.870 --> 01:25:19.698
E vou apresentar outro arquivo de cabeçalho aqui.

01:25:19.698 --> 01:25:22.240
E eu prometo que não haverá muitos mais desses.

01:25:22.240 --> 01:25:26.860
Mas este é chamado de lib.h padrão para a biblioteca padrão.

01:25:26.860 --> 01:25:31.060
E neste arquivo estão as declarações, os protótipos para malloc e free,

01:25:31.060 --> 01:25:32.530
e um monte de outras coisas também.

01:25:32.530 --> 01:25:35.270
Isso me permite agora gerenciar minha própria memória.

01:25:35.270 --> 01:25:37.360
Então, vamos nos concentrar agora na linha 11.

01:25:37.360 --> 01:25:39.400
A linha 11 é onde eu errei antes.

01:25:39.400 --> 01:25:41.650
Porque, conceitualmente, quero copiar toda a string.

01:25:41.650 --> 01:25:45.530
Mas é claro, estou apenas copiando modestamente o endereço individual.

01:25:45.530 --> 01:25:47.680
Então, como faço para copiar a coisa toda?

01:25:47.680 --> 01:25:49.400
Bem, o que eu preciso fazer é isso.

01:25:49.400 --> 01:25:53.290
Quando declaro que t é o endereço de algo na memória,

01:25:53.290 --> 01:25:56.780
por que não defino t como o endereço de um pedaço livre de memória?

01:25:56.780 --> 01:25:59.620
Então deixe-me pedir ao sistema operacional, me dê tantos bytes.

01:25:59.620 --> 01:26:00.820
Diga-me qual é o endereço.

01:26:00.820 --> 01:26:03.190
E eu vou armazenar isso em t inicialmente apenas para que eu

01:26:03.190 --> 01:26:04.850
saber onde há espaço livre para mim.

01:26:04.850 --> 01:26:06.020
Então, como faço isso?

01:26:06.020 --> 01:26:09.250
Bem, simplesmente, chamo malloc e passo o número de bytes

01:26:09.250 --> 01:26:09.850
que eu preciso.

01:26:09.850 --> 01:26:12.850
Agora, para o ponto de exclamação HI, acho que preciso de três.

01:26:12.850 --> 01:26:13.770
Embora espere, não.

01:26:13.770 --> 01:26:16.620
Eu realmente preciso de quatro por causa do caractere NUL.

01:26:16.620 --> 01:26:19.120
Mas não acho que devo codificar números como este.

01:26:19.120 --> 01:26:21.328
Porque quem sabe o que o humano vai digitar?

01:26:21.328 --> 01:26:25.630
Então eu posso realmente usar strlen de s, e então mais 1.

01:26:25.630 --> 01:26:28.870
Isso pedirá ao malloc então quantos bytes

01:26:28.870 --> 01:26:32.380
corresponde ao número de caracteres que o humano digitou mais 1,

01:26:32.380 --> 01:26:33.970
para novamente, o caractere NUL.

01:26:33.970 --> 01:26:37.550
Portanto, é apenas ser inteligente e defensivo, em vez de escolher um número sozinho.

01:26:37.550 --> 01:26:41.330
Mas agora tudo o que é um ponteiro, se você quiser,

01:26:41.330 --> 01:26:43.520
para algum pedaço aleatório de espaço livre.

01:26:43.520 --> 01:26:45.010
Então ainda não tem nada.

01:26:45.010 --> 01:26:45.993
Ou há pedaços lá.

01:26:45.993 --> 01:26:47.410
Mas quem sabe o valor que eles são?

01:26:47.410 --> 01:26:49.870
Eles certamente não são idênticos ao que o humano digitou.

01:26:49.870 --> 01:26:51.430
Agora eu tenho que fazer isso.

01:26:51.430 --> 01:26:55.090
Então, como posso copiar uma string para a outra?

01:26:55.090 --> 01:26:56.450
Bem, deixe-me fazer isso.

01:26:56.450 --> 01:27:00.650
Em vez de capitalizar algo ainda, deixe-me fazer isso.

01:27:00.650 --> 01:27:08.020
Que tal quatro int eu recebo 0, i é menor que o comprimento de s.

01:27:08.020 --> 01:27:09.262
E então eu mais mais.

01:27:09.262 --> 01:27:11.720
Então, vou iterar por todo o comprimento da string.

01:27:11.720 --> 01:27:13.630
E aqui, eu só vou fazer isso.

01:27:13.630 --> 01:27:18.640
O i-ésimo caractere em t deve ser idêntico ao i-ésimo caractere em s.

01:27:18.640 --> 01:27:22.870
Então, estou literalmente copiando da direita para a esquerda cada caractere em s.

01:27:22.870 --> 01:27:24.980
E posso confiar que há memória suficiente em t.

01:27:24.980 --> 01:27:25.480
Por que?

01:27:25.480 --> 01:27:27.670
Porque eu pedi tantos bytes mais 1.

01:27:27.670 --> 01:27:29.410
Agora há tecnicamente um bug aqui.

01:27:29.410 --> 01:27:31.240
Na verdade, eu provavelmente deveria fazer isso.

01:27:31.240 --> 01:27:34.480
Eu deveria fazer mais 1 aqui.

01:27:34.480 --> 01:27:39.100
Ou se preferir, devo fazer menor ou igual ao strlen.

01:27:39.100 --> 01:27:41.440
Mas acho que está um pouco claro fazer o mais 1.

01:27:41.440 --> 01:27:46.360
Por que eu pela primeira vez quero ir além do limite de s

01:27:46.360 --> 01:27:48.130
e copiar mais 1 byte?

01:27:48.130 --> 01:27:49.005
AUDIÊNCIA: [INAUDÍVEL]

01:27:49.005 --> 01:27:50.963
DAVID J. MALAN: Sim, preciso do personagem NUL.

01:27:50.963 --> 01:27:53.895
Eu poderia tecnicamente adicioná-lo manualmente com alguma linha de código adicional.

01:27:53.895 --> 01:27:55.270
Mas eu poderia muito bem apenas copiá-lo.

01:27:55.270 --> 01:27:57.580
Porque a barra invertida zero é a barra invertida zero.

01:27:57.580 --> 01:27:59.920
Portanto, desta vez, e provavelmente apenas desta vez,

01:27:59.920 --> 01:28:03.340
é razoável e correto ir além do limite de sua string

01:28:03.340 --> 01:28:06.640
então você copia o caractere de terminação NUL para que o computador também

01:28:06.640 --> 01:28:08.050
sabe onde t termina.

01:28:08.050 --> 01:28:12.800
E agora acho que o que posso fazer com um pouco mais de segurança é isso.

01:28:12.800 --> 01:28:18.100
Deixe-me descer aqui e dizer, t colchete 0 é igual a 2 superior

01:28:18.100 --> 01:28:21.368
de t, de 2 superior de t colchete 0.

01:28:21.368 --> 01:28:22.660
Então, a mesma linha de código de antes.

01:28:22.660 --> 01:28:25.327
Se eu realmente quiser estar realmente seguro, provavelmente devo fazer isso.

01:28:25.327 --> 01:28:28.540
Portanto, se o strlen de t for maior que zero.

01:28:28.540 --> 01:28:30.010
Portanto, há pelo menos 1 byte lá.

01:28:30.010 --> 01:28:33.700
OK, agora é seguro colocar o primeiro caractere em maiúscula cegamente.

01:28:33.700 --> 01:28:36.290
E acho que agora me deixa em melhor forma.

01:28:36.290 --> 01:28:37.270
Então deixe-me tentar isso agora.

01:28:37.270 --> 01:28:43.300
Deixe-me abrir meu terminal, fazer uma cópia, uma cópia dot slash.

01:28:43.300 --> 01:28:46.690
Vou digitar oi ponto de exclamação em letras minúsculas

01:28:46.690 --> 01:28:48.280
cruzando os dedos desta vez.

01:28:48.280 --> 01:28:53.260
E agora, se eu aumentar o zoom, ele realmente capitalizou apenas t

01:28:53.260 --> 01:28:55.570
e não s neste caso.

01:28:55.570 --> 01:28:57.610
Então, pictoricamente, deixe-me mudar aqui.

01:28:57.610 --> 01:29:02.890
Aqui está, como antes, a variável s apontando para hi em letras minúsculas.

01:29:02.890 --> 01:29:07.000
Quando eu chamo malloc, porém, isso me dá um pedaço de memória

01:29:07.000 --> 01:29:09.430
que vou armazenar o endereço em t de.

01:29:09.430 --> 01:29:12.245
Portanto, se t for alguma outra variável, como no meu código,

01:29:12.245 --> 01:29:15.370
e há algum outro pedaço de memória disponível, não sei onde está.

01:29:15.370 --> 01:29:19.660
Mas vamos supor que, como sempre, esteja em 0x456, 457, 458, 459.

01:29:19.660 --> 01:29:20.980
Portanto, 4 bytes no total.

01:29:20.980 --> 01:29:22.360
O que está acontecendo agora?

01:29:22.360 --> 01:29:24.760
Bem, t é definido como apontando para isso.

01:29:24.760 --> 01:29:26.950
Porque é isso que malloc nos dá, o endereço

01:29:26.950 --> 01:29:29.260
do primeiro byte da memória livre.

01:29:29.260 --> 01:29:33.070
E agora com o loop for, estou apenas iterando sobre ele, copiando o h,

01:29:33.070 --> 01:29:36.700
depois o i, depois o ponto de exclamação e, para garantir,

01:29:36.700 --> 01:29:39.790
a barra invertida 0 em vez disso.

01:29:39.790 --> 01:29:43.476
Dúvidas então sobre esse processo aqui?

01:29:43.476 --> 01:29:44.370
AUDIÊNCIA: [INAUDÍVEL]

01:29:44.370 --> 01:29:45.995
DAVID J. MALAN: Uma pergunta muito boa.

01:29:45.995 --> 01:29:52.350
Se eu omiti no meu código o mais 1 e não fiz menos que

01:29:52.350 --> 01:29:56.130
ou igual a então estou copiando o quarto byte, as probabilidades estão neste programa,

01:29:56.130 --> 01:29:59.280
porque é tão curto que você não notaria que há um erro real.

01:29:59.280 --> 01:30:04.650
Mas o que pode acontecer é quando eu chamo printf em t,

01:30:04.650 --> 01:30:09.720
se não houver nenhum byte NUL lá, ele pode imprimir h, i, ponto de exclamação,

01:30:09.720 --> 01:30:12.960
alguns valores aleatórios, alguns valores aleatórios, alguns valores aleatórios, alguns valores aleatórios

01:30:12.960 --> 01:30:16.380
até que tenha sorte e haja um byte 0, um NUL

01:30:16.380 --> 01:30:18.340
byte por acaso, por exemplo.

01:30:18.340 --> 01:30:22.800
Então, se você não incluir a barra invertida zero de alguma forma, isso vai acontecer.

01:30:22.800 --> 01:30:23.970
E eu digo de alguma forma.

01:30:23.970 --> 01:30:25.030
Eu poderia até fazer isso.

01:30:25.030 --> 01:30:29.520
Tecnicamente, eu poderia apenas copiar o comprimento da string s e, bem na parte inferior

01:30:29.520 --> 01:30:33.030
aqui, eu poderia fazer algo como t colchetes i--

01:30:33.030 --> 01:30:38.010
desculpe, t suporte strlen de t.

01:30:38.010 --> 01:30:39.520
Eu poderia fazer isso.

01:30:39.520 --> 01:30:41.010
Mas isso simplesmente não é necessário.

01:30:41.010 --> 01:30:43.540
Eu poderia adicioná-lo manualmente no final da string.

01:30:43.540 --> 01:30:46.170
Mas, novamente, eu diria que é mais simples pedir emprestado,

01:30:46.170 --> 01:30:48.450
que é copy, aquela que já está no s porque é

01:30:48.450 --> 01:30:50.370
a mesma coisa no final do dia.

01:30:50.370 --> 01:30:51.130
Boa pergunta.

01:30:51.130 --> 01:30:53.960
Outras perguntas sobre esta cópia corretamente agora?

01:30:57.040 --> 01:30:57.540
Tudo bem.

01:30:57.540 --> 01:31:00.070
Há espaço para melhorias aqui?

01:31:00.070 --> 01:31:02.310
Bem, deixe-me propor uma pequena otimização.

01:31:02.310 --> 01:31:04.860
Isso é uma espécie de retrocesso agora para a primeira semana.

01:31:04.860 --> 01:31:09.810
Acontece que, indiscutivelmente, minha linha 13 aqui, onde eu tenho este loop for,

01:31:09.810 --> 01:31:12.750
agora que estou fazendo as coisas em loops de novo e de novo

01:31:12.750 --> 01:31:15.210
e usando uma função como strlen, isso está correto.

01:31:15.210 --> 01:31:21.510
Ele irá iterar de zero até o comprimento de i, comprimento de s mais 1.

01:31:21.510 --> 01:31:26.910
Mas é meio estúpido da minha parte escrever isso for loop dessa maneira.

01:31:26.910 --> 01:31:27.438
Por que?

01:31:27.438 --> 01:31:29.230
Bem, aqui está minha inicialização à esquerda.

01:31:29.230 --> 01:31:30.930
Aqui está a minha condição no meio.

01:31:30.930 --> 01:31:35.190
E, em geral, chamar uma função dentro de sua condição

01:31:35.190 --> 01:31:38.400
provavelmente não é um design muito bom.

01:31:38.400 --> 01:31:39.000
Por que?

01:31:39.000 --> 01:31:43.260
Por que é ruim para mim chamar uma função como strlen nesta condição

01:31:43.260 --> 01:31:44.610
no meio do meu loop for?

01:31:44.610 --> 01:31:45.150
Sim.

01:31:45.150 --> 01:31:48.430
AUDIÊNCIA: [INAUDÍVEL]

01:31:48.430 --> 01:31:50.930
DAVID J. MALAN: Sim, você está ligando de novo e de novo

01:31:50.930 --> 01:31:51.650
por nenhuma razão.

01:31:51.650 --> 01:31:53.040
O comprimento de s nunca muda.

01:31:53.040 --> 01:31:55.820
Então, por que você está perdendo o tempo de todos chamando strlen de s

01:31:55.820 --> 01:32:00.110
novamente, novamente, novamente, novamente apenas para verificar essa desigualdade, se eu

01:32:00.110 --> 01:32:01.350
é menor que esse valor?

01:32:01.350 --> 01:32:03.260
Acontece que, se você ainda não descobriu isso,

01:32:03.260 --> 01:32:05.093
há uma pequena otimização que podemos fazer aqui

01:32:05.093 --> 01:32:08.570
que não tem nada a ver fundamentalmente com strings ou ponteiros, apenas

01:32:08.570 --> 01:32:09.770
com melhor desenho.

01:32:09.770 --> 01:32:12.260
Na verdade, posso definir duas variáveis ​​ao mesmo tempo.

01:32:12.260 --> 01:32:13.350
Eu poderia fazer isso.

01:32:13.350 --> 01:32:15.230
Deixe-me remover toda essa condição.

01:32:15.230 --> 01:32:20.660
E deixe-me adicionar uma vírgula depois que i for igual a 0, definir n ou qualquer variável,

01:32:20.660 --> 01:32:24.590
igual ao strlen de s mais 1.

01:32:24.590 --> 01:32:30.020
Depois do ponto e vírgula, faça a pergunta enquanto i for menor que n.

01:32:30.020 --> 01:32:31.620
Então é quase o mesmo.

01:32:31.620 --> 01:32:35.090
Mas observe agora minha condição bem no meio deste loop

01:32:35.090 --> 01:32:37.730
está, pelo menos, comparando dois valores estáticos.

01:32:37.730 --> 01:32:38.700
n nunca muda.

01:32:38.700 --> 01:32:39.200
Desculpe.

01:32:39.200 --> 01:32:41.390
Um valor estático. n nunca muda.

01:32:41.390 --> 01:32:42.500
Tudo o que muda é eu.

01:32:42.500 --> 01:32:45.810
Mas não estou chamando strlen, strlen, strlen tolamente de novo e de novo.

01:32:45.810 --> 01:32:46.310
Por que?

01:32:46.310 --> 01:32:47.600
Bem, como funciona o strlen?

01:32:47.600 --> 01:32:52.547
Semelhante em espírito a printf, strlen, dado o nome de uma string,

01:32:52.547 --> 01:32:54.380
olha para o primeiro caractere e então começa

01:32:54.380 --> 01:32:57.590
procurando por toda a string procurando o caractere NUL.

01:32:57.590 --> 01:33:01.320
E vimos isso na segunda semana, contando quantos personagens existem.

01:33:01.320 --> 01:33:03.820
Portanto, é apenas uma perda de tempo repetidas vezes.

01:33:03.820 --> 01:33:09.330
AUDIÊNCIA: [INAUDÍVEL] até o topo, então, [INAUDÍVEL]??

01:33:09.330 --> 01:33:10.330
DAVID J. MALAN: Totalmente.

01:33:10.330 --> 01:33:12.220
Se você quiser usar n várias vezes, você

01:33:12.220 --> 01:33:16.330
poderia absolutamente tirá-lo do loop for, colocá-lo logo após s ser definido,

01:33:16.330 --> 01:33:17.770
e reutilizar n e novamente e novamente.

01:33:17.770 --> 01:33:18.430
Absolutamente.

01:33:18.430 --> 01:33:19.990
Mas, em geral, considere isso.

01:33:19.990 --> 01:33:23.500
Ao projetar for loops, embora compiladores modernos como Clang,

01:33:23.500 --> 01:33:26.200
pode realmente corrigir esse problema, essa ineficiência para você,

01:33:26.200 --> 01:33:29.320
boa prática seria não chamar funções desnecessariamente,

01:33:29.320 --> 01:33:33.020
especialmente se a resposta for sempre a mesma.

01:33:33.020 --> 01:33:33.520
Tudo bem.

01:33:33.520 --> 01:33:37.100
Então, o que mais devo refinar aqui?

01:33:37.100 --> 01:33:41.380
Bem, que tal eu fazer uma última coisa e apenas comentar sobre o que exatamente

01:33:41.380 --> 01:33:42.890
pode dar errado aqui.

01:33:42.890 --> 01:33:44.320
Bem, um par de coisas.

01:33:44.320 --> 01:33:46.480
Bem, na verdade, isso também é bobo.

01:33:46.480 --> 01:33:50.290
Certamente, alguém antes de mim no mundo já teve que copiar uma string antes.

01:33:50.290 --> 01:33:53.380
Certamente, há uma função chamada strcpy talvez,

01:33:53.380 --> 01:33:55.000
como strcompare, como strlen.

01:33:55.000 --> 01:33:55.900
E de fato existe.

01:33:55.900 --> 01:33:58.960
Então, deixe-me propor que realmente nos livremos de todo esse loop for

01:33:58.960 --> 01:34:03.880
e, na verdade, apenas chamamos uma função chamada strcpy, não O, apenas strcpy.

01:34:03.880 --> 01:34:08.320
E passe o destino, que é t primeiro, e depois a fonte

01:34:08.320 --> 01:34:10.300
que você deseja copiar para o destino.

01:34:10.300 --> 01:34:13.810
E isso ocupa inteiramente o lugar de todo esse loop.

01:34:13.810 --> 01:34:17.140
Então, novamente, demonstrei o loop primeiro apenas para ser muito pedante sobre isso.

01:34:17.140 --> 01:34:18.320
Mas isso é perder tempo.

01:34:18.320 --> 01:34:20.820
Você está perdendo tempo escrevendo linhas de código desnecessárias.

01:34:20.820 --> 01:34:24.020
strcpy é o que você pode usar aqui.

01:34:24.020 --> 01:34:25.720
E então isso agora sempre existiu.

01:34:25.720 --> 01:34:26.930
E o que mais posso fazer?

01:34:26.930 --> 01:34:30.520
Bem, como um ponto final, verifica-se que na verdade há

01:34:30.520 --> 01:34:33.940
coisas que podem dar errado neste código, mesmo além da string

01:34:33.940 --> 01:34:34.785
sendo muito curto.

01:34:34.785 --> 01:34:37.160
Se o humano apenas apertar Enter e não houver caracteres,

01:34:37.160 --> 01:34:40.243
Não quero capitalizar cegamente o primeiro caractere que não existe.

01:34:40.243 --> 01:34:41.950
É por isso que adicionei essa condição if.

01:34:41.950 --> 01:34:43.840
Mas há outras coisas que podem dar errado.

01:34:43.840 --> 01:34:45.520
E nós os apresentamos a você hoje.

01:34:45.520 --> 01:34:52.330
Acontece que funções como get string e funções como malloc return

01:34:52.330 --> 01:34:54.190
potencialmente um valor especial.

01:34:54.190 --> 01:34:58.320
E maravilhosamente confuso, também é chamado de NULL, mas com dois L's.

01:34:58.320 --> 01:34:58.820
Tudo bem?

01:34:58.820 --> 01:35:01.780
Então, mão esquerda e mão direita não se falavam tão bem décadas atrás.

01:35:01.780 --> 01:35:04.480
NUL é uma barra invertida zero.

01:35:04.480 --> 01:35:08.950
É um único personagem, como sempre foi por algumas semanas.

01:35:08.950 --> 01:35:12.070
NULL é tecnicamente um ponteiro.

01:35:12.070 --> 01:35:14.650
É um endereço, mas é o endereço zero.

01:35:14.650 --> 01:35:18.550
É como o canto superior esquerdo, se preferir, da memória do seu computador

01:35:18.550 --> 01:35:21.490
que simplesmente nada deve entrar por convenção.

01:35:21.490 --> 01:35:24.790
Então NULL é sinônimo de zero.

01:35:24.790 --> 01:35:26.260
Mas é especificamente um endereço.

01:35:26.260 --> 01:35:27.500
Agora, por que isso é útil?

01:35:27.500 --> 01:35:30.622
Bem, suponha que no meu código aqui, algo dê errado com get string.

01:35:30.622 --> 01:35:33.830
Suponha que você esteja sendo um pouco louco e digite uma string muito longa.

01:35:33.830 --> 01:35:36.223
Não é apenas oi, mas é como um ensaio inteiro de texto.

01:35:36.223 --> 01:35:38.140
E não há memória suficiente no computador.

01:35:38.140 --> 01:35:41.350
Como obter sinal de string para o programador, uau,

01:35:41.350 --> 01:35:44.290
isso é uma string muito grande, não consigo encaixá-la na memória?

01:35:44.290 --> 01:35:45.860
Bem, nós nunca dissemos isso a você.

01:35:45.860 --> 01:35:49.120
Mas todo esse tempo, acontece que get

01:35:49.120 --> 01:35:53.600
string retornará este valor especial chamado NULL se algo der errado.

01:35:53.600 --> 01:35:57.080
Portanto, para ter muito cuidado agora, você deve fazer algo assim.

01:35:57.080 --> 01:36:03.160
Se s for igual a literalmente NULL, então é melhor você sair do programa completamente

01:36:03.160 --> 01:36:06.400
e retorne como um, ou dois, ou três para significar que algo deu errado.

01:36:06.400 --> 01:36:08.320
Não vá mais longe.

01:36:08.320 --> 01:36:12.002
Da mesma forma com malloc, é possível se você pedir muita memória, isso

01:36:12.002 --> 01:36:14.710
pode falhar, especialmente se você está pedindo agora o dobro da memória

01:36:14.710 --> 01:36:16.168
depois que o humano digitou algo.

01:36:16.168 --> 01:36:18.760
Portanto, se t é igual a NULL, sabe de uma coisa?

01:36:18.760 --> 01:36:20.860
Vamos também retornar um, ou algum outro valor,

01:36:20.860 --> 01:36:25.220
para apenas sair antes que algo caia ou congele no humano também.

01:36:25.220 --> 01:36:28.377
Sinceramente, não costumo fazer isso sempre em sala de aula porque o código apenas

01:36:28.377 --> 01:36:29.710
fica tão inchado e complicado.

01:36:29.710 --> 01:36:32.780
Mas você absolutamente na prática precisa começar a fazer isso.

01:36:32.780 --> 01:36:36.040
Caso contrário, você será responsável pelos congelamentos e travamentos,

01:36:36.040 --> 01:36:38.140
e as reinicializações que os usuários no mundo real

01:36:38.140 --> 01:36:40.450
pode realmente encontrar o contrário.

01:36:40.450 --> 01:36:43.300
Claro, se chegarmos ao fundo deste programa agora,

01:36:43.300 --> 01:36:46.960
Eu provavelmente deveria retornar zero explicitamente, ou implicitamente, para apenas

01:36:46.960 --> 01:36:50.260
significa que tudo é bem sucedido.

01:36:50.260 --> 01:36:52.660
Mas há outra coisa que não fiz.

01:36:52.660 --> 01:36:53.890
Apresentamos malloc.

01:36:53.890 --> 01:36:55.725
Mas o que eu afirmei que também existia?

01:36:55.725 --> 01:36:56.350
AUDIÊNCIA: Gratuito.

01:36:56.350 --> 01:36:57.220
DAVID J. MALAN: Tão livre.

01:36:57.220 --> 01:36:58.762
Eu também estou sendo um pouco imprudente agora.

01:36:58.762 --> 01:37:00.850
Aqui não estou praticando o que estou pregando.

01:37:00.850 --> 01:37:03.370
Estou pedindo memória ao computador via get string,

01:37:03.370 --> 01:37:05.830
Estou pedindo mais memória ao computador via malloc,

01:37:05.830 --> 01:37:08.210
e eu nunca vou devolvê-lo tecnicamente.

01:37:08.210 --> 01:37:11.770
Então, realmente o que eu deveria estar fazendo no final do meu programa

01:37:11.770 --> 01:37:16.120
também está liberando a memória que eu pedi.

01:37:16.120 --> 01:37:19.540
Doravante, é uma regra, uma lei, se você quiser em C,

01:37:19.540 --> 01:37:23.380
sempre que você aloca memória com malloc, ou algumas outras funções

01:37:23.380 --> 01:37:27.670
também, você, o programador, deve liberá-lo quando terminar.

01:37:27.670 --> 01:37:30.250
Agora, isso é um pouco exagerado porque, tecnicamente,

01:37:30.250 --> 01:37:32.800
quando os programas são encerrados, eles liberam a memória automaticamente.

01:37:32.800 --> 01:37:35.410
Então você não vai quebrar o Mac ou PC de alguém porque você necessariamente

01:37:35.410 --> 01:37:35.980
tem esse bug.

01:37:35.980 --> 01:37:38.480
Mas para programas que estão rodando o tempo todo, como alguém

01:37:38.480 --> 01:37:41.890
mantém um Chrome, seu navegador aberto, Microsoft Word ou similares, coisas ruins

01:37:41.890 --> 01:37:44.960
vai acontecer se com o tempo você nunca, nunca, nunca ligar de graça

01:37:44.960 --> 01:37:46.210
e o programa continua rodando.

01:37:46.210 --> 01:37:48.250
Portanto, adquira sempre esse hábito aqui.

01:37:48.250 --> 01:37:52.540
Você não precisa da memória livre que vem de get string porque o CS50

01:37:52.540 --> 01:37:54.680
biblioteca libera automaticamente para você.

01:37:54.680 --> 01:37:58.840
Mas você, sempre que usar malloc daqui em diante, como você fez ou eu fiz aqui,

01:37:58.840 --> 01:38:04.150
você deve liberar isso apenas passando no mesmo endereço que você voltou.

01:38:04.150 --> 01:38:09.740
Perguntas agora no malloc e grátis?

01:38:09.740 --> 01:38:11.000
Questões?

01:38:11.000 --> 01:38:11.890
Sim.

01:38:11.890 --> 01:38:17.878
AUDIÊNCIA: [INAUDÍVEL]

01:38:17.878 --> 01:38:19.420
DAVID J. MALAN: Realmente boa pergunta.

01:38:19.420 --> 01:38:22.260
Tão grátis apenas-- então o que o grátis faz?

01:38:22.260 --> 01:38:26.072
Tão grátis apenas permite que o computador saiba que você

01:38:26.072 --> 01:38:27.780
são feitos com esse pedaço de memória, que

01:38:27.780 --> 01:38:29.572
significa que se você tiver outra linha de código

01:38:29.572 --> 01:38:32.430
em outro lugar, essa mesma memória pode ser reutilizada,

01:38:32.430 --> 01:38:34.020
e pode ser usado novamente e novamente.

01:38:34.020 --> 01:38:36.280
E isso certamente será necessário para qualquer programa de longa duração.

01:38:36.280 --> 01:38:37.827
Você não pode pedir memória constantemente.

01:38:37.827 --> 01:38:38.910
Você acabará por esgotar.

01:38:38.910 --> 01:38:40.368
Portanto, você precisa liberá-lo dessa maneira.

01:38:40.368 --> 01:38:41.555
Outras línguas como um aparte.

01:38:41.555 --> 01:38:43.680
Python, mais uma motivação em algumas semanas

01:38:43.680 --> 01:38:46.013
pois será Python e algumas outras linguagens

01:38:46.013 --> 01:38:47.890
gerencie toda essa dor de cabeça para você.

01:38:47.890 --> 01:38:52.600
Mas em C, o objetivo aqui é realmente aproveitar esses recursos nós mesmos.

01:38:52.600 --> 01:38:53.100
Tudo bem.

01:38:53.100 --> 01:38:56.140
Acontece que quase todos na sala, todos na sala,

01:38:56.140 --> 01:38:57.420
inclusive eu, você vai estragar tudo

01:38:57.420 --> 01:39:00.090
quando se trata de qualquer coisa relacionada à memória, se você ainda não o fez.

01:39:00.090 --> 01:39:01.630
Seg falhas estão em seu futuro.

01:39:01.630 --> 01:39:04.560
Mas espero que existam ferramentas através das quais você pode detectar essas coisas

01:39:04.560 --> 01:39:09.750
e corrija-os proativamente, e não apenas use printf, debug50 ou pato de borracha.

01:39:09.750 --> 01:39:12.397
Na verdade, temos outra ferramenta com a qual podemos equipá-lo agora

01:39:12.397 --> 01:39:13.980
que irá ajudá-lo a encontrar alguns erros.

01:39:13.980 --> 01:39:14.920
Então deixe-me fazer isso.

01:39:14.920 --> 01:39:16.800
Deixe-me fechar copy.c.

01:39:16.800 --> 01:39:19.980
Deixe-me abrir um programa que escrevi com antecedência chamado memory.c

01:39:19.980 --> 01:39:22.120
isso não faz nada realmente interessante.

01:39:22.120 --> 01:39:24.070
Mas vai ter dois bugs nele.

01:39:24.070 --> 01:39:27.090
Observe que incluí standardio.h como sempre.

01:39:27.090 --> 01:39:30.270
Também incluí standardlib.h, que é necessário agora

01:39:30.270 --> 01:39:33.690
para qualquer coisa relacionada a malloc e ou free e afins.

01:39:33.690 --> 01:39:34.890
Linha seis.

01:39:34.890 --> 01:39:36.730
É um pouco estranho o que eu fiz aqui.

01:39:36.730 --> 01:39:42.300
Mas esta é a maneira manual de solicitar memória suficiente para uma matriz.

01:39:42.300 --> 01:39:45.690
Na segunda semana, como pedimos memória para um array?

01:39:45.690 --> 01:39:49.470
Você simplesmente diz, int x3.

01:39:49.470 --> 01:39:52.140
E isso dá a você um array chamado x de tamanho três.

01:39:52.140 --> 01:39:55.770
Mas se você fizer isso manualmente agora usando malloc, o que você tem que fazer

01:39:55.770 --> 01:39:57.780
é usar sintaxe como esta.

01:39:57.780 --> 01:40:02.173
Você chama malloc, pede três coisas vezes o tamanho de um int.

01:40:02.173 --> 01:40:03.090
Agora sabemos que são quatro.

01:40:03.090 --> 01:40:04.650
Então você poderia literalmente escrever 12 aqui.

01:40:04.650 --> 01:40:06.250
Mas isso é mais genérico.

01:40:06.250 --> 01:40:09.930
Portanto, três vezes o tamanho de um número inteiro fornecerá 12 dinamicamente.

01:40:09.930 --> 01:40:11.280
E o que malloc retorna?

01:40:11.280 --> 01:40:14.400
O endereço do primeiro byte que você recebe de volta.

01:40:14.400 --> 01:40:15.940
Onde eu quero colocar isso?

01:40:15.940 --> 01:40:17.560
Bem, eu quero colocá-lo em uma variável.

01:40:17.560 --> 01:40:20.620
Agora a variável não pode ser apenas int x porque é um número.

01:40:20.620 --> 01:40:22.260
Não é um endereço em si.

01:40:22.260 --> 01:40:25.530
Se eu quiser armazenar este endereço em uma variável, posso chamá-la de x,

01:40:25.530 --> 01:40:26.490
Eu poderia chamá-lo de p.

01:40:26.490 --> 01:40:31.200
Mas int star x significa apenas que x agora é o endereço de um pedaço de memória,

01:40:31.200 --> 01:40:33.420
especificamente um pedaço de memória que é grande o suficiente não

01:40:33.420 --> 01:40:36.660
para um, mas para três ints no total.

01:40:36.660 --> 01:40:39.930
Tudo bem, agora, estou apenas colocando ingenuamente

01:40:39.930 --> 01:40:43.210
nosso velho amigo 72, 73 e 33 no primeiro, segundo,

01:40:43.210 --> 01:40:44.940
e terceiros locais na memória.

01:40:44.940 --> 01:40:47.340
Mas talvez com base na segunda ou quarta semana,

01:40:47.340 --> 01:40:49.530
Estou claramente estragando tudo aqui de algumas maneiras.

01:40:49.530 --> 01:40:52.200
Alguém quer identificar pelo menos um bug?

01:40:52.200 --> 01:40:53.193
O que eu fiz errado?

01:40:53.193 --> 01:40:55.110
AUDIÊNCIA: Você começa do zero em vez do um.

01:40:55.110 --> 01:40:58.410
DAVID J. MALAN: Sim, isso agora é coisa de amador.

01:40:58.410 --> 01:41:00.790
Eu deveria estar indexando zero e não uma indexação.

01:41:00.790 --> 01:41:03.210
Então isso tem que ser zero, um, dois no final das contas.

01:41:03.210 --> 01:41:05.775
E outros bugs que talvez sejam mais específicos da quarta semana?

01:41:08.340 --> 01:41:09.180
Outros erros.

01:41:09.180 --> 01:41:09.930
É mais sutil.

01:41:09.930 --> 01:41:10.430
Sim.

01:41:10.430 --> 01:41:11.310
AUDIÊNCIA: [INAUDÍVEL]

01:41:11.310 --> 01:41:12.390
DAVID J. MALAN: Não estou liberando a memória, certo?

01:41:12.390 --> 01:41:14.970
Portanto, não estou praticando o que estou pregando liberando essa memória.

01:41:14.970 --> 01:41:16.470
Agora suponha que eles não sejam óbvios.

01:41:16.470 --> 01:41:20.070
E honestamente, depois de uma ou duas horas disso, isso ainda não deveria ser óbvio.

01:41:20.070 --> 01:41:21.420
Será ao longo do tempo.

01:41:21.420 --> 01:41:25.830
Como eu poderia encontrar esses bugs com software em vez de

01:41:25.830 --> 01:41:28.530
para apenas olhar para a coisa, ou pedir ajuda a alguém?

01:41:28.530 --> 01:41:29.980
Bem, deixe-me propor isso.

01:41:29.980 --> 01:41:33.930
Deixe-me primeiro ir em frente e executar make memory para compilar o programa.

01:41:33.930 --> 01:41:35.970
E parece funcionar - parece bom.

01:41:35.970 --> 01:41:37.800
Não há erros de sintaxe, pelo menos.

01:41:37.800 --> 01:41:40.838
A memória dot slash, observe, parece funcionar bem também.

01:41:40.838 --> 01:41:42.880
Agora, este programa não faz nada de interessante.

01:41:42.880 --> 01:41:44.610
Não há printf ou algo assim.

01:41:44.610 --> 01:41:45.760
Mas não caiu.

01:41:45.760 --> 01:41:48.000
Não há falha de segmentação. Mas isso não

01:41:48.000 --> 01:41:51.060
significa que não há bugs latentes no software.

01:41:51.060 --> 01:41:54.090
E isso é verdade, infelizmente, para todos os softwares atuais.

01:41:54.090 --> 01:41:56.340
Chrome e Microsoft Word e outros programas

01:41:56.340 --> 01:42:00.120
certamente têm bugs relacionados à memória que as pessoas do Google e da Microsoft

01:42:00.120 --> 01:42:01.080
ainda não encontrei.

01:42:01.080 --> 01:42:04.410
Mas existem ferramentas pelo menos para encontrar o mais óbvio desses bugs.

01:42:04.410 --> 01:42:07.620
E vamos apresentar a você agora um programa chamado valgrind.

01:42:07.620 --> 01:42:09.900
Então, valgrind, é um programa bastante sofisticado.

01:42:09.900 --> 01:42:11.700
Mas vamos usá-lo para maneiras muito simples.

01:42:11.700 --> 01:42:15.840
Analisaremos seu código e encontraremos erros de memória durante a execução

01:42:15.840 --> 01:42:18.060
e tentar ajudá-lo a entender onde eles estão.

01:42:18.060 --> 01:42:20.190
Então, deixe-me voltar ao VS Code aqui.

01:42:20.190 --> 01:42:21.515
A memória parece estar bem.

01:42:21.515 --> 01:42:23.640
Eu sinto que, OK, vou enviar este dever de casa.

01:42:23.640 --> 01:42:24.180
Tudo está bem.

01:42:24.180 --> 01:42:25.170
Nenhuma mensagem de erro.

01:42:25.170 --> 01:42:26.620
Isso não é mais o caso.

01:42:26.620 --> 01:42:28.740
Agora você precisa mexer um pouco mais no seu código

01:42:28.740 --> 01:42:30.820
para ver se talvez ainda haja algum bug lá.

01:42:30.820 --> 01:42:35.560
Então deixe-me fazer isso. valgrind e depois espaço, ponto barra memória.

01:42:35.560 --> 01:42:38.700
Assim como o debug50, você o executa em um programa que já compilou.

01:42:38.700 --> 01:42:41.550
valgrind, vou rodar em um programa que já compilei.

01:42:41.550 --> 01:42:44.760
Deixe-me ampliar a janela do meu terminal para que possamos ver mais de uma vez.

01:42:44.760 --> 01:42:46.110
E Entre.

01:42:46.110 --> 01:42:49.273
Tudo bem, a saída é absurdamente enigmática sem um bom motivo.

01:42:49.273 --> 01:42:50.940
Há muitos números e sinais de igualdade.

01:42:50.940 --> 01:42:52.200
É muita confusão.

01:42:52.200 --> 01:42:54.250
Mas há algumas informações suculentas aqui.

01:42:54.250 --> 01:42:55.950
E deixe-me começar de cima para baixo.

01:42:55.950 --> 01:42:58.470
Gravação inválida de tamanho quatro.

01:42:58.470 --> 01:43:02.400
Portanto, escrever significa alterar um valor, ler significa acessar um valor.

01:43:02.400 --> 01:43:06.000
E isso é, novamente, esotérico, como muitas de nossas mensagens de erro.

01:43:06.000 --> 01:43:11.580
Mas parece que depois de um bloco de tamanho 12 alocado, e então há

01:43:11.580 --> 01:43:13.200
essas estranhas notações hexadecimais.

01:43:13.200 --> 01:43:14.580
Há alguma menção de malloc.

01:43:14.580 --> 01:43:18.120
Mas honestamente, a parte interessante aqui é memory.c, linha seis.

01:43:18.120 --> 01:43:21.610
Isso é provavelmente minha culpa. Então, vamos olhar para a linha seis por essa saída.

01:43:21.610 --> 01:43:24.300
Deixe-me encolher a janela do terminal, veja a linha seis.

01:43:24.300 --> 01:43:26.160
OK, 12 agora é pertinente.

01:43:26.160 --> 01:43:29.000
Se você fez a matemática mental do tamanho de um n vezes 3,

01:43:29.000 --> 01:43:31.170
12 está de alguma forma envolvido aqui.

01:43:31.170 --> 01:43:36.090
Mas a linha seis agora está acontecendo aqui.

01:43:36.090 --> 01:43:37.650
Foi daí que veio a memória.

01:43:37.650 --> 01:43:38.500
O que é isso?

01:43:38.500 --> 01:43:39.480
Deixe-me ampliar novamente.

01:43:39.480 --> 01:43:45.150
Onde há gravação inválida de tamanho quatro?

01:43:45.150 --> 01:43:47.820
O que talvez esteja acontecendo de errado aqui?

01:43:47.820 --> 01:43:49.830
Gravação inválida de tamanho quatro.

01:43:49.830 --> 01:43:50.880
O que isso significa?

01:43:50.880 --> 01:43:53.850
É como uma forma muito técnica de explicar.

01:43:53.850 --> 01:43:57.270
O bug está na verdade uma linha depois, na linha sete, como já identificamos.

01:43:57.270 --> 01:43:57.945
Sim.

01:43:57.945 --> 01:43:58.820
AUDIÊNCIA: [INAUDÍVEL]

01:43:58.820 --> 01:43:59.300
DAVID J. MALAN: De fato.

01:43:59.300 --> 01:44:00.467
E eu falei errado um momento atrás.

01:44:00.467 --> 01:44:02.420
O bug realmente surge aqui com a linha nove.

01:44:02.420 --> 01:44:06.575
Portanto, após a alocação de memória, estou de alguma forma escrevendo 4 bytes incorretamente.

01:44:06.575 --> 01:44:08.450
E, infelizmente, o ônus é meio que seu

01:44:08.450 --> 01:44:11.420
para pensar dedutivamente o que isso poderia significar.

01:44:11.420 --> 01:44:14.960
Mas estou claramente tocando em 4 bytes de memória nessas poucas linhas de código

01:44:14.960 --> 01:44:15.797
que eu não deveria ser.

01:44:15.797 --> 01:44:18.380
E espero que aqui, como a lâmpada já apagou antes,

01:44:18.380 --> 01:44:20.150
oh, eu não sou indexação zero.

01:44:20.150 --> 01:44:22.800
OK, isso deve significar que x colchete três, como você sabe,

01:44:22.800 --> 01:44:25.170
está muito além do pedaço de memória.

01:44:25.170 --> 01:44:28.670
Portanto, estou escrevendo invalidamente em 4 bytes que não deveria.

01:44:28.670 --> 01:44:30.200
Então, novamente, não é super óbvio.

01:44:30.200 --> 01:44:31.920
Isso não é super amigável.

01:44:31.920 --> 01:44:35.120
Mas pelo menos dá uma pista de onde está o bug.

01:44:35.120 --> 01:44:38.690
Portanto, a solução será simplesmente alterar o

01:44:38.690 --> 01:44:42.020
a zero, dois a um e três a dois.

01:44:42.020 --> 01:44:42.775
Isso vai resolver isso.

01:44:42.775 --> 01:44:44.150
Mas ainda há um segundo erro.

01:44:44.150 --> 01:44:46.250
E deixe-me olhar para a saída enigmática novamente.

01:44:46.250 --> 01:44:50.180
Resumo da pilha, algumas coisas lá, OK, isso não soa bem aqui.

01:44:50.180 --> 01:44:54.740
12 bytes em um bloco são definitivamente perdidos no registro de perda um de um.

01:44:54.740 --> 01:44:56.510
Saída muito arcana dois.

01:44:56.510 --> 01:44:59.970
Mas claramente relacionado à linha seis novamente, nossa alocação de memória.

01:44:59.970 --> 01:45:02.300
Agora também aqui, não é óbvio qual é a solução.

01:45:02.300 --> 01:45:04.010
Mas a memória está perdida.

01:45:04.010 --> 01:45:05.900
AKA, isso é um vazamento de memória.

01:45:05.900 --> 01:45:08.910
E agora a dedução depende de você.

01:45:08.910 --> 01:45:09.720
O que está vazando?

01:45:09.720 --> 01:45:10.220
Oh espere.

01:45:10.220 --> 01:45:11.480
Eu não liguei de graça.

01:45:11.480 --> 01:45:13.760
E então a segunda solução aqui é provavelmente

01:45:13.760 --> 01:45:16.242
para liberar x no final do programa.

01:45:16.242 --> 01:45:18.950
E se você realmente quer ser pedante, provavelmente deveria verificar,

01:45:18.950 --> 01:45:21.590
como propus anteriormente, se x for NULL, apenas

01:45:21.590 --> 01:45:24.260
saia agora enquanto pode e nem

01:45:24.260 --> 01:45:25.650
toque nessas outras linhas de código.

01:45:25.650 --> 01:45:27.410
Mas se você chegar ao fundo, retorne zero.

01:45:27.410 --> 01:45:30.740
Mas, na verdade, as conclusões são: consertei minha indexação zero

01:45:30.740 --> 01:45:33.530
da matriz para evitar a gravação inválida de tamanho quatro.

01:45:33.530 --> 01:45:36.390
E agora estou liberando a memória que pedi.

01:45:36.390 --> 01:45:37.927
Portanto, não deve haver vazamento perdido.

01:45:37.927 --> 01:45:39.260
Tudo bem, vamos tentar isso de novo.

01:45:39.260 --> 01:45:41.900
Faça memória, ponto barra memória.

01:45:41.900 --> 01:45:43.370
Ainda não há erros visíveis.

01:45:43.370 --> 01:45:45.980
Mas deixe-me agora aumentar minha janela de terminal novamente, faça

01:45:45.980 --> 01:45:49.010
valgrind da memória ponto slash, cruzando os dedos,

01:45:49.010 --> 01:45:53.598
e agora todos os blocos de heap foram liberados, nenhum vazamento é possível.

01:45:53.598 --> 01:45:54.890
Não vejo nenhuma gravação inválida.

01:45:54.890 --> 01:45:56.150
Ainda há uma quantidade louca de produção.

01:45:56.150 --> 01:45:57.350
Mas nada disso é errado.

01:45:57.350 --> 01:45:58.310
Não é ruim.

01:45:58.310 --> 01:46:00.020
Agora consertei meus bugs de memória.

01:46:00.020 --> 01:46:01.970
E então agora meu ta, meu tf, eles não vão

01:46:01.970 --> 01:46:03.890
para encontrá-los porque pelo menos valgrind

01:46:03.890 --> 01:46:05.990
tem proativamente feito isso por mim.

01:46:05.990 --> 01:46:08.717
Perguntas então sobre valgrind?

01:46:08.717 --> 01:46:11.300
Geralmente, são esses dois tipos de erros que você pode tropeçar.

01:46:11.300 --> 01:46:14.720
Não há muito mais no caminho da saída arcana.

01:46:14.720 --> 01:46:17.550
Perguntas então sobre isso?

01:46:17.550 --> 01:46:18.050
Não?

01:46:18.050 --> 01:46:20.640
Tudo bem, bem, o que mais pode estar acontecendo?

01:46:20.640 --> 01:46:22.530
Então, alguém aludiu a isso antes.

01:46:22.530 --> 01:46:26.780
O que acontece quando você, por exemplo, esquece o terminador NULL

01:46:26.780 --> 01:46:30.740
ou você geralmente começa a vasculhar a memória que você mesmo não pediu

01:46:30.740 --> 01:46:33.440
ou olhando valores que você não colocou lá?

01:46:33.440 --> 01:46:34.940
Bem, deixe-me ir em frente e abrir isto.

01:46:34.940 --> 01:46:39.140
Código de trash.c, em homenagem a Oscar the Grouch aqui das sortes.

01:46:39.140 --> 01:46:42.740
E aqui está um programa simples se eu esconder minha janela de terminal que

01:46:42.740 --> 01:46:44.390
apenas faz algo meio arbitrário.

01:46:44.390 --> 01:46:47.870
Primeiro declaro um array chamado scores.

01:46:47.870 --> 01:46:50.630
Mas eu o tornei muito grande, como 1024.

01:46:50.630 --> 01:46:52.520
São muitos números inteiros.

01:46:52.520 --> 01:46:53.430
Mas assim seja.

01:46:53.430 --> 01:46:55.520
E então eu integro sobre esses números inteiros.

01:46:55.520 --> 01:46:57.350
E imprimo cada uma dessas pontuações.

01:46:57.350 --> 01:46:59.570
Estou usando a sintaxe da segunda semana aqui.

01:46:59.570 --> 01:47:02.630
Mas com base neste programa, o que eu claramente não fiz que fiz

01:47:02.630 --> 01:47:04.400
fazer de volta na segunda semana?

01:47:04.400 --> 01:47:07.355
Eu aloquei o array, estou imprimindo o array, mas, mas, mas...

01:47:07.355 --> 01:47:09.600
AUDIÊNCIA: [INAUDÍVEL]

01:47:09.600 --> 01:47:12.600
DAVID J. MALAN: Sim, não inicializei nenhum valor para esse array.

01:47:12.600 --> 01:47:14.160
Na segunda semana, não fizemos 1024.

01:47:14.160 --> 01:47:14.910
Nós gostamos de três.

01:47:14.910 --> 01:47:17.310
E digitei três pontuações de teste ou algo assim.

01:47:17.310 --> 01:47:20.310
Aqui, estou alocando memória ainda mais do que isso só porque realmente

01:47:20.310 --> 01:47:22.310
quero ser dramático com o que estou demonstrando.

01:47:22.310 --> 01:47:24.760
Mas não estou inicializando esses valores para nada.

01:47:24.760 --> 01:47:27.660
E então aqui, verifica-se em C, geralmente,

01:47:27.660 --> 01:47:30.300
se você não inicializar uma variável ou não

01:47:30.300 --> 01:47:32.490
inicializar uma matriz com valores explícitos,

01:47:32.490 --> 01:47:35.220
haverá valores de lixo lá, por assim dizer,

01:47:35.220 --> 01:47:39.210
resquícios dessa memória tendo sido usados ​​antes provavelmente

01:47:39.210 --> 01:47:42.540
por alguma outra função sua, alguma função de biblioteca ou outra coisa

01:47:42.540 --> 01:47:43.800
enquanto seu programa está em execução.

01:47:43.800 --> 01:47:46.480
Não é um grande negócio com um programa super pequeno como este.

01:47:46.480 --> 01:47:49.140
Mas para qualquer coisa considerável, a memória será usada,

01:47:49.140 --> 01:47:52.560
e não utilizado, e usado, e não utilizado que é colocado e liberado de novo e de novo.

01:47:52.560 --> 01:47:55.650
Haverá muitos valores de lixo na memória do computador

01:47:55.650 --> 01:47:59.460
por padrão. Então, se eu abrir minha janela de terminal aqui, deixe

01:47:59.460 --> 01:48:04.230
se eu fizer lixo, deixe-me ampliar meu terminal para que possamos ver a saída.

01:48:04.230 --> 01:48:06.960
Quando executo lixo de ponto e barra, teoricamente,

01:48:06.960 --> 01:48:11.445
deve ver 1.024 inteiros, mas nenhum deles foi inicializado.

01:48:11.445 --> 01:48:13.320
Agora vou ter sorte com alguns deles.

01:48:13.320 --> 01:48:16.470
E parece que, uau, OK, muitos deles são inicializados com zero.

01:48:16.470 --> 01:48:19.260
E C em alguns contextos inicializa a memória para você

01:48:19.260 --> 01:48:22.770
a zero, pelo menos no início, mas não de novo e de novo normalmente.

01:48:22.770 --> 01:48:27.870
Mas se eu começar a rolar para trás no tempo neste array de tamanho 1024,

01:48:27.870 --> 01:48:30.780
de onde vieram esses valores?

01:48:30.780 --> 01:48:34.920
Então, apenas números positivos e negativos aleatórios intercalados entre os zeros?

01:48:34.920 --> 01:48:38.848
Bem, isso é porque estou literalmente bisbilhotando os 1.024 aleatórios

01:48:38.848 --> 01:48:40.140
bytes da memória do computador.

01:48:40.140 --> 01:48:41.440
Quem sabe o que está lá?

01:48:41.440 --> 01:48:43.960
Portanto, a lição aqui é que os valores de lixo são de fato

01:48:43.960 --> 01:48:47.910
este termo de R. Isso significa que uma variável que você pode ter

01:48:47.910 --> 01:48:49.980
definido que você pode ter declarado.

01:48:49.980 --> 01:48:53.690
Se você não der um valor explícito, quem sabe o que estará lá?

01:48:53.690 --> 01:48:55.440
E a lição aqui é simplesmente não faça isso.

01:48:55.440 --> 01:48:58.200
Sempre inicialize variáveis ​​para algo,

01:48:58.200 --> 01:49:01.950
ou você mesmo, ou levando o humano para isso.

01:49:01.950 --> 01:49:05.650
Dúvidas sobre valores de lixo.

01:49:05.650 --> 01:49:09.540
Você os verá às vezes se imprimir coisas que não deveria ou tocar em matrizes

01:49:09.540 --> 01:49:11.590
além de seus limites.

01:49:11.590 --> 01:49:12.090
Tudo bem.

01:49:12.090 --> 01:49:15.330
Então, talvez para tornar isso um pouco visual também, muitas coisas

01:49:15.330 --> 01:49:16.860
pode dar errado, infelizmente, com ponteiros.

01:49:16.860 --> 01:49:17.910
E vimos alguns deles.

01:49:17.910 --> 01:49:20.118
E aqui está outro programa um pouco artificial.

01:49:20.118 --> 01:49:20.860
É muito simples.

01:49:20.860 --> 01:49:23.618
E trata-se apenas de manipular valores.

01:49:23.618 --> 01:49:25.410
Ele não faz nada de útil per se, exceto

01:49:25.410 --> 01:49:26.980
demonstrar alguns dos conceitos atuais.

01:49:26.980 --> 01:49:29.580
Então, no main aqui, deixe-me propor que declaremos

01:49:29.580 --> 01:49:32.970
um ponteiro chamado x que vai armazenar eventualmente o endereço de um inteiro

01:49:32.970 --> 01:49:33.630
aparentemente.

01:49:33.630 --> 01:49:36.420
Aqui está outro chamado y que vai armazenar o endereço de um número inteiro

01:49:36.420 --> 01:49:36.990
também.

01:49:36.990 --> 01:49:40.995
Aqui agora, estou alocando memória suficiente para caber em um inteiro.

01:49:40.995 --> 01:49:42.120
Agora, tecnicamente, são quatro.

01:49:42.120 --> 01:49:42.662
Nós sabemos isso.

01:49:42.662 --> 01:49:45.720
Mas o tamanho de int apenas me dá essa resposta dinamicamente.

01:49:45.720 --> 01:49:47.760
Portanto, funcionará em todos os sistemas.

01:49:47.760 --> 01:49:52.230
E vou armazenar o endereço que malloc encontra para mim em x.

01:49:52.230 --> 01:49:56.610
Então eu vou para x e coloco o número 42 lá.

01:49:56.610 --> 01:49:57.690
Tudo bem, por quê?

01:49:57.690 --> 01:50:00.630
O tipo de significado da vida, o universo e tudo aqui,

01:50:00.630 --> 01:50:05.020
mas o asterisco x, novamente, significa apenas ir a esse endereço e colocar um valor lá.

01:50:05.020 --> 01:50:05.670
Então por que?

01:50:05.670 --> 01:50:06.240
Não sei.

01:50:06.240 --> 01:50:08.610
Mas é apenas correto neste ponto.

01:50:08.610 --> 01:50:10.170
Mas e essa linha aqui?

01:50:10.170 --> 01:50:12.900
Estrela y é igual a 13.

01:50:12.900 --> 01:50:14.280
Azar neste caso.

01:50:14.280 --> 01:50:17.362
O que há de ruim nessa fala aqui, star y?

01:50:17.362 --> 01:50:20.070
Agora é uma combinação dos primitivos de hoje e desse ponto aqui.

01:50:20.070 --> 01:50:20.922
Sim.

01:50:20.922 --> 01:50:21.822
AUDIÊNCIA: [INAUDÍVEL]

01:50:21.822 --> 01:50:24.780
DAVID J. MALAN: Sim, não pedimos ao computador para alocar nenhum espaço.

01:50:24.780 --> 01:50:28.750
Então y não foi inicializado com um sinal de igual em nenhum ponto para nada.

01:50:28.750 --> 01:50:31.410
E então, o que há dentro de você, por assim dizer?

01:50:31.410 --> 01:50:32.077
Um valor lixo.

01:50:32.077 --> 01:50:35.077
Talvez seja zero, o que não é ruim, porque pelo menos é bom e simples.

01:50:35.077 --> 01:50:37.090
Mas talvez seja algum grande número positivo louco,

01:50:37.090 --> 01:50:38.650
ou algum grande número negativo maluco.

01:50:38.650 --> 01:50:40.710
De qualquer forma, as chances são se eu for para este endereço

01:50:40.710 --> 01:50:44.562
ou aquele endereço aleatoriamente com estrela y, coisas ruins vão acontecer.

01:50:44.562 --> 01:50:46.020
E então deixe-me ir em frente e propor.

01:50:46.020 --> 01:50:47.200
Bem, não vamos fazer isso.

01:50:47.200 --> 01:50:50.655
Em vez disso, vamos fazer isso, atribuir y igual a x.

01:50:50.655 --> 01:50:51.780
E já fizemos isso antes.

01:50:51.780 --> 01:50:56.580
E então posso ir para y agora e mudar o que era 42 para 13.

01:50:56.580 --> 01:50:57.120
Mais uma vez, por quê?

01:50:57.120 --> 01:50:58.840
Isso é apenas para fins educacionais.

01:50:58.840 --> 01:51:04.020
Mas, por enquanto, isso não trava porque eu apenas desreferencio y com star y

01:51:04.020 --> 01:51:05.550
depois de realmente dar-lhe um valor.

01:51:05.550 --> 01:51:09.570
Embora, um valor duplicado semelhante ao nosso exemplo de cópia anterior.

01:51:09.570 --> 01:51:12.333
Então, nossos amigos de Stanford montaram um visual maravilhoso.

01:51:12.333 --> 01:51:13.500
Tem cerca de dois minutos de duração.

01:51:13.500 --> 01:51:15.960
Permita-me diminuir drasticamente as luzes, se pudermos,

01:51:15.960 --> 01:51:20.550
e brinque com o que acontece com a memória quando você faz coisas ruins como essa.

01:51:20.550 --> 01:51:21.334
[REPRODUÇÃO DE VÍDEO]

01:51:21.334 --> 01:51:23.923
[MÚSICA, TOCANDO]

01:51:23.923 --> 01:51:24.840
LOCUTOR 1: Ei, Binky.

01:51:24.840 --> 01:51:25.620
Acordar.

01:51:25.620 --> 01:51:28.230
É hora de se divertir com o ponteiro.

01:51:28.230 --> 01:51:29.310
BINKY: O que é isso?

01:51:29.310 --> 01:51:30.960
Aprender sobre ponteiros?

01:51:30.960 --> 01:51:32.253
Que bom.

01:51:32.253 --> 01:51:34.170
LOCUTOR 1: Bem, para começar, acho que estamos

01:51:34.170 --> 01:51:35.760
vai precisar de alguns ponteiros.

01:51:35.760 --> 01:51:40.370
BINKY: OK, este código aloca dois ponteiros que podem apontar para inteiros.

01:51:40.370 --> 01:51:42.352
LOCUTOR 1: OK, bem, vejo os dois ponteiros.

01:51:42.352 --> 01:51:44.310
Mas eles não parecem estar apontando para nada.

01:51:44.310 --> 01:51:45.143
BINKY: Isso mesmo.

01:51:45.143 --> 01:51:47.220
Inicialmente, os ponteiros não apontam para nada.

01:51:47.220 --> 01:51:49.500
As coisas para as quais eles apontam são chamadas de pontas.

01:51:49.500 --> 01:51:51.243
E configurá-los é uma etapa separada.

01:51:51.243 --> 01:51:52.410
LOCUTOR 1: Ah, certo, certo.

01:51:52.410 --> 01:51:53.130
Eu sabia.

01:51:53.130 --> 01:51:54.990
As pontas são separadas.

01:51:54.990 --> 01:51:57.390
Então, como você aloca uma ponta?

01:51:57.390 --> 01:52:01.020
BINKY: OK, bem, este código aloca uma nova ponta inteira

01:52:01.020 --> 01:52:04.043
e esta parte define x para apontar para ele.

01:52:04.043 --> 01:52:05.460
LOCUTOR 1: Ei, isso parece melhor.

01:52:05.460 --> 01:52:07.040
Então, faça-o fazer alguma coisa.

01:52:07.040 --> 01:52:10.520
BINKY: OK, vou desreferenciar o ponteiro x para armazenar o número

01:52:10.520 --> 01:52:12.620
42 em sua ponta.

01:52:12.620 --> 01:52:16.250
Para este truque, vou precisar da minha varinha mágica de desreferenciação.

01:52:16.250 --> 01:52:19.940
LOCUTOR 1: Sua varinha mágica de desreferenciação?

01:52:19.940 --> 01:52:21.520
Isso é ótimo.

01:52:21.520 --> 01:52:23.200
BINKY: É assim que o código se parece.

01:52:23.200 --> 01:52:26.025
Vou configurar o número e...

01:52:26.025 --> 01:52:26.900
LOCUTOR 1: Ei, olha.

01:52:26.900 --> 01:52:28.190
Lá vai.

01:52:28.190 --> 01:52:31.790
Então, fazer uma desreferência em x segue a seta

01:52:31.790 --> 01:52:35.240
para acessar sua ponta, no caso, a loja 42 ali dentro.

01:52:35.240 --> 01:52:39.770
Ei, tente usá-lo para armazenar o número 13 por meio do outro ponteiro, y.

01:52:39.770 --> 01:52:41.180
BINKY: Tudo bem.

01:52:41.180 --> 01:52:45.290
Basta ir até aqui para y e configurar o número 13,

01:52:45.290 --> 01:52:49.550
e, em seguida, pegue a varinha de desreferenciação e apenas--

01:52:49.550 --> 01:52:50.948
[SOM DE BUZZER] uau!

01:52:50.948 --> 01:52:51.740
LOCUTOR 1: Ah, ei.

01:52:51.740 --> 01:52:53.120
Isso não funcionou.

01:52:53.120 --> 01:52:58.580
Diga, Binky, não acho que desreferenciar y seja uma boa ideia porque configurar

01:52:58.580 --> 01:53:00.210
a ponta é uma etapa separada.

01:53:00.210 --> 01:53:02.600
E acho que nunca fizemos isso.

01:53:02.600 --> 01:53:03.650
BINKY: Bom ponto.

01:53:03.650 --> 01:53:06.110
LOCUTOR 1: Sim, alocamos o ponteiro y,

01:53:06.110 --> 01:53:09.320
mas nunca o definimos para apontar para uma ponta.

01:53:09.320 --> 01:53:10.458
BINKY: Muito observador.

01:53:10.458 --> 01:53:12.500
LOCUTOR 1: Ei, você está bem aí, Binky.

01:53:12.500 --> 01:53:15.440
Você pode corrigi-lo de modo que y aponte para o mesmo ponto que x?

01:53:15.440 --> 01:53:16.160
BINKY: Claro.

01:53:16.160 --> 01:53:18.782
Vou usar minha varinha mágica de atribuição de ponteiro.

01:53:18.782 --> 01:53:20.990
LOCUTOR 1: Isso vai ser um problema como antes?

01:53:20.990 --> 01:53:22.910
BINKY: Não, isso não toca nas pontas.

01:53:22.910 --> 01:53:26.540
Ele apenas muda um ponteiro para apontar para a mesma coisa que outro.

01:53:26.540 --> 01:53:27.590
LOCUTOR 1: Ah, entendo.

01:53:27.590 --> 01:53:30.575
Agora y aponta para o mesmo lugar que x.

01:53:30.575 --> 01:53:32.150
Então espere, agora y está fixo.

01:53:32.150 --> 01:53:33.230
Tem ponta.

01:53:33.230 --> 01:53:35.210
Então você pode tentar a varinha de desreferenciar novamente

01:53:35.210 --> 01:53:37.790
para enviar os 13.

01:53:37.790 --> 01:53:40.182
BINKY: OK, aqui vai.

01:53:40.182 --> 01:53:41.390
LOCUTOR 1: Ei, olha isso.

01:53:41.390 --> 01:53:43.190
Agora, a desreferenciação funciona em y.

01:53:43.190 --> 01:53:47.210
E porque os ponteiros estão compartilhando aquela ponta, ambos veem o 13.

01:53:47.210 --> 01:53:48.380
BINKY: Sim, compartilhando.

01:53:48.380 --> 01:53:48.920
Qualquer que seja.

01:53:48.920 --> 01:53:50.917
Então vamos trocar de lugar agora?

01:53:50.917 --> 01:53:51.750
LOCUTOR 1: Ah, olha.

01:53:51.750 --> 01:53:52.575
Estamos sem tempo.

01:53:52.575 --> 01:53:53.075
BINKY: Mas...

01:53:53.075 --> 01:53:53.270
[TERMINAR REPRODUÇÃO]

01:53:53.270 --> 01:53:54.980
DAVID J. MALAN: Nossos agradecimentos ao professor Nick Parlante

01:53:54.980 --> 01:53:57.290
de Stanford por passar uma grande quantidade de tempo

01:53:57.290 --> 01:53:59.180
fazendo animação em stop motion para isso.

01:53:59.180 --> 01:54:02.120
Mas espero que agora você tenha uma noção do que também pode dar errado

01:54:02.120 --> 01:54:04.612
quando você faz mau uso de uma memória dessa maneira.

01:54:04.612 --> 01:54:06.320
Mas no final do dia, nós realmente só

01:54:06.320 --> 01:54:08.070
temos esses quatro novos blocos de construção hoje,

01:54:08.070 --> 01:54:11.090
como o operador estrela, o operador e comercial, malloc e free.

01:54:11.090 --> 01:54:13.340
E realmente com isso, e o entendimento subjacente

01:54:13.340 --> 01:54:15.810
do que seu computador está fazendo sob o capô,

01:54:15.810 --> 01:54:18.242
nós temos esse jeito agora de realmente manipular as coisas

01:54:18.242 --> 01:54:19.700
na memória, para o bem ou para o mal.

01:54:19.700 --> 01:54:21.960
E, eventualmente, veremos como podemos construir coisas.

01:54:21.960 --> 01:54:23.930
Mas agora também podemos usar os primitivos de hoje

01:54:23.930 --> 01:54:26.390
para explicar melhor algumas coisas que temos

01:54:26.390 --> 01:54:29.130
pedindo-lhe para tomar como certo ao longo das últimas semanas.

01:54:29.130 --> 01:54:33.200
Então, por exemplo, deixe-me propor que façamos...

01:54:33.200 --> 01:54:35.180
um voluntário aqui em cima, se pudéssemos.

01:54:35.180 --> 01:54:37.392
Podemos conseguir um voluntário que...

01:54:37.392 --> 01:54:38.600
você quer vir direto para cima?

01:54:38.600 --> 01:54:39.810
Sim, bem no meio.

01:54:39.810 --> 01:54:40.070
Vamos.

01:54:40.070 --> 01:54:41.903
Você terá que virar à esquerda ou à direita lá.

01:54:47.760 --> 01:54:48.360
Tudo bem.

01:54:48.360 --> 01:54:52.380
Temos aqui dois copos vazios e duas cores de líquido.

01:54:52.380 --> 01:54:57.150
E nós temos, deixe-me dar-lhe o microfone, se você quiser dizer olá ao grupo.

01:54:57.150 --> 01:54:57.840
MONGE: Olá.

01:54:57.840 --> 01:54:58.950
Eu sou Moine.

01:54:58.950 --> 01:55:00.780
Estou no [INAUDÍVEL] e no primeiro ano.

01:55:00.780 --> 01:55:01.170
DAVID J. MALAN: Tudo bem.

01:55:01.170 --> 01:55:01.670
Bem-vindo.

01:55:01.670 --> 01:55:02.520
Bem, bem-vindo aqui.

01:55:02.520 --> 01:55:06.390
Vou encher esses dois copos com esse líquido colorido,

01:55:06.390 --> 01:55:08.280
roxo aqui à minha direita.

01:55:08.280 --> 01:55:11.430
Vamos encher um copo aqui.

01:55:11.430 --> 01:55:12.690
MOINE: É ameaçador.

01:55:12.690 --> 01:55:14.460
DAVID J. MALAN: Sim, não beba.

01:55:14.460 --> 01:55:18.250
E agora vamos colocar um pouco de laranja aqui.

01:55:18.250 --> 01:55:21.660
E o que gostaríamos que você fizesse para o público, se não se importar,

01:55:21.660 --> 01:55:23.583
é trocar os dois valores.

01:55:23.583 --> 01:55:25.500
Você tem um valor roxo e um valor laranja.

01:55:25.500 --> 01:55:28.770
E eu gostaria do líquido roxo neste copo e do líquido laranja

01:55:28.770 --> 01:55:29.655
nesse copo, por favor.

01:55:32.652 --> 01:55:34.010
MOINE: Posso tomar outro copo?

01:55:34.010 --> 01:55:34.550
DAVID J. MALAN: Ah, tudo bem.

01:55:34.550 --> 01:55:35.390
Boa intuição.

01:55:35.390 --> 01:55:37.267
Mas para o microfone--

01:55:37.267 --> 01:55:38.600
MOINE: Posso tomar outro copo?

01:55:38.600 --> 01:55:39.440
DAVID J. MALAN: Então você pode.

01:55:39.440 --> 01:55:41.552
E na verdade, eu trouxe um aqui para você.

01:55:41.552 --> 01:55:43.010
Por que você está pedindo isso?

01:55:43.010 --> 01:55:45.620
MOINE: Porque se eu despejar isso aqui, vai se misturar.

01:55:45.620 --> 01:55:46.537
DAVID J. MALAN: Certo.

01:55:46.537 --> 01:55:49.410
Obviamente, precisamos de uma variável temporária, se preferir.

01:55:49.410 --> 01:55:52.765
Então aqui está sua variável temporária.

01:55:52.765 --> 01:55:53.640
MOINE: E você quer...

01:55:53.640 --> 01:55:54.330
OK.

01:55:54.330 --> 01:55:55.205
DAVID J. MALAN: Sim.

01:55:55.205 --> 01:55:56.640
Há-- sim.

01:55:56.640 --> 01:55:59.730
Tudo bem então despejando o valor do copo laranja

01:55:59.730 --> 01:56:03.390
nesta variável temporária, se você quiser.

01:56:03.390 --> 01:56:04.080
Tudo bem.

01:56:04.080 --> 01:56:09.240
E agora despejando o valor do copo roxo no antigo copo laranja.

01:56:12.740 --> 01:56:14.270
E agora--

01:56:14.270 --> 01:56:15.570
MOINE: E agora isso volta.

01:56:15.570 --> 01:56:19.965
DAVID J. MALAN: O valor temporário volta para o vidro roxo original.

01:56:19.965 --> 01:56:21.840
E agora acho que damos uma salva de palmas

01:56:21.840 --> 01:56:23.132
por ter feito isso muito bem.

01:56:23.132 --> 01:56:25.970
[INAUDÍVEL]

01:56:25.970 --> 01:56:27.120
MOINE: Obrigado.

01:56:27.120 --> 01:56:28.280
DAVID J. MALAN: Tudo bem.

01:56:28.280 --> 01:56:31.680
Portanto, não é preciso dizer que, no mundo real, é assim que você faz isso.

01:56:31.680 --> 01:56:34.430
E, de fato, no código, é basicamente assim que você deve fazer isso,

01:56:34.430 --> 01:56:37.632
embora pergunte-nos em algum momento uma maneira super chique de fazer isso

01:56:37.632 --> 01:56:38.840
sem uma variável temporária.

01:56:38.840 --> 01:56:41.090
Acontece que é possível usar bits.

01:56:41.090 --> 01:56:43.703
Mas, por enquanto, vamos supor que, de fato, isso demonstre

01:56:43.703 --> 01:56:44.870
qual é a realidade no código.

01:56:44.870 --> 01:56:46.910
Se você quiser trocar dois valores, você precisa ter

01:56:46.910 --> 01:56:48.990
algo como uma variável temporária.

01:56:48.990 --> 01:56:52.820
Então, por exemplo, na tela aqui está um-- o começo de uma função

01:56:52.820 --> 01:56:56.420
chamado swap, cujo objetivo na vida é, como você acabou de fazer, trocar dois valores,

01:56:56.420 --> 01:56:59.270
chame de A e B. Então, laranja e roxo, respectivamente

01:56:59.270 --> 01:57:01.730
agora são apenas A e B e números inteiros para manter as coisas simples.

01:57:01.730 --> 01:57:03.688
Bem, aqui está o código correspondente, se me permite,

01:57:03.688 --> 01:57:05.300
ao que você acabou de representar como humano.

01:57:05.300 --> 01:57:08.700
Você declarou uma variável temporária, uma chamada temporária neste caso,

01:57:08.700 --> 01:57:10.640
que foi como eu entregando a você o copo vazio.

01:57:10.640 --> 01:57:14.000
E você armazenou o líquido laranja nele, também conhecido como A, você então

01:57:14.000 --> 01:57:19.190
mude o valor do vidro anteriormente laranja para ser igual ao roxo

01:57:19.190 --> 01:57:20.480
despejando um no outro.

01:57:20.480 --> 01:57:22.040
E então você fez o oposto lá.

01:57:22.040 --> 01:57:25.500
Agora, no final disso, você ainda tem uma variável temporária que agora está vazia.

01:57:25.500 --> 01:57:27.260
Portanto, é temporário literalmente nesse sentido.

01:57:27.260 --> 01:57:28.552
Você simplesmente não precisa mais disso.

01:57:28.552 --> 01:57:30.570
Mas foi necessário ao longo do caminho.

01:57:30.570 --> 01:57:33.770
Portanto, ouso dizer que este código está correto logicamente.

01:57:33.770 --> 01:57:39.440
Isso irá trocar dois valores A e B graças ao uso dessa variável temporária.

01:57:39.440 --> 01:57:42.348
Infelizmente, porém, se eu realmente fizer isso na prática,

01:57:42.348 --> 01:57:44.390
deixe-me ir até o VS Code aqui e abrir um programa

01:57:44.390 --> 01:57:48.920
Eu escrevi com antecedência chamado swap.c, que faz isso da seguinte maneira.

01:57:48.920 --> 01:57:52.790
Aqui, observe que tenho meu protótipo para uma função de troca bem no topo.

01:57:52.790 --> 01:57:54.590
E deixe-me rolar até o final.

01:57:54.590 --> 01:57:56.210
Existe exatamente o mesmo código.

01:57:56.210 --> 01:58:00.050
Então eu sou o mesmo código para trocar dois valores A e B,

01:58:00.050 --> 01:58:02.253
que estou afirmando por enquanto está correto.

01:58:02.253 --> 01:58:04.670
Agora, se eu voltar aqui, o que main vai fazer por nós?

01:58:04.670 --> 01:58:06.628
Main é apenas para ser uma demonstração

01:58:06.628 --> 01:58:08.220
da exatidão do seu algoritmo.

01:58:08.220 --> 01:58:11.990
Aqui eu declaro na linha sete e oito, duas variáveis, x e y,

01:58:11.990 --> 01:58:14.660
sendo um e dois arbitrariamente, respectivamente.

01:58:14.660 --> 01:58:18.230
Em seguida, na linha 10, apenas imprimo qual é o valor de x e y

01:58:18.230 --> 01:58:20.210
é apenas para que eu possa vê-lo na tela.

01:58:20.210 --> 01:58:22.940
Em seguida, chamo a função swap na linha 11,

01:58:22.940 --> 01:58:26.780
e então eu literalmente imprimo exatamente a mesma coisa novamente, eu imprimo x e y.

01:58:26.780 --> 01:58:29.190
Esperançosamente, obviamente será o oposto.

01:58:29.190 --> 01:58:31.640
Então eu acho que logicamente, a troca é realmente correta.

01:58:31.640 --> 01:58:34.520
Deixe-me fazer a troca e, em seguida, a troca de ponto e barra.

01:58:34.520 --> 01:58:40.100
E devo ver que x é 1, y é 2 e, com sorte, x é 2, y é 1.

01:58:40.100 --> 01:58:41.630
Digitar.

01:58:41.630 --> 01:58:42.980
Mas eu não.

01:58:42.980 --> 01:58:46.800
E funcionou no sentido de que o código foi compilado, o código foi executado.

01:58:46.800 --> 01:58:49.010
Portanto, não é um bug nesse sentido.

01:58:49.010 --> 01:58:52.850
Mas porque eu não entendo muito bem o que está acontecendo por baixo do capô,

01:58:52.850 --> 01:58:55.370
pelo menos a partir de agora, ou semanas anteriores,

01:58:55.370 --> 01:58:59.330
este código aqui é realmente bugado de alguma forma.

01:58:59.330 --> 01:59:02.660
Mas alguém tem uma intuição, talvez baseada na discussão de hoje,

01:59:02.660 --> 01:59:06.500
por que esse código, embora logicamente correto, funciona claramente na realidade,

01:59:06.500 --> 01:59:09.670
aparentemente não funciona em C?

01:59:09.670 --> 01:59:10.780
Alguma intuição?

01:59:10.780 --> 01:59:11.320
Sim.

01:59:11.320 --> 01:59:13.980
AUDIÊNCIA: [INAUDÍVEL]

01:59:13.980 --> 01:59:14.980
DAVID J. MALAN: Perfeito.

01:59:14.980 --> 01:59:17.147
E para resumir, aqui está o termo artístico que prometo.

01:59:17.147 --> 01:59:20.680
Quando você chama uma função e passa dois argumentos, como a e b,

01:59:20.680 --> 01:59:23.120
você está passando esses argumentos por valor.

01:59:23.120 --> 01:59:25.850
Portanto, cópias desses valores de forma eficaz.

01:59:25.850 --> 01:59:28.610
E então, quando swap é realmente chamado aqui -

01:59:28.610 --> 01:59:29.110
desculpe.

01:59:29.110 --> 01:59:31.682
Quando você passa por um x e y, nós os chamamos de a e b.

01:59:31.682 --> 01:59:32.890
Mas isso é apenas uma convenção.

01:59:32.890 --> 01:59:35.410
Podemos chamar os parâmetros do que quisermos.

01:59:35.410 --> 01:59:39.950
O que a e b são são de fato os valores de x e y, respectivamente,

01:59:39.950 --> 01:59:41.810
mas cópias dos valores.

01:59:41.810 --> 01:59:45.220
Então esse código aqui faz muito sucesso, no VS Code também,

01:59:45.220 --> 01:59:47.110
trocando os valores de a e b.

01:59:47.110 --> 01:59:51.610
Mas, como você notou, porque estou passando por valor, literalmente um,

01:59:51.610 --> 01:59:55.450
literalmente dois, e não por outro termo da arte, por referência, AKA

01:59:55.450 --> 01:59:59.650
por seus endereços, swap não tem capacidade em C

01:59:59.650 --> 02:00:02.740
para ir a esses locais, trocar os locais reais,

02:00:02.740 --> 02:00:04.990
assim como fizemos com sucesso na realidade.

02:00:04.990 --> 02:00:07.300
Mas acho que já temos a sintaxe

02:00:07.300 --> 02:00:10.690
para resolver isso se considerarmos que realmente, isso é apenas uma questão de escopo.

02:00:10.690 --> 02:00:12.790
Já falamos um pouco sobre escopo no passado,

02:00:12.790 --> 02:00:16.150
em que o escopo se refere ao contexto em que uma variável vive.

02:00:16.150 --> 02:00:18.310
E geralmente, eu afirmei que existe uma variável

02:00:18.310 --> 02:00:20.290
entre as chaves mais recentes.

02:00:20.290 --> 02:00:24.010
E isso é verdade para a função de troca porque a e b,

02:00:24.010 --> 02:00:27.670
Agora reivindico novamente, existem apenas no contexto dessas chaves.

02:00:27.670 --> 02:00:32.048
Eles não têm efeito no main up top, que tem diferentes variáveis ​​x e y.

02:00:32.048 --> 02:00:34.840
Mas podemos considerar agora o que realmente está acontecendo sob o capô.

02:00:34.840 --> 02:00:37.360
E aqui está a mesma imagem da memória, como vimos no passado.

02:00:37.360 --> 02:00:39.550
Se aumentarmos o zoom e vermos esses pequenos chips pretos,

02:00:39.550 --> 02:00:41.200
este é um monte de bytes de memória.

02:00:41.200 --> 02:00:43.780
Se eu criar uma grade apenas para destacar

02:00:43.780 --> 02:00:47.500
que podemos endereçar cada um desses bytes, jogar fora a placa de circuito de plástico,

02:00:47.500 --> 02:00:51.430
e focar apenas nesses bytes, o que está acontecendo sob o capô

02:00:51.430 --> 02:00:55.600
quando as funções são chamadas em C, o que você vem fazendo há semanas?

02:00:55.600 --> 02:00:59.350
Bem, esse retângulo de memória, se nós meio que abstrairmos ainda mais,

02:00:59.350 --> 02:01:02.870
é geralmente dividido em diferentes regiões ou segmentos,

02:01:02.870 --> 02:01:04.000
como eu os chamei antes.

02:01:04.000 --> 02:01:06.490
E coisas diferentes são colocadas em partes diferentes

02:01:06.490 --> 02:01:07.760
da memória do computador.

02:01:07.760 --> 02:01:10.330
E sem entrar muito no mato, quando

02:01:10.330 --> 02:01:12.490
você clica duas vezes em um programa no seu Mac ou PC,

02:01:12.490 --> 02:01:15.940
ou quando você faz dot slash algo em um Linux,

02:01:15.940 --> 02:01:19.630
você está carregando seu código de máquina na memória do computador

02:01:19.630 --> 02:01:21.410
do disco rígido do computador.

02:01:21.410 --> 02:01:24.550
Assim, todos os zeros e uns que compõem o Microsoft Word, ou Chrome,

02:01:24.550 --> 02:01:27.970
ou o que quer que esteja carregado na memória ou RAM do computador.

02:01:27.970 --> 02:01:31.360
E, por convenção, é colocado no topo da chamada área de código de máquina.

02:01:31.360 --> 02:01:34.660
E é assim que a CPU tem acesso a eles rapidamente.

02:01:34.660 --> 02:01:37.450
Abaixo disso estão o que serão nossos globais.

02:01:37.450 --> 02:01:40.360
Portanto, variáveis ​​globais, que não usamos muito em C.

02:01:40.360 --> 02:01:44.080
Mas você pode declará-los fora de main no topo de seus arquivos.

02:01:44.080 --> 02:01:47.320
Se você tem globais, eles acabam lá também, apenas para sua informação.

02:01:47.320 --> 02:01:49.180
E então há esse grande pedaço de memória

02:01:49.180 --> 02:01:52.480
que vimos valgrind mencionar indiretamente anteriormente chamado de heap.

02:01:52.480 --> 02:01:54.340
E é como uma pilha, literalmente.

02:01:54.340 --> 02:01:57.550
É um monte de memória que você pode usar como quiser.

02:01:57.550 --> 02:02:01.030
E a pilha é de onde malloc pega a memória.

02:02:01.030 --> 02:02:02.920
Então, inicialmente, não há nada na pilha.

02:02:02.920 --> 02:02:04.480
É apenas um grande pedaço de espaço livre.

02:02:04.480 --> 02:02:08.680
Sempre que você chama malloc, malloc sai da área de heap

02:02:08.680 --> 02:02:09.790
mais e mais bytes.

02:02:09.790 --> 02:02:11.920
E malloc acompanha, essencialmente, quais

02:02:11.920 --> 02:02:13.480
bytes já foram alocados.

02:02:13.480 --> 02:02:14.890
Então, inicialmente, parece vazio.

02:02:14.890 --> 02:02:17.290
Mas bytes diferentes, quadrados se você quiser,

02:02:17.290 --> 02:02:20.560
continuam sendo solicitados repetidamente enquanto um programa é executado graças às funções

02:02:20.560 --> 02:02:21.340
como malloc.

02:02:21.340 --> 02:02:23.900
E cresce, se você quiser, conceitualmente para baixo.

02:02:23.900 --> 02:02:27.173
Portanto, quanto mais memória você solicitar do malloc, ele será iniciado aqui.

02:02:27.173 --> 02:02:29.590
Mas então o próximo pedaço que você obtém está aqui conceitualmente.

02:02:29.590 --> 02:02:31.250
O próximo pedaço está aqui embaixo, aqui embaixo.

02:02:31.250 --> 02:02:35.170
Então, meio que preenche o espaço disponível na memória geral do computador.

02:02:35.170 --> 02:02:38.740
Mas há outro pedaço de memória chamado pilha.

02:02:38.740 --> 02:02:42.250
E assim como uma pilha de bandejas em Annenberg ou uma cafeteria,

02:02:42.250 --> 02:02:45.340
tipo de crescer para cima, assim como uma pilha de memória.

02:02:45.340 --> 02:02:50.620
E acontece que a pilha é onde as funções têm variáveis,

02:02:50.620 --> 02:02:53.530
e ter argumentos armazenados temporariamente.

02:02:53.530 --> 02:02:57.100
Então, sempre que você chamar uma função e ela tiver variáveis ​​dentro dela,

02:02:57.100 --> 02:03:00.010
ou tem argumentos lá também, este é o pedaço de memória,

02:03:00.010 --> 02:03:03.610
e o bloco geral de memória do computador, que são usados ​​para funções.

02:03:03.610 --> 02:03:06.425
Mas sempre que você chama malloc, é memória aqui em cima.

02:03:06.425 --> 02:03:08.800
No final do dia, eles só tinham que escolher uma direção.

02:03:08.800 --> 02:03:10.660
Acima, abaixo e tecnicamente é a interpretação de um artista.

02:03:10.660 --> 02:03:13.310
Você pode circular essa coisa em qualquer orientação que desejar.

02:03:13.310 --> 02:03:16.540
Mas você está apenas usando uma quantidade finita de memória dessa maneira convencional.

02:03:16.540 --> 02:03:19.360
Malloc começa aqui, as funções começam aqui.

02:03:19.360 --> 02:03:22.415
Agora você pode ver onde coisas ruins podem acontecer.

02:03:22.415 --> 02:03:24.790
E, de fato, uma das outras razões pelas quais programas, computadores,

02:03:24.790 --> 02:03:27.910
pode travar é se você pedir muita memória da pilha

02:03:27.910 --> 02:03:30.040
ligando para malloc muitas, muitas, muitas vezes,

02:03:30.040 --> 02:03:33.730
ou se você chamar muitas funções, ou acidentalmente na última semana,

02:03:33.730 --> 02:03:37.570
você recursa infinitas vezes, pode haver uma falha de segmentação.

02:03:37.570 --> 02:03:40.100
E isso porque você está usando muita memória de pilha.

02:03:40.100 --> 02:03:42.460
Portanto, isso provavelmente será um problema eventualmente.

02:03:42.460 --> 02:03:45.550
E o ônus é do programador apenas minimizar

02:03:45.550 --> 02:03:49.270
a probabilidade de fazer isso e realmente evitar a possibilidade de fazer isso

02:03:49.270 --> 02:03:53.770
apenas verificando os valores de retorno, verificando se malloc ou get string retornam NULL.

02:03:53.770 --> 02:03:56.260
Porque você pode proativamente com condicionais

02:03:56.260 --> 02:03:59.830
certifique-se de que essas duas coisas não colidam apenas certificando-se

02:03:59.830 --> 02:04:02.060
que você recupere valores não NULL.

02:04:02.060 --> 02:04:04.840
Então, vamos considerar a pilha no contexto de troca

02:04:04.840 --> 02:04:06.400
e o que realmente está acontecendo aqui.

02:04:06.400 --> 02:04:09.233
E Carter, se você não se importar em me ajudar a animar a tela aqui,

02:04:09.233 --> 02:04:13.000
quando chamo a função principal de qualquer programa,

02:04:13.000 --> 02:04:17.483
é alocada uma fatia de memória chamada quadro na parte inferior dessa pilha.

02:04:17.483 --> 02:04:19.650
Então, se Carter, você quiser seguir em frente e avançar aqui,

02:04:19.650 --> 02:04:22.260
aqui está a primeira fatia de memória que sempre

02:04:22.260 --> 02:04:26.520
ser usado por main se tiver argumentos de linha de comando ou variáveis ​​locais.

02:04:26.520 --> 02:04:28.260
Acaba ficando aqui na memória.

02:04:28.260 --> 02:04:32.980
Suponha agora, de acordo com nosso programa swap.c, que main chama swap.

02:04:32.980 --> 02:04:35.190
Bem, onde vai parar a memória para swap?

02:04:35.190 --> 02:04:35.950
Aqui em cima.

02:04:35.950 --> 02:04:39.390
Então swap tinha duas variáveis-- dois argumentos a e b.

02:04:39.390 --> 02:04:41.140
E também tinha uma variável temporária.

02:04:41.140 --> 02:04:42.993
Então tudo isso acaba aqui na memória.

02:04:42.993 --> 02:04:44.910
E se você quiser ir em frente e avançar novamente,

02:04:44.910 --> 02:04:48.330
Carter, uma vez que a troca é executada, seja apenas

02:04:48.330 --> 02:04:51.780
retorna porque não há mais linhas de código ou você retorna explicitamente,

02:04:51.780 --> 02:04:54.577
essa memória é liberada automaticamente.

02:04:54.577 --> 02:04:55.410
Você não liga de graça.

02:04:55.410 --> 02:04:56.610
Você não desfaz malloc.

02:04:56.610 --> 02:04:58.110
Isso tudo acontece automaticamente.

02:04:58.110 --> 02:04:59.880
Foi desde a primeira semana.

02:04:59.880 --> 02:05:02.820
Agora, tecnicamente, ainda está lá, embora tenhamos

02:05:02.820 --> 02:05:04.200
removeu-o da imagem.

02:05:04.200 --> 02:05:06.870
E aí está sua primeira sugestão de valores de lixo.

02:05:06.870 --> 02:05:08.340
Ainda há zeros e uns lá.

02:05:08.340 --> 02:05:11.340
E eles são deixados no original-- a configuração anterior.

02:05:11.340 --> 02:05:13.967
E então a razão pela qual você obtém valores aleatórios na memória

02:05:13.967 --> 02:05:16.050
é porque, embora não tenhamos desenhado swap aqui,

02:05:16.050 --> 02:05:17.730
havia coisas lá um momento atrás.

02:05:17.730 --> 02:05:20.400
Estará lá na próxima vez que você usar a mesma memória.

02:05:20.400 --> 02:05:23.250
Agora vamos seguir em frente e passar por isso um pouco mais metodicamente.

02:05:23.250 --> 02:05:27.210
Main tem duas variáveis ​​chamadas x e y um e dois.

02:05:27.210 --> 02:05:30.330
Então vamos avançar e representar x como um, y como dois

02:05:30.330 --> 02:05:31.950
ocupando esses dois pedaços de memória.

02:05:31.950 --> 02:05:35.130
Quando chamamos swap agora, swap recebe uma nova fatia de memória

02:05:35.130 --> 02:05:40.050
que então nos dá três variáveis, a e b, tecnicamente os argumentos,

02:05:40.050 --> 02:05:40.800
e temp.

02:05:40.800 --> 02:05:41.820
Então o que acontece?

02:05:41.820 --> 02:05:45.900
Bem, como as funções passam automaticamente valores por valor,

02:05:45.900 --> 02:05:48.930
ou melhor, passar argumentos por valor, x fica

02:05:48.930 --> 02:05:53.130
copiado para a, y é copiado para b, e então uma vez que nós

02:05:53.130 --> 02:05:55.920
começar a executar o algoritmo, a la os copos d'água, bem,

02:05:55.920 --> 02:05:57.040
o que acontece aqui?

02:05:57.040 --> 02:06:01.710
Portanto, se eu executar a primeira linha de código, temp é igual a a, temp obtém uma cópia de a.

02:06:01.710 --> 02:06:03.645
O que acontece depois? a é igual a b.

02:06:03.645 --> 02:06:05.880
Assim, a assume uma cópia de b.

02:06:05.880 --> 02:06:09.030
E agora fazemos a troca final no vidro, b é igual a temp.

02:06:09.030 --> 02:06:10.890
b obtém uma cópia de temp.

02:06:10.890 --> 02:06:13.872
Agora não precisamos alterar a temperatura porque ela está essencialmente vazia,

02:06:13.872 --> 02:06:15.330
embora haja o valor do lixo.

02:06:15.330 --> 02:06:18.390
Um sempre estará lá até que reutilizemos essa memória.

02:06:18.390 --> 02:06:21.240
O importante, porém, é que a e b foram trocados.

02:06:21.240 --> 02:06:26.430
Mas o que obviamente não foi trocado, como se manifesta quando a troca retorna, x

02:06:26.430 --> 02:06:27.660
e y são intocáveis.

02:06:27.660 --> 02:06:29.830
Porque as cópias foram passadas.

02:06:29.830 --> 02:06:31.690
Portanto, precisamos de uma solução para esse problema.

02:06:31.690 --> 02:06:34.290
E se avançarmos mais uma vez, se você não se importa, deixe-me passar por aqui

02:06:34.290 --> 02:06:35.748
mas, em seguida, chamá-lo de volta em um segundo.

02:06:35.748 --> 02:06:38.310
Este código aqui é logicamente correto.

02:06:38.310 --> 02:06:39.540
Isto é o que você fez.

02:06:39.540 --> 02:06:41.460
Mas isso agora é um detalhe de c.

02:06:41.460 --> 02:06:44.670
Você não pode simplesmente trocar as coisas por valor, porque você só está mudando

02:06:44.670 --> 02:06:46.260
no escopo da função swap.

02:06:46.260 --> 02:06:50.610
Mas acho que se mudarmos para isso e adicionarmos alguma sintaxe irritante,

02:06:50.610 --> 02:06:52.500
nós podemos resolver o problema.

02:06:52.500 --> 02:06:55.740
Assim como você pode declarar variáveis ​​como endereços de armazenamento,

02:06:55.740 --> 02:07:00.360
você pode declarar argumentos para funções, parâmetros AKA, como endereços.

02:07:00.360 --> 02:07:04.950
Esta nova versão do swap significa que a deve ser o endereço de um inteiro.

02:07:04.950 --> 02:07:07.050
b deve ser o endereço de um número inteiro.

02:07:07.050 --> 02:07:09.150
E agora fica um pouco enigmático aqui.

02:07:09.150 --> 02:07:12.270
Temp é o mesmo porque é apenas um número inteiro como era na primeira semana.

02:07:12.270 --> 02:07:14.040
Nada de especial sobre temp.

02:07:14.040 --> 02:07:18.135
Mas se você deseja obter o valor em a, você marca a estrela.

02:07:18.135 --> 02:07:21.150
E isso vai para o endereço, pega o número um presumivelmente.

02:07:21.150 --> 02:07:24.268
Se você quiser alterar o valor de a, vá para esse endereço,

02:07:24.268 --> 02:07:26.310
você segue o mapa do tesouro até a outra caixa de correio,

02:07:26.310 --> 02:07:29.310
e você o iguala a qualquer valor de b.

02:07:29.310 --> 02:07:30.900
Você vai para b também.

02:07:30.900 --> 02:07:33.450
Última linha, você vai para b agora e muda para ser

02:07:33.450 --> 02:07:36.990
qualquer que fosse a variável temporária, que era a mesma que a.

02:07:36.990 --> 02:07:39.300
Então é aí que o valor final é trocado.

02:07:39.300 --> 02:07:41.810
Mas aqui, há muito mais entrecruzamento metafórico

02:07:41.810 --> 02:07:43.560
através do palco onde você está indo para todos

02:07:43.560 --> 02:07:46.950
desses endereços diferentes na função swap para fazer essas alterações.

02:07:46.950 --> 02:07:49.200
Então, se avançarmos agora para a versão pictórica disso,

02:07:49.200 --> 02:07:51.480
aqui está a mesma história de antes com main.

02:07:51.480 --> 02:07:53.700
E x e y são um e dois, respectivamente.

02:07:53.700 --> 02:07:57.540
Quando a troca for chamada agora, observe, e farei isso com setas aqui,

02:07:57.540 --> 02:08:01.680
a está efetivamente apontando para x, b está efetivamente apontando para y.

02:08:01.680 --> 02:08:04.290
Se realmente entrarmos no mato, na verdade são endereços.

02:08:04.290 --> 02:08:05.910
Mas quem se importa com os detalhes?

02:08:05.910 --> 02:08:07.540
É realmente apenas o conceito aqui.

02:08:07.540 --> 02:08:08.700
Então agora o que acontece?

02:08:08.700 --> 02:08:10.500
A temperatura interna recebe estrela a.

02:08:10.500 --> 02:08:12.840
Estrela a significa começar em a e ir até lá.

02:08:12.840 --> 02:08:14.160
Siga a seta, se quiser.

02:08:14.160 --> 02:08:15.570
Tipo de calhas e estilo de escadas.

02:08:15.570 --> 02:08:16.620
E então esse é um.

02:08:16.620 --> 02:08:18.010
Então, colocamos um em temp.

02:08:18.010 --> 02:08:18.510
Tudo bem.

02:08:18.510 --> 02:08:20.123
A estrela a é igual à estrela b.

02:08:20.123 --> 02:08:21.540
Então, vamos fazer da direita para a esquerda.

02:08:21.540 --> 02:08:23.220
Estrela b significa seguir a seta.

02:08:23.220 --> 02:08:24.050
São dois.

02:08:24.050 --> 02:08:25.050
E então o que você faz?

02:08:25.050 --> 02:08:26.040
Siga a seta.

02:08:26.040 --> 02:08:29.790
Agora são dois porque você copia um para o outro da direita para a esquerda.

02:08:29.790 --> 02:08:31.740
E, finalmente, a estrela b recebe temperatura.

02:08:31.740 --> 02:08:33.270
Então comece em b, vá para b.

02:08:33.270 --> 02:08:36.330
E agora armazene qualquer valor em temp.

02:08:36.330 --> 02:08:39.930
Então, apenas por ter essa nova sintaxe básica de e comercial e estrelas,

02:08:39.930 --> 02:08:42.270
e assim por diante, agora podemos ir a lugares

02:08:42.270 --> 02:08:44.790
e contornar o que de outra forma é uma característica de C,

02:08:44.790 --> 02:08:47.160
que essas variáveis ​​têm escopo local.

02:08:47.160 --> 02:08:50.265
Mas você ainda pode acessar coisas em outras funções também.

02:08:50.265 --> 02:08:52.390
Então, muito obrigado por ajudar a passar por isso.

02:08:52.390 --> 02:08:55.440
Agora temos uma aplicação disso que

02:08:55.440 --> 02:08:59.830
explica por que agora, nesta versão do código C, isso realmente funcionaria.

02:08:59.830 --> 02:09:03.030
Na verdade, deixe-me voltar ao meu código de troca aqui.

02:09:03.030 --> 02:09:06.030
E deixe-me mudar a função levemente no VS Code.

02:09:06.030 --> 02:09:08.800
Então, deixe-me rolar para baixo, deixando o principal igual.

02:09:08.800 --> 02:09:13.590
E deixe-me mudar o protótipo de swaps para receber endereços.

02:09:13.590 --> 02:09:15.060
Deixe-me ir para um aqui.

02:09:15.060 --> 02:09:16.320
Deixe-me ir para um aqui.

02:09:16.320 --> 02:09:17.760
Deixe-me ir para b aqui.

02:09:17.760 --> 02:09:19.590
E deixe-me ir para b aqui também.

02:09:19.590 --> 02:09:20.930
Mas nada mais muda.

02:09:20.930 --> 02:09:23.540
Essa mudança aqui em particular é uma pista suficiente

02:09:23.540 --> 02:09:27.410
para ver o que significa quando você chama swap e passa dois valores,

02:09:27.410 --> 02:09:31.040
Estou esperando endereços agora, não números inteiros.

02:09:31.040 --> 02:09:34.640
Mas agora que fiz essa alteração, preciso ir até a página principal

02:09:34.640 --> 02:09:37.490
e faça uma alteração.

02:09:37.490 --> 02:09:40.190
Alguém tem a intuição do que agora precisa mudar

02:09:40.190 --> 02:09:45.590
em main para que eu passe em x e y por referência, ou seja, por endereço e não

02:09:45.590 --> 02:09:48.290
do que por valor ou cópia?

02:09:48.290 --> 02:09:49.652
Sim, atrás.

02:09:49.652 --> 02:09:52.198
AUDIÊNCIA: [INAUDÍVEL]

02:09:52.198 --> 02:09:53.240
DAVID J. MALAN: Tão perto.

02:09:53.240 --> 02:09:57.170
Então, na linha de troca, não é uma estrela que eu quero na frente do x e do y.

02:09:57.170 --> 02:09:59.834
Em vez disso...

02:09:59.834 --> 02:10:00.720
AUDIÊNCIA: [INAUDÍVEL]

02:10:00.720 --> 02:10:01.560
DAVID J. MALAN: Qual é o outro?

02:10:01.560 --> 02:10:02.380
AUDIÊNCIA: E comercial.

02:10:02.380 --> 02:10:03.235
DAVID J. MALAN: É o e comercial.

02:10:03.235 --> 02:10:03.735
Por que?

02:10:03.735 --> 02:10:06.840
Porque se eu quiser habilitar a troca para ir a algum lugar, assim como Carter

02:10:06.840 --> 02:10:08.590
e eu joguei este jogo com as caixas de correio,

02:10:08.590 --> 02:10:12.220
Preciso informar swap do endereço de x e o endereço de y.

02:10:12.220 --> 02:10:14.470
E novamente, no início da aula de hoje,

02:10:14.470 --> 02:10:16.720
e comercial é a sintaxe através da qual fazemos isso.

02:10:16.720 --> 02:10:19.840
Então eu adiciono um e comercial aqui para obter o endereço de x, e comercial aqui

02:10:19.840 --> 02:10:20.860
para obter o endereço de y.

02:10:20.860 --> 02:10:23.530
E agora este código se alinha com a imagem

02:10:23.530 --> 02:10:25.280
que Carter acabou de nos ajudar a atravessar.

02:10:25.280 --> 02:10:29.360
E então, quando executo o make swap aqui, ocorre um erro.

02:10:29.360 --> 02:10:30.670
Ah, o que eu fiz de errado?

02:10:30.670 --> 02:10:31.600
Não intencional.

02:10:31.600 --> 02:10:34.240
Mas acho que vale a pena apontar.

02:10:34.240 --> 02:10:35.230
Eu errei aqui.

02:10:35.230 --> 02:10:40.000
Não gosta de e comercial x por causa de algo

02:10:40.000 --> 02:10:43.240
na linha três, que está bem no início do código.

02:10:43.240 --> 02:10:44.470
O que eu estraguei?

02:10:44.470 --> 02:10:45.490
Sim, no meio.

02:10:45.490 --> 02:10:47.757
AUDIÊNCIA: [INAUDÍVEL]

02:10:47.757 --> 02:10:50.090
DAVID J. MALAN: Sim, então é por isso que nós-- você não deveria

02:10:50.090 --> 02:10:53.215
copiar e colar, mesmo que seja necessário para coisas como protótipos de funções.

02:10:53.215 --> 02:10:56.240
Se eu mudei a troca na parte inferior, preciso mudar seu protótipo.

02:10:56.240 --> 02:10:59.360
Deixe-me adicionar a estrela ali, adicionar a estrela ali ou apenas copiar novamente e colar

02:10:59.360 --> 02:11:00.780
no topo do arquivo.

02:11:00.780 --> 02:11:02.490
Agora deixe-me fazer a troca novamente.

02:11:02.490 --> 02:11:03.980
Deixe-me agora fazer a troca de ponto e barra.

02:11:03.980 --> 02:11:06.530
E agora devo ver que x é 1, y é 2.

02:11:06.530 --> 02:11:10.760
E com sorte, x é 2, y é 1, o que eu faço agora.

02:11:10.760 --> 02:11:12.017
Então a lógica é a mesma.

02:11:12.017 --> 02:11:13.100
O algoritmo é o mesmo.

02:11:13.100 --> 02:11:14.810
Todas as coisas da semana zero são iguais.

02:11:14.810 --> 02:11:17.960
Exceto agora, na quarta semana, você só tem um pouco mais de expressividade

02:11:17.960 --> 02:11:22.310
através do qual você pode dizer ao computador exatamente o que deseja manipular

02:11:22.310 --> 02:11:24.070
e como.

02:11:24.070 --> 02:11:29.250
Alguma dúvida então sobre essa técnica aqui?

02:11:29.250 --> 02:11:29.750
Não?

02:11:29.750 --> 02:11:30.250
Tudo bem.

02:11:30.250 --> 02:11:33.072
Bem, quando consertarmos isso, ainda haverá problemas.

02:11:33.072 --> 02:11:35.030
E só para você ver alguns termos de arte aqui,

02:11:35.030 --> 02:11:38.113
isso é ruim sempre que você tem duas setas apontando uma para a outra certamente

02:11:38.113 --> 02:11:40.400
se você pode usar e reutilizar mais e mais memória.

02:11:40.400 --> 02:11:43.320
E acontece que existem alguns termos de arte que de repente agora podem fazer sentido,

02:11:43.320 --> 02:11:44.945
especialmente se você já programou antes.

02:11:44.945 --> 02:11:47.210
Coisas ruins podem acontecer com esse design.

02:11:47.210 --> 02:11:49.045
Mas realmente só existe esse tipo de design

02:11:49.045 --> 02:11:50.670
porque é uma quantidade finita de memória.

02:11:50.670 --> 02:11:52.370
Então, em algum momento, coisas ruins vão acontecer, não importa

02:11:52.370 --> 02:11:54.070
e se um computador ficar sem memória.

02:11:54.070 --> 02:11:55.820
Portanto, não é que tenha sido uma má decisão.

02:11:55.820 --> 02:11:59.480
É apenas necessário, dadas quantidades finitas de memória em um computador.

02:11:59.480 --> 02:12:01.790
Mas um estouro de pilha, por assim dizer, é quando

02:12:01.790 --> 02:12:05.300
você realmente transborda a pilha e toca na memória que não deveria estar lá em cima.

02:12:05.300 --> 02:12:08.300
Estouro de pilha é quando você de alguma forma transborda a pilha e toca

02:12:08.300 --> 02:12:10.030
memória que você não deveria lá embaixo.

02:12:10.030 --> 02:12:12.780
Então, com isso dito, esses são apenas problemas que podem acontecer.

02:12:12.780 --> 02:12:14.488
E são encarnações específicas do que

02:12:14.488 --> 02:12:16.610
são geralmente chamados de buffer overflows.

02:12:16.610 --> 02:12:19.670
Um buffer, como no sentido do YouTube, é apenas um pedaço de memória,

02:12:19.670 --> 02:12:23.030
que no caso do YouTube, armazena os próximos segundos ou minutos de vídeo.

02:12:23.030 --> 02:12:25.910
Mas, de um modo geral, um buffer é apenas um pedaço de memória

02:12:25.910 --> 02:12:27.860
que o computador está usando para algum propósito,

02:12:27.860 --> 02:12:31.430
seja a pilha, seja o heap, seja um array no computador.

02:12:31.430 --> 02:12:34.280
E assim estouros de buffer são o que acontece quando você apenas

02:12:34.280 --> 02:12:37.100
tem bugs lógicos em seu código.

02:12:37.100 --> 02:12:39.710
Mas com esses primitivos agora em mente, nós

02:12:39.710 --> 02:12:42.050
queria concluir com uma revelação final.

02:12:42.050 --> 02:12:44.940
E é assim que funcionam algumas funções como essas aqui.

02:12:44.940 --> 02:12:48.140
A outra coisa na biblioteca CS50, além do typedef para aspas sem aspas

02:12:48.140 --> 02:12:50.240
"string" é, claro, todas essas funções.

02:12:50.240 --> 02:12:51.573
E nós damos-lhe estas funções.

02:12:51.573 --> 02:12:55.370
Porque honestamente em C é difícil, é chato, é doloroso,

02:12:55.370 --> 02:12:58.430
é difícil obter a entrada do usuário corretamente.

02:12:58.430 --> 02:13:01.670
É muito fácil quando você não sabe o quanto o humano é

02:13:01.670 --> 02:13:04.280
vai digitar para escrever código com bugs quando se trata dele.

02:13:04.280 --> 02:13:06.800
E, de fato, é muito difícil armazená-lo corretamente

02:13:06.800 --> 02:13:09.930
sem acidentalmente ter algum tipo de estouro de buffer.

02:13:09.930 --> 02:13:12.150
Então, por exemplo, deixe-me mostrar um programa aqui.

02:13:12.150 --> 02:13:14.400
Vou seguir em frente e escrever este do zero.

02:13:14.400 --> 02:13:17.060
Então deixe-me ir em frente e abrir um arquivo chamado get.c,

02:13:17.060 --> 02:13:20.480
em que vou seguir em frente e imitar a ideia de obter números inteiros manualmente

02:13:20.480 --> 02:13:21.950
sem a biblioteca CS50.

02:13:21.950 --> 02:13:24.470
Vou incluir apenas standardio.h,

02:13:24.470 --> 02:13:27.395
Vou definir main como não aceitando nenhum argumento de linha de comando,

02:13:27.395 --> 02:13:29.270
e então eu vou fazer algo assim.

02:13:29.270 --> 02:13:31.850
Dê-me uma variável x sem valor ainda.

02:13:31.850 --> 02:13:34.250
E normalmente, eu faria algo como get int.

02:13:34.250 --> 02:13:35.450
Mas deixe-me tirar isso.

02:13:35.450 --> 02:13:37.490
Não há mais rodinhas para obter int também.

02:13:37.490 --> 02:13:39.890
Deixe-me apenas definir o int x.

02:13:39.890 --> 02:13:44.270
Deixe-me imprimir algo como um prompt.

02:13:44.270 --> 02:13:47.090
E vou fazer x dois pontos apenas para tornar óbvio para o ser humano o que

02:13:47.090 --> 02:13:48.330
estamos esperando.

02:13:48.330 --> 02:13:51.800
E agora vou usar uma função C integrada para obter a entrada do usuário.

02:13:51.800 --> 02:13:54.920
Vou chamar uma função chamada scanf, que faz uma varredura

02:13:54.920 --> 02:13:56.600
o teclado do usuário para entrada.

02:13:56.600 --> 02:13:58.400
Vou digitalizá-lo em busca de um número inteiro.

02:13:58.400 --> 02:14:01.850
Assim como printf, vou usar i porque espero um int.

02:14:01.850 --> 02:14:04.760
E então eu quero dizer ao scanf onde colocar

02:14:04.760 --> 02:14:07.640
inteiro do humano do teclado.

02:14:07.640 --> 02:14:09.950
Porém, não é correto dizer x.

02:14:09.950 --> 02:14:12.770
Porque se eu disser x, me deparo com o mesmo problema de troca.

02:14:12.770 --> 02:14:13.490
scanf.

02:14:13.490 --> 02:14:16.250
Nenhuma função pode alterar o valor de x a menos que eu passe

02:14:16.250 --> 02:14:20.200
não por valor, mas por referência.

02:14:20.200 --> 02:14:22.020
Então, estamos de volta ao nosso amigo comercial.

02:14:22.020 --> 02:14:26.700
E agora, tem um mapa do tesouro para a localização real de x,

02:14:26.700 --> 02:14:27.998
e, portanto, pode alterá-lo.

02:14:27.998 --> 02:14:29.790
E agora, bem no final deste programa,

02:14:29.790 --> 02:14:34.890
deixe-me fazer algo simples como, vamos em frente e imprimir com printf

02:14:34.890 --> 02:14:40.575
o valor de x, usando %i como sempre conectando x, não e comercial x.

02:14:40.575 --> 02:14:41.700
Este é agora o material da primeira semana.

02:14:41.700 --> 02:14:44.430
Eu quero imprimir o valor inteiro real de x.

02:14:44.430 --> 02:14:47.400
Portanto, a única mudança aqui é que, em vez de usar get int,

02:14:47.400 --> 02:14:51.540
Agora estou usando essa nova função que a partir de hoje existe chamada scanf.

02:14:51.540 --> 02:14:54.600
Então deixe-me ir em frente e correr buscar.

02:14:54.600 --> 02:14:56.400
Faça começar a criar este programa.

02:14:56.400 --> 02:14:57.632
Ponto barra obter.

02:14:57.632 --> 02:14:59.340
Vamos em frente e digite um valor para x.

02:14:59.340 --> 02:15:00.240
50.

02:15:00.240 --> 02:15:01.080
Digitar.

02:15:01.080 --> 02:15:02.160
E simplesmente funciona.

02:15:02.160 --> 02:15:05.710
Acontece que get int é bem simples de implementar.

02:15:05.710 --> 02:15:07.380
No entanto, observe o que não funciona.

02:15:07.380 --> 02:15:11.010
Se eu digitar cat, por exemplo, cat será convertido em zero.

02:15:11.010 --> 02:15:14.610
Enquanto isso, get int, recall, solicitará novamente ao usuário.

02:15:14.610 --> 02:15:16.890
Se um humano não digitar um número inteiro real,

02:15:16.890 --> 02:15:18.360
você é automaticamente solicitado novamente.

02:15:18.360 --> 02:15:20.160
Esse é um dos recursos que oferecemos para o CS50

02:15:20.160 --> 02:15:22.960
adicionado para obter int apenas para tornar seus programas mais amigáveis.

02:15:22.960 --> 02:15:25.710
Mas caso contrário, obter int é bastante simples

02:15:25.710 --> 02:15:27.600
para reimplementar usando scanf.

02:15:27.600 --> 02:15:30.210
Infelizmente, isso não é verdade para strings.

02:15:30.210 --> 02:15:33.393
Porque como você sabe quando escreve seu código qual palavra o humano é

02:15:33.393 --> 02:15:34.560
vai eventualmente digitar?

02:15:34.560 --> 02:15:37.590
Quanto tempo eles estão cumprimentando, como oi?

02:15:37.590 --> 02:15:40.140
Se o nome deles for David, ou Carter, ou qualquer outra coisa,

02:15:40.140 --> 02:15:42.670
você simplesmente não antecipa quanta memória precisa.

02:15:42.670 --> 02:15:45.360
Então, como podemos fazer isso com strings?

02:15:45.360 --> 02:15:48.170
Bem, deixe-me prosseguir e declarar uma string s.

02:15:48.170 --> 02:15:49.170
Embora, você sabe o quê?

02:15:49.170 --> 02:15:50.400
Não há biblioteca CS50.

02:15:50.400 --> 02:15:53.230
Então, em vez disso, fazemos char star s hoje.

02:15:53.230 --> 02:15:56.850
E isso me dá não uma string em si, mas um ponteiro

02:15:56.850 --> 02:15:59.670
que apontará presumivelmente para uma string.

02:15:59.670 --> 02:16:00.990
Idealmente, eu usaria isso.

02:16:00.990 --> 02:16:01.770
Obter corda.

02:16:01.770 --> 02:16:04.030
Mas, novamente, tiramos essa roda de treinamento.

02:16:04.030 --> 02:16:08.040
Agora que tenho um ponteiro s, suponha que eu solicite ao humano um valor para s,

02:16:08.040 --> 02:16:09.090
Assim como antes.

02:16:09.090 --> 02:16:13.575
Deixe-me usar scanf agora e dizer ao usuário que espero ler uma string,

02:16:13.575 --> 02:16:18.150
%s do teclado e armazene-o em s.

02:16:18.150 --> 02:16:19.470
Agora isso é sutil.

02:16:19.470 --> 02:16:24.240
Tecnicamente, não preciso de um e comercial aqui, embora precisasse de um int.

02:16:24.240 --> 02:16:28.020
E eu faria um float, um double, um long, um bool e um char.

02:16:28.020 --> 02:16:34.260
Por que não preciso de um e comercial nesta história para passar por referência?

02:16:34.260 --> 02:16:34.879
Porque s é--

02:16:34.879 --> 02:16:36.129
AUDIÊNCIA: Já [INAUDÍVEL].

02:16:36.129 --> 02:16:37.299
DAVID J. MALAN: Já é um endereço.

02:16:37.299 --> 02:16:38.830
Mais uma vez, as cordas são apenas especiais.

02:16:38.830 --> 02:16:40.809
Strings agora são sempre endereços.

02:16:40.809 --> 02:16:43.809
Portanto, você não precisa adicionar um e comercial aqui.

02:16:43.809 --> 02:16:45.575
Essa é a única diferença sutil aqui.

02:16:45.575 --> 02:16:48.700
Mas agora, se eu for em frente e imprimir no final qual é o valor de s

02:16:48.700 --> 02:16:54.709
usando %s como antes, este programa parece ser quase o mesmo que o int

02:16:54.709 --> 02:16:55.209
versão.

02:16:55.209 --> 02:16:57.190
Mas vamos fazer get.

02:16:57.190 --> 02:16:59.500
E OK, então isso não é bom.

02:16:59.500 --> 02:17:01.910
Tudo bem, então não gosta de um valor não inicializado.

02:17:01.910 --> 02:17:02.980
Então deixe-me fazê-lo feliz.

02:17:02.980 --> 02:17:05.138
Eu disse anteriormente para sempre inicializar minha variável.

02:17:05.138 --> 02:17:07.930
Então, vamos inicializá-lo para NULL para que pelo menos algo esteja lá.

02:17:07.930 --> 02:17:09.910
Esse é o seu bom valor padrão hoje em dia.

02:17:09.910 --> 02:17:12.400
Agora, se eu fizer dot slash get, agora estamos bem.

02:17:12.400 --> 02:17:15.969
E deixe-me digitar algo como cat.

02:17:15.969 --> 02:17:17.870
OK, gato não é x.

02:17:17.870 --> 02:17:19.120
Bem, deixe-me tentar outra palavra.

02:17:19.120 --> 02:17:20.379
Talvez seja apenas gato errado.

02:17:20.379 --> 02:17:21.160
Cachorro.

02:17:21.160 --> 02:17:22.910
OK, deixe-me tentar David.

02:17:22.910 --> 02:17:24.430
Simplesmente não parece estar funcionando.

02:17:24.430 --> 02:17:27.040
Além disso, está imprimindo como um zero.

02:17:27.040 --> 02:17:30.719
Qual é, logicamente, o bug aqui?

02:17:30.719 --> 02:17:32.790
Scanf trabalhou um momento atrás para números inteiros.

02:17:32.790 --> 02:17:34.320
Mas não está funcionando para strings.

02:17:34.320 --> 02:17:37.170
E parece estar esquecendo CAT. É esquecer CÃO.

02:17:37.170 --> 02:17:40.820
É esquecer DAVID. Por que?

02:17:40.820 --> 02:17:44.090
O que está acontecendo aqui?

02:17:44.090 --> 02:17:47.920
Pense nas nossas imagens amarelas da memória.

02:17:47.920 --> 02:17:49.090
Quando eu... sim.

02:17:49.090 --> 02:17:50.267
AUDIÊNCIA: [INAUDÍVEL]

02:17:50.267 --> 02:17:52.600
DAVID J. MALAN: Pode estar lendo apenas o próprio NULL

02:17:52.600 --> 02:17:54.790
porque s está sendo inicializado como NULL.

02:17:54.790 --> 02:17:58.090
E que passo eu esqueci de apenas alguns minutos atrás?

02:17:58.090 --> 02:18:01.760
O que eu realmente não solicitei do computador?

02:18:01.760 --> 02:18:06.290
Memória real para armazenar o CAT, o DOG, o DAVID.

02:18:06.290 --> 02:18:10.010
Em nenhum lugar eu pedi ao computador alguma quantidade de memória.

02:18:10.010 --> 02:18:14.600
E, tecnicamente, pode estar lendo em algum local de lixo.

02:18:14.600 --> 02:18:18.020
E esse é realmente o problema aqui. s é inicializado como NULL agora.

02:18:18.020 --> 02:18:20.278
E então, de fato, está imprimindo zero como NULL.

02:18:20.278 --> 02:18:22.070
Mas não estou vendo nenhuma das outras letras

02:18:22.070 --> 02:18:23.653
porque não havia onde colocá-los.

02:18:23.653 --> 02:18:27.920
GATO, CÃO, DAVID porque não pedi 3 bytes, 4 bytes, 5 bytes,

02:18:27.920 --> 02:18:28.610
100 bytes.

02:18:28.610 --> 02:18:29.840
Não adianta malloc.

02:18:29.840 --> 02:18:31.100
Não há uso de uma matriz.

02:18:31.100 --> 02:18:35.370
Não há memória alocada para nada além do próprio ponteiro.

02:18:35.370 --> 02:18:38.209
E é aqui que, honestamente, a vida fica difícil com o scanf.

02:18:38.209 --> 02:18:40.709
Eu poderia resolver esse problema de duas maneiras.

02:18:40.709 --> 02:18:41.910
Deixe-me ir em frente e fazer isso.

02:18:41.910 --> 02:18:44.150
Em vez de declarar s como um ponteiro, deixe

02:18:44.150 --> 02:18:48.469
Eu declaro que s é, na verdade, um array de quatro caracteres.

02:18:48.469 --> 02:18:51.540
E agora deixe-me ir em frente e recompilar o código.

02:18:51.540 --> 02:18:55.380
Então faça get ponto slash get, e eu vou digitar cat agora.

02:18:55.380 --> 02:18:56.780
Isso agora funciona.

02:18:56.780 --> 02:18:57.590
Por que?

02:18:57.590 --> 02:19:00.680
Bem, estou alocando um array explícito de tamanho quatro,

02:19:00.680 --> 02:19:03.930
o suficiente para uma, duas, três letras, mais um caractere NULL.

02:19:03.930 --> 02:19:06.379
Aqui está a pergunta de alguém antes,

02:19:06.379 --> 02:19:09.469
Acontece que, em alguns contextos, você pode tratar arrays

02:19:09.469 --> 02:19:12.000
como se eles próprios fossem ponteiros.

02:19:12.000 --> 02:19:14.010
Então você fará a conversão para você.

02:19:14.010 --> 02:19:17.540
Mas, por enquanto, apenas suponha que s é apenas uma matriz de tamanho quatro.

02:19:17.540 --> 02:19:20.719
E se você passar para o scanf, é como um tesouro

02:19:20.719 --> 02:19:24.559
mapa que leva a esses 4 bytes, então scanf agora pode preenchê-lo com sucesso

02:19:24.559 --> 02:19:29.309
com GATO, CÃO. Mas vamos tentar isso de novo.

02:19:29.309 --> 02:19:30.440
Vamos digitar David.

02:19:30.440 --> 02:19:32.940
E aqui, OK, tivemos sorte.

02:19:32.940 --> 02:19:35.459
Mas tecnicamente toquei na memória que não deveria.

02:19:35.459 --> 02:19:38.209
E, de fato, se eu digitar uma string longa o suficiente e não achar

02:19:38.209 --> 02:19:40.910
Eu poderia fazer isso facilmente por-- sem digitar

02:19:40.910 --> 02:19:42.830
isso milhares ou centenas de vezes.

02:19:42.830 --> 02:19:43.910
Ainda ok.

02:19:43.910 --> 02:19:47.298
Mas você notará que o resto está esquecido agora.

02:19:47.298 --> 02:19:49.590
Então, em algum lugar, fomos além do limite do array.

02:19:49.590 --> 02:19:52.230
E simplesmente não temos espaço de armazenamento suficiente para tudo isso.

02:19:52.230 --> 02:19:53.647
Então, o que você faz no seu programa?

02:19:53.647 --> 02:19:57.050
Se você não sabe quanto tempo vai ter o nome da pessoa ou o nome do animal,

02:19:57.050 --> 02:19:57.530
o que você faz?

02:19:57.530 --> 02:19:58.030
40?

02:19:58.030 --> 02:19:59.180
400?

02:19:59.180 --> 02:19:59.960
4.000?

02:19:59.960 --> 02:20:00.785
40.000?

02:20:00.785 --> 02:20:02.910
Em algum momento, você deve traçar uma linha na areia.

02:20:02.910 --> 02:20:06.980
E é por isso que obter entrada do usuário é tão irritante em uma linguagem como C.

02:20:06.980 --> 02:20:08.900
E é por isso que get string existe.

02:20:08.900 --> 02:20:12.500
O que fazemos, se você estiver curioso, é olhar para a entrada do usuário

02:20:12.500 --> 02:20:13.760
e damos passos de bebê.

02:20:13.760 --> 02:20:15.980
Nós olhamos para um personagem de cada vez.

02:20:15.980 --> 02:20:18.380
E toda vez que vemos outro personagem, na verdade

02:20:18.380 --> 02:20:19.750
ligue para malloc novamente e diga não.

02:20:19.750 --> 02:20:20.750
Eu preciso de mais de 1 byte.

02:20:20.750 --> 02:20:21.470
eu preciso de 2.

02:20:21.470 --> 02:20:23.012
Oh espere, eles digitaram três letras.

02:20:23.012 --> 02:20:23.930
Preciso de 3 em vez de 2.

02:20:23.930 --> 02:20:25.340
Ah, eu preciso de 4 em vez de 2.

02:20:25.340 --> 02:20:27.470
E nós temos esse loop maluco essencialmente que

02:20:27.470 --> 02:20:30.500
continua pedindo mais e mais memória, mas dando passos de bebê.

02:20:30.500 --> 02:20:33.380
E honestamente, se todos vocês tivessem que fazer isso na primeira semana, meu Deus.

02:20:33.380 --> 02:20:35.640
Não podíamos mais escrever, olá, mundo.

02:20:35.640 --> 02:20:38.450
E é por isso que essas rodinhas existem, pelo menos no início.

02:20:38.450 --> 02:20:42.050
E é por isso que em linguagens de alto nível como em Python,

02:20:42.050 --> 02:20:43.820
você não precisa fazer isso.

02:20:43.820 --> 02:20:45.960
Ele simplesmente funciona como você esperaria.

02:20:45.960 --> 02:20:47.640
Então, o que mais podemos fazer?

02:20:47.640 --> 02:20:51.050
Bem, você verá no conjunto de problemas quatro na próxima semana, se eu abrir

02:20:51.050 --> 02:20:53.750
um exemplo como este, phonebook.c, você

02:20:53.750 --> 02:20:56.510
veja que você pode manipular arquivos agora, que você

02:20:56.510 --> 02:20:57.950
ter um vocabulário para ponteiros.

02:20:57.950 --> 02:20:59.570
Vai ser novo rapidamente.

02:20:59.570 --> 02:21:02.000
Mas aqui temos um exemplo de como.

02:21:02.000 --> 02:21:04.490
Eu tenho um programa usando algumas bibliotecas familiares aqui.

02:21:04.490 --> 02:21:08.010
Mas, como afirmo em meu comentário, isso salva nomes e números em um arquivo CSV.

02:21:08.010 --> 02:21:10.235
Todos os meus exemplos até agora, eu digito algumas palavras,

02:21:10.235 --> 02:21:12.110
Eu digito alguns nomes e alguns números de telefone,

02:21:12.110 --> 02:21:14.550
e desaparecem porque só os guardamos na memória.

02:21:14.550 --> 02:21:18.290
Mas se você quiser armazenar dados como um arquivo CSV, valores separados por vírgulas, que

02:21:18.290 --> 02:21:21.200
é como uma planilha simples como o Excel e o Apple Numbers,

02:21:21.200 --> 02:21:23.910
e o Planilhas Google pode abrir, você mesmo pode fazer isso.

02:21:23.910 --> 02:21:26.660
Então, apenas como um teaser para esta semana, aqui na linha nove,

02:21:26.660 --> 02:21:27.950
Estou usando um novo tipo de dados.

02:21:27.950 --> 02:21:28.820
Não é uma coisa CS50.

02:21:28.820 --> 02:21:30.575
Isso é uma coisa em C chamada arquivo.

02:21:30.575 --> 02:21:32.450
Mas se você quiser manipular arquivos, você precisa

02:21:32.450 --> 02:21:34.250
para usar endereços, isto é, ponteiros.

02:21:34.250 --> 02:21:37.160
Aqui estou eu criando uma variável chamada arquivo

02:21:37.160 --> 02:21:40.070
isso vai apontar para um arquivo real no disco rígido,

02:21:40.070 --> 02:21:42.140
no servidor, ou no seu Mac ou PC.

02:21:42.140 --> 02:21:45.560
fopen será uma nova função que você usará para abrir um arquivo.

02:21:45.560 --> 02:21:49.160
E ele retornará efetivamente um ponteiro para lá na memória.

02:21:49.160 --> 02:21:51.560
O nome do arquivo que desejo abrir é agenda.csv.

02:21:51.560 --> 02:21:54.230
E neste exemplo, será um modo de caneta.

02:21:54.230 --> 02:21:57.447
Ele continuará permitindo que eu adicione mais e mais nomes e números a este arquivo.

02:21:57.447 --> 02:21:59.780
Aqui estão algumas coisas antigas, porque eu não vou

02:21:59.780 --> 02:22:01.460
reinventar get string com scanf.

02:22:01.460 --> 02:22:03.930
Mas aqui está uma função ligeiramente nova.

02:22:03.930 --> 02:22:05.260
Não é printf, mas fprintf.

02:22:05.260 --> 02:22:08.010
Acontece que é muito fácil imprimir coisas não na tela,

02:22:08.010 --> 02:22:09.800
mas para um arquivo com fprintf.

02:22:09.800 --> 02:22:11.900
E é preciso um argumento adicional, em vez

02:22:11.900 --> 02:22:14.000
de começar com a string entre aspas, você

02:22:14.000 --> 02:22:16.400
tem que dizer em qual arquivo você deseja gravar.

02:22:16.400 --> 02:22:20.240
E fprintf vamos descobrir como colocar os bits nisso

02:22:20.240 --> 02:22:23.520
arquivo passando algo como nome, número de vírgula.

02:22:23.520 --> 02:22:26.940
Então, se eu executar isso rapidamente aqui, deixe-me fazer isso.

02:22:26.940 --> 02:22:31.400
Deixe-me pré-criar um arquivo chamado phonebook.csv.

02:22:31.400 --> 02:22:34.940
E em phonebook.csv, vou criar uma linha temporária aqui, nome

02:22:34.940 --> 02:22:37.820
número de vírgula apenas para que haja algo neste arquivo.

02:22:37.820 --> 02:22:41.810
E agora deixe-me ir em frente e fazer isso e dividir minha tela aqui.

02:22:41.810 --> 02:22:46.410
Se eu tiver phonebook.csv à direita e phonebook.c à esquerda,

02:22:46.410 --> 02:22:51.345
deixe-me compilar, fazer lista telefônica, que é a versão C, lista telefônica de ponto e barra.

02:22:51.345 --> 02:22:53.220
E agora sou solicitado a fornecer um nome e um número.

02:22:53.220 --> 02:22:58.080
Vou digitar David e, por exemplo, mais 1-949--

02:22:58.080 --> 02:22:58.580
o que é?

02:22:58.580 --> 02:23:01.190
4682750.

02:23:01.190 --> 02:23:02.390
Digitar.

02:23:02.390 --> 02:23:03.110
Oh droga.

02:23:03.110 --> 02:23:03.995
Erro.

02:23:03.995 --> 02:23:05.120
Finja que isso não aconteceu.

02:23:05.120 --> 02:23:06.990
Esqueci de entrar no arquivo.

02:23:06.990 --> 02:23:08.630
Então, vamos fazer isso de novo.

02:23:08.630 --> 02:23:17.900
Se eu executar o programa novamente, David, e mais 1-949-4682750,

02:23:17.900 --> 02:23:20.970
Enter, ele foi salvo agora no arquivo.

02:23:20.970 --> 02:23:27.230
E se eu fechar este arquivo e reabrir o código de phonebook.csv,

02:23:27.230 --> 02:23:29.990
você verá que o arquivo persiste.

02:23:29.990 --> 02:23:32.053
E se eu baixei isso para o meu Mac, ou meu PC,

02:23:32.053 --> 02:23:33.470
Eu poderia clicar duas vezes no arquivo CSV.

02:23:33.470 --> 02:23:36.260
E pronto, o Excel abriria, ou o Apple Numbers, ou algo parecido.

02:23:36.260 --> 02:23:38.527
Na verdade, criei um arquivo CSV real.

02:23:38.527 --> 02:23:41.360
Se você está sorrindo porque eu continuo repetindo meu número de telefone em voz alta,

02:23:41.360 --> 02:23:43.910
Gostaria de encorajá-lo a ligar ou enviar uma mensagem de texto para esse número em algum momento.

02:23:43.910 --> 02:23:46.100
Pode muito bem ser uma espécie de ovo de Páscoa.

02:23:46.100 --> 02:23:49.160
Mas por meio dessas funções aqui, temos agora a capacidade

02:23:49.160 --> 02:23:52.130
para gravar arquivos de entrada e saída.

02:23:52.130 --> 02:23:54.442
E entre as metas então para esta semana, como veremos,

02:23:54.442 --> 02:23:56.900
são realmente brincar com imagens no espírito de algo

02:23:56.900 --> 02:23:58.670
como filtros do Instagram ou similares.

02:23:58.670 --> 02:24:01.490
E apresentaremos, por exemplo, um formato de arquivo chamado

02:24:01.490 --> 02:24:05.990
BNPs, que fecham o círculo no início da aula, são apenas mapas de bits,

02:24:05.990 --> 02:24:09.830
mas mais do que apenas bits individuais para branco e preto, mas sim padrões coloridos

02:24:09.830 --> 02:24:10.500
também.

02:24:10.500 --> 02:24:12.500
E vai te dar imagens como essa da Weeks Bridge

02:24:12.500 --> 02:24:13.875
aqui do outro lado do rio em Harvard.

02:24:13.875 --> 02:24:16.490
E você executa, depois de escrever seu próprio código em C,

02:24:16.490 --> 02:24:19.925
e entender como os dados são armazenados na memória do computador,

02:24:19.925 --> 02:24:22.550
você poderá aplicar seus próprios filtros semelhantes aos do Instagram para criar

02:24:22.550 --> 02:24:25.830
coisas em escala de cinza, ou sépia neste caso.

02:24:25.830 --> 02:24:28.820
Você pode até inverter os bits para que a coisa seja uma imagem espelhada.

02:24:28.820 --> 02:24:30.530
Você pode desfocar ainda mais as coisas.

02:24:30.530 --> 02:24:32.510
Ou se você realmente está se sentindo mais confortável,

02:24:32.510 --> 02:24:35.570
você pode até escrever um código que encontre as bordas da imagem

02:24:35.570 --> 02:24:37.520
e cria obras de arte como estas.

02:24:37.520 --> 02:24:39.740
Portanto, tudo isso e muito mais no conjunto de problemas quatro.

02:24:39.740 --> 02:24:42.650
Nos vemos na próxima vez.

02:24:42.650 --> 02:24:47.200
[MÚSICA, TOCANDO]