WEBVTT

00:00:00.000 --> 00:00:02.988
[INÍCIO DO JOGADOR REEL-TO-REEL]

00:00:02.988 --> 00:00:05.976
[MÚSICA, TOCANDO]

00:01:13.350 --> 00:01:16.090
DAVID J. MALAN: Tudo bem, aqui é o CS50.

00:01:16.090 --> 00:01:19.090
E esta é a semana 1, onde continuamos a programação,

00:01:19.090 --> 00:01:22.420
mas fazemos isso em um idioma diferente porque, lembre-se da última vez, nós

00:01:22.420 --> 00:01:25.060
focado nesta linguagem gráfica chamada Scratch.

00:01:25.060 --> 00:01:28.360
Mas usamos o Scratch, não apenas porque é divertido e acessível,

00:01:28.360 --> 00:01:31.750
mas porque nos permite explorar muitos desses conceitos aqui,

00:01:31.750 --> 00:01:35.810
ou seja, funções e condicionais, expressões booleanas, loops, variáveis,

00:01:35.810 --> 00:01:36.410
e mais.

00:01:36.410 --> 00:01:41.050
E assim, de fato, mesmo que a sintaxe de hoje, conforme fazemos a transição para esta nova linguagem

00:01:41.050 --> 00:01:44.980
chamado C, parece um pouco enigmático, talvez um pouco intimidador no começo,

00:01:44.980 --> 00:01:48.040
e você não consegue ver todo o significado dos símbolos

00:01:48.040 --> 00:01:51.310
além da própria sintaxe, perceba que as ideias são, em última análise,

00:01:51.310 --> 00:01:52.670
vai ser o mesmo.

00:01:52.670 --> 00:01:55.870
Na verdade, enquanto fazemos a transição do que foi na semana passada...

00:01:55.870 --> 00:02:00.017
um programa Hello World que se parecia um pouco com isto-- esta semana,

00:02:00.017 --> 00:02:02.350
claro, agora vai parecer um pouco mais enigmático.

00:02:02.350 --> 00:02:04.350
Vai se parecer um pouco com isto.

00:02:04.350 --> 00:02:06.370
E agora, mesmo que você não consiga distinguir

00:02:06.370 --> 00:02:08.479
o que todos os vários símbolos significam neste código,

00:02:08.479 --> 00:02:10.120
acontece que no final do dia, é

00:02:10.120 --> 00:02:11.578
realmente vai fazer o que você espera.

00:02:11.578 --> 00:02:14.170
Vai apenas dizer, olá, mundo na tela,

00:02:14.170 --> 00:02:15.370
assim como fizemos no Scratch.

00:02:15.370 --> 00:02:19.610
Então, vamos começar a aplicar alguma terminologia a esses tokens primeiro.

00:02:19.610 --> 00:02:22.332
Então, o que estamos prestes a ver, o que estamos prestes a escrever a partir de agora,

00:02:22.332 --> 00:02:24.040
vamos começar a chamar o código-fonte.

00:02:24.040 --> 00:02:27.908
O código que você, o programador humano, escreve é ​​doravante chamado de código-fonte.

00:02:27.908 --> 00:02:29.200
Não importa se é Scratch.

00:02:29.200 --> 00:02:32.370
Não importa se é C. Não importa se é Python em breve.

00:02:32.370 --> 00:02:34.120
Código-fonte é o termo geral para realmente

00:02:34.120 --> 00:02:37.330
o que você e eu, como programadores humanos, iremos escrever.

00:02:37.330 --> 00:02:42.190
É claro que os computadores não entendem o código-fonte.

00:02:42.190 --> 00:02:46.200
Computadores não entendem Scratch e Puzzle Pieces, per se, ou código C

00:02:46.200 --> 00:02:47.200
como estamos prestes a ver.

00:02:47.200 --> 00:02:49.870
Eles só entendem isso, que chamamos de semana passada?

00:02:49.870 --> 00:02:50.650
AUDIÊNCIA: Zeros e uns.

00:02:50.650 --> 00:02:51.525
DAVID J. MALAN: Sim.

00:02:51.525 --> 00:02:53.080
Então isso é binário, zeros e uns.

00:02:53.080 --> 00:02:56.470
Mas, na verdade, são apenas informações representadas em binário.

00:02:56.470 --> 00:03:00.370
E, de fato, o termo técnico agora para padrões de zeros e uns

00:03:00.370 --> 00:03:04.810
que um computador não só entende como interpretar como letras, ou números,

00:03:04.810 --> 00:03:09.520
ou cores, ou imagens, ou mais, mas sabe como executar também doravante

00:03:09.520 --> 00:03:12.880
vai ser chamado de código de máquina para contrastá-lo com o código-fonte.

00:03:12.880 --> 00:03:15.160
Enquanto você e eu, os humanos, escrevemos o código-fonte,

00:03:15.160 --> 00:03:18.860
é o computador que, em última análise, só entende o código da máquina.

00:03:18.860 --> 00:03:21.940
E mesmo que não entremos em detalhes sobre exatamente qual padrão

00:03:21.940 --> 00:03:27.010
de símbolos significa o que, você verá que neste tipo de padrão de zeros

00:03:27.010 --> 00:03:28.600
e uns, haverá números.

00:03:28.600 --> 00:03:29.530
Haverá cartas.

00:03:29.530 --> 00:03:32.200
Mas também haverá instruções porque, de fato, os computadores

00:03:32.200 --> 00:03:35.140
são muito bons em fazer coisas-- adição, subtração, mover coisas

00:03:35.140 --> 00:03:36.430
dentro e fora da memória.

00:03:36.430 --> 00:03:40.720
E basta dizer que os Macs, os PCs, os demais computadores do mundo

00:03:40.720 --> 00:03:44.740
acabamos de decidir como uma sociedade que certos padrões de zeros e uns

00:03:44.740 --> 00:03:48.220
significa quando se trata de operações também - não apenas dados,

00:03:48.220 --> 00:03:49.200
mas instruções.

00:03:49.200 --> 00:03:50.950
Mas esses padrões não são algo que estamos

00:03:50.950 --> 00:03:52.575
vai se concentrar em uma aula como esta.

00:03:52.575 --> 00:03:55.450
Vamos nos concentrar no lado de software de nível superior,

00:03:55.450 --> 00:03:58.910
simplesmente assumindo que precisamos de alguma forma gerar código de máquina.

00:03:58.910 --> 00:04:02.050
Acontece, então, que esse problema que

00:04:02.050 --> 00:04:04.300
tem que resolver ir do código-fonte para o código da máquina

00:04:04.300 --> 00:04:07.120
realmente se encaixa no mesmo paradigma da última vez.

00:04:07.120 --> 00:04:11.230
Mas a entrada neste caso será o código-fonte por um lado.

00:04:11.230 --> 00:04:13.750
Isso é o que você e eu idealmente escreveremos para que possamos

00:04:13.750 --> 00:04:15.430
não precisa escrever zeros e uns.

00:04:15.430 --> 00:04:18.140
Mas precisamos de alguma forma gerar código de máquina

00:04:18.140 --> 00:04:19.990
porque é isso que seus Macs, PCs, telefones

00:04:19.990 --> 00:04:21.730
realmente vão entender.

00:04:21.730 --> 00:04:25.390
Bem, acontece que existem programas especiais na vida cujo propósito é

00:04:25.390 --> 00:04:28.690
para fazer exatamente esta conversão-- converter o código-fonte que você

00:04:28.690 --> 00:04:32.320
e escrevo para o código de máquina que nossos telefones e computadores entendem.

00:04:32.320 --> 00:04:36.050
E esse tipo de programa será chamado de compilador.

00:04:36.050 --> 00:04:39.400
Portanto, hoje, apresentaremos a você outro software.

00:04:39.400 --> 00:04:40.810
E estes vêm em muitas formas.

00:04:40.810 --> 00:04:45.580
Usaremos um popular aqui que permite converter o código-fonte em C

00:04:45.580 --> 00:04:48.805
para código de máquina em zeros e uns.

00:04:48.805 --> 00:04:50.680
Agora, você não precisava fazer isso com o Scratch.

00:04:50.680 --> 00:04:53.513
No mundo do Scratch, era tão simples quanto clicar na bandeira verde

00:04:53.513 --> 00:04:57.280
porque essencialmente o MIT fez todo o trabalho pesado lá descobrindo

00:04:57.280 --> 00:05:00.760
como converter essas peças gráficas do quebra-cabeça para o código de máquina subjacente.

00:05:00.760 --> 00:05:04.420
Mas agora a partir de hoje, quando começamos a estudar programação e ciência da computação

00:05:04.420 --> 00:05:06.550
certo, agora que o poder se move para você.

00:05:06.550 --> 00:05:09.340
E cabe a você agora fazer esse tipo de conversão.

00:05:09.340 --> 00:05:12.160
Mas, felizmente, o fato de esses compiladores existirem

00:05:12.160 --> 00:05:14.320
significa que você e eu não temos que programar

00:05:14.320 --> 00:05:17.500
em código de máquina como nossos ancestrais fizeram uma vez,

00:05:17.500 --> 00:05:19.973
seja virtualmente ou com cartões perfurados físicos,

00:05:19.973 --> 00:05:21.640
como pedaços de papel com buracos.

00:05:21.640 --> 00:05:25.810
Você e eu nos concentramos em nosso teclado, como tal.

00:05:25.810 --> 00:05:29.370
Mas hoje não será apenas uma questão de escrever código.

00:05:29.370 --> 00:05:31.120
Vai ser uma questão, finalmente, hoje

00:05:31.120 --> 00:05:32.930
em diante de escrever um bom código também.

00:05:32.930 --> 00:05:35.180
E esse é o tipo de coisa que você não aprende da noite para o dia.

00:05:35.180 --> 00:05:35.870
Leva tempo.

00:05:35.870 --> 00:05:36.620
É preciso prática.

00:05:36.620 --> 00:05:38.650
Assim como escrever um ensaio em qualquer assunto

00:05:38.650 --> 00:05:41.050
pode levar tempo, prática e iteração ao longo do tempo.

00:05:41.050 --> 00:05:44.020
Mas em uma aula de programação como CS50, estamos

00:05:44.020 --> 00:05:48.820
vai aspirar a avaliar a qualidade do código ao longo desses três eixos,

00:05:48.820 --> 00:05:49.360
geralmente.

00:05:49.360 --> 00:05:51.040
É correto, em primeiro lugar?

00:05:51.040 --> 00:05:52.810
O código faz o que deveria fazer?

00:05:52.810 --> 00:05:54.460
Afinal, se não, bem, qual era o ponto

00:05:54.460 --> 00:05:55.835
de escrevê-lo em primeiro lugar?

00:05:55.835 --> 00:05:59.350
Portanto, nem é preciso dizer que você deseja que o código que escreve esteja correto.

00:05:59.350 --> 00:06:00.820
E obviamente nem sempre.

00:06:00.820 --> 00:06:03.340
Novamente, sempre que seu Mac, PC ou telefone travar,

00:06:03.340 --> 00:06:05.560
algum humano em algum lugar escreveu buggy--

00:06:05.560 --> 00:06:07.030
isso é código com erros.

00:06:07.030 --> 00:06:10.060
Mas a correção do código será o primeiro e mais importante objetivo.

00:06:10.060 --> 00:06:13.930
Mas então há um objetivo mais subjetivo ver no tempo, uma questão de design.

00:06:13.930 --> 00:06:16.030
E vimos um pouco disso semana passada

00:06:16.030 --> 00:06:19.510
quando propus que poderíamos projetar até programas de rascunho melhor,

00:06:19.510 --> 00:06:22.510
talvez usando loops em vez de apenas copiar e colar

00:06:22.510 --> 00:06:24.170
os mesmos blocos de novo e de novo.

00:06:24.170 --> 00:06:26.080
Portanto, o design é mais subjetivo.

00:06:26.080 --> 00:06:29.830
É mais uma arte aprendida em que duas pessoas podem, em última análise,

00:06:29.830 --> 00:06:32.882
discordam sobre qual versão de um programa é melhor projetada.

00:06:32.882 --> 00:06:35.840
Mas daremos a você blocos de construção e princípios nas próximas semanas

00:06:35.840 --> 00:06:37.840
para que você possa ter uma noção melhor de si mesmo

00:06:37.840 --> 00:06:40.090
se o seu próprio código for bem projetado.

00:06:40.090 --> 00:06:41.530
E por que isso é valioso?

00:06:41.530 --> 00:06:44.980
Bem, quanto melhor for o design do seu código, geralmente mais rápido ele será executado,

00:06:44.980 --> 00:06:47.438
mais sustentável será por você ou colegas

00:06:47.438 --> 00:06:49.438
se você estiver trabalhando com outras pessoas no mundo real.

00:06:49.438 --> 00:06:50.900
Portanto, um bom design é uma coisa boa.

00:06:50.900 --> 00:06:54.490
Ele ajuda você a comunicar suas ideias, como em um ensaio típico de inglês.

00:06:54.490 --> 00:06:57.523
E, finalmente, falaremos esta semana sobre estilo.

00:06:57.523 --> 00:06:59.690
E isso é apenas a estética do seu código.

00:06:59.690 --> 00:07:04.720
Acontece que os computadores geralmente não se importam com o quão desleixado é o seu código real,

00:07:04.720 --> 00:07:08.920
onde no mundo do código, você realmente não precisa

00:07:08.920 --> 00:07:10.750
para recuar as coisas de uma maneira bonita.

00:07:10.750 --> 00:07:13.150
Você não precisa paginar coisas como em um ensaio.

00:07:13.150 --> 00:07:16.390
O computador geralmente não se importa, mas o humano sim.

00:07:16.390 --> 00:07:17.817
O assistente de ensino faz.

00:07:17.817 --> 00:07:19.900
Você vai se importar no dia seguinte quando estiver apenas tentando

00:07:19.900 --> 00:07:21.560
para entender o que seu código faz.

00:07:21.560 --> 00:07:24.520
Por fim, vamos nos concentrar no estilo, na estética do código

00:07:24.520 --> 00:07:25.520
que você está escrevendo.

00:07:25.520 --> 00:07:27.280
Então, onde vamos escrever o código?

00:07:27.280 --> 00:07:28.940
Onde vamos compilar o código?

00:07:28.940 --> 00:07:32.770
Portanto, para esta aula, não apenas com C, mas com as outras linguagens que usaremos posteriormente

00:07:32.770 --> 00:07:35.140
no termo, vamos usar um texto livre

00:07:35.140 --> 00:07:39.280
editor que é um programa chamado Visual Studio Code, também conhecido como VS Code.

00:07:39.280 --> 00:07:43.450
É super popular hoje em dia, não apenas para C, mas para C++ e Python,

00:07:43.450 --> 00:07:45.970
e Java, e qualquer número de outras linguagens.

00:07:45.970 --> 00:07:49.270
É um editor de texto no sentido de que permite editar texto.

00:07:49.270 --> 00:07:52.150
E isso é tudo que o código vai ser.

00:07:52.150 --> 00:07:54.907
Agora, estritamente falando, você poderia escrever código em papel/lápis.

00:07:54.907 --> 00:07:56.740
Na verdade, no ensino médio, se você assistisse a uma aula,

00:07:56.740 --> 00:07:59.532
você pode ter feito isso uma ou mais vezes como um exercício em sala de aula.

00:07:59.532 --> 00:08:02.532
Você não pode colocá-lo no papel, é claro, mas pode escrevê-lo, certamente.

00:08:02.532 --> 00:08:04.570
Você pode usar algo como o Microsoft Word,

00:08:04.570 --> 00:08:07.240
ou Notepad.exe, ou Text Edit no Mac.

00:08:07.240 --> 00:08:09.340
Mas nenhum desses programas foi realmente projetado

00:08:09.340 --> 00:08:12.190
para formatar o código da melhor maneira para você,

00:08:12.190 --> 00:08:15.250
nem são projetados para permitir que você compile e execute o código.

00:08:15.250 --> 00:08:19.120
Então o VS Code será uma ferramenta através da qual você pode fazer tudo isso

00:08:19.120 --> 00:08:22.240
e mais-- escreva o código, compile o código, execute o código.

00:08:22.240 --> 00:08:25.630
Para que todos vocês não tenham que lutar com suporte técnico estúpido

00:08:25.630 --> 00:08:29.110
dores de cabeça no início do curso instalando este software e que

00:08:29.110 --> 00:08:33.070
em seus Macs ou PCs, usaremos uma versão baseada em nuvem do VS Code

00:08:33.070 --> 00:08:34.780
em code.cs50.io.

00:08:34.780 --> 00:08:36.580
E essa será exatamente a mesma ferramenta.

00:08:36.580 --> 00:08:38.860
E a meta, então, é até o final do semestre

00:08:38.860 --> 00:08:43.240
para migrá-lo desse ambiente baseado em nuvem para seu próprio Mac e PC

00:08:43.240 --> 00:08:46.090
para que, mesmo que CS50 seja a única aula de CS que você faz,

00:08:46.090 --> 00:08:50.290
você está 100% equipado para continuar escrevendo código após a aula usando

00:08:50.290 --> 00:08:54.010
não é algo específico do CS50, mas uma indústria de fato

00:08:54.010 --> 00:08:55.760
padrão, pelo menos por algum tempo.

00:08:55.760 --> 00:08:59.020
Então, como será esse programa VS Code, seja no seu Mac,

00:08:59.020 --> 00:09:00.990
PC, ou inicialmente no seu navegador?

00:09:00.990 --> 00:09:02.990
Vai se parecer um pouco com isto.

00:09:02.990 --> 00:09:05.657
E haverá várias regiões diferentes na tela.

00:09:05.657 --> 00:09:07.450
E retratado aqui é o mesmo código que eu

00:09:07.450 --> 00:09:10.335
continue propondo como o programa mais simples que você pode escrever em C.

00:09:10.335 --> 00:09:12.460
E quais são essas diferentes regiões da tela?

00:09:12.460 --> 00:09:15.440
Bem, há essencialmente esses quatro aqui.

00:09:15.440 --> 00:09:19.660
Então, primeiro, destacada na parte superior, haverá uma ou mais guias onde

00:09:19.660 --> 00:09:21.160
você vai realmente escrever o código.

00:09:21.160 --> 00:09:23.230
Assim como no Google Docs ou no Microsoft Word,

00:09:23.230 --> 00:09:24.940
você pode ter abas abertas com arquivos.

00:09:24.940 --> 00:09:28.330
Da mesma forma no VS Code-- ou, na verdade, qualquer ambiente de programação--

00:09:28.330 --> 00:09:30.830
você geralmente hoje em dia tem algum tipo de guia.

00:09:30.830 --> 00:09:34.480
E esta será uma guia contendo um arquivo, ao que parece, chamado hello.c.

00:09:34.480 --> 00:09:38.020
E esse será o primeiro arquivo que escreveremos daqui a pouco.

00:09:38.020 --> 00:09:40.720
Aqui embaixo, no entanto, haverá uma interface que muitos de vocês

00:09:40.720 --> 00:09:41.920
pode não saber.

00:09:41.920 --> 00:09:44.170
Isso é chamado de janela de terminal.

00:09:44.170 --> 00:09:47.920
E uma janela de terminal fornece o que geralmente é chamado de linha de comando

00:09:47.920 --> 00:09:49.720
Interface ou CLI.

00:09:49.720 --> 00:09:53.680
E isso está em contraste com uma Interface Gráfica do Usuário, ou GUI.

00:09:53.680 --> 00:09:57.760
Agora, você e eu, todos os dias, estamos usando GUIs em nossos telefones, em nossos PCs.

00:09:57.760 --> 00:10:01.420
E uma GUI é literalmente gráfica-- menus, botões e ícones.

00:10:01.420 --> 00:10:04.060
E você geralmente usa o dedo ou um trackpad

00:10:04.060 --> 00:10:06.380
ou um mouse ou algo parecido para interagir com ele.

00:10:06.380 --> 00:10:08.410
Mas acontece que muitos programadores - eles são

00:10:08.410 --> 00:10:11.770
dizendo que a maioria dos programadores, pelo menos com o tempo, prefere,

00:10:11.770 --> 00:10:14.620
não uma GUI, mas uma CLI, uma interface de linha de comando

00:10:14.620 --> 00:10:20.650
onde você realmente faz tudo de maneira um tanto misteriosa apenas com o teclado.

00:10:20.650 --> 00:10:21.250
Por que?

00:10:21.250 --> 00:10:24.610
Bem, acontece que há apenas mais recursos integrados à maioria dos computadores

00:10:24.610 --> 00:10:26.260
se você pode acessá-los com um teclado.

00:10:26.260 --> 00:10:29.530
Acontece que a maioria de nós pode digitar mais rápido do que apontar e clicar.

00:10:29.530 --> 00:10:32.330
E isso acaba sendo um ganho de eficiência ao longo do tempo.

00:10:32.330 --> 00:10:35.140
Então, com o tempo, você se sentirá confortável usando este terminal

00:10:35.140 --> 00:10:39.370
janela para fazer coisas como compilar seu código ou tornar seu programa

00:10:39.370 --> 00:10:40.390
bem como executá-lo.

00:10:40.390 --> 00:10:43.810
Então você não terá o hábito inicialmente de apenas clicar duas vezes nos ícones

00:10:43.810 --> 00:10:45.800
como fazemos em nosso mundo real típico.

00:10:45.800 --> 00:10:47.890
Você fará isso do jeito do programador.

00:10:47.890 --> 00:10:51.820
Mas não exclui a adição de ícones, capacidade de clique e muito mais.

00:10:51.820 --> 00:10:53.950
No lado esquerdo do VS Code, há

00:10:53.950 --> 00:10:56.920
será um explorador de arquivos um tanto familiar,

00:10:56.920 --> 00:11:00.040
algum tipo de árvore hierárquica, como no seu Mac ou PC, onde você pode

00:11:00.040 --> 00:11:02.110
ver todos os arquivos em sua conta.

00:11:02.110 --> 00:11:04.390
A foto aqui, por exemplo, é apenas hello.c,

00:11:04.390 --> 00:11:06.140
que eu mesmo criarei em um momento.

00:11:06.140 --> 00:11:09.343
E bem longe, à esquerda, está a chamada Barra de Atividade,

00:11:09.343 --> 00:11:12.260
e é aqui que você obtém muitos menus e botões tradicionais.

00:11:12.260 --> 00:11:16.250
Portanto, o próprio VS Code oferece uma GUI e uma CLI.

00:11:16.250 --> 00:11:19.958
Mas está dentro da CLI, a janela do terminal, a região inferior da tela

00:11:19.958 --> 00:11:22.250
que vamos digitar a maioria dos nossos comandos.

00:11:22.250 --> 00:11:25.417
E, em geral, na aula, vou esconder todo o material gráfico que está

00:11:25.417 --> 00:11:28.380
apenas não de tanto interesse.

00:11:28.380 --> 00:11:30.710
Então, com isso dito, deixe-me realmente mudar

00:11:30.710 --> 00:11:32.878
para uma versão ao vivo do VS Code.

00:11:32.878 --> 00:11:34.670
E eu realmente me escondi na barra de atividades.

00:11:34.670 --> 00:11:36.470
Eu realmente escondi o File Explorer.

00:11:36.470 --> 00:11:39.380
Então, o que eu tenho aqui para visibilidade é uma área muito grande

00:11:39.380 --> 00:11:42.840
para escrever código e uma janela de terminal realmente grande na parte inferior.

00:11:42.840 --> 00:11:45.260
Você verá na janela do terminal, há cifrão.

00:11:45.260 --> 00:11:47.160
E isso não significa qualquer forma de moeda.

00:11:47.160 --> 00:11:51.230
Este é apenas o símbolo padrão que representa os comandos de tipo aqui.

00:11:51.230 --> 00:11:53.480
Portanto, o fato de haver apenas um cifrão e um cursor

00:11:53.480 --> 00:11:55.490
significa, eventualmente, que é onde vou digitar os comandos.

00:11:55.490 --> 00:11:58.020
Mas primeiro, vou realmente criar algum código.

00:11:58.020 --> 00:12:02.900
Então, como posso programar usando o VS Code-- seja no meu Mac, PC,

00:12:02.900 --> 00:12:07.160
ou neste ambiente baseado em nuvem que você configurará para o conjunto de problemas 1 -

00:12:07.160 --> 00:12:08.870
escrever meu primeiro arquivo?

00:12:08.870 --> 00:12:10.610
Bem, talvez a maneira mais fácil seja esta.

00:12:10.610 --> 00:12:14.090
Literalmente execute o código de comando e depois o nome do arquivo

00:12:14.090 --> 00:12:15.200
você deseja criar.

00:12:15.200 --> 00:12:18.838
Observe que eu deliberadamente termino o arquivo com .c em letras minúsculas.

00:12:18.838 --> 00:12:21.380
Observe que coloquei deliberadamente todo o nome do arquivo em letras minúsculas.

00:12:21.380 --> 00:12:22.672
E estas são apenas convenções.

00:12:22.672 --> 00:12:24.140
Você poderia usar H maiúsculo.

00:12:24.140 --> 00:12:27.260
Você poderia usar um C maiúsculo. Mas não faça isso.

00:12:27.260 --> 00:12:30.260
Siga as melhores práticas para que sejam consistentes com o que a maioria das pessoas

00:12:30.260 --> 00:12:31.100
outra coisa faria.

00:12:31.100 --> 00:12:33.770
Quando pressiono Enter, recebo uma guia vazia,

00:12:33.770 --> 00:12:35.540
assim como a imagem de um momento atrás.

00:12:35.540 --> 00:12:40.100
E é nesta guia que agora posso escrever meu primeiro programa em C.

00:12:40.100 --> 00:12:42.620
Infelizmente, não é tão fácil de usar quanto o Scratch

00:12:42.620 --> 00:12:45.992
onde você arrasta e solta algumas peças do quebra-cabeça e pronto, pronto.

00:12:45.992 --> 00:12:47.450
Então, eu vou fazer isso para a memória.

00:12:47.450 --> 00:12:49.970
Mas isso também se tornará familiar para você com o tempo.

00:12:49.970 --> 00:12:53.720
Vou incluir algo chamado stdio.h.

00:12:53.720 --> 00:12:57.230
Vou digitar int main, void entre parênteses.

00:12:57.230 --> 00:13:01.190
Em uma nova linha, vou inserir algumas chaves, como as chamaremos.

00:13:01.190 --> 00:13:03.830
E então eu vou digitar printf, e então alguns

00:13:03.830 --> 00:13:09.200
parênteses, e depois entre aspas, olá, vírgula, mundo, depois uma barra invertida, depois

00:13:09.200 --> 00:13:12.800
um n minúsculo, depois uma aspa fechada e um ponto e vírgula

00:13:12.800 --> 00:13:14.280
bem no final da linha.

00:13:14.280 --> 00:13:19.010
Então, tudo o que fiz foi recriar, apenas de memória, aquele primeiro programa.

00:13:19.010 --> 00:13:21.710
Daqui a pouco, vamos deixar claro o que a maior parte disso faz.

00:13:21.710 --> 00:13:23.857
Mas, por enquanto, vamos apenas executar essa coisa.

00:13:23.857 --> 00:13:26.690
E assim como eu cliquei na bandeira verde na semana passada pela primeira vez,

00:13:26.690 --> 00:13:29.840
vamos realmente compilar e executar este programa.

00:13:29.840 --> 00:13:33.967
Se fosse seu Mac ou PC e Google, ou Microsoft, ou outra pessoa

00:13:33.967 --> 00:13:36.050
tinha feito o software, neste ponto da história,

00:13:36.050 --> 00:13:37.408
estaríamos clicando duas vezes em um ícone.

00:13:37.408 --> 00:13:38.450
Mas não podemos fazer isso ainda.

00:13:38.450 --> 00:13:39.930
Este ainda é o código-fonte.

00:13:39.930 --> 00:13:42.380
Vou clicar novamente na janela do meu terminal.

00:13:42.380 --> 00:13:45.650
Observe que tenho um segundo cifrão abaixo do primeiro, que apenas

00:13:45.650 --> 00:13:47.880
significa que está pronto para um segundo comando.

00:13:47.880 --> 00:13:53.000
E agora o comando através do qual tornar isso um programa real, para compilá-lo

00:13:53.000 --> 00:13:56.990
do código-fonte para o código de máquina, será simplesmente fazer

00:13:56.990 --> 00:13:59.360
e depois o nome do programa que quero fazer.

00:13:59.360 --> 00:14:03.710
Ligeira sutileza-- estou omitindo deliberadamente .c porque o programa que eu

00:14:03.710 --> 00:14:05.870
quero fazer, só quero dar um alô.

00:14:05.870 --> 00:14:07.400
Não escreva make hello.c.

00:14:07.400 --> 00:14:08.780
Basta escrever fazer olá.

00:14:08.780 --> 00:14:13.040
E este programa make é essencialmente nosso compilador.

00:14:13.040 --> 00:14:15.560
Tecnicamente falando, é um programa que automatiza

00:14:15.560 --> 00:14:17.580
a compilação do meu programa para mim.

00:14:17.580 --> 00:14:20.180
Mas vai ver que digitei a palavra olá.

00:14:20.180 --> 00:14:25.100
Ele vai procurar automaticamente um arquivo no disco rígido chamado hello.c

00:14:25.100 --> 00:14:30.690
e convertê-lo de código-fonte em C para código de máquina em zeros e uns.

00:14:30.690 --> 00:14:37.170
Então, se eu não cometi nenhum erro de digitação, Enter, nada parece acontecer.

00:14:37.170 --> 00:14:38.210
E isso é bom.

00:14:38.210 --> 00:14:41.862
Quase sempre, se nada for exibido na tela, você fez bem.

00:14:41.862 --> 00:14:43.070
Você não cometeu nenhum erro.

00:14:43.070 --> 00:14:43.880
Você não foi xingado.

00:14:43.880 --> 00:14:45.000
Não há mensagens de erro.

00:14:45.000 --> 00:14:46.590
Então isso é realmente uma coisa boa.

00:14:46.590 --> 00:14:47.942
Como faço agora para executar este programa?

00:14:47.942 --> 00:14:50.150
Bem, observe que tenho um terceiro cifrão, que apenas

00:14:50.150 --> 00:14:52.110
significa que estou pronto para um terceiro comando.

00:14:52.110 --> 00:14:55.400
E agora vou prosseguir e executar ./hello.

00:14:55.400 --> 00:14:58.798
E isso é reconhecidamente um pouco estranho que você tenha que fazer barra de ponto.

00:14:58.798 --> 00:15:00.590
Mas, por enquanto, apenas acredite que isso é

00:15:00.590 --> 00:15:04.610
como você executa um programa chamado hello Em sua pasta atual,

00:15:04.610 --> 00:15:07.730
em seu diretório atual neste ambiente baseado em nuvem.

00:15:07.730 --> 00:15:10.430
Tudo bem, cruzando os dedos novamente, apertando Enter.

00:15:10.430 --> 00:15:12.110
E pronto.

00:15:12.110 --> 00:15:15.950
Meu primeiro programa em C, olá, mundo.

00:15:15.950 --> 00:15:20.480
E agora deixe-me ir em frente e revelar o File Explorer que propus

00:15:20.480 --> 00:15:21.292
existe antes.

00:15:21.292 --> 00:15:23.750
Vou apenas usar o atalho de teclado para revelar isso.

00:15:23.750 --> 00:15:27.000
E geralmente, eu o mantenho fechado porque realmente não preciso constantemente o que

00:15:27.000 --> 00:15:28.250
os arquivos estão na minha conta.

00:15:28.250 --> 00:15:31.820
Mas você verá agora no File Explorer, semelhante em espírito a um Mac ou PC

00:15:31.820 --> 00:15:35.270
mas graficamente um pouco diferente, aqui está meu arquivo, hello.c.

00:15:35.270 --> 00:15:37.520
Está destacado porque tenho essa guia aberta.

00:15:37.520 --> 00:15:40.970
Mas agora há um segundo arquivo aqui chamado apenas olá.

00:15:40.970 --> 00:15:42.690
Esse é o nome do meu programa.

00:15:42.690 --> 00:15:46.100
Portanto, se você estiver em um Mac ou PC, o ideal é clicar duas vezes nessa coisa.

00:15:46.100 --> 00:15:48.162
Você não pode fazer isso em um ambiente de linha de comando.

00:15:48.162 --> 00:15:49.370
Você tem que executá-lo aqui.

00:15:49.370 --> 00:15:50.453
Mas isso é tudo o que fizemos.

00:15:50.453 --> 00:15:53.750
Criamos um arquivo chamado hello.c e, em seguida, meu compilador

00:15:53.750 --> 00:15:56.240
fez o programa a partir disso.

00:15:56.240 --> 00:16:00.080
Deixe-me fazer uma pausa aqui e ver se há alguma dúvida, porque isso é

00:16:00.080 --> 00:16:01.970
um monte de frases mágicas.

00:16:01.970 --> 00:16:04.450
Sim?

00:16:04.450 --> 00:16:04.950
Sim.

00:16:04.950 --> 00:16:08.390
Então, se você está acompanhando, tocando em casa

00:16:08.390 --> 00:16:10.890
e você está recebendo algum tipo de mensagem de erro, parte de hoje

00:16:10.890 --> 00:16:13.950
será para mim induzir deliberadamente algumas dessas mensagens de erro.

00:16:13.950 --> 00:16:17.070
Por enquanto, deixe-me apenas propor que, se você literalmente fez o que eu fiz,

00:16:17.070 --> 00:16:19.320
você deve ter cometido um erro de digitação em algum lugar.

00:16:19.320 --> 00:16:23.790
E observe que é realmente padrão io-- stdio.h.

00:16:23.790 --> 00:16:25.890
Talvez você tenha digitado studio.h?

00:16:25.890 --> 00:16:30.600
OK, erro supercomum, eu poderia chamá-lo para fora.

00:16:30.600 --> 00:16:32.280
Não é estúdio.h.

00:16:32.280 --> 00:16:34.560
É stdio.h-- tão comum.

00:16:34.560 --> 00:16:37.658
Mas isso é exatamente representativo do tipo de dor de cabeça estúpida

00:16:37.658 --> 00:16:40.200
você vai encontrar esta semana, provavelmente por algumas semanas,

00:16:40.200 --> 00:16:41.730
provavelmente, honestamente, por alguns anos.

00:16:41.730 --> 00:16:45.180
Mas você começa a ver além desses erros estúpidos ao longo do tempo,

00:16:45.180 --> 00:16:47.610
e fica cada vez mais fácil porque o computador é

00:16:47.610 --> 00:16:49.110
vai ser tão arregimentado.

00:16:49.110 --> 00:16:50.950
Ele só fará o que você disser para fazer.

00:16:50.950 --> 00:16:54.223
E se você disser porque verbalmente soa como studio.h,

00:16:54.223 --> 00:16:55.890
não saberá qual é o arquivo.

00:16:55.890 --> 00:16:58.182
Então, na verdade, obrigado por tropeçar nisso tão cedo.

00:16:58.182 --> 00:16:59.740
Isso é super comum de acontecer.

00:16:59.740 --> 00:17:00.240
Sim?

00:17:00.240 --> 00:17:02.540
AUDIÊNCIA: Por que você tem dois arquivos hello?

00:17:02.540 --> 00:17:03.799
DAVID J. MALAN: Por que tenho que saudar arquivos?

00:17:03.799 --> 00:17:04.400
AUDIÊNCIA: Sim.

00:17:04.400 --> 00:17:06.400
DAVID J. MALAN: Então, por que tenho que saudar os arquivos?

00:17:06.400 --> 00:17:09.170
Um é o que eu criei como o humano chamado hello.c,

00:17:09.170 --> 00:17:10.520
e está retratado aqui.

00:17:10.520 --> 00:17:15.890
Mas então, quando executei make hello, esse processo compilou meu código-fonte

00:17:15.890 --> 00:17:17.040
em código de máquina.

00:17:17.040 --> 00:17:20.240
Portanto, este segundo arquivo chamado hello é o arquivo que

00:17:20.240 --> 00:17:25.700
contém todos os zeros e uns que o servidor realmente entende.

00:17:25.700 --> 00:17:27.200
Tudo bem, então sim, pergunta?

00:17:27.200 --> 00:17:29.710
AUDIÊNCIA: O acesso ao olá [INAUDÍVEL]

00:17:29.710 --> 00:17:31.960
DAVID J. MALAN: Se você tentar clicar no arquivo hello,

00:17:31.960 --> 00:17:34.270
você verá neste ambiente o VS Code,

00:17:34.270 --> 00:17:36.580
aspas/sem aspas, o arquivo não é exibido no editor

00:17:36.580 --> 00:17:38.230
porque é binário--

00:17:38.230 --> 00:17:41.437
AKA zeros e uns-- ou usa uma codificação de texto não suportada.

00:17:41.437 --> 00:17:42.520
Neste caso, é binário.

00:17:42.520 --> 00:17:43.660
São zeros e uns.

00:17:43.660 --> 00:17:47.680
Agora, você pode usar um software para ver esses zeros e uns.

00:17:47.680 --> 00:17:50.320
Não será intelectualmente esclarecedor para a maioria dos humanos.

00:17:50.320 --> 00:17:53.165
Portanto, o VS Code apenas escolhe não mostrá-lo a você.

00:17:53.165 --> 00:17:56.290
Portanto, também seria um erro comum clicar em um arquivo que você não deseja.

00:17:56.290 --> 00:18:00.190
Mas o código-fonte será editado por nós.

00:18:00.190 --> 00:18:01.900
Tudo bem, então eu escrevi este programa.

00:18:01.900 --> 00:18:04.780
Parece funcionar magicamente, pelo menos com algum esforço

00:18:04.780 --> 00:18:06.700
se você acertar todas as teclas.

00:18:06.700 --> 00:18:08.440
Bem, o que está acontecendo?

00:18:08.440 --> 00:18:09.460
E como isso funciona?

00:18:09.460 --> 00:18:13.180
Bem, antes de tudo, observe que mesmo sem eu destacar as coisas

00:18:13.180 --> 00:18:17.740
ou escolhendo botões para menus, observe que já está codificado por cores.

00:18:17.740 --> 00:18:20.980
E, no entanto, eu não estava destacando ao longo do caminho no estilo do Google Docs,

00:18:20.980 --> 00:18:22.510
mudando a cor, certamente.

00:18:22.510 --> 00:18:25.960
Bem, acontece que o VS Code e a maioria dos ambientes de programação

00:18:25.960 --> 00:18:29.600
hoje em dia fazer por você automaticamente é destaque de sintaxe.

00:18:29.600 --> 00:18:33.850
Portanto, o realce de sintaxe é apenas esse recurso dos editores de texto típicos

00:18:33.850 --> 00:18:36.760
hoje em dia que analisa o código que você digitou.

00:18:36.760 --> 00:18:40.000
E quando percebe certos tipos de teclas,

00:18:40.000 --> 00:18:43.900
coisas que representam funções, ou condicionais, ou loops, ou variáveis--

00:18:43.900 --> 00:18:47.570
muito do vocabulário da semana passada - apenas o destaca de maneira muito diferente

00:18:47.570 --> 00:18:48.070
para você.

00:18:48.070 --> 00:18:51.430
O so main, por exemplo, que veremos em breve, está aqui em roxo.

00:18:51.430 --> 00:18:53.890
Int, void e include estão em vermelho.

00:18:53.890 --> 00:18:55.630
Olá, o mundo está em azul.

00:18:55.630 --> 00:18:57.390
Meus parênteses estão em verde.

00:18:57.390 --> 00:18:59.290
Isso também varia totalmente de acordo com o programador.

00:18:59.290 --> 00:19:02.995
Na verdade, se você quiser alterar essas cores para o conjunto de problemas 1

00:19:02.995 --> 00:19:04.870
para o seu próprio ambiente, você pode pesquisar

00:19:04.870 --> 00:19:07.190
Configurações do VS Code por meio do ícone de engrenagem.

00:19:07.190 --> 00:19:09.820
Você pode mudar para um tema de cor diferente.

00:19:09.820 --> 00:19:13.480
O realce de sintaxe não é um esquema de cores específico como no Scratch.

00:19:13.480 --> 00:19:16.485
Geralmente é para cada ser humano sua própria preferência.

00:19:16.485 --> 00:19:18.610
Mas isso é tudo o que está acontecendo aqui é essa noção

00:19:18.610 --> 00:19:20.830
de realce de sintaxe no momento.

00:19:20.830 --> 00:19:25.510
Bem, o que mais está acontecendo neste código antes de executá-lo, mas sim escrevê-lo?

00:19:25.510 --> 00:19:28.790
Bem, parece algo assim se eu tirar todas as cores.

00:19:28.790 --> 00:19:30.550
E então, apenas para fins de discussão, deixe-me ir em frente

00:19:30.550 --> 00:19:32.500
e pinte-o um pouco mais como o Scratch.

00:19:32.500 --> 00:19:34.690
Lembre-se de que nosso primeiro programa Scratch

00:19:34.690 --> 00:19:39.670
que acabou de dizer olá, o mundo na tela tinha um ícone de bandeira verde clicado--

00:19:39.670 --> 00:19:45.070
peça do quebra-cabeça, mais ou menos em laranja e, em seguida, um bloco roxo abaixo dela.

00:19:45.070 --> 00:19:48.820
Considerando que esta é a versão C, se voltarmos para a semana passada,

00:19:48.820 --> 00:19:50.950
este era o mesmo programa no Scratch.

00:19:50.950 --> 00:19:53.090
Mas o que está acontecendo agora é exatamente o mesmo.

00:19:53.090 --> 00:19:55.060
Então, se você pensar na semana passada e tiver

00:19:55.060 --> 00:19:58.600
tem alguma função, como a função say em roxo,

00:19:58.600 --> 00:20:01.270
que pode levar um ou mais argumentos, como entradas que

00:20:01.270 --> 00:20:03.190
influencia o que diz na tela.

00:20:03.190 --> 00:20:05.230
E então as funções, lembre-se, às vezes podem

00:20:05.230 --> 00:20:08.480
têm efeitos colaterais, como o balão de diálogo aparecendo na tela.

00:20:08.480 --> 00:20:11.260
Na semana passada, quando usamos o bloco say e

00:20:11.260 --> 00:20:13.840
aprovada em uma discussão de olá, mundo à esquerda,

00:20:13.840 --> 00:20:17.915
temos esse efeito colateral visual na tela que diz agora olá, mundo

00:20:17.915 --> 00:20:18.790
no balão de fala.

00:20:18.790 --> 00:20:23.230
E isso é exatamente o que aconteceu no VS Code, mas muito, muito mais textualmente.

00:20:23.230 --> 00:20:25.900
E vamos olhar um pouco mais de perto agora para o próprio código.

00:20:25.900 --> 00:20:29.020
Deixe-me acenar com o equivalente a quando

00:20:29.020 --> 00:20:32.890
bandeira verde clicou em parte do meu código, e vamos nos concentrar apenas

00:20:32.890 --> 00:20:38.350
no bloco say em Scratch e a função correspondente em C.

00:20:38.350 --> 00:20:41.770
Então, se eu passar por isso e quiser converter o que

00:20:41.770 --> 00:20:44.830
fizemos na semana passada com o bloco say para C,

00:20:44.830 --> 00:20:47.645
Eu usaria primeiro a função de impressão - embora isso seja realmente

00:20:47.645 --> 00:20:48.520
um pouco de uma mentira branca.

00:20:48.520 --> 00:20:50.440
Na verdade, é a função printf.

00:20:50.440 --> 00:20:52.030
Printf significa formatado.

00:20:52.030 --> 00:20:55.360
E é apenas uma função que permite formatar o texto na tela.

00:20:55.360 --> 00:20:58.570
Não há função say em C. Existe uma função printf.

00:20:58.570 --> 00:21:02.650
O que o MIT fez anos atrás foi pegar o que existia historicamente

00:21:02.650 --> 00:21:05.290
como printf, e eles o simplificaram para um público mais amplo

00:21:05.290 --> 00:21:08.050
apenas chamando-o, essencialmente, diga em vez disso.

00:21:08.050 --> 00:21:13.450
Mas observe que agora, se eu quiser converter o código Scratch à esquerda para o código C

00:21:13.450 --> 00:21:16.250
certo, é a mesma forma.

00:21:16.250 --> 00:21:18.940
Então o MIT usou deliberadamente este oval branco,

00:21:18.940 --> 00:21:23.510
até porque evoca essa ideia de ter parênteses também.

00:21:23.510 --> 00:21:26.770
À direita, se eu quiser passar um argumento ou uma entrada

00:21:26.770 --> 00:21:31.240
para a função printf, eu uso parênteses de abertura e parênteses de fechamento.

00:21:31.240 --> 00:21:33.700
Nesses parênteses, eu digito o que quer que seja

00:21:33.700 --> 00:21:35.600
é o que eu quero imprimir na tela--

00:21:35.600 --> 00:21:37.460
neste caso, olá, vírgula, mundo.

00:21:37.460 --> 00:21:39.310
Mas observe que eu deliberadamente deixei algum espaço

00:21:39.310 --> 00:21:42.160
porque você precisa de algumas teclas extras no mundo do C.

00:21:42.160 --> 00:21:44.590
Sempre que você digitar algum texto--

00:21:44.590 --> 00:21:49.150
também conhecido como string de texto, para usar o jargão da ciência da computação--

00:21:49.150 --> 00:21:52.100
você precisa citá-lo, neste caso com aspas duplas.

00:21:52.100 --> 00:21:54.520
Aspas duplas à esquerda, aspas duplas à direita.

00:21:54.520 --> 00:21:57.730
E observe também que vou incluir alguns símbolos ligeiramente enigmáticos

00:21:57.730 --> 00:22:01.660
aqui também-- barra invertida n, que eu também digitei e disse verbalmente anteriormente,

00:22:01.660 --> 00:22:05.480
e então um último incômodo no final disso, que é um ponto e vírgula.

00:22:05.480 --> 00:22:08.890
Basta dizer que é por isso que começamos com o Scratch.

00:22:08.890 --> 00:22:10.960
Isso, arraste e solte, você está pronto para ir.

00:22:10.960 --> 00:22:14.680
Em uma linguagem como C, printf, parênteses, aspas duplas, o texto

00:22:14.680 --> 00:22:16.630
você quer, barra invertida n, ponto e vírgula no final.

00:22:16.630 --> 00:22:18.970
Há tanta sobrecarga sintática.

00:22:18.970 --> 00:22:21.290
Mas no final do dia, é apenas uma função.

00:22:21.290 --> 00:22:25.180
E você vai se acostumar com esses incômodos como os parênteses, as aspas,

00:22:25.180 --> 00:22:27.130
o ponto e vírgula, e assim por diante.

00:22:27.130 --> 00:22:31.810
Mas as coisas podem muito facilmente dar errado, e é muito fácil cometer erros,

00:22:31.810 --> 00:22:33.380
mesmo com linhas de código como esta.

00:22:33.380 --> 00:22:34.190
Então deixe-me fazer isso.

00:22:34.190 --> 00:22:37.070
Deixe-me voltar ao VS Code, onde tenho exatamente o mesmo código.

00:22:37.070 --> 00:22:40.910
Observe que na linha 5 está exatamente essa linha de código.

00:22:40.910 --> 00:22:42.910
Portanto, este é o equivalente ao bloco say.

00:22:42.910 --> 00:22:46.090
E vamos considerar quais erros posso cometer no início ou mesmo agora

00:22:46.090 --> 00:22:49.930
20 anos depois de aprender isso que são bastante comuns em geral.

00:22:49.930 --> 00:22:52.180
Suponha que eu esqueça o ponto e vírgula aqui.

00:22:52.180 --> 00:22:53.380
Tão fácil de fazer.

00:22:53.380 --> 00:22:54.910
Você fará isso eventualmente.

00:22:54.910 --> 00:22:57.970
Vamos ver o que acontece agora quando eu voltar para a janela do meu terminal

00:22:57.970 --> 00:22:59.920
e tente compilar meu código novamente.

00:22:59.920 --> 00:23:02.590
Só para manter as coisas organizadas, vou limpar minha tela.

00:23:02.590 --> 00:23:05.170
Mas isso é apenas para efeito de palestra, para que possamos nos concentrar apenas

00:23:05.170 --> 00:23:06.460
no comando mais recente.

00:23:06.460 --> 00:23:09.940
Mas vou prosseguir agora e executar novamente o make hello.

00:23:09.940 --> 00:23:13.690
Isso garantirá que meu programa seja recompilado.

00:23:13.690 --> 00:23:14.950
E este é um processo manual.

00:23:14.950 --> 00:23:16.060
Eu mudei meu código.

00:23:16.060 --> 00:23:18.670
Os zeros e uns no disco rígido não foram alterados.

00:23:18.670 --> 00:23:21.980
Preciso recompilá-lo para gerar o código de máquina mais recente.

00:23:21.980 --> 00:23:22.580
Aqui vamos nos.

00:23:22.580 --> 00:23:24.830
Vou apertar Enter, cruzando os dedos como antes.

00:23:24.830 --> 00:23:29.320
Mas, novamente, removo o ponto e vírgula por acidente.

00:23:29.320 --> 00:23:29.980
Oh meu Deus.

00:23:29.980 --> 00:23:33.700
Há mais linhas de erros agora do que de código real.

00:23:33.700 --> 00:23:35.770
E isso também leva algum tempo para se acostumar.

00:23:35.770 --> 00:23:38.590
Os programas que estamos usando não foram necessariamente escritos

00:23:38.590 --> 00:23:40.480
com o público menos confortável em mente

00:23:40.480 --> 00:23:42.760
mas, realmente, programadores profissionais de antigamente.

00:23:42.760 --> 00:23:46.000
Mas através da prática, da experiência e dos erros,

00:23:46.000 --> 00:23:47.750
você começará a notar padrões aqui também.

00:23:47.750 --> 00:23:49.090
Então aqui está o que eu digitei.

00:23:49.090 --> 00:23:51.220
Faça olá após o prompt de sinal.

00:23:51.220 --> 00:23:57.010
Agora recebo gritos como segue, hello.c, dois pontos, 5, dois pontos, 29.

00:23:57.010 --> 00:23:58.420
Bem, a que isso se refere?

00:23:58.420 --> 00:24:03.460
Eu estraguei tudo em algum lugar-- na linha 5, no 29º caractere dessa linha.

00:24:03.460 --> 00:24:05.740
Geralmente, o caractere específico não é tão útil

00:24:05.740 --> 00:24:07.448
a menos que você realmente queira contar.

00:24:07.448 --> 00:24:08.630
Mas a linha 5 é uma boa pista.

00:24:08.630 --> 00:24:09.130
Por que?

00:24:09.130 --> 00:24:11.660
Significa que errei em algum lugar na linha 5 aqui.

00:24:11.660 --> 00:24:12.160
Tudo bem.

00:24:12.160 --> 00:24:13.360
Bem, qual é o erro?

00:24:13.360 --> 00:24:16.242
Esperava-se um ponto e vírgula após a expressão.

00:24:16.242 --> 00:24:17.950
E esse erro é realmente bastante óbvio

00:24:17.950 --> 00:24:20.103
agora que vejo e percebo, oh, espere um minuto.

00:24:20.103 --> 00:24:21.520
Tudo bem, aqui está minha linha de código.

00:24:21.520 --> 00:24:26.890
Aqui em uma espécie de arte ASCII, por assim dizer-- texto textual representando gráficos--

00:24:26.890 --> 00:24:30.550
ele quer que eu coloque em verde aqui o ponto e vírgula no final dessa linha.

00:24:30.550 --> 00:24:32.470
1 erro gerado, integrado--

00:24:32.470 --> 00:24:33.850
então algumas coisas esotéricas lá.

00:24:33.850 --> 00:24:36.340
Mas meu programa não compilou.

00:24:36.340 --> 00:24:39.470
Quando você vê um erro como esse, significa que não funcionou.

00:24:39.470 --> 00:24:40.360
Então, qual é a correção?

00:24:40.360 --> 00:24:45.470
Bem, obviamente, a correção é voltar aqui, colocar o ponto e vírgula lá.

00:24:45.470 --> 00:24:48.760
E agora, se eu recompilar meu código com make hello--

00:24:48.760 --> 00:24:52.060
Não vou limpar minha tela ainda só para mostrar a diferença - agora

00:24:52.060 --> 00:24:52.990
simplesmente funcionou.

00:24:52.990 --> 00:24:55.550
Então, estamos de volta aos negócios como antes.

00:24:55.550 --> 00:24:57.910
Tudo bem, deixe-me fazer uma pausa aqui, porém, e perguntar se há

00:24:57.910 --> 00:25:02.240
qualquer dúvida sobre o que acabei de fazer.

00:25:02.240 --> 00:25:04.460
Essas mensagens de erro se tornarão frequentes inicialmente.

00:25:04.460 --> 00:25:04.960
Sim?

00:25:04.960 --> 00:25:08.848
AUDIÊNCIA: Então, você precisa de um ponto e vírgula após a linha ou apenas alguns deles?

00:25:08.848 --> 00:25:10.390
DAVID J. MALAN: Realmente boa pergunta.

00:25:10.390 --> 00:25:12.960
Você precisa de um ponto e vírgula após cada linha ou apenas algumas?

00:25:12.960 --> 00:25:14.022
Acontece que apenas alguns.

00:25:14.022 --> 00:25:16.980
Isso é algo que você aprenderá através da prática, através de demonstrações

00:25:16.980 --> 00:25:18.240
e exemplos hoje.

00:25:18.240 --> 00:25:22.810
Geralmente, você coloca um ponto e vírgula após uma declaração, por assim dizer.

00:25:22.810 --> 00:25:25.230
E este é o termo técnico para esta linha de código.

00:25:25.230 --> 00:25:25.950
É uma declaração.

00:25:25.950 --> 00:25:29.230
E pense nisso como se fosse o código equivalente a uma frase em inglês.

00:25:29.230 --> 00:25:32.820
Portanto, o ponto e vírgula no código é como um ponto em inglês

00:25:32.820 --> 00:25:34.830
quando você terminar com aquele pensamento em particular.

00:25:34.830 --> 00:25:37.650
Você não precisa de ponto e vírgula por enquanto em nenhum outro lugar.

00:25:37.650 --> 00:25:39.750
E veremos exemplos de onde mais você os coloca.

00:25:39.750 --> 00:25:42.780
Mas geralmente está no final de uma linha de código

00:25:42.780 --> 00:25:46.980
isso não é puramente sintático como chaves em vez disso.

00:25:46.980 --> 00:25:51.600
Outras perguntas sobre o erro que acabei de corrigir e criar para mim?

00:25:51.600 --> 00:25:52.230
Sim?

00:25:52.230 --> 00:25:55.170
AUDIÊNCIA: [INAUDÍVEL]

00:25:55.170 --> 00:25:56.170
DAVID J. MALAN: Correto.

00:25:56.170 --> 00:25:58.950
Portanto, a linha 5 é onde o erro é mais provável.

00:25:58.950 --> 00:26:02.250
O caractere 29 significa que são 29 caracteres dessa forma.

00:26:02.250 --> 00:26:04.800
E então, neste caso, está me dando uma sugestão.

00:26:04.800 --> 00:26:07.420
O compilador nem sempre saberá me aconselhar,

00:26:07.420 --> 00:26:09.750
especialmente se eu fiz uma verdadeira bagunça no meu código.

00:26:09.750 --> 00:26:13.260
Mas, muitas vezes, fará o possível para lhe dar a resposta assim.

00:26:13.260 --> 00:26:14.170
Sim?

00:26:14.170 --> 00:26:16.930
AUDIÊNCIA: Por que você colocou o código hello.c pela primeira vez?

00:26:16.930 --> 00:26:21.140
DAVID J. MALAN: Ah, então como é que eu digitei código pela primeira vez, espaço, olá.c,

00:26:21.140 --> 00:26:22.940
e agora estou digitando make hello?

00:26:22.940 --> 00:26:24.180
Dois processos diferentes.

00:26:24.180 --> 00:26:27.350
Então, quando eu digitei código, espaço, hello.c, isso

00:26:27.350 --> 00:26:31.280
foi porque eu queria abrir o VS Code e criar um novo arquivo chamado hello.c.

00:26:31.280 --> 00:26:34.910
É como ir para Arquivo, Novo em um Mac ou PC.

00:26:34.910 --> 00:26:38.690
Depois disso, porém, uma vez que o arquivo existe e está realmente aberto aqui -

00:26:38.690 --> 00:26:41.900
e salva automaticamente, você não precisa pressionar Command-S ou Control-S tudo

00:26:41.900 --> 00:26:42.560
A Hora--

00:26:42.560 --> 00:26:46.110
Agora posso compilá-lo com make hello de novo e de novo.

00:26:46.110 --> 00:26:50.570
Então, teoricamente, eu nunca precisaria digitar code, space, hello.c

00:26:50.570 --> 00:26:54.020
novamente, a menos que eu queira criar um arquivo totalmente novo com o mesmo nome.

00:26:54.020 --> 00:26:57.200
Tudo bem, e quanto a esta outra parte da sintaxe aqui?

00:26:57.200 --> 00:26:58.790
Deixe-me limpar minha janela de terminal aqui.

00:26:58.790 --> 00:27:01.280
Você também pode pressionar Control-L apenas para lançar tudo

00:27:01.280 --> 00:27:03.380
afastado apenas para limpá-lo esteticamente.

00:27:03.380 --> 00:27:06.470
Suponha que eu omita qualquer que seja essa sequência de símbolos

00:27:06.470 --> 00:27:09.680
é, barra invertida n, já que não tenho certeza à primeira vista

00:27:09.680 --> 00:27:11.460
por que isso está lá.

00:27:11.460 --> 00:27:13.310
Alguém quer conjecturar, especialmente

00:27:13.310 --> 00:27:18.110
se você nunca programou antes, o que pode acontecer agora se eu recompilar

00:27:18.110 --> 00:27:20.450
e executar novamente esta versão do programa?

00:27:20.450 --> 00:27:25.130
Deixei o ponto e vírgula, mas retirei a barra invertida n.

00:27:25.130 --> 00:27:28.390
Algum instinto?

00:27:28.390 --> 00:27:29.920
Tudo bem, bem-- sim?

00:27:29.920 --> 00:27:32.470
AUDIÊNCIA: O próximo cifrão aparecerá

00:27:32.470 --> 00:27:34.190
logo após o seu olá, mundo?

00:27:34.190 --> 00:27:35.190
DAVID J. MALAN: Será.

00:27:35.190 --> 00:27:38.740
O próximo cifrão aparecerá logo após o meu olá, mundo.

00:27:38.740 --> 00:27:40.564
Mas o que te faz pensar isso?

00:27:40.564 --> 00:27:43.010
AUDIÊNCIA: Porque a barra invertida n cria uma nova linha?

00:27:43.010 --> 00:27:44.010
DAVID J. MALAN: Exatamente.

00:27:44.010 --> 00:27:46.050
Barra invertida n é na verdade uma sequência especial

00:27:46.050 --> 00:27:48.060
de símbolos que cria uma nova linha.

00:27:48.060 --> 00:27:52.710
E assim, para o seu ponto, se eu recompilar este programa, faça hello, Enter--

00:27:52.710 --> 00:27:55.420
nenhum erro de sintaxe, então ele compilou desta vez.

00:27:55.420 --> 00:27:57.180
Então você não precisa da barra invertida n.

00:27:57.180 --> 00:27:58.800
Você precisa do ponto e vírgula.

00:27:58.800 --> 00:28:02.730
Mas se você não tiver a barra invertida n, observe o que acontece quando eu faço ./hello

00:28:02.730 --> 00:28:03.510
desta vez.

00:28:03.510 --> 00:28:07.230
Agora, de fato, vejo olá, vírgula, mundo e depois um cifrão estranho.

00:28:07.230 --> 00:28:08.460
E isso ainda é um prompt.

00:28:08.460 --> 00:28:12.270
Ainda posso digitar comandos nele, como claro, e tudo fica limpo.

00:28:12.270 --> 00:28:13.710
Mas parece meio estúpido.

00:28:13.710 --> 00:28:18.240
Se eu executá-lo novamente aqui com ./hello, não é muito amigável.

00:28:18.240 --> 00:28:20.740
É convenção que, quando você terminar de executar seu programa,

00:28:20.740 --> 00:28:22.950
você deve idealmente limpar as coisas, mover o cursor

00:28:22.950 --> 00:28:24.460
para a próxima linha para o usuário.

00:28:24.460 --> 00:28:27.540
E assim a barra invertida n é simplesmente o símbolo especial,

00:28:27.540 --> 00:28:32.640
também conhecido como uma sequência de escape que C conhece

00:28:32.640 --> 00:28:34.980
significa mover o cursor para a próxima linha.

00:28:34.980 --> 00:28:39.640
Em outras linguagens, Python entre elas, também usa essa mesma simbologia.

00:28:39.640 --> 00:28:44.850
Agora, se eu voltar ao código aqui e, por exemplo,

00:28:44.850 --> 00:28:47.220
Eu tento fazer isso de forma diferente.

00:28:47.220 --> 00:28:49.020
Suponha que eu não coloque a barra invertida n.

00:28:49.020 --> 00:28:52.860
Acabei de pressionar Enter como uma pessoa normal faria no Google Docs ou no Microsoft Word.

00:28:52.860 --> 00:28:55.107
Deixe-me ir em frente e tentar compilar este programa.

00:28:55.107 --> 00:28:56.940
E isso, você esperaria, funcionaria, certo?

00:28:56.940 --> 00:29:00.210
Você esperaria que isso imprimisse olá, mundo e, em seguida, uma linha em branco

00:29:00.210 --> 00:29:02.220
porque eu movo o cursor para a próxima linha.

00:29:02.220 --> 00:29:02.790
Mas não.

00:29:02.790 --> 00:29:07.290
Se eu executar make hello now e tentar compilar isso, C não gostará disso.

00:29:07.290 --> 00:29:09.690
Agora recebo um erro diferente, ainda na linha 5,

00:29:09.690 --> 00:29:12.240
desta vez começando no caractere 12--

00:29:12.240 --> 00:29:15.810
erro, faltando o caractere de aspas duplas e, em seguida,

00:29:15.810 --> 00:29:17.070
algumas outras coisas esotéricas.

00:29:17.070 --> 00:29:19.530
E então isso não parece bom - erro fatal desta vez,

00:29:19.530 --> 00:29:21.900
muitos erros emitidos, parando agora.

00:29:21.900 --> 00:29:23.470
Então eu realmente estraguei tudo aqui.

00:29:23.470 --> 00:29:25.320
Então, por que não posso fazer isso?

00:29:25.320 --> 00:29:26.190
Só porque.

00:29:26.190 --> 00:29:29.730
Os humanos que projetaram C decidiram que, se você tiver uma string de texto,

00:29:29.730 --> 00:29:31.380
deve permanecer na mesma linha.

00:29:31.380 --> 00:29:32.760
Pode ficar muito longo.

00:29:32.760 --> 00:29:36.150
Ele pode envolver suavemente - ou seja, sem você pressionar Enter.

00:29:36.150 --> 00:29:38.220
Mas você não pode pressionar Enter para criar uma nova linha.

00:29:38.220 --> 00:29:42.870
Se você deseja deliberadamente uma nova linha, deve usar esta barra invertida n

00:29:42.870 --> 00:29:43.958
personagem de fuga.

00:29:43.958 --> 00:29:45.250
Então deixe-me ir em frente e fazer isso.

00:29:45.250 --> 00:29:46.710
Deixe-me colocá-lo de volta.

00:29:46.710 --> 00:29:48.720
Deixe-me voltar para a janela do meu terminal.

00:29:48.720 --> 00:29:50.080
Vou limpar a tela novamente.

00:29:50.080 --> 00:29:54.090
Deixe-me ir em frente agora e fazer olá para recompilar para essa versão-- ./hello.

00:29:54.090 --> 00:29:54.900
E pronto.

00:29:54.900 --> 00:29:57.780
Estamos de volta ao trabalho com olá.

00:29:57.780 --> 00:30:00.300
Tudo bem, agora vamos separar alguns outros aspectos

00:30:00.300 --> 00:30:03.870
deste código porque há muita coisa acontecendo apenas para nos fazer dizer olá,

00:30:03.870 --> 00:30:04.920
mundo na tela.

00:30:04.920 --> 00:30:07.740
Por hoje, vamos ignorar isso-- int

00:30:07.740 --> 00:30:10.145
main(void) e essas chaves aqui.

00:30:10.145 --> 00:30:12.520
Voltaremos a isso em breve para saber por que está lá.

00:30:12.520 --> 00:30:15.870
Mas, por enquanto, pense em int main(void) e essas chaves

00:30:15.870 --> 00:30:19.180
aqui como realmente sendo o equivalente em C de quando a bandeira verde foi clicada.

00:30:19.180 --> 00:30:19.680
Por que?

00:30:19.680 --> 00:30:20.638
Você só precisa dele lá.

00:30:20.638 --> 00:30:22.320
É assim que você faz seu programa funcionar.

00:30:22.320 --> 00:30:25.500
E main realmente será uma função especial, mas mais sobre isso

00:30:25.500 --> 00:30:26.340
outra hora.

00:30:26.340 --> 00:30:28.950
Mas por que eu tenho essa linha de código aqui?

00:30:28.950 --> 00:30:33.990
A grafia correta é realmente stdio.h, STDIO dot H.

00:30:33.990 --> 00:30:37.500
E eles são colchetes angulares desta vez, então isso é um pouco novo.

00:30:37.500 --> 00:30:40.290
Há um hash e, em seguida, uma palavra-chave include.

00:30:40.290 --> 00:30:42.123
Se você não sabe o que é algo, há

00:30:42.123 --> 00:30:45.165
não há muito mal em apenas se livrar dele e ver o que acontece.

00:30:45.165 --> 00:30:46.360
Então deixe-me deletar essa linha.

00:30:46.360 --> 00:30:48.910
Deixe-me voltar para a janela do meu terminal, limpar a tela,

00:30:48.910 --> 00:30:50.160
e então execute make hello novamente.

00:30:50.160 --> 00:30:53.290
E vamos tentar compilar este programa agora sem essa primeira linha.

00:30:53.290 --> 00:30:53.790
Por que?

00:30:53.790 --> 00:30:56.340
Eu não entendo, então vamos ver o que acontece.

00:30:56.340 --> 00:30:58.920
Tudo bem, aqui está outro erro, mas vamos ver...

00:30:58.920 --> 00:31:03.480
hello.c, linha 5, caractere 5-- então é bem cedo--

00:31:03.480 --> 00:31:07.920
erro, declarando implicitamente a função de biblioteca printf com o tipo int

00:31:07.920 --> 00:31:09.150
e então ponto, ponto, ponto.

00:31:09.150 --> 00:31:12.630
Então, declarando implicitamente a função de biblioteca printf--

00:31:12.630 --> 00:31:14.490
então isso soa muito enigmático.

00:31:14.490 --> 00:31:16.920
Você ficará melhor em entender frases como essas.

00:31:16.920 --> 00:31:22.620
Mas, aparentemente, preciso da linha include para stdio.h.

00:31:22.620 --> 00:31:23.820
Mas por que?

00:31:23.820 --> 00:31:27.810
Com base nesse sintoma, o que seu instinto pode

00:31:27.810 --> 00:31:33.330
ser para o que essa primeira linha de código está fazendo por nós em primeiro lugar?

00:31:33.330 --> 00:31:35.370
Por que intuitivamente deve estar lá?

00:31:35.370 --> 00:31:37.290
AUDIÊNCIA: É como o [INAUDÍVEL] funciona.

00:31:37.290 --> 00:31:38.290
DAVID J. MALAN: Exatamente.

00:31:38.290 --> 00:31:41.350
É como importar uma biblioteca para que você possa fazer coisas como imprimir coisas

00:31:41.350 --> 00:31:42.137
fora da tela.

00:31:42.137 --> 00:31:45.220
Agora, no Scratch, você não precisava fazer isso para a maioria das peças do quebra-cabeça.

00:31:45.220 --> 00:31:47.950
Mas você deve se lembrar que no meio da semana 0,

00:31:47.950 --> 00:31:51.640
Fui até o botão Extensões na parte inferior esquerda da tela do Scratch,

00:31:51.640 --> 00:31:54.340
e importei algumas peças extras do quebra-cabeça para texto

00:31:54.340 --> 00:31:59.170
ao discurso que nos deu a voz humanizada assustadora que realmente saiu

00:31:59.170 --> 00:32:00.100
da boca do gato.

00:32:00.100 --> 00:32:02.500
Bem, isso foi como adicionar uma biblioteca--

00:32:02.500 --> 00:32:04.390
código que outra pessoa escreveu.

00:32:04.390 --> 00:32:06.550
Nesse caso, foi um terceiro.

00:32:06.550 --> 00:32:08.380
Mas eu me dei acesso a ele.

00:32:08.380 --> 00:32:09.250
Mesmo aqui.

00:32:09.250 --> 00:32:13.900
Acontece que você realmente não obtém printf automaticamente em C.

00:32:13.900 --> 00:32:17.560
Você tem que incluir um chamado arquivo de cabeçalho que

00:32:17.560 --> 00:32:20.020
declara que a função existe.

00:32:20.020 --> 00:32:22.570
Agora, a razão para isso historicamente é apenas eficiência.

00:32:22.570 --> 00:32:26.882
Antigamente, quando os computadores eram realmente mais lentos e com recursos limitados,

00:32:26.882 --> 00:32:29.590
você não quer apenas ter acesso a toda a cozinha

00:32:29.590 --> 00:32:30.610
pia de funcionalidade.

00:32:30.610 --> 00:32:34.690
Você deseja incluir apenas as funções com as quais realmente se importa.

00:32:34.690 --> 00:32:39.180
Hoje em dia, é uma etapa de copiar/colar porque você quase sempre

00:32:39.180 --> 00:32:40.930
deseja imprimir algo na tela,

00:32:40.930 --> 00:32:42.680
pelo menos ao escrever programas como estes.

00:32:42.680 --> 00:32:45.760
Mas esses chamados arquivos de cabeçalho contêm informações suficientes

00:32:45.760 --> 00:32:50.350
sobre todas as funções no que é chamado de Standard I/O Library.

00:32:50.350 --> 00:32:53.450
E E/S padrão significa apenas Entrada e Saída padrão.

00:32:53.450 --> 00:32:54.700
E isso é apropriado, certo?

00:32:54.700 --> 00:32:57.010
Porque a impressão é uma saída bastante básica.

00:32:57.010 --> 00:32:59.920
Acontece que existem outras funções para obter informações do humano

00:32:59.920 --> 00:33:01.310
teclado-- mais sobre isso daqui a pouco.

00:33:01.310 --> 00:33:03.970
Mas sempre que você quiser imprimir algo na tela em C,

00:33:03.970 --> 00:33:07.630
você realmente precisa incluir este arquivo de cabeçalho na parte superior do seu código.

00:33:07.630 --> 00:33:11.350
E isso basicamente informará o compilador, ei, compilador,

00:33:11.350 --> 00:33:15.980
Desejo usar a funcionalidade da biblioteca de E/S padrão,

00:33:15.980 --> 00:33:18.320
incluindo printf neste caso.

00:33:18.320 --> 00:33:20.770
E se você omitir o arquivo de cabeçalho por acidente,

00:33:20.770 --> 00:33:24.040
simplesmente não vai funcionar porque não sabe o que é printf.

00:33:24.040 --> 00:33:27.970
É algum símbolo não reconhecido nesse caso.

00:33:27.970 --> 00:33:34.320
Tudo bem, perguntas, então, sobre esta linha de código, esta linha de código aqui,

00:33:34.320 --> 00:33:37.590
ou o que são esses arquivos de cabeçalho?

00:33:37.590 --> 00:33:40.890
Tudo bem, você pode se perguntar, bem, como você sabe quais funções existem?

00:33:40.890 --> 00:33:43.990
Como você sabe quais arquivos você realmente deseja incluir?

00:33:43.990 --> 00:33:46.620
Bem, acontece que C é uma linguagem de muitos anos,

00:33:46.620 --> 00:33:48.720
e tem ampla documentação.

00:33:48.720 --> 00:33:52.770
Uma ressalva é que sua documentação não é necessariamente tão amigável ao usuário.

00:33:52.770 --> 00:33:56.370
Mas o que temos para o curso é uma versão simplificada

00:33:56.370 --> 00:34:01.680
da documentação oficial para C neste URL aqui, manual.cs50.io.

00:34:01.680 --> 00:34:04.380
Portanto, no mundo de C e em outras linguagens também,

00:34:04.380 --> 00:34:06.150
existem as chamadas páginas de manual.

00:34:06.150 --> 00:34:08.820
E estes são apenas documentação baseada em texto

00:34:08.820 --> 00:34:11.010
que, honestamente, é tipicamente escrito em uma voz

00:34:11.010 --> 00:34:14.560
que você tem que ser um programador experiente para entender algumas delas.

00:34:14.560 --> 00:34:17.699
Então, o que fizemos nesta versão da mesma documentação

00:34:17.699 --> 00:34:20.699
é que importamos toda a documentação oficial original,

00:34:20.699 --> 00:34:24.074
mas adicionamos traduções menos confortáveis ​​em inglês

00:34:24.074 --> 00:34:26.699
para muitas das funcionalidades que você pode usar em sala de aula apenas

00:34:26.699 --> 00:34:27.713
para ajudá-lo a embarcar.

00:34:27.713 --> 00:34:30.630
Portanto, no final das contas, você não precisa dessa documentação a longo prazo.

00:34:30.630 --> 00:34:34.320
Mas apenas para começar, vamos traduzi-lo em terminologia

00:34:34.320 --> 00:34:36.630
que você pode apreciar de um assistente de ensino,

00:34:36.630 --> 00:34:39.969
por exemplo, em oposição ao autor original desses documentos.

00:34:39.969 --> 00:34:42.420
E assim, por exemplo, se você estiver interessado em ler

00:34:42.420 --> 00:34:48.330
sobre quais funções existem no arquivo stdio.h, bem,

00:34:48.330 --> 00:34:52.830
você pode acessar um URL como este ou pesquisá-lo em manual.cs50.io.

00:34:52.830 --> 00:34:56.350
Isso mostraria uma lista de todas as funções disponíveis nessa biblioteca,

00:34:56.350 --> 00:34:58.350
e imprimir se de fato seria um deles.

00:34:58.350 --> 00:35:00.683
E então você pode clicar mais sobre isso, alcançando um URL

00:35:00.683 --> 00:35:03.475
assim, que fornecerá toda a documentação de como

00:35:03.475 --> 00:35:04.110
para usar printf.

00:35:04.110 --> 00:35:07.560
Acontece que você pode fazer ainda mais do que apenas imprimir olá, mundo.

00:35:07.560 --> 00:35:09.450
E vamos arranhar a superfície disso hoje.

00:35:09.450 --> 00:35:12.900
Mas acontece que a documentação sempre

00:35:12.900 --> 00:35:16.680
seja sua fonte confiável para perguntas como, o que posso fazer,

00:35:16.680 --> 00:35:18.160
e como posso fazer isso?

00:35:18.160 --> 00:35:23.010
Enquanto isso, o CS50 tem sua própria biblioteca

00:35:23.010 --> 00:35:25.980
e acessível por meio do arquivo de cabeçalho chamado cs50.h.

00:35:25.980 --> 00:35:28.530
Acontece em C que a saída é realmente

00:35:28.530 --> 00:35:30.750
muito fácil, relativamente falando, uma vez que você

00:35:30.750 --> 00:35:34.110
acostume-se com todas as chaves, parênteses, aspas e coisas do gênero.

00:35:34.110 --> 00:35:36.670
Mas a entrada é um pouco mais difícil.

00:35:36.670 --> 00:35:41.100
E se você já programou antes, a entrada não é tão difícil de fazer em Python.

00:35:41.100 --> 00:35:42.540
Não é tão difícil de fazer em Java.

00:35:42.540 --> 00:35:46.312
É mais difícil de fazer em C. E veremos por que em algumas semanas.

00:35:46.312 --> 00:35:48.270
Mas nas primeiras semanas de aula,

00:35:48.270 --> 00:35:50.880
na verdade, fornecemos algumas rodinhas de treinamento,

00:35:50.880 --> 00:35:53.700
tipos, em que temos uma série de funções

00:35:53.700 --> 00:35:56.430
que são declarados neste arquivo, cs50.h.

00:35:56.430 --> 00:35:59.220
Ele vive sua documentação em um URL como este.

00:35:59.220 --> 00:36:01.230
E daqui a pouco, usaremos alguns deles.

00:36:01.230 --> 00:36:05.040
Você verá que o CS50 fornece algumas funções como get_char

00:36:05.040 --> 00:36:08.580
para obter um único caractere do teclado do usuário,

00:36:08.580 --> 00:36:11.790
get_int para obter um número inteiro do teclado do usuário,

00:36:11.790 --> 00:36:15.450
get_string para obter uma sequência de texto do teclado do usuário e um monte

00:36:15.450 --> 00:36:16.930
dos outros também.

00:36:16.930 --> 00:36:19.920
Então, vamos usar algumas dessas funções, que tal,

00:36:19.920 --> 00:36:22.410
revisitando, realmente, o segundo programa que

00:36:22.410 --> 00:36:26.710
escreveu no Scratch da última vez, o que adiciona alguma entrada à saída.

00:36:26.710 --> 00:36:28.830
Portanto, a primeira versão do Scratch era apenas olá, mundo.

00:36:28.830 --> 00:36:31.200
Disse a mesma coisa toda vez que você clica na bandeira verde.

00:36:31.200 --> 00:36:33.180
A versão 2, lembre-se, porém, fez isso.

00:36:33.180 --> 00:36:35.190
Perguntou ao usuário, qual é o seu nome?

00:36:35.190 --> 00:36:40.870
E então isso de alguma forma devolveu um valor de retorno, nós o chamamos.

00:36:40.870 --> 00:36:44.100
E então juntamos alô e esse nome para dizer algo um pouco mais

00:36:44.100 --> 00:36:46.420
interessante na tela.

00:36:46.420 --> 00:36:48.420
Então, como era esse modelo?

00:36:48.420 --> 00:36:49.560
A mesma coisa de antes.

00:36:49.560 --> 00:36:52.680
Temos uma função no meio onde a função é como o código

00:36:52.680 --> 00:36:54.480
implementação do nosso algoritmo.

00:36:54.480 --> 00:36:56.910
Isso inclui um ou mais argumentos, como o que você

00:36:56.910 --> 00:37:00.000
quer dizer na tela em última análise?

00:37:00.000 --> 00:37:03.580
E o valor de retorno, neste caso, será na verdade um valor que retorna.

00:37:03.580 --> 00:37:07.660
Então, no caso de obter entrada, podemos considerar este bloco ask novamente,

00:37:07.660 --> 00:37:08.490
como na semana passada.

00:37:08.490 --> 00:37:12.420
A entrada para ele é qualquer palavra em inglês que você deseja perguntar ao usuário.

00:37:12.420 --> 00:37:14.670
E então ele retorna um valor.

00:37:14.670 --> 00:37:17.550
E isso foi chamado por padrão na resposta mundial do MIT.

00:37:17.550 --> 00:37:20.460
Mas veremos em C, você pode chamar esses valores de retorno de qualquer coisa

00:37:20.460 --> 00:37:22.300
você quer, em última análise, em variáveis.

00:37:22.300 --> 00:37:24.100
Mas isso é diferente de um efeito colateral.

00:37:24.100 --> 00:37:27.100
Um efeito colateral é apenas algo visual que geralmente acontece na tela,

00:37:27.100 --> 00:37:28.980
como o balão de fala ou olá, mundo.

00:37:28.980 --> 00:37:32.220
Um valor de retorno é na verdade um valor que você recebe de uma função

00:37:32.220 --> 00:37:34.020
que você pode usar ou reutilizar.

00:37:34.020 --> 00:37:38.400
Então, como convertemos este bloco Scratch da semana passada para o código C desta semana?

00:37:38.400 --> 00:37:41.340
Bem, se você quiser perguntar ao usuário algo como seu nome,

00:37:41.340 --> 00:37:42.580
você consegue fazer isso.

00:37:42.580 --> 00:37:45.600
Você usa uma função CS50 chamada get_string.

00:37:45.600 --> 00:37:49.950
E você usa os parênteses para representar aqui vem as entradas lá também.

00:37:49.950 --> 00:37:52.967
Você pode então colocar a frase que deseja perguntar ao usuário--

00:37:52.967 --> 00:37:54.300
aspas/sem aspas, qual é o seu nome?

00:37:54.300 --> 00:37:57.150
Mas você realmente precisa das aspas literalmente em C.

00:37:57.150 --> 00:37:59.220
Então, vou em frente e adicioná-los também.

00:37:59.220 --> 00:38:03.720
Sutil, mas incluí deliberadamente um espaço após o ponto de interrogação,

00:38:03.720 --> 00:38:06.840
mas antes das aspas duplas, só para que o cursor

00:38:06.840 --> 00:38:08.998
avança um passo porque, neste caso,

00:38:08.998 --> 00:38:11.790
não vamos obter uma caixa de fala especial como fizemos no Scratch.

00:38:11.790 --> 00:38:14.582
Ele só vai deixar o cursor onde está, então veremos isso,

00:38:14.582 --> 00:38:16.980
esteticamente, isso apenas move o cursor piscando um

00:38:16.980 --> 00:38:19.800
espaço após a frase na tela.

00:38:19.800 --> 00:38:21.930
Tudo bem, mas o problema é com o Scratch,

00:38:21.930 --> 00:38:25.140
acabamos de receber automaticamente a resposta do usuário

00:38:25.140 --> 00:38:27.180
em uma variável especial chamada resposta.

00:38:27.180 --> 00:38:30.270
Em C, você terá que ser um pouco mais específico.

00:38:30.270 --> 00:38:35.780
Em C, se você deseja recuperar um valor de retorno de uma função como get_string,

00:38:35.780 --> 00:38:40.420
você tem que usar um sinal de igual e, em seguida, o nome de uma variável à esquerda.

00:38:40.420 --> 00:38:42.280
A escolha das variáveis ​​é com você.

00:38:42.280 --> 00:38:44.290
Eu poderia ter chamado isso de qualquer coisa-- x, y, z.

00:38:44.290 --> 00:38:47.470
Vou chamá-lo de forma mais descritiva, respondendo por paridade com o que

00:38:47.470 --> 00:38:48.880
MIT fez com o Scratch.

00:38:48.880 --> 00:38:53.090
Mas observe que isso não representa igualdade per se.

00:38:53.090 --> 00:38:55.640
Esta é a atribuição neste caso.

00:38:55.640 --> 00:38:58.180
Então, em C, quando você usa um único sinal de igual,

00:38:58.180 --> 00:39:01.720
isso significa copiar o valor à direita para o valor

00:39:01.720 --> 00:39:03.590
à esquerda - da direita para a esquerda.

00:39:03.590 --> 00:39:05.390
Então, o que isso faz por nós?

00:39:05.390 --> 00:39:08.170
Bem, se get_string é uma função que solicita ao usuário,

00:39:08.170 --> 00:39:12.160
aspas/sem aspas, qual é o seu nome, e reivindico um valor de retorno,

00:39:12.160 --> 00:39:14.750
isso significa que me devolve algum valor.

00:39:14.750 --> 00:39:17.960
Mas cabe a mim em C fazer algo com esse valor.

00:39:17.960 --> 00:39:21.520
Então, se eu quiser copiar esse valor em uma variável que possa usar e reutilizar,

00:39:21.520 --> 00:39:25.300
Eu uso um sinal de igual e invento no lado esquerdo desse sinal de igual

00:39:25.300 --> 00:39:27.340
qualquer nome de variável que eu quiser.

00:39:27.340 --> 00:39:28.450
Existem certas regras.

00:39:28.450 --> 00:39:29.700
Existem certas convenções.

00:39:29.700 --> 00:39:32.590
Mas geralmente se você usar uma única palavra com letras minúsculas,

00:39:32.590 --> 00:39:34.570
você está em boa forma.

00:39:34.570 --> 00:39:37.040
Mas C é um pouco mais pedante do que isso.

00:39:37.040 --> 00:39:38.980
E aqueles de vocês que já programaram antes

00:39:38.980 --> 00:39:41.410
pode não ser usado para isso, por exemplo, em Python, que

00:39:41.410 --> 00:39:43.330
é um mundo ao qual chegaremos em algumas semanas.

00:39:43.330 --> 00:39:48.670
Você também precisa dizer a C que tipo de valor está armazenando.

00:39:48.670 --> 00:39:54.370
Então, se eu quiser uma string de texto do usuário-- não um número inteiro, não

00:39:54.370 --> 00:39:55.270
um único personagem.

00:39:55.270 --> 00:39:58.430
Eu quero uma sequência inteira de texto, como uma frase, uma frase, um nome,

00:39:58.430 --> 00:39:59.270
nesse caso--

00:39:59.270 --> 00:40:04.250
Tenho que dizer a C que esta variável é do tipo string.

00:40:04.250 --> 00:40:06.267
Então é um pouco prolixo, mas você se acostuma.

00:40:06.267 --> 00:40:07.600
E você só precisa ser preciso.

00:40:07.600 --> 00:40:12.760
Você está informando ao computador que tipo de valor vai nessa variável.

00:40:12.760 --> 00:40:15.040
Tudo bem, está tão perto de estar correto,

00:40:15.040 --> 00:40:19.210
mas omiti algo que ainda é irritantemente importante.

00:40:19.210 --> 00:40:20.470
O que ainda falta?

00:40:20.470 --> 00:40:21.070
Sim?

00:40:21.070 --> 00:40:21.970
AUDIÊNCIA: Ponto e vírgula?

00:40:21.970 --> 00:40:23.178
DAVID J. MALAN: Então, ponto e vírgula.

00:40:23.178 --> 00:40:24.230
Esta é uma declaração.

00:40:24.230 --> 00:40:27.040
Isto é como um pensamento completo, se você quiser.

00:40:27.040 --> 00:40:31.680
No Code, preciso terminar com o ponto e vírgula no final.

00:40:31.680 --> 00:40:33.430
Tudo bem, então isso foi mais um bocado,

00:40:33.430 --> 00:40:35.720
mas vamos tentar usar isso agora no meu código.

00:40:35.720 --> 00:40:40.250
Deixe-me voltar ao VS Code, onde tenho a versão 0 do meu código aqui.

00:40:40.250 --> 00:40:44.560
Deixe-me prosseguir e incluir outro arquivo no início de hello.c,

00:40:44.560 --> 00:40:48.790
ou seja, inclua cs50.h para que eu tenha acesso agora

00:40:48.790 --> 00:40:51.370
para get_string e qualquer outra coisa que eu queira.

00:40:51.370 --> 00:40:56.710
Agora deixe-me adicionar uma linha de código aqui dentro dessas chaves.

00:40:56.710 --> 00:40:58.390
E deixe-me ir em frente e fazer isso--

00:40:58.390 --> 00:41:03.820
string resposta é igual a get_string, aspas/sem aspas, qual é o seu nome,

00:41:03.820 --> 00:41:04.847
ponto de interrogação.

00:41:04.847 --> 00:41:07.180
Vou adicionar um espaço extra antes das aspas duplas.

00:41:07.180 --> 00:41:10.430
Vou realmente terminar meu pensamento com um ponto e vírgula.

00:41:10.430 --> 00:41:14.260
E agora deixe-me cometer um erro deliberadamente, apenas para enfatizar aqui.

00:41:14.260 --> 00:41:19.840
Deixe-me agora tentar mudar olá, mundo para olá, vírgula, resposta.

00:41:19.840 --> 00:41:22.630
Agora, talvez, mesmo que sejam algumas novas linhas de código,

00:41:22.630 --> 00:41:24.520
você pode ver onde eu já errei.

00:41:24.520 --> 00:41:26.980
Mas deixe-me tentar fazer este programa agora.

00:41:26.980 --> 00:41:27.970
Até agora tudo bem.

00:41:27.970 --> 00:41:29.120
Portanto, sem mensagens de erro.

00:41:29.120 --> 00:41:30.140
Então isso é uma coisa boa.

00:41:30.140 --> 00:41:34.000
Deixe-me prosseguir e executar ./hello, e você verá o prompt.

00:41:34.000 --> 00:41:35.650
Qual é o seu nome, ponto de interrogação.

00:41:35.650 --> 00:41:37.942
E observe, o cursor é de fato um espaço à direita

00:41:37.942 --> 00:41:39.817
só porque achei que ficaria mais bonito

00:41:39.817 --> 00:41:42.190
para colocar um pequeno espaço em branco lá em vez de deixar

00:41:42.190 --> 00:41:43.600
logo após o ponto de interrogação.

00:41:43.600 --> 00:41:44.530
Deixe-me digitar meu nome.

00:41:44.530 --> 00:41:48.340
Mas mesmo que você nunca tenha programado antes, eu estraguei tudo aqui.

00:41:48.340 --> 00:41:51.240
O que vamos ver na tela quando eu apertar Enter?

00:41:51.240 --> 00:41:52.240
AUDIÊNCIA: Olá, responda.

00:41:52.240 --> 00:41:53.115
DAVID J. MALAN: Sim.

00:41:53.115 --> 00:41:54.280
Olá, responda, provavelmente.

00:41:54.280 --> 00:41:54.730
Por que?

00:41:54.730 --> 00:41:56.855
Porque o computador vai me levar literalmente.

00:41:56.855 --> 00:41:59.020
E se eu disser, aspas/sem aspas, olá, responda.

00:41:59.020 --> 00:42:01.750
Essa é a string de texto seguida por uma nova linha que é

00:42:01.750 --> 00:42:03.260
vai ser enviado para a tela.

00:42:03.260 --> 00:42:08.530
Portanto, precisamos de alguma maneira de conectar a resposta a essa linha de código.

00:42:08.530 --> 00:42:10.330
Não é tão simples como arranhar onde

00:42:10.330 --> 00:42:14.140
você poderia simplesmente pegar um segundo bloco e arrastar e soltar a variável lá.

00:42:14.140 --> 00:42:15.670
Na verdade, precisamos de uma nova sintaxe.

00:42:15.670 --> 00:42:18.250
E vai parecer estranho no começo, mas está em todo lugar

00:42:18.250 --> 00:42:22.900
em software hoje em dia, especialmente no mundo de C e algumas outras linguagens.

00:42:22.900 --> 00:42:27.610
Então, deixe-me ir em frente e propor que eu resolva da seguinte maneira.

00:42:27.610 --> 00:42:31.450
Bem, quando fizemos isso no Scratch, lembre-se que a solução mais elegante

00:42:31.450 --> 00:42:32.350
foi isso aqui.

00:42:32.350 --> 00:42:36.550
Usamos o bloco say still, que será análogo ao printf hoje.

00:42:36.550 --> 00:42:41.630
Mas eu uso a peça do quebra-cabeça e Scratch para combinar olá, vírgula, espaço,

00:42:41.630 --> 00:42:43.340
e então o nome do humano.

00:42:43.340 --> 00:42:45.790
Então, como traduzimos esse código para C?

00:42:45.790 --> 00:42:47.830
Bem, vai parecer um pouco diferente agora.

00:42:47.830 --> 00:42:51.700
Vou começar com printf com alguns parênteses e um ponto e vírgula

00:42:51.700 --> 00:42:53.530
representando o bloco say.

00:42:53.530 --> 00:42:55.240
Mas como faço agora essa junção?

00:42:55.240 --> 00:42:58.330
É aqui que as peças do quebra-cabeça não se traduzem perfeitamente.

00:42:58.330 --> 00:43:00.290
Esta seria a maneira de fazer isso.

00:43:00.290 --> 00:43:03.430
Você coloca olá, vírgula e, em seguida, um espaço reservado.

00:43:03.430 --> 00:43:07.810
Isso é conhecido como código de formato em C, especificamente para printf.

00:43:07.810 --> 00:43:11.350
E isso significa apenas que este é um espaço reservado para uma string.

00:43:11.350 --> 00:43:12.740
Novamente, uma string é apenas texto.

00:43:12.740 --> 00:43:17.120
Isso significa, ei, computador, imprima literalmente, olá, vírgula, espaço,

00:43:17.120 --> 00:43:23.200
e então não literalmente %s. %s é tratado especialmente para significar plug em algum valor

00:43:23.200 --> 00:43:23.903
aqui.

00:43:23.903 --> 00:43:25.570
Tudo bem, então o que mais eu ainda preciso?

00:43:25.570 --> 00:43:28.030
Bem, isso ainda é um texto, então ainda estou

00:43:28.030 --> 00:43:32.460
vai cercar a coisa toda com aspas duplas.

00:43:32.460 --> 00:43:35.220
Eu ainda vou incluir minha barra invertida n apenas

00:43:35.220 --> 00:43:37.870
para manter as coisas organizadas e mover o cursor para a próxima linha.

00:43:37.870 --> 00:43:45.120
Portanto, a última etapa aqui em C é, de alguma forma, juntar a resposta com a palavra olá.

00:43:45.120 --> 00:43:49.980
E a maneira de fazer isso é com printf, passando não um argumento, o que

00:43:49.980 --> 00:43:51.000
é o que continuo fazendo.

00:43:51.000 --> 00:43:53.820
Continuo passando uma sequência de texto, entre aspas e tire aspas.

00:43:53.820 --> 00:43:58.320
Vou agora adicionar uma vírgula e depois o nome do valor que eu quero

00:43:58.320 --> 00:44:02.760
printf para voltar e conectar-se a esse %s.

00:44:02.760 --> 00:44:04.410
E printf é inteligente sobre isso.

00:44:04.410 --> 00:44:09.390
Se você tiver um %s e um argumento adicional depois de uma vírgula, ele simplesmente...

00:44:09.390 --> 00:44:10.980
da direita para a esquerda, ele o conecta.

00:44:10.980 --> 00:44:16.470
Se você tiver dois %s e duas variáveis ​​após a vírgula, tudo bem também.

00:44:16.470 --> 00:44:19.860
Se você os separar com vírgulas, ele colocará o primeiro no primeiro %s

00:44:19.860 --> 00:44:22.380
e a segunda variável no segundo %s.

00:44:22.380 --> 00:44:24.750
Então é da esquerda para a direita, a ordem das operações.

00:44:24.750 --> 00:44:30.302
Não é tão bonito ou simples assim, mas é assim que é feito em C.

00:44:30.302 --> 00:44:32.760
Tudo bem, deixe-me fazer uma pausa porque isso é muita simbologia.

00:44:32.760 --> 00:44:35.080
Alguma dúvida sobre essa técnica aqui?

00:44:35.080 --> 00:44:35.580
Sim?

00:44:35.580 --> 00:44:39.725
AUDIÊNCIA: Por que você excluiu a barra invertida n na seção anterior?

00:44:39.725 --> 00:44:41.600
DAVID J. MALAN: Sim, uma pergunta muito boa.

00:44:41.600 --> 00:44:45.550
Por que excluí a barra invertida um momento atrás?

00:44:45.550 --> 00:44:48.280
Realmente, apenas meu senso de estética, se você quiser.

00:44:48.280 --> 00:44:49.760
Nenhuma boa razão além disso.

00:44:49.760 --> 00:44:52.210
Então, se eu olhar para o meu código, você com razão

00:44:52.210 --> 00:44:54.460
observe que eu não tinha uma barra invertida n lá.

00:44:54.460 --> 00:44:57.400
Isso porque, por qualquer senso de estilo que eu tenha,

00:44:57.400 --> 00:45:00.460
Eu queria que o nome fosse digitado logo após a pergunta.

00:45:00.460 --> 00:45:04.030
Eu poderia ter adicionado uma barra invertida n lá em vez de um espaço.

00:45:04.030 --> 00:45:06.490
Isso teria me permitido digitar aqui.

00:45:06.490 --> 00:45:07.490
Totalmente bem.

00:45:07.490 --> 00:45:09.670
Só queria te mostrar algo diferente.

00:45:09.670 --> 00:45:10.210
Boa pegada.

00:45:10.210 --> 00:45:10.660
Sim?

00:45:10.660 --> 00:45:12.070
AUDIÊNCIA: Você pode mostrar um exemplo com dois %s?

00:45:12.070 --> 00:45:14.470
DAVID J. MALAN: Posso mostrar um exemplo com dois %s?

00:45:14.470 --> 00:45:15.250
Certamente.

00:45:15.250 --> 00:45:17.570
Então deixe-me no VS Code fazer isso.

00:45:17.570 --> 00:45:20.050
Deixe-me limpar a janela do meu terminal para limpar as coisas.

00:45:20.050 --> 00:45:21.170
E deixe-me fazer isso.

00:45:21.170 --> 00:45:23.620
Em vez de chamar a resposta variável em todo o lugar,

00:45:23.620 --> 00:45:26.080
deixe-me chamá-lo primeiro.

00:45:26.080 --> 00:45:27.490
E eu vou fazer duas perguntas.

00:45:27.490 --> 00:45:28.880
Qual é o seu primeiro nome?

00:45:28.880 --> 00:45:32.620
E agora deixe-me fazer string last equals get_string--

00:45:32.620 --> 00:45:35.560
ops, a capitalização é importante, então deixe-me corrigir meu S maiúsculo

00:45:35.560 --> 00:45:41.720
aí-- aspas/sem aspas, qual é o seu sobrenome, ponto de interrogação, ponto e vírgula.

00:45:41.720 --> 00:45:47.320
E agora vamos conectar um %s e um segundo %s.

00:45:47.320 --> 00:45:52.720
E agora vou conectar primeiro primeiro e último último, coincidentemente.

00:45:52.720 --> 00:45:55.240
E agora vou voltar para a janela do terminal.

00:45:55.240 --> 00:46:00.280
Faça olá-- cruzando os dedos, tudo bem-- ./olá.

00:46:00.280 --> 00:46:02.620
Aqui está a minha primeira pergunta, David.

00:46:02.620 --> 00:46:04.240
Aqui está a minha segunda pergunta, Malan.

00:46:04.240 --> 00:46:05.650
E de novo?

00:46:05.650 --> 00:46:06.670
Olá, David Malan.

00:46:06.670 --> 00:46:08.440
Então, ele apenas os insere da esquerda para a direita.

00:46:08.440 --> 00:46:10.510
Tudo o que eu estava fazendo para obter paridade com o Scratch...

00:46:10.510 --> 00:46:12.670
e deixe-me ir em frente e desfazer isso novamente.

00:46:12.670 --> 00:46:15.130
Eu vou voltar a responder, assim.

00:46:15.130 --> 00:46:17.800
Voltarei a apenas perguntar o nome da pessoa.

00:46:17.800 --> 00:46:19.300
Vou deletar a menção do último.

00:46:19.300 --> 00:46:21.520
Vou deletar a menção do segundo %s.

00:46:21.520 --> 00:46:24.400
E agora, se eu recompilar esta versão mais simples,

00:46:24.400 --> 00:46:27.720
oh, eu estraguei tudo - não foi minha intenção.

00:46:27.720 --> 00:46:29.220
O que eu fiz errado?

00:46:29.220 --> 00:46:31.353
AUDIÊNCIA: Você esqueceu de mudar primeiro na linha 7.

00:46:31.353 --> 00:46:33.270
DAVID J. MALAN: Sim, apenas erros de novato.

00:46:33.270 --> 00:46:37.800
Então mudei minha variável de volta para responder apenas para ser consistente com a semana 0,

00:46:37.800 --> 00:46:39.610
mas não troquei aqui.

00:46:39.610 --> 00:46:42.750
Portanto, primeiro uso um identificador não declarado.

00:46:42.750 --> 00:46:46.470
Não é declarado no sentido de que declarei resposta uma linha antes.

00:46:46.470 --> 00:46:47.950
Eu não declarei primeiro.

00:46:47.950 --> 00:46:51.060
Então, de fato, intuitivamente, quero apenas mudar isso para aquilo.

00:46:51.060 --> 00:46:56.740
Deixe-me agora fazer olá novamente, ./olá, digite apenas meu primeiro nome desta vez.

00:46:56.740 --> 00:46:59.400
E aí está-- olá, David.

00:46:59.400 --> 00:47:02.220
Perguntas sobre esta sintaxe com printf?

00:47:02.220 --> 00:47:03.390
Sim?

00:47:03.390 --> 00:47:04.608
AUDIÊNCIA: [INAUDÍVEL]

00:47:04.608 --> 00:47:06.150
DAVID J. MALAN: Ah, o espaço reservado--

00:47:06.150 --> 00:47:09.240
Vou ampliar-- é apenas um único por cento, em seguida, um s.

00:47:09.240 --> 00:47:17.370
Então dentro da minha string aqui está %s, e então eu tenho uma vírgula fora das aspas,

00:47:17.370 --> 00:47:23.400
e, em seguida, o nome da variável cujo valor desejo inserir para esse %s.

00:47:23.400 --> 00:47:28.080
E agora observe que há tecnicamente duas vírgulas dentro

00:47:28.080 --> 00:47:30.300
desses parênteses na linha 7.

00:47:30.300 --> 00:47:33.690
E, no entanto, afirmo que printf, no momento,

00:47:33.690 --> 00:47:37.290
está aceitando apenas dois argumentos.

00:47:37.290 --> 00:47:41.582
Por que há então duas vírgulas, mas apenas dois argumentos?

00:47:41.582 --> 00:47:43.290
Se houvesse duas vírgulas, você pensaria

00:47:43.290 --> 00:47:45.700
haveria três argumentos, certo?

00:47:45.700 --> 00:47:47.904
AUDIÊNCIA: A vírgula está entre aspas,

00:47:47.904 --> 00:47:49.700
então conta como vírgula [INAUDÍVEL]

00:47:49.700 --> 00:47:50.700
DAVID J. MALAN: Exatamente.

00:47:50.700 --> 00:47:53.160
A vírgula entre as aspas é apenas uma coisa em inglês.

00:47:53.160 --> 00:47:55.240
É separar o olá do nome.

00:47:55.240 --> 00:47:57.690
Então é por isso que não está apenas entre aspas,

00:47:57.690 --> 00:48:01.710
é também por isso que programas como o VS Code tendem a destacar a sintaxe

00:48:01.710 --> 00:48:05.580
um pouco diferente apenas para que pareça diferente para você,

00:48:05.580 --> 00:48:08.790
embora, neste caso, seja um pouco sutil-- um azul claro versus branco--

00:48:08.790 --> 00:48:10.830
mas, de fato, está tentando o seu melhor.

00:48:10.830 --> 00:48:13.150
Outras perguntas agora sobre este espaço reservado?

00:48:13.150 --> 00:48:13.650
Sim?

00:48:13.650 --> 00:48:16.390
AUDIÊNCIA: Se você quiser colocar um ponto de exclamação no final,

00:48:16.390 --> 00:48:18.460
você colocaria uma vírgula após sua variável de resposta,

00:48:18.460 --> 00:48:21.943
e isso colocaria [INAUDÍVEL] ou você teria que adicionar uma nova linha?

00:48:21.943 --> 00:48:23.360
DAVID J. MALAN: Ah, boa pergunta.

00:48:23.360 --> 00:48:25.750
Se eu quiser adicionar um ponto de exclamação após o nome,

00:48:25.750 --> 00:48:28.230
eu teria que adicionar outro espaço reservado e assim por diante?

00:48:28.230 --> 00:48:29.980
Na verdade, eu poderia fazer isso de maneira muito mais simples.

00:48:29.980 --> 00:48:33.610
Posso apenas colocar o ponto de exclamação logo após o sinal de porcentagem.

00:48:33.610 --> 00:48:35.830
Não preciso de um espaço reservado adicional, por si só.

00:48:35.830 --> 00:48:40.030
Se eu diminuir o zoom agora e executar make hello novamente, ./hello,

00:48:40.030 --> 00:48:42.280
e digite apenas meu nome-- sem ponto de exclamação--

00:48:42.280 --> 00:48:45.580
agora você vai ver com mais entusiasmo, alô, vírgula, David.

00:48:45.580 --> 00:48:46.510
Então printf é inteligente.

00:48:46.510 --> 00:48:51.400
Ele descobrirá onde está o %s e o substituirá.

00:48:51.400 --> 00:48:54.662
Agora, deixe-me propor que uma coisa comum na programação

00:48:54.662 --> 00:48:57.370
é que assim que tomamos uma decisão sobre como projetar algo,

00:48:57.370 --> 00:49:01.240
muitas vezes nos encurralamos e nos arrependemos de uma decisão.

00:49:01.240 --> 00:49:08.410
Alguém pode pensar em um problema que surge ao usar %s como um espaço reservado

00:49:08.410 --> 00:49:11.680
nesta string para printf?

00:49:11.680 --> 00:49:14.635
O que poderia dar errado se estivéssemos usando porcentagem dessa maneira especial?

00:49:14.635 --> 00:49:16.775
AUDIÊNCIA: [INAUDÍVEL]

00:49:16.775 --> 00:49:17.650
DAVID J. MALAN: Sim.

00:49:17.650 --> 00:49:20.320
Se você literalmente quiser dizer, por qualquer motivo estranho,

00:49:20.320 --> 00:49:23.245
%s na tela-- ou honestamente, apenas um único %.

00:49:23.245 --> 00:49:25.930
Acontece que um sinal de porcentagem é tratado

00:49:25.930 --> 00:49:29.650
especialmente dentro de strings printf.

00:49:29.650 --> 00:49:31.460
Então, qual é a solução aqui?

00:49:31.460 --> 00:49:34.690
Existem diferentes padrões de soluções para problemas como esses.

00:49:34.690 --> 00:49:40.990
Mas suponha que você queira dizer, eu tenho 100%, por exemplo.

00:49:40.990 --> 00:49:43.480
Deixe-me ir em frente e mudar isso completamente.

00:49:43.480 --> 00:49:47.290
Então eu tirei 100% no seu teste ou algo assim.

00:49:47.290 --> 00:49:50.860
Tudo bem, deixe-me ir em frente e fazer olá, Enter.

00:49:50.860 --> 00:49:52.950
Certo, especificador de conversões inválido.

00:49:52.950 --> 00:49:55.450
Quero dizer, não tenho ideia do que isso significa, mas está sublinhado

00:49:55.450 --> 00:49:57.410
o sinal de porcentagem como problemático.

00:49:57.410 --> 00:50:00.730
Bem, acontece que os humanos anos atrás decidiram, ugh, tudo bem, droga.

00:50:00.730 --> 00:50:01.615
Já usamos %.

00:50:01.615 --> 00:50:04.990
Bem, sinais de dois por cento significarão um por cento, literalmente.

00:50:04.990 --> 00:50:09.727
Então, agora, se eu executar novamente make hello, aha, ./hello, obtive 100%.

00:50:09.727 --> 00:50:13.060
Haverá coisas assim, honestamente, que você terá que perguntar a alguém,

00:50:13.060 --> 00:50:15.190
você tem que procurar no Google, você tem que procurar na documentação.

00:50:15.190 --> 00:50:17.840
Mas há sempre uma solução para esses tipos de problemas.

00:50:17.840 --> 00:50:19.930
E, felizmente, eles não aparecem com tanta frequência.

00:50:19.930 --> 00:50:21.230
Sim?

00:50:21.230 --> 00:50:22.360
Ah, só apontando.

00:50:22.360 --> 00:50:23.060
Outras perguntas?

00:50:23.060 --> 00:50:23.560
Sim?

00:50:23.560 --> 00:50:27.622
AUDIÊNCIA: Então, se você tiver vários [INAUDÍVEL]

00:50:27.622 --> 00:50:29.580
DAVID J. MALAN: Se você tiver múltiplas variáveis,

00:50:29.580 --> 00:50:31.380
está na ordem esquerda-direita.

00:50:31.380 --> 00:50:34.187
Então printf irá analisar a primeira string de texto

00:50:34.187 --> 00:50:35.520
que você passa entre aspas.

00:50:35.520 --> 00:50:40.290
E qualquer que seja o primeiro %, a primeira variável passada após uma vírgula

00:50:40.290 --> 00:50:41.207
fica ligado lá.

00:50:41.207 --> 00:50:44.290
E então o segundo é conectado ao segundo, terceiro e ao terceiro,

00:50:44.290 --> 00:50:44.832
e assim por diante.

00:50:44.832 --> 00:50:47.130
Portanto, é baseado apenas da esquerda para a direita.

00:50:47.130 --> 00:50:48.220
Sim?

00:50:48.220 --> 00:50:50.760
AUDIÊNCIA: Esta é mais uma pergunta de esclarecimento.

00:50:50.760 --> 00:50:52.453
O que exatamente significa %s?

00:50:52.453 --> 00:50:54.120
DAVID J. MALAN: É apenas um espaço reservado.

00:50:54.120 --> 00:50:58.570
É chamado de código de formato e significa apenas coloquialmente, insira algum valor

00:50:58.570 --> 00:50:59.070
aqui.

00:50:59.070 --> 00:51:04.060
E printf-- os humanos que escreveram printf décadas atrás decidiram tratar %s

00:51:04.060 --> 00:51:04.560
especial.

00:51:04.560 --> 00:51:04.890
Por que?

00:51:04.890 --> 00:51:05.490
Só porque.

00:51:05.490 --> 00:51:06.900
Eles precisavam de algum espaço reservado.

00:51:06.900 --> 00:51:10.110
Eles decidiram que, eh, ninguém nunca vai realmente querer digitar %s.

00:51:10.110 --> 00:51:12.420
E se o fizerem, eles podem apenas fazer %%s.

00:51:12.420 --> 00:51:17.280
Então eles decidiram implementar o printf de forma que tivessem um código que

00:51:17.280 --> 00:51:20.190
analisa qualquer texto que entra, procura por %s,

00:51:20.190 --> 00:51:24.960
e, de alguma forma, conecta os valores subsequentes a esse espaço reservado.

00:51:24.960 --> 00:51:28.390
E apenas a-- ah, pergunta?

00:51:28.390 --> 00:51:28.890
Desculpe?

00:51:28.890 --> 00:51:30.870
AUDIÊNCIA: E se quiséssemos fazer nossas iniciais ou algo assim?

00:51:30.870 --> 00:51:33.720
DAVID J. MALAN: Ah, e se você quisesse fazer um único personagem,

00:51:33.720 --> 00:51:38.070
como iniciais, como DM ou DJM para primeiro, meio, último, absolutamente.

00:51:38.070 --> 00:51:41.670
E isso também é uma passagem perfeita de vocês dois para o que, em geral,

00:51:41.670 --> 00:51:44.310
serão chamados de tipos de dados em C.

00:51:44.310 --> 00:51:48.135
Acontece que em C não há apenas strings como texto.

00:51:48.135 --> 00:51:50.760
E veremos com mais detalhes nas próximas semanas o que

00:51:50.760 --> 00:51:52.560
uma corda realmente está debaixo do capô.

00:51:52.560 --> 00:51:55.620
Mas strings de texto não são a única coisa que os programas podem produzir.

00:51:55.620 --> 00:51:58.860
Eles podem, de fato, produzir caracteres únicos, como iniciais.

00:51:58.860 --> 00:52:01.020
Eles também podem produzir números inteiros.

00:52:01.020 --> 00:52:03.510
Acontece que printf tem códigos de formato diferentes

00:52:03.510 --> 00:52:05.868
para todos os tipos de dados diferentes.

00:52:05.868 --> 00:52:08.410
E apenas alguns dos tipos de dados que veremos nas próximas semanas

00:52:08.410 --> 00:52:10.530
será esta lista aqui, que você notará

00:52:10.530 --> 00:52:13.920
se alinha quase perfeitamente com as funções do CS50

00:52:13.920 --> 00:52:17.722
que falei antes, como get_char, get_int, get_string.

00:52:17.722 --> 00:52:20.430
A razão pela qual chamamos essas funções é porque cada uma delas

00:52:20.430 --> 00:52:23.490
é projetado para retornar a você um tipo diferente de valor.

00:52:23.490 --> 00:52:26.070
Já usamos get_string neste exemplo aqui.

00:52:26.070 --> 00:52:29.880
Em breve veremos get_int e veremos oportunidades de usar outros.

00:52:29.880 --> 00:52:33.660
Mas estes são de fato o menu de dados disponíveis

00:52:33.660 --> 00:52:35.940
tipos mais outros-- ponto, ponto, ponto-- que você

00:52:35.940 --> 00:52:38.400
pode usar ao escrever um programa em C.

00:52:38.400 --> 00:52:41.430
A responsabilidade, portanto, cabe a você decidir antecipadamente,

00:52:41.430 --> 00:52:44.250
eu quero armazenar um int nesta variável, ou uma string,

00:52:44.250 --> 00:52:48.420
ou, diabos, ao escrever um código mais sofisticado, uma imagem, um som ou até mesmo um vídeo.

00:52:48.420 --> 00:52:51.030
Todos podem ser tipos de dados diferentes, ponto ponto ponto.

00:52:51.030 --> 00:52:54.300
Mas, por enquanto, vamos nos concentrar apenas nesses primitivos.

00:52:54.300 --> 00:52:54.988
Isso foi muito.

00:52:54.988 --> 00:52:57.030
Vamos em frente e fazer uma pausa de cinco minutos aqui.

00:52:57.030 --> 00:52:57.680
Ainda não há cookies.

00:52:57.680 --> 00:53:00.180
Mas em cinco minutos, voltaremos, mergulharemos em mais detalhes.

00:53:00.180 --> 00:53:02.097
No segundo intervalo de hoje, teremos biscoitos.

00:53:05.640 --> 00:53:07.295
Tudo bem, estamos de volta.

00:53:07.295 --> 00:53:09.170
E então, se você tem tocado em casa

00:53:09.170 --> 00:53:11.587
mas bater em alguns solavancos na estrada, isso é totalmente normal.

00:53:11.587 --> 00:53:13.430
E, de fato, os objetivos da palestra geralmente

00:53:13.430 --> 00:53:16.395
será dar a você uma noção, conceitualmente, de onde iremos

00:53:16.395 --> 00:53:18.020
vai durante a semana.

00:53:18.020 --> 00:53:20.498
Mas, de fato, é por meio de laboratórios práticos e conjuntos de problemas

00:53:20.498 --> 00:53:22.790
que você realmente terá uma oportunidade no seu próprio ritmo

00:53:22.790 --> 00:53:25.730
para trabalhar com alguns desses mesmos solavancos na estrada.

00:53:25.730 --> 00:53:28.880
Mas por hoje, deixe-me dar-lhe mais alguns blocos de construção.

00:53:28.880 --> 00:53:31.460
E esses dois vão traduzir do Scratch inicialmente.

00:53:31.460 --> 00:53:33.860
Ou seja, como condicionais, como agora em C,

00:53:33.860 --> 00:53:36.690
depois de saber agora como podemos usar funções--

00:53:36.690 --> 00:53:39.530
pelo menos get_string e printf--

00:53:39.530 --> 00:53:43.370
e podemos usar variáveis ​​como a string que criei anteriormente,

00:53:43.370 --> 00:53:46.490
como posso agora adicionar à mistura coisas como tomada de decisão e condicionais

00:53:46.490 --> 00:53:47.100
em que?

00:53:47.100 --> 00:53:50.780
Bem, com condicionais no Scratch, tínhamos esse tipo de sintaxe à esquerda.

00:53:50.780 --> 00:53:55.220
Aqui no Scratch é como você pode expressar se duas variáveis, x e y,

00:53:55.220 --> 00:53:56.360
ter esta relação.

00:53:56.360 --> 00:54:01.020
Se x for menor que y, diga na tela, x é menor que y.

00:54:01.020 --> 00:54:03.320
Bem, deixe-me traduzir isso para a direita agora no código C.

00:54:03.320 --> 00:54:06.500
Em C, o código correspondente ficará assim,

00:54:06.500 --> 00:54:08.390
assumindo que x e y já existem -

00:54:08.390 --> 00:54:09.530
mais sobre isso mais tarde.

00:54:09.530 --> 00:54:13.140
E observe um padrão que veremos repetidamente.

00:54:13.140 --> 00:54:18.560
Haverá parênteses em torno de x e menor que y-- então parênteses

00:54:18.560 --> 00:54:20.390
em torno da expressão booleana, lembre-se.

00:54:20.390 --> 00:54:23.768
A expressão booleana é a resposta verdadeiro/falso, sim/não,

00:54:23.768 --> 00:54:26.060
uma pergunta que você está tentando fazer para decidir

00:54:26.060 --> 00:54:27.680
se deve ou não fazer algo.

00:54:27.680 --> 00:54:29.310
Então você usa parênteses lá.

00:54:29.310 --> 00:54:34.550
Tão semelhante em funções onde usamos parênteses para printf e parênteses

00:54:34.550 --> 00:54:38.660
para get_string, e esta é apenas uma estranha inconsistência estilisticamente.

00:54:38.660 --> 00:54:42.860
Ao usar a palavra-chave se, você deve, como prática recomendada,

00:54:42.860 --> 00:54:44.690
coloque um espaço após a palavra se.

00:54:44.690 --> 00:54:49.070
Ao usar uma função como printf ou get_string, você não deveria.

00:54:49.070 --> 00:54:52.400
Ambos funcionarão, mas você descobrirá que essas são convenções estilisticamente

00:54:52.400 --> 00:54:55.970
que a maioria das pessoas adere-- espaço ao usar um if aqui.

00:54:55.970 --> 00:54:58.850
Tudo bem, agora dentro das chaves

00:54:58.850 --> 00:55:02.360
é onde vai o código real que você deseja executar condicionalmente.

00:55:02.360 --> 00:55:05.270
Então, se você quiser imprimir x é menor que y

00:55:05.270 --> 00:55:08.570
somente se x for realmente menor que y em C, você

00:55:08.570 --> 00:55:10.670
use esta chave aberta - que, até agora,

00:55:10.670 --> 00:55:12.740
você provavelmente raramente usou em seu teclado--

00:55:12.740 --> 00:55:14.820
e a chave fechada aqui embaixo.

00:55:14.820 --> 00:55:17.960
E esses estão abraçando, se você quiser, uma ou mais linhas

00:55:17.960 --> 00:55:20.990
de código abaixo do if-- muito semelhante em espírito

00:55:20.990 --> 00:55:25.050
de como o bloco laranja aqui abraça a peça roxa do quebra-cabeça aqui.

00:55:25.050 --> 00:55:27.050
Portanto, não há gráficos em C. É tudo texto.

00:55:27.050 --> 00:55:31.760
Então você pode pensar nessas chaves como realmente representando a mesma ideia.

00:55:31.760 --> 00:55:37.460
Como observação, se você tiver apenas uma linha de código dentro do if

00:55:37.460 --> 00:55:41.430
condição, se você quiser, estritamente, falando, não precisa das chaves.

00:55:41.430 --> 00:55:43.670
Mas, por uma questão de bom estilo, inclua-os.

00:55:43.670 --> 00:55:46.040
Isso tornará mais óbvio qual é a sua intenção.

00:55:46.040 --> 00:55:48.650
Que tal no Scratch se você quiser expressar isso--

00:55:48.650 --> 00:55:52.700
dois caminhos na estrada que você pode seguir, esquerda ou direita, por assim dizer?

00:55:52.700 --> 00:55:56.480
Bem, se x é menor que y, quero dizer, x é menor que y.

00:55:56.480 --> 00:56:01.190
Caso contrário, quero dizer o contrário, x não é menor que y neste caso.

00:56:01.190 --> 00:56:03.710
Então, estou tomando uma decisão com base nessa expressão booleana.

00:56:03.710 --> 00:56:08.340
Em C, é quase o mesmo, mas você está adicionando à mistura a palavra-chave else--

00:56:08.340 --> 00:56:11.210
então o MIT emprestou para o Scratch a mesma palavra-chave aqui--

00:56:11.210 --> 00:56:14.690
e um segundo par de chaves, abrir e fechar, respectivamente.

00:56:14.690 --> 00:56:17.150
E você pode adivinhar agora o que vai dentro deles.

00:56:17.150 --> 00:56:22.905
Bem, você imprime x é menor que y, ou você imprime x não é menor que y.

00:56:22.905 --> 00:56:25.280
Tudo bem, e se houver uma bifurcação de três vias na estrada?

00:56:25.280 --> 00:56:29.370
No Scratch, isso realmente fica um pouco pesado graficamente, se você preferir.

00:56:29.370 --> 00:56:34.490
Mas observe que no Scratch, é assim que poderíamos expressar se x é menor que y,

00:56:34.490 --> 00:56:36.110
digamos que x é menor que y.

00:56:36.110 --> 00:56:40.760
Caso contrário, se x for maior que y, digamos que x seja maior que y.

00:56:40.760 --> 00:56:45.470
Caso contrário, se x for igual a y, digamos que x é igual a y.

00:56:45.470 --> 00:56:48.770
Agora, pequena inconsistência aqui.

00:56:48.770 --> 00:56:51.980
Há pouco, afirmei, em C, que um sinal de igual

00:56:51.980 --> 00:56:54.435
representa qual operação?

00:56:54.435 --> 00:56:55.310
AUDIÊNCIA: Atribuição.

00:56:55.310 --> 00:56:57.770
DAVID J. MALAN: Atribuição da direita para a esquerda.

00:56:57.770 --> 00:56:59.900
Na medida em que o Scratch é realmente destinado a crianças,

00:56:59.900 --> 00:57:03.350
e eles realmente não queriam entrar no mato desse tipo de semântica,

00:57:03.350 --> 00:57:06.360
sinal de igual no Scratch significa igualdade.

00:57:06.360 --> 00:57:09.050
No entanto, precisaremos corrigir isso em C em apenas um momento.

00:57:09.050 --> 00:57:11.750
Em C, sinal de igual significa atribuição da direita para a esquerda.

00:57:11.750 --> 00:57:14.210
No Scratch, significa literalmente o que você esperaria.

00:57:14.210 --> 00:57:17.690
Tudo bem, vamos traduzir este código para C. À direita,

00:57:17.690 --> 00:57:20.780
esse código corresponderia realmente a isso.

00:57:20.780 --> 00:57:24.110
E talvez você possa ver, um tanto bobo, qual foi a solução,

00:57:24.110 --> 00:57:28.160
não muito diferente da solução %% anterior, quando os humanos se pintaram em um

00:57:28.160 --> 00:57:29.100
outro canto.

00:57:29.100 --> 00:57:32.900
Você diz se, você diz senão se, e você diz senão se,

00:57:32.900 --> 00:57:36.620
e como já resolvemos o uso de um único sinal de igual?

00:57:36.620 --> 00:57:39.650
Em C, quando você quer expressar igualdade -

00:57:39.650 --> 00:57:42.110
é a coisa à esquerda igual à coisa à direita -

00:57:42.110 --> 00:57:45.590
você literalmente usa dois sinais de igual um ao lado do outro, sem espaço

00:57:45.590 --> 00:57:47.090
entre eles.

00:57:47.090 --> 00:57:50.960
Mas agora esse código estaria correto tanto à esquerda quanto à direita,

00:57:50.960 --> 00:57:53.640
se você está fazendo isso no Scratch ou C, respectivamente.

00:57:53.640 --> 00:57:58.400
Mas agora podemos escolher nosso código, especificamente o design dele.

00:57:58.400 --> 00:58:02.820
Logicamente, alguém pode criticar o design deste código,

00:58:02.820 --> 00:58:04.280
no Scratch ou C?

00:58:04.280 --> 00:58:06.200
Sinto que poderíamos fazer melhor.

00:58:06.200 --> 00:58:07.576
Que tal atrás?

00:58:07.576 --> 00:58:10.908
AUDIÊNCIA: A única opção após ficar maior ou menor

00:58:10.908 --> 00:58:12.930
do que [INAUDÍVEL].

00:58:12.930 --> 00:58:13.930
DAVID J. MALAN: Perfeito.

00:58:13.930 --> 00:58:17.350
Logicamente, tem que ser o caso que x é menor que y,

00:58:17.350 --> 00:58:22.510
ou x é maior que y, ou por conclusão, tem que ser igual a y.

00:58:22.510 --> 00:58:24.910
Então, por que você está perdendo meu tempo ou o tempo do computador

00:58:24.910 --> 00:58:26.170
fazendo uma terceira pergunta?

00:58:26.170 --> 00:58:30.160
Você não precisa perguntar isso senão porque logicamente, como você observou,

00:58:30.160 --> 00:58:31.510
não é necessário de dizer.

00:58:31.510 --> 00:58:33.220
Portanto, é um pequeno ajuste.

00:58:33.220 --> 00:58:37.120
Você está fazendo um trabalho extra potencialmente nos casos em que x é igual a y.

00:58:37.120 --> 00:58:38.350
Então, podemos apenas refinar isso.

00:58:38.350 --> 00:58:42.280
E assim como no Scratch, você pode usar apenas um bloco else, da mesma forma em C,

00:58:42.280 --> 00:58:47.110
poderíamos simplificar este código para apenas uma outra, uma espécie de catch-all logicamente

00:58:47.110 --> 00:58:49.720
que apenas lida com a realidade que, é claro, isso vai

00:58:49.720 --> 00:58:52.400
para ser a situação final em vez disso.

00:58:52.400 --> 00:58:55.570
Tudo bem, agora temos essa capacidade de expressar condicionais

00:58:55.570 --> 00:58:56.770
com expressões booleanas.

00:58:56.770 --> 00:58:59.030
Vamos realmente fazer algo com isso aqui.

00:58:59.030 --> 00:59:00.610
Então, deixe-me voltar ao VS Code.

00:59:00.610 --> 00:59:03.520
Fechei o hello.c e quero criar um segundo arquivo

00:59:03.520 --> 00:59:05.020
por causa de algumas demos agora.

00:59:05.020 --> 00:59:09.160
Lembre-se de que você pode criar novos arquivos digitando código, espaço e, em seguida,

00:59:09.160 --> 00:59:11.440
o nome do arquivo que você deseja criar.

00:59:11.440 --> 00:59:13.565
Por exemplo, eu poderia fazer compare.c.

00:59:13.565 --> 00:59:15.940
Eu quero escrever um programa que vai começar a comparar

00:59:15.940 --> 00:59:17.740
alguns valores para efeito de demonstração.

00:59:17.740 --> 00:59:20.050
Mas antes de fazer isso, deixe-me mostrar-lhe

00:59:20.050 --> 00:59:23.830
abrindo o File Explorer à direita, isso é semelhante em espírito

00:59:23.830 --> 00:59:25.180
para um Mac ou PC.

00:59:25.180 --> 00:59:28.750
Você pode subir aqui e clicar em um ícone, e você pode clicar no ícone de adição,

00:59:28.750 --> 00:59:30.010
e você receberá uma caixa azul.

00:59:30.010 --> 00:59:34.120
E posso digitar compare.c e criá-lo manualmente dessa forma.

00:59:34.120 --> 00:59:37.930
Repare que abre a aba mesmo sem eu ter digitado o código.

00:59:37.930 --> 00:59:41.470
Então, novamente, à esquerda, você tem uma GUI, uma Interface Gráfica do Usuário,

00:59:41.470 --> 00:59:42.820
ainda que simplista.

00:59:42.820 --> 00:59:45.970
À direita e na parte inferior aqui, você tem uma interface de linha de comando,

00:59:45.970 --> 00:59:47.260
mas eles são um no mesmo.

00:59:47.260 --> 00:59:52.090
O que é bom, porém, é que se eu fechar este arquivo acidentalmente, intencionalmente,

00:59:52.090 --> 00:59:54.790
sei lá, posso reabri-lo sem criar

00:59:54.790 --> 00:59:58.930
um novo apenas executando o mesmo comando-- code, space, compare.c.

00:59:58.930 --> 01:00:00.340
Portanto, o código é uma coisa do VS Code.

01:00:00.340 --> 01:00:02.140
É apenas um atalho amigável.

01:00:02.140 --> 01:00:05.888
Mas é apenas criar um arquivo ou abrir um arquivo existente assim.

01:00:05.888 --> 01:00:08.930
Vou ocultar o File Explorer apenas para dar mais espaço para o código aqui.

01:00:08.930 --> 01:00:10.222
E vamos em frente e fazer isso.

01:00:10.222 --> 01:00:14.200
Vamos escrever um programa que compara dois valores que o humano insere,

01:00:14.200 --> 01:00:15.340
mas não cordas desta vez.

01:00:15.340 --> 01:00:17.170
Vamos usar alguns inteiros reais.

01:00:17.170 --> 01:00:20.920
Tudo bem, vou prosseguir e incluir o cabeçalho da biblioteca CS50

01:00:20.920 --> 01:00:22.090
arquivo no topo--

01:00:22.090 --> 01:00:23.260
cs50.h.

01:00:23.260 --> 01:00:25.804
Vou incluir também stdio.h.

01:00:25.804 --> 01:00:26.668
Por que?

01:00:26.668 --> 01:00:31.190
Um me dá uma entrada amigável via get_string, get_int e assim por diante.

01:00:31.190 --> 01:00:35.560
Um me dá uma saída amigável via printf no caso de stdio.h.

01:00:35.560 --> 01:00:39.430
Agora vou digitar cegamente esta linha de código, à qual voltaremos

01:00:39.430 --> 01:00:40.310
nas próximas semanas.

01:00:40.310 --> 01:00:42.520
Mas, por enquanto, isso é análogo ao quando

01:00:42.520 --> 01:00:44.920
bandeira verde código clicado no Scratch.

01:00:44.920 --> 01:00:46.460
E agora vamos em frente e fazer isso.

01:00:46.460 --> 01:00:49.210
Deixe-me ir em frente e get_int do usuário

01:00:49.210 --> 01:00:51.713
e pergunte ao usuário, What's x, ponto de interrogação.

01:00:51.713 --> 01:00:53.380
Não vou me preocupar com uma nova linha.

01:00:53.380 --> 01:00:56.410
Eu quero manter tudo em uma linha, apenas por uma questão de estética.

01:00:56.410 --> 01:00:59.710
Mas quando eu voltar e int, assim como eu recebo uma string,

01:00:59.710 --> 01:01:01.580
Recebo um valor de retorno.

01:01:01.580 --> 01:01:06.040
Então, se eu quiser armazenar o resultado de get_int em algum lugar,

01:01:06.040 --> 01:01:07.927
É melhor colocar em uma variável.

01:01:07.927 --> 01:01:09.760
E posso chamar a variável do que quiser.

01:01:09.760 --> 01:01:12.790
Anteriormente, eu usava resposta, primeiro ou último.

01:01:12.790 --> 01:01:14.410
Agora vou usar x.

01:01:14.410 --> 01:01:18.310
Mas ainda há duas coisas a fazer aqui logicamente, embora nós

01:01:18.310 --> 01:01:19.870
ainda não fiz isso tecnicamente.

01:01:19.870 --> 01:01:21.130
O que ainda preciso fazer?

01:01:21.130 --> 01:01:22.410
AUDIÊNCIA: Um ponto e vírgula.

01:01:22.410 --> 01:01:24.535
DAVID J. MALAN: Então, preciso do ponto e vírgula no final.

01:01:24.535 --> 01:01:26.010
AUDIÊNCIA: E o int primeiro.

01:01:26.010 --> 01:01:27.885
DAVID J. MALAN: E o int no início.

01:01:27.885 --> 01:01:31.257
Você, o programador, a partir de hoje, precisa decidir o que está

01:01:31.257 --> 01:01:32.840
vai estar armazenando em suas variáveis.

01:01:32.840 --> 01:01:35.750
E você só precisa dizer isso ao computador para que ele saiba.

01:01:35.750 --> 01:01:38.990
Agora, como um teaser para linguagens como Python, linguagens mais modernas,

01:01:38.990 --> 01:01:41.240
Acontece que os humanos perceberam, bem, nossa, isso é estúpido.

01:01:41.240 --> 01:01:44.115
Por que o computador não consegue descobrir que estou colocando um int lá?

01:01:44.115 --> 01:01:45.800
Por que eu tenho que dizer isso proativamente?

01:01:45.800 --> 01:01:48.080
Então, em algumas linguagens hoje em dia, como Python

01:01:48.080 --> 01:01:50.990
vai se livrar de parte dessa sintaxe, vai se livrar dos pontos e vírgulas.

01:01:50.990 --> 01:01:54.530
Mas, por enquanto, estamos analisando, realmente, as origens de como tudo isso funcionou.

01:01:54.530 --> 01:01:57.380
Tudo bem, então eu fiz esta linha terminando com ponto e vírgula.

01:01:57.380 --> 01:01:58.440
Deixe-me fazer um outro.

01:01:58.440 --> 01:02:02.390
E deixe-me obter um segundo int perguntando ao usuário, o que é y, ponto de interrogação.

01:02:02.390 --> 01:02:06.680
Respostas quase idênticas, mas diferentes do usuário, espero.

01:02:06.680 --> 01:02:10.490
E deixe-me perguntar simplesmente se x é menor que y,

01:02:10.490 --> 01:02:14.690
entre parênteses, depois algumas chaves, deixe-me ir em frente e imprimir,

01:02:14.690 --> 01:02:18.950
aspas/sem aspas, x é menor que y barra invertida n.

01:02:18.950 --> 01:02:20.600
E agora apenas como uma nota lateral -

01:02:20.600 --> 01:02:23.240
Parece que estou digitando rápido.

01:02:23.240 --> 01:02:25.610
Parte disso é porque o VS Code está me ajudando.

01:02:25.610 --> 01:02:29.720
Deixe-me voltar a esta primeira linha com o if, pressione Enter.

01:02:29.720 --> 01:02:33.630
E agora estou apenas no teclado digitando a chave aberta.

01:02:33.630 --> 01:02:36.410
Esta é uma característica de muitos editores de texto hoje em dia.

01:02:36.410 --> 01:02:37.980
Termina parte do seu pensamento.

01:02:37.980 --> 01:02:38.480
Por que?

01:02:38.480 --> 01:02:40.580
Apenas para economizar um pressionamento de tecla para ter certeza

01:02:40.580 --> 01:02:42.660
você não esquece acidentalmente o fechamento.

01:02:42.660 --> 01:02:45.750
Assim, você notará às vezes que estão acontecendo coisas que você não digitou.

01:02:45.750 --> 01:02:49.550
É apenas VS Code ou programas futuros que você usa tentando ser útil para você.

01:02:49.550 --> 01:02:52.445
Vou prosseguir e digitar manualmente agora printf

01:02:52.445 --> 01:02:57.050
x é menor que y barra invertida n ponto e vírgula de aspas.

01:02:57.050 --> 01:03:01.400
Então deixe-me ir em frente agora e tentar rodar isso, e veremos...

01:03:01.400 --> 01:03:02.000
vamos ver.

01:03:02.000 --> 01:03:05.510
Então faça-- não olá-- mas compare porque este arquivo é

01:03:05.510 --> 01:03:09.050
chamado compare.c, pressionando Enter.

01:03:09.050 --> 01:03:12.320
Nenhuma saída é boa porque significa que não errei.

01:03:12.320 --> 01:03:16.580
Deixe-me ./compare em vez de ./hello, Enter.

01:03:16.580 --> 01:03:17.390
O que é x?

01:03:17.390 --> 01:03:18.410
Que tal 1?

01:03:18.410 --> 01:03:19.040
O que é y?

01:03:19.040 --> 01:03:19.840
Que tal 2?

01:03:19.840 --> 01:03:22.230
X é menor que y.

01:03:22.230 --> 01:03:23.387
Bem, vamos tentar de novo.

01:03:23.387 --> 01:03:25.220
E aqui, vou poupar algumas teclas também.

01:03:25.220 --> 01:03:26.360
Deixe-me limpar minha tela.

01:03:26.360 --> 01:03:30.350
Em vez de digitar constantemente ./this e ./that,

01:03:30.350 --> 01:03:34.610
você também pode usar as setas do teclado no VS Code para rolar para trás

01:03:34.610 --> 01:03:35.310
tempo.

01:03:35.310 --> 01:03:37.940
Portanto, se eu clicar em Up uma vez, haverá o último comando que escrevi.

01:03:37.940 --> 01:03:41.480
Se eu subir duas vezes, há o penúltimo comando que escrevi.

01:03:41.480 --> 01:03:43.460
Então, às vezes, se você me vê fazendo as coisas rápido,

01:03:43.460 --> 01:03:46.550
é só porque estou trapaceando e passando pela minha história assim.

01:03:46.550 --> 01:03:51.380
Tudo bem, deixe-me prosseguir e executar novamente ./compare, Enter.

01:03:51.380 --> 01:03:52.670
Vamos inverter desta vez -

01:03:52.670 --> 01:03:55.100
2 para x, 1 para y.

01:03:55.100 --> 01:03:56.870
E agora, claro, não há saída.

01:03:56.870 --> 01:03:58.670
Tudo bem, bem, isso é logicamente esperado

01:03:58.670 --> 01:04:00.170
porque não tínhamos outro aqui.

01:04:00.170 --> 01:04:00.980
Então vamos adicionar isso.

01:04:00.980 --> 01:04:05.060
Senão-- agora vamos abrir minhas chaves, deixando o VS Code fazer um deles

01:04:05.060 --> 01:04:12.350
para mim -- printf, aspas/sem aspas, x não é menor que y barra invertida n ponto e vírgula.

01:04:12.350 --> 01:04:16.430
Deixe-me ir em frente e tentar novamente-- ./compare, Enter.

01:04:16.430 --> 01:04:19.100
Novamente, 2 para x, 1 para y.

01:04:19.100 --> 01:04:20.540
E devemos ver--

01:04:20.540 --> 01:04:22.990
huh.

01:04:22.990 --> 01:04:24.830
O que eu fiz errado?

01:04:24.830 --> 01:04:27.050
Por que não estou vendo nenhuma outra saída?

01:04:27.050 --> 01:04:27.550
Sim?

01:04:27.550 --> 01:04:29.592
AUDIÊNCIA: Você mudou seu código ao reconstruir.

01:04:29.592 --> 01:04:30.690
Você precisa compilá-lo.

01:04:30.690 --> 01:04:31.290
DAVID J. MALAN: Exatamente.

01:04:31.290 --> 01:04:34.415
Você deve adquirir o hábito depois de alterar seu código de recompilá-lo.

01:04:34.415 --> 01:04:36.420
Ou então, os zeros e uns no servidor

01:04:36.420 --> 01:04:39.000
são os antigos até você compilar manualmente.

01:04:39.000 --> 01:04:41.040
Então, vamos corrigir isso-- compare, Enter.

01:04:41.040 --> 01:04:42.030
Nenhuma mensagem de erro.

01:04:42.030 --> 01:04:45.420
Isso é bom. ./compare, 2, 1.

01:04:45.420 --> 01:04:47.320
E agora recebo de volta a saída.

01:04:47.320 --> 01:04:49.230
Então x não é menor que y.

01:04:49.230 --> 01:04:52.390
Que tal se eu for e adicionar na terceira condição?

01:04:52.390 --> 01:04:55.650
Bem, podemos fazer isso de forma eficiente ou ineficiente.

01:04:55.650 --> 01:04:57.270
Deixe-me ir em frente e refinar isso.

01:04:57.270 --> 01:05:03.780
Então, se x for maior que y, digamos literalmente, x é maior que y.

01:05:03.780 --> 01:05:07.950
E agora eu poderia fazer x senão se x é igual a y.

01:05:07.950 --> 01:05:11.080
Mas acho que já afirmamos que isso é desnecessariamente ineficiente.

01:05:11.080 --> 01:05:12.810
Então, vamos pegar nosso catchall.

01:05:12.810 --> 01:05:14.730
E aqui vou dizer, aspas/sem aspas,

01:05:14.730 --> 01:05:19.960
x é igual a y barra invertida n, feche aspas lá.

01:05:19.960 --> 01:05:24.070
Acho que agora, com esse código, lidamos com todos os três cenários.

01:05:24.070 --> 01:05:28.680
Deixe-me prosseguir e recompilá-lo adequadamente - make compare, ./compare.

01:05:28.680 --> 01:05:31.350
E agora 1 e 2--

01:05:31.350 --> 01:05:32.340
é menor que y.

01:05:32.340 --> 01:05:33.510
Deixe-me executá-lo novamente.

01:05:33.510 --> 01:05:36.690
2 e 1-- x é maior que y.

01:05:36.690 --> 01:05:41.100
E por último, 1 e 1, e x é igual a y.

01:05:41.100 --> 01:05:43.270
Portanto, na maior parte, nosso código está ficando mais longo.

01:05:43.270 --> 01:05:45.870
Temos até 21 linhas de código, embora algumas delas

01:05:45.870 --> 01:05:47.700
são apenas caracteres únicos na tela.

01:05:47.700 --> 01:05:49.410
Quase todo o resto é o mesmo.

01:05:49.410 --> 01:05:56.190
Estou usando o arquivo de cabeçalho da biblioteca CS50 para minha função get_int, stdio.h

01:05:56.190 --> 01:05:58.590
para minha função printf, e o resto disso

01:05:58.590 --> 01:06:01.810
é agora uma nova sintaxe para condicionais também.

01:06:01.810 --> 01:06:04.350
Perguntas, então, sobre esta implementação C

01:06:04.350 --> 01:06:08.237
de apenas algumas comparações básicas como esta?

01:06:08.237 --> 01:06:08.820
Alguma pergunta?

01:06:08.820 --> 01:06:09.320
Sim?

01:06:09.320 --> 01:06:12.360
AUDIÊNCIA: Apenas uma questão de sintaxe-- faça a abertura

01:06:12.360 --> 01:06:14.530
colchetes precisam estar em uma linha separada?

01:06:14.530 --> 01:06:15.190
DAVID J. MALAN: Boa pergunta.

01:06:15.190 --> 01:06:17.440
Os colchetes de abertura precisam estar em uma linha separada?

01:06:17.440 --> 01:06:18.610
No CS50, sim.

01:06:18.610 --> 01:06:21.310
O que você verá é que, como parte do processo de envio,

01:06:21.310 --> 01:06:25.540
comparamos seu código com um guia de estilo, que é a norma na indústria.

01:06:25.540 --> 01:06:29.290
Uma empresa teria seu próprio senso de estilo e como seu código deveria ser.

01:06:29.290 --> 01:06:31.540
E geralmente existem ferramentas automatizadas dentro de uma empresa

01:06:31.540 --> 01:06:35.080
que ajudam a fornecer feedback sobre o código ou estilizá-lo como tal.

01:06:35.080 --> 01:06:38.410
Existem estilos alternativos aos que usamos na aula.

01:06:38.410 --> 01:06:41.500
Mantemos deliberadamente e pedimos que você mantenha

01:06:41.500 --> 01:06:44.110
as chaves em sua própria linha, se apenas

01:06:44.110 --> 01:06:48.430
porque se assemelha à natureza envolvente dos blocos do Scratch

01:06:48.430 --> 01:06:51.370
e apenas deixa claro que eles estão equilibrados, abertos e fechados.

01:06:51.370 --> 01:06:56.020
Porém, outro paradigma comum em algumas linguagens e com alguns programadores

01:06:56.020 --> 01:06:59.420
é fazer algo assim em cada um deles.

01:06:59.420 --> 01:07:03.670
Então você tem a chave de abertura na mesma linha aqui.

01:07:03.670 --> 01:07:05.030
Nós não recomendamos isso.

01:07:05.030 --> 01:07:07.900
Isso está em voga no mundo do JavaScript e em alguns outros.

01:07:07.900 --> 01:07:11.110
Mas, no final das contas, no mundo real, cabe a cada programador individual

01:07:11.110 --> 01:07:13.720
e/ou a empresa em que trabalha, se for o caso,

01:07:13.720 --> 01:07:16.210
para decidir sobre essas coisas.

01:07:16.210 --> 01:07:18.640
Tudo bem, então além dessas condicionais,

01:07:18.640 --> 01:07:21.140
e se quisermos fazer algo que talvez seja bastante comum?

01:07:21.140 --> 01:07:24.280
Quase todos os softwares ou sites que você usa hoje em dia

01:07:24.280 --> 01:07:28.360
você concorda com alguns termos e condições digitando Sim ou Não ou apenas

01:07:28.360 --> 01:07:30.280
S para Sim e N para Não.

01:07:30.280 --> 01:07:33.195
Então, como poderíamos implementar algum tipo de sistema de acordo?

01:07:33.195 --> 01:07:34.070
Bem, deixe-me fazer isso.

01:07:34.070 --> 01:07:37.810
Deixe-me criar um novo programa, um terceiro chamado Concorde.c.

01:07:37.810 --> 01:07:41.230
Então, vou escrever o código agree.c apenas para me dar uma nova guia.

01:07:41.230 --> 01:07:44.230
Vou começar, como sempre agora, incluir cs50.h.

01:07:44.230 --> 01:07:46.480
Vamos incluir stdio.h.

01:07:46.480 --> 01:07:50.770
E então deixe-me fazer meu int main(void)-- que, novamente, para os propósitos de hoje,

01:07:50.770 --> 01:07:53.200
que consideraremos pelo valor de face é apenas copiar/colar.

01:07:53.200 --> 01:07:57.850
E se eu quiser apenas obter S ou N, por exemplo, em vez de Sim ou Não,

01:07:57.850 --> 01:08:00.520
podemos apenas usar uma variável mais simples aqui.

01:08:00.520 --> 01:08:03.800
Que tal apenas um char, um personagem, um único personagem?

01:08:03.800 --> 01:08:07.120
Então eu posso usar get_char para perguntar ao usuário, por exemplo,

01:08:07.120 --> 01:08:09.760
você concorda, ponto de interrogação.

01:08:09.760 --> 01:08:12.880
Mas, como antes, preciso guardar isso em algum lugar.

01:08:12.880 --> 01:08:15.130
Portanto, não quero uma string porque é um único caractere.

01:08:15.130 --> 01:08:16.180
Eu não quero um int.

01:08:16.180 --> 01:08:17.380
Eu só quero um char.

01:08:17.380 --> 01:08:21.500
E é literalmente CHAR. E então eu posso chamar essa coisa do que eu quiser.

01:08:21.500 --> 01:08:25.370
É convencional se você tiver um programa simples com apenas uma única variável

01:08:25.370 --> 01:08:27.040
e é do tipo char, chame-o de c.

01:08:27.040 --> 01:08:28.569
Se for um int, chame-o de i.

01:08:28.569 --> 01:08:29.830
Se for uma string, chame-a de s.

01:08:29.830 --> 01:08:32.590
Por enquanto, vou mantê-lo simples e chamá-lo de c.

01:08:32.590 --> 01:08:34.370
E agora vou fazer uma pergunta.

01:08:34.370 --> 01:08:43.240
Então, se c é igual a, que tal, aspas/sem aspas, y, então

01:08:43.240 --> 01:08:47.290
deixe-me ir em frente e imprimir a barra invertida acordada n,

01:08:47.290 --> 01:08:50.380
como se concordassem com meus termos e condições.

01:08:50.380 --> 01:08:51.880
Caso contrário, vejamos.

01:08:51.880 --> 01:08:57.729
Caso contrário, se o caractere for igual a, aspas/sem aspas, n, deixe-me prosseguir

01:08:57.729 --> 01:09:03.609
e imprima, digamos, Não concordado, como se não o fizessem, citando/retirando aspas.

01:09:03.609 --> 01:09:07.060
E vamos deixar por isso mesmo, eu acho, aqui inicialmente.

01:09:07.060 --> 01:09:11.830
Agora, você notará uma curiosidade, talvez uma inconsistência.

01:09:11.830 --> 01:09:15.760
Alguém quer falar sobre isso, embora seja um tanto sutil?

01:09:15.760 --> 01:09:19.720
Eu fiz algo ligeiramente diferente sem explicá-lo ainda.

01:09:19.720 --> 01:09:20.380
Você vê?

01:09:20.380 --> 01:09:22.625
AUDIÊNCIA: As aspas simples.

01:09:22.625 --> 01:09:23.500
DAVID J. MALAN: Sim.

01:09:23.500 --> 01:09:27.880
Então, de repente, usei aspas simples para meus caracteres únicos

01:09:27.880 --> 01:09:30.590
e aspas duplas para minhas strings de texto reais.

01:09:30.590 --> 01:09:34.210
Isso é uma necessidade em C. Quando você está lidando com strings, como strings

01:09:34.210 --> 01:09:37.420
de texto, como o nome de alguém, uma frase, um parágrafo, qualquer coisa

01:09:37.420 --> 01:09:41.380
realmente mais de um caractere, você normalmente usa aspas duplas.

01:09:41.380 --> 01:09:42.399
E, de fato, você deve.

01:09:42.399 --> 01:09:47.620
Ao lidar com caracteres deliberadamente únicos, como estou aqui para y ou n,

01:09:47.620 --> 01:09:49.819
você deve usar aspas simples.

01:09:49.819 --> 01:09:50.319
Por que?

01:09:50.319 --> 01:09:52.240
Porque isso garante que o computador

01:09:52.240 --> 01:09:54.550
sabe que é de fato um char e não uma string.

01:09:54.550 --> 01:09:55.930
Portanto, aspas duplas são para strings.

01:09:55.930 --> 01:09:57.520
Aspas simples são para caracteres.

01:09:57.520 --> 01:10:00.550
Então, com isso dito, deixe-me ir em frente e diminuir o zoom.

01:10:00.550 --> 01:10:04.780
Deixe-me ir em frente na janela do meu terminal, executar, concordar, Enter.

01:10:04.780 --> 01:10:08.770
Parece funcionar bem, então deixe-me ir em frente e fazer ./concordo.

01:10:08.770 --> 01:10:12.250
Deixe-me ir em frente agora e digitar y.

01:10:12.250 --> 01:10:13.090
Aqui vamos nós.

01:10:13.090 --> 01:10:14.980
Digitar.

01:10:14.980 --> 01:10:16.540
Huh.

01:10:16.540 --> 01:10:17.470
Deixe-me tentar novamente.

01:10:17.470 --> 01:10:18.580
Repetir ./concordo.

01:10:18.580 --> 01:10:20.170
Que tal não?

01:10:20.170 --> 01:10:22.480
Digitar.

01:10:22.480 --> 01:10:25.720
Por que não está se comportando como eu esperava?

01:10:25.720 --> 01:10:28.480
AUDIÊNCIA: Porque você digitou o Y maiúsculo e o N maiúsculo.

01:10:28.480 --> 01:10:29.590
DAVID J. MALAN: Sim, eu meio que trapaceei lá,

01:10:29.590 --> 01:10:32.230
e apertei a tecla Caps Lock assim que comecei a digitar a entrada.

01:10:32.230 --> 01:10:32.730
Por que?

01:10:32.730 --> 01:10:35.950
Porque eu queria deliberadamente digitar letras maiúsculas em vez de minúsculas,

01:10:35.950 --> 01:10:37.540
o que é meio razoável.

01:10:37.540 --> 01:10:40.728
É um pouco desagradável se você forçar o usuário a alternar o caps lock

01:10:40.728 --> 01:10:42.770
ative ou desative a tecla quando você só precisa de uma resposta simples.

01:10:42.770 --> 01:10:45.310
Essa não é a melhor experiência do usuário ou UX.

01:10:45.310 --> 01:10:47.200
Mas funcionaria se eu cooperasse.

01:10:47.200 --> 01:10:49.420
Deixe-me executar isso novamente sem caps lock--

01:10:49.420 --> 01:10:52.030
y minúsculo para sim.

01:10:52.030 --> 01:10:55.210
Ah, isso funcionou. n minúsculo para não.

01:10:55.210 --> 01:10:55.990
Isso funcionou.

01:10:55.990 --> 01:10:57.910
Mas como eu poderia fazê-lo funcionar para ambos?

01:10:57.910 --> 01:10:59.180
Bem, que tal isso?

01:10:59.180 --> 01:11:01.400
Deixe-me ir em frente e apenas adicionar duas possibilidades.

01:11:01.400 --> 01:11:06.340
Então, se c for igual a aspas/sem aspas Y maiúsculo,

01:11:06.340 --> 01:11:10.720
então também imprima a barra invertida n.

01:11:10.720 --> 01:11:17.470
E aqui embaixo, caso contrário, se c for igual a aspas simples N maiúsculo,

01:11:17.470 --> 01:11:20.980
então vá em frente e imprima, novamente, Não acordado.

01:11:20.980 --> 01:11:23.770
Isso, eu afirmo agora, está correto.

01:11:23.770 --> 01:11:26.980
E eu vou concordar bem rápido, ./concordo.

01:11:26.980 --> 01:11:28.210
E vou usar capital.

01:11:28.210 --> 01:11:29.170
Agora funciona.

01:11:29.170 --> 01:11:30.610
Vou usar capital.

01:11:30.610 --> 01:11:32.200
Novamente funciona.

01:11:32.200 --> 01:11:34.510
Mas este talvez não seja o melhor design.

01:11:34.510 --> 01:11:39.220
Deixe-me esconder a janela do terminal e colocá-la na tela de uma só vez.

01:11:39.220 --> 01:11:43.195
Por que esse pode não ser o melhor design, mesmo que esteja correto?

01:11:46.250 --> 01:11:49.628
Há outro termo de arte que podemos lançar aqui, como [SNIFFS] algo

01:11:49.628 --> 01:11:51.170
cheira meio estranho sobre este código.

01:11:51.170 --> 01:11:52.450
Este é um termo real da arte.

01:11:52.450 --> 01:11:54.100
Há cheiro de código aqui.

01:11:54.100 --> 01:11:55.930
Algo cheira um pouco fora.

01:11:55.930 --> 01:11:56.620
Por que?

01:11:56.620 --> 01:11:57.894
O que você acha?

01:11:57.894 --> 01:12:01.846
AUDIÊNCIA: [INAUDÍVEL]

01:12:06.895 --> 01:12:07.770
DAVID J. MALAN: Sim.

01:12:07.770 --> 01:12:09.370
Há a mesma saída de novo e de novo.

01:12:09.370 --> 01:12:10.530
Quer dizer, eu digitei manualmente.

01:12:10.530 --> 01:12:12.905
Mas honestamente, eu poderia muito bem ter apenas copiado e colado

01:12:12.905 --> 01:12:17.080
a maior parte do meu código original para fazer isso repetidamente para as duas letras maiúsculas.

01:12:17.080 --> 01:12:23.370
Portanto, se as linhas 10 e 14 são iguais E as linhas 18 e 22 são iguais, E então

01:12:23.370 --> 01:12:26.875
o resto destes if e else ifs são quase os mesmos,

01:12:26.875 --> 01:12:28.500
[SNIFFS] há algum cheiro de código lá.

01:12:28.500 --> 01:12:29.370
Não é bem desenhado.

01:12:29.370 --> 01:12:29.820
Por que?

01:12:29.820 --> 01:12:32.778
Porque se eu quiser mudar as coisas agora, como na semana passada no Scratch,

01:12:32.778 --> 01:12:35.970
Posso ter que alterar meu código em vários lugares ou copiar/colar

01:12:35.970 --> 01:12:37.120
nunca é uma coisa boa.

01:12:37.120 --> 01:12:41.280
E Deus me livre, quero adicionar suporte para Sim e Não como palavras completas,

01:12:41.280 --> 01:12:42.760
realmente vai demorar.

01:12:42.760 --> 01:12:44.170
Então, como podemos resolver isso?

01:12:44.170 --> 01:12:47.160
Bem, podemos combinar alguns desses pensamentos.

01:12:47.160 --> 01:12:49.470
Então deixe-me tentar melhorar os Sims primeiro.

01:12:49.470 --> 01:12:54.325
Acontece que, se eu excluir essa cláusula, posso realmente ou as coisas juntas.

01:12:54.325 --> 01:12:57.450
No Scratch, há algumas peças de quebra-cabeça, se você não as descobriu,

01:12:57.450 --> 01:12:59.430
que literalmente tem a palavra ou e a palavra

01:12:59.430 --> 01:13:02.350
e neles, que permitem combinar expressões booleanas.

01:13:02.350 --> 01:13:06.600
De modo que ou isso ou isso é verdade, ou isso e isso é verdade.

01:13:06.600 --> 01:13:09.270
Em C, você não pode simplesmente dizer a palavra ou.

01:13:09.270 --> 01:13:12.850
Em vez disso, você usa duas barras verticais.

01:13:12.850 --> 01:13:16.260
E as barras verticais juntas significam ou, logicamente.

01:13:16.260 --> 01:13:21.780
E assim posso dizer, c igual a aspas/sem aspas Y maiúsculo, de acordo.

01:13:21.780 --> 01:13:24.270
E agora posso me livrar desse código aqui.

01:13:24.270 --> 01:13:29.100
E deixe-me ir em frente e dizer, barra vertical duas vezes c

01:13:29.100 --> 01:13:32.340
é igual a aspas/sem aspas N em maiúsculas.

01:13:32.340 --> 01:13:36.870
E agora meu programa é aproximadamente um terço menor, o que é bom.

01:13:36.870 --> 01:13:38.140
Há menos redundância.

01:13:38.140 --> 01:13:43.290
E se eu reabrir minha janela de terminal, execute novamente make of concorda, ./agree,

01:13:43.290 --> 01:13:49.860
agora posso digitar y minúsculo ou Y grande e a mesma coisa para letras minúsculas e maiúsculas

01:13:49.860 --> 01:13:54.090
N. Qualquer dúvida então sobre esta sintaxe, pela qual agora você pode combinar pensamentos

01:13:54.090 --> 01:13:56.407
e apenas apertar as coisas?

01:13:56.407 --> 01:13:57.990
E haverá outros truques também.

01:13:57.990 --> 01:13:58.942
Sim?

01:13:58.942 --> 01:14:01.615
AUDIÊNCIA: Não existe uma função para simplesmente ignorar o caso?

01:14:01.615 --> 01:14:03.240
DAVID J. MALAN: Uma pergunta muito boa.

01:14:03.240 --> 01:14:06.030
Não existe uma função para simplesmente ignorar o caso?

01:14:06.030 --> 01:14:07.890
Resposta curta, existe.

01:14:07.890 --> 01:14:10.950
E veremos como fazer isso, na verdade, em apenas uma semana.

01:14:10.950 --> 01:14:13.080
E em outros idiomas, há ainda mais maneiras

01:14:13.080 --> 01:14:17.100
para apenas canonizar a entrada do usuário, descartando quaisquer caracteres de espaço

01:14:17.100 --> 01:14:19.890
eles podem ter acertado acidentalmente, forçando tudo a ficar minúsculo.

01:14:19.890 --> 01:14:23.372
Em C, vai dar um pouco mais de trabalho da nossa parte fazer isso.

01:14:23.372 --> 01:14:26.080
Mas, na verdade, já na próxima semana, veremos como podemos fazer isso.

01:14:26.080 --> 01:14:29.490
Mas, por enquanto, estamos comparando apenas esses valores literais.

01:14:29.490 --> 01:14:30.570
Outras perguntas?

01:14:30.570 --> 01:14:33.874
AUDIÊNCIA: Portanto, estamos assumindo que o usuário está colocando o que está sugerindo.

01:14:33.874 --> 01:14:37.618
Como você lidaria se eles colocassem um número?

01:14:37.618 --> 01:14:39.160
DAVID J. MALAN: Realmente boa pergunta.

01:14:39.160 --> 01:14:42.068
Portanto, estamos assumindo, com este programa e todos os meus últimos,

01:14:42.068 --> 01:14:45.360
que o humano está cooperando e quando eu pergunto o nome deles, eles digitam David

01:14:45.360 --> 01:14:49.290
e não 123, ou, neste caso, digitaram um único caractere e não

01:14:49.290 --> 01:14:50.040
uma palavra completa.

01:14:50.040 --> 01:14:53.520
Portanto, esse é um dos recursos frequentemente usados ​​em uma biblioteca.

01:14:53.520 --> 01:14:59.550
Então, por exemplo, se eu concordar novamente e disser algo como claro, Enter,

01:14:59.550 --> 01:15:01.330
ela o rejeita completamente.

01:15:01.330 --> 01:15:01.830
Por que?

01:15:01.830 --> 01:15:05.850
Porque s, u, r, e é uma string de caracteres.

01:15:05.850 --> 01:15:07.320
Não é um único personagem.

01:15:07.320 --> 01:15:11.380
Agora, eu poderia apenas dizer algo como x, que não é nem y nem n, é claro.

01:15:11.380 --> 01:15:14.190
Mas tolera isso porque é um único personagem.

01:15:14.190 --> 01:15:17.790
Mas embutido na biblioteca do CS50 estão algumas rejeições embutidas

01:15:17.790 --> 01:15:19.210
de entradas que não são esperadas.

01:15:19.210 --> 01:15:22.920
Portanto, se você usar get_int e o usuário digitar não o número 1 ou 2

01:15:22.920 --> 01:15:26.940
mas gato, CAT, ele apenas os solicitará novamente, os solicitará novamente.

01:15:26.940 --> 01:15:30.480
E é aqui também, se você fizer isso manualmente em C,

01:15:30.480 --> 01:15:34.068
você acaba escrevendo tanto código apenas para verificar todos esses erros.

01:15:34.068 --> 01:15:36.360
É por isso que usamos essas rodinhas por algumas semanas

01:15:36.360 --> 01:15:38.190
apenas para tornar o código mais robusto.

01:15:38.190 --> 01:15:40.500
Mas dentro de algumas semanas, tiraremos a liberdade.

01:15:40.500 --> 01:15:44.970
E você verá e entenderá como de fato está fazendo tudo isso.

01:15:44.970 --> 01:15:46.750
Tudo bem, então que tal isso.

01:15:46.750 --> 01:15:50.640
Vamos agora fazer a transição para algo um pouco mais parecido com o Scratch, literalmente,

01:15:50.640 --> 01:15:53.290
criando que tal outro programa aqui chamado meow--

01:15:53.290 --> 01:15:54.567
tão miau.c.

01:15:54.567 --> 01:15:56.650
Não teremos recursos de áudio para este.

01:15:56.650 --> 01:15:57.750
Vamos confiar apenas na impressão.

01:15:57.750 --> 01:16:00.390
E suponha que eu queira escrever um programa

01:16:00.390 --> 01:16:03.000
e veja que apenas simula um miado de gato.

01:16:03.000 --> 01:16:04.960
Portanto, ainda não preciso de nenhuma entrada do usuário.

01:16:04.960 --> 01:16:06.960
Vou usar stdio.h.

01:16:06.960 --> 01:16:09.940
Vou fazer meu int main(void) aqui.

01:16:09.940 --> 01:16:13.710
E então eu vou em frente e faço printf miau barra invertida n.

01:16:13.710 --> 01:16:16.650
E vamos fazer esse gato miar três vezes, como na semana passada.

01:16:16.650 --> 01:16:18.870
Então eu vou fazer miau, miau, miau.

01:16:18.870 --> 01:16:21.100
Observe como um aparte sempre que você destacar as linhas,

01:16:21.100 --> 01:16:22.350
você verá pequenos pontos aparecerem.

01:16:22.350 --> 01:16:24.780
Esta é apenas uma dica visual para você descobrir

01:16:24.780 --> 01:16:26.460
quantos espaços você recuou.

01:16:26.460 --> 01:16:30.133
O VS Code, como muitos editores, indentará automaticamente seu código para você.

01:16:30.133 --> 01:16:32.550
Eu não bati na barra de espaço quatro vezes todas as vezes.

01:16:32.550 --> 01:16:34.020
Eu nem tenho batido no Tab.

01:16:34.020 --> 01:16:38.280
No entanto, em C, a convenção é de fato recuar linhas

01:16:38.280 --> 01:16:40.410
onde apropriado por quatro espaços--

01:16:40.410 --> 01:16:41.933
então não três, não cinco.

01:16:41.933 --> 01:16:44.100
E esses pontos ajudam você a ver as coisas para que elas simplesmente

01:16:44.100 --> 01:16:45.850
alinhar como uma questão de bom estilo.

01:16:45.850 --> 01:16:48.600
Tudo bem, então este programa, vou apenas estipular agora,

01:16:48.600 --> 01:16:49.600
realmente vai funcionar.

01:16:49.600 --> 01:16:52.560
Faça miau-- que é meio fofo-- e agora miau.

01:16:52.560 --> 01:16:54.000
Aí, três vezes.

01:16:54.000 --> 01:16:54.540
Correto.

01:16:54.540 --> 01:16:55.500
Está miando três vezes.

01:16:55.500 --> 01:16:57.060
Mas é claro que isso não é bem projetado.

01:16:57.060 --> 01:16:58.935
Não foi bem projetado no Scratch na semana passada.

01:16:58.935 --> 01:17:00.480
Por que?

01:17:00.480 --> 01:17:03.130
O que eu deveria estar fazendo diferente?

01:17:03.130 --> 01:17:03.630
Sim?

01:17:03.630 --> 01:17:04.120
AUDIÊNCIA: Um loop?

01:17:04.120 --> 01:17:05.412
AUDIÊNCIA: Isso pode ser um loop.

01:17:05.412 --> 01:17:07.140
DAVID J. MALAN: Sim.

01:17:07.140 --> 01:17:09.310
É uma oportunidade perfeita para um loop.

01:17:09.310 --> 01:17:09.810
Por que?

01:17:09.810 --> 01:17:12.810
Porque se você quiser mudar talvez a capitalização dessas palavras,

01:17:12.810 --> 01:17:16.260
ou você queria mudar o som para um latido de cachorro ou algo assim,

01:17:16.260 --> 01:17:18.390
você teria que mudar um, dois, três lugares.

01:17:18.390 --> 01:17:20.160
E isso é meio estúpido, certo?

01:17:20.160 --> 01:17:23.020
No código, você deve idealmente alterar as coisas em um só lugar.

01:17:23.020 --> 01:17:24.880
Então, como posso fazer isso?

01:17:24.880 --> 01:17:27.120
Bem, poderíamos introduzir um loop, sim.

01:17:27.120 --> 01:17:30.420
Mas também vamos precisar de outro bloco de construção que tínhamos no Scratch,

01:17:30.420 --> 01:17:32.710
ou seja, aquelas coisas chamadas variáveis.

01:17:32.710 --> 01:17:35.070
Então lembre-se que uma variável, como uma álgebra-- x,

01:17:35.070 --> 01:17:38.520
y, z, qualquer coisa-- pode armazenar um valor para você.

01:17:38.520 --> 01:17:42.630
E uma variável no Scratch poderia ter esta aparência.

01:17:42.630 --> 01:17:45.880
Você usa esta peça de quebra-cabeça laranja para definir uma variável de qualquer nome,

01:17:45.880 --> 01:17:46.890
não apenas x, y ou z.

01:17:46.890 --> 01:17:49.710
Mas você poderia chamá-lo de algo mais descritivo, como contador,

01:17:49.710 --> 01:17:51.840
e você pode defini-lo igual a algum valor.

01:17:51.840 --> 01:17:56.490
Em C, a maneira de fazer isso é semelhante ao espírito para algumas das sintaxes

01:17:56.490 --> 01:17:57.570
vimos até agora.

01:17:57.570 --> 01:17:59.910
Você começa dizendo o nome da variável que deseja,

01:17:59.910 --> 01:18:01.740
um único sinal de igual e, em seguida, o valor.

01:18:01.740 --> 01:18:05.470
Você também deseja inicializá-lo, copiando, portanto, da direita para a esquerda.

01:18:05.470 --> 01:18:05.970
Por que?

01:18:05.970 --> 01:18:09.570
Porque o sinal de igual denota, novamente, atribuição da direita para a esquerda.

01:18:09.570 --> 01:18:10.740
Isso não é suficiente embora.

01:18:10.740 --> 01:18:12.282
Você pode ter a intuição já.

01:18:12.282 --> 01:18:16.170
O que provavelmente está faltando nesta linha de código apenas para criar uma variável?

01:18:16.170 --> 01:18:16.767
AUDIÊNCIA: Int.

01:18:16.767 --> 01:18:19.350
DAVID J. MALAN: Portanto, precisamos de int para garantir que o computador saiba

01:18:19.350 --> 01:18:20.610
que este é realmente um int.

01:18:20.610 --> 01:18:23.802
E por último, ponto e vírgula também.

01:18:23.802 --> 01:18:25.260
E isso agora completa o pensamento.

01:18:25.260 --> 01:18:27.302
Então, um pouco mais irritante do que o Scratch, mas estamos

01:18:27.302 --> 01:18:28.660
começando a ver padrões aqui.

01:18:28.660 --> 01:18:30.810
Portanto, nem toda parte da sintaxe será nova.

01:18:30.810 --> 01:18:33.480
Tudo bem, se você quiser incrementar o contador em um,

01:18:33.480 --> 01:18:37.480
Scratch usa o verbo mudar, e eles significam adicionar o valor ao contador.

01:18:37.480 --> 01:18:41.700
Então, se eu quiser incrementar uma variável existente chamada contador,

01:18:41.700 --> 01:18:43.930
esta sintaxe é um pouco mais interessante.

01:18:43.930 --> 01:18:48.690
Acontece que o código se parece com isso, o que quase parece um paradoxo.

01:18:48.690 --> 01:18:51.990
Como pode o contador ser igual ao contador mais 1?

01:18:51.990 --> 01:18:53.160
Não é assim que a matemática funciona.

01:18:53.160 --> 01:18:56.860
Mas, novamente, um único sinal de igual é atribuído da direita para a esquerda.

01:18:56.860 --> 01:18:59.910
Então, isso está dizendo, pegue qualquer que seja o valor do contador, adicione 1 a ele,

01:18:59.910 --> 01:19:03.930
e copie esse valor da direita para a esquerda no próprio contador.

01:19:03.930 --> 01:19:07.530
Você ainda precisa do ponto e vírgula, mas eu reivindico

01:19:07.530 --> 01:19:13.330
você não precisa mencionar a palavra-chave int ao atualizar uma variável existente.

01:19:13.330 --> 01:19:18.060
Então, somente quando você cria uma variável em C você usa a palavra string, ou a palavra

01:19:18.060 --> 01:19:19.950
int, ou qualquer um dos outros que iremos eventualmente

01:19:19.950 --> 01:19:23.370
veja-- somente ao criá-lo ou inicializá-lo pela primeira vez.

01:19:23.370 --> 01:19:25.780
Depois disso, se você quiser alterá-lo, ele simplesmente existe.

01:19:25.780 --> 01:19:27.060
É a palavra que você deu.

01:19:27.060 --> 01:19:29.950
O computador é inteligente o suficiente para pelo menos lembrar de que tipo é.

01:19:29.950 --> 01:19:32.100
Portanto, esta linha agora está completa

01:19:32.100 --> 01:19:35.580
Acontece que, no código, como veremos, é muito comum querer adicionar coisas

01:19:35.580 --> 01:19:37.740
juntos, incrementar as coisas por um.

01:19:37.740 --> 01:19:40.710
Então, na verdade, há uma sintaxe diferente para a mesma ideia.

01:19:40.710 --> 01:19:43.290
O termo da arte aqui é açúcar sintático.

01:19:43.290 --> 01:19:46.410
Muitas vezes há no código muitas maneiras de fazer a mesma coisa,

01:19:46.410 --> 01:19:49.900
mesmo que, no final das contas, eles façam exatamente a mesma funcionalidade.

01:19:49.900 --> 01:19:54.120
Então, por exemplo, se depois de alguns dias de CS50 você achar isso um pouco tedioso

01:19:54.120 --> 01:19:57.765
para continuar digitando em algum programa, você pode simplificá-lo para apenas isso.

01:19:57.765 --> 01:19:59.340
Este é o açúcar sintático.

01:19:59.340 --> 01:20:03.810
Você pode usar mais igual e mencionar o nome da variável apenas uma vez à esquerda,

01:20:03.810 --> 01:20:06.480
e só sabe que isso significa o anterior.

01:20:06.480 --> 01:20:10.420
É apenas um pouco mais sucinto.

01:20:10.420 --> 01:20:12.900
Isso também é uma coisa tão comum para adicionar 1 a um valor.

01:20:12.900 --> 01:20:13.800
E não precisa ser 1.

01:20:13.800 --> 01:20:14.800
Mas neste caso é.

01:20:14.800 --> 01:20:19.110
Mas se for realmente 1, você pode apertar ainda mais o código para fazer apenas isso,

01:20:19.110 --> 01:20:20.550
contador++.

01:20:20.550 --> 01:20:25.740
Portanto, sempre que você vir ++ em C, significa literalmente adicionar 1 a esse determinado

01:20:25.740 --> 01:20:26.472
variável.

01:20:26.472 --> 01:20:28.680
Há outras maneiras de fazer isso na outra direção.

01:20:28.680 --> 01:20:31.420
Se você quiser subtrair 1 de uma variável,

01:20:31.420 --> 01:20:34.890
você pode usar qualquer uma das sintaxes anteriores usando um sinal de menos em vez de mais,

01:20:34.890 --> 01:20:38.490
ou você pode mais sucintamente contra--.

01:20:38.490 --> 01:20:42.520
É assim que um programador C típico faria isso.

01:20:42.520 --> 01:20:45.210
Tudo bem, então se não temos variáveis, vamos

01:20:45.210 --> 01:20:47.500
vá e resolva o miado com loop.

01:20:47.500 --> 01:20:49.320
Então, no Scratch, vimos loops como este.

01:20:49.320 --> 01:20:52.680
Isso, é claro, fez o gato miar três vezes.

01:20:52.680 --> 01:20:54.480
Como fazemos isso em C?

01:20:54.480 --> 01:20:58.900
Agora, é aqui que as coisas ficam um pouco mais complicadas em termos de código.

01:20:58.900 --> 01:21:01.140
mas se você entender cada linha,

01:21:01.140 --> 01:21:03.520
vamos seguir logicamente o que está acontecendo.

01:21:03.520 --> 01:21:07.320
Então aqui, eu afirmo, é uma maneira de implementar

01:21:07.320 --> 01:21:12.330
um loop que itera três vezes em C. E isso é meio ridículo, certo?

01:21:12.330 --> 01:21:15.900
Passamos de duas peças de quebra-cabeça super simples como essa para, meu deus,

01:21:15.900 --> 01:21:18.990
são 1, 2, 3, 4, 5, 6 linhas de código, todas bem envolvidas.

01:21:18.990 --> 01:21:20.740
Então isso aumentou rapidamente.

01:21:20.740 --> 01:21:21.960
Mas o que cada linha está fazendo?

01:21:21.960 --> 01:21:24.120
E veremos outras maneiras de fazer isso de forma mais simples.

01:21:24.120 --> 01:21:28.710
Então, estamos inicializando uma variável chamada contador para 3, como antes.

01:21:28.710 --> 01:21:29.370
Por que?

01:21:29.370 --> 01:21:32.800
Bem, o que significa repetir ou repetir algo três vezes?

01:21:32.800 --> 01:21:35.190
Bem, é como fazer algo três vezes,

01:21:35.190 --> 01:21:37.260
e, em seguida, fazê-lo e, em seguida, contar e, em seguida,

01:21:37.260 --> 01:21:41.080
faça isso, e depois conte, e então faça, até que você esteja sem conta.

01:21:41.080 --> 01:21:44.910
Portanto, isso está declarando uma variável chamada contador, definindo-a como igual a 3.

01:21:44.910 --> 01:21:50.370
Em seguida, estou induzindo um loop em C, que é semelhante em espírito à repetição 3,

01:21:50.370 --> 01:21:52.440
mas você tem que fazer mais matemática sozinho.

01:21:52.440 --> 01:21:54.990
Então, estou fazendo a pergunta entre parênteses,

01:21:54.990 --> 01:21:59.200
enquanto count é maior que 0, o que eu quero fazer?

01:21:59.200 --> 01:22:04.080
Bem, pelo recuo dentro das chaves, quero miar uma vez.

01:22:04.080 --> 01:22:06.990
E então, para ser claro, o que esta última linha de código está fazendo?

01:22:06.990 --> 01:22:12.120
Se o contador começar em três, isso o tornará 2 subtraindo 1 dele.

01:22:12.120 --> 01:22:13.320
Então o que acontece?

01:22:13.320 --> 01:22:17.620
Pela natureza do loop, assim como no Scratch, ele sabe ir e voltar.

01:22:17.620 --> 01:22:21.010
mesmo que haja uma flecha bonita e bonita no Scratch, e não há aqui,

01:22:21.010 --> 01:22:26.310
C sabe fazer isso de novo, e de novo, e de novo, constantemente fazendo essa pergunta

01:22:26.310 --> 01:22:28.870
e, em seguida, atualizando esse valor no final.

01:22:28.870 --> 01:22:33.690
Então, se eu destacar apenas algumas dessas etapas, a variável começa em 3.

01:22:33.690 --> 01:22:35.100
E, na verdade, deixe-me simplificar 2.

01:22:35.100 --> 01:22:37.980
Afirmei anteriormente que, ao usar variáveis ​​únicas,

01:22:37.980 --> 01:22:41.280
as pessoas costumam chamá-lo de i para int ou c para char,

01:22:41.280 --> 01:22:43.480
ou s para string, a menos que você tenha várias variáveis.

01:22:43.480 --> 01:22:44.730
Então deixe-me apertar o código.

01:22:44.730 --> 01:22:47.220
E isso já faz com que pareça um pouco mais tolerável.

01:22:47.220 --> 01:22:50.320
Deixe-me apertar ainda mais, adicionar mais um passo.

01:22:50.320 --> 01:22:52.860
Então agora isso é tão apertado, tão sucinto

01:22:52.860 --> 01:22:54.653
como você pode fazer este código no momento.

01:22:54.653 --> 01:22:56.320
Então, o que realmente vai acontecer aqui?

01:22:56.320 --> 01:22:59.550
Bem, a primeira linha de código é executada e inicializa i como 3.

01:22:59.550 --> 01:23:00.900
Em seguida, verificamos a condição.

01:23:00.900 --> 01:23:03.840
Enquanto i é maior que 0, i é maior que 0?

01:23:03.840 --> 01:23:05.580
Bem, pelos meus três dedos, obviamente.

01:23:05.580 --> 01:23:07.590
Então, imprimimos miau na tela.

01:23:07.590 --> 01:23:13.110
Em seguida, subtraímos 1 de i, ponto em que agora temos 2 como o valor de i.

01:23:13.110 --> 01:23:15.330
Em seguida, o código volta para a condição.

01:23:15.330 --> 01:23:17.580
E observe, a condição está entre parênteses.

01:23:17.580 --> 01:23:19.420
Essa é outra expressão booleana.

01:23:19.420 --> 01:23:23.340
Portanto, os loops podem usar expressões booleanas, assim como os condicionais usam

01:23:23.340 --> 01:23:24.990
Expressões booleanas para tomar decisões.

01:23:24.990 --> 01:23:27.840
O loop, porém, é decidir não fazer isso ou aquilo

01:23:27.840 --> 01:23:31.330
mas se deve fazer a mesma coisa de novo, e de novo, e de novo.

01:23:31.330 --> 01:23:34.200
E à medida que percorre o código, uma linha após a outra,

01:23:34.200 --> 01:23:40.450
no final das contas, vai cair para 1, depois para 0 e então parar.

01:23:40.450 --> 01:23:45.330
Colocando de outra forma-- veio com alguns adereços aqui-- então suponha que esta bola aqui

01:23:45.330 --> 01:23:49.410
é a sua variável, e você a inicializa para 3 com três bolas de estresse,

01:23:49.410 --> 01:23:51.570
você pode fazer algo três vezes, certo?

01:23:51.570 --> 01:23:53.320
Se eu quiser distribuir três bolas de estresse--

01:23:53.320 --> 01:23:56.653
aqui está sua chance de ganhar bolas de estresse grátis sem ter que responder a nenhuma pergunta.

01:23:56.653 --> 01:23:57.400
OK, lá vamos nós.

01:23:57.400 --> 01:24:00.180
Aqui vamos nós, subtraindo 1 da minha variável.

01:24:00.180 --> 01:24:01.830
Eu fico com dois.

01:24:01.830 --> 01:24:02.460
Oh meu Deus.

01:24:02.460 --> 01:24:04.845
Tudo bem, não conte a Sanders.

01:24:04.845 --> 01:24:07.470
[GRUUNS] Oh, me desculpe.

01:24:07.470 --> 01:24:08.080
Oh.

01:24:08.080 --> 01:24:08.580
[RISADA]

01:24:08.580 --> 01:24:10.350
OK, isso acabou mal.

01:24:10.350 --> 01:24:11.070
Desculpas.

01:24:11.070 --> 01:24:11.570
Tudo bem.

01:24:11.570 --> 01:24:13.740
Mas agora o ponto educacional, porém, é

01:24:13.740 --> 01:24:17.037
que minha variável foi diminuída, fiz mais para ter apenas -

01:24:17.037 --> 01:24:18.370
Eu não estou jogando tão longe novamente.

01:24:18.370 --> 01:24:19.620
Eu não posso fazer isso.

01:24:19.620 --> 01:24:20.143
Aqui vamos nós.

01:24:20.143 --> 01:24:21.060
Tudo bem, aqui vamos nós.

01:24:21.060 --> 01:24:22.740
E uma subtração final.

01:24:22.740 --> 01:24:24.880
E agora nossa variável é deixada vazia.

01:24:24.880 --> 01:24:28.380
Então, tínhamos três bolas de estresse lá, e isso é tudo que uma variável é.

01:24:28.380 --> 01:24:29.475
É algum tipo de armazenamento.

01:24:29.475 --> 01:24:32.100
Na verdade, é claro, implementado na memória do computador.

01:24:32.100 --> 01:24:35.860
Mas, metaforicamente, é apenas uma tigela com alguns valores.

01:24:35.860 --> 01:24:37.800
E toda vez que você ou, neste caso, subtrair,

01:24:37.800 --> 01:24:39.840
você está apenas alterando o valor dessa variável.

01:24:39.840 --> 01:24:43.830
E então o código, entretanto, é claro, entre parênteses, está apenas verificando,

01:24:43.830 --> 01:24:44.610
a tigela está vazia?

01:24:44.610 --> 01:24:45.360
A tigela está vazia?

01:24:45.360 --> 01:24:46.570
A tigela está vazia?

01:24:46.570 --> 01:24:50.350
AKA, i é maior que 0 ou não?

01:24:50.350 --> 01:24:55.210
Alguma dúvida sobre como implementamos loops dessa maneira?

01:24:55.210 --> 01:24:58.080
E devo-te uma bola anti-stress depois da aula.

01:24:58.080 --> 01:24:59.820
Dúvidas sobre loops?

01:24:59.820 --> 01:25:03.240
Tudo bem, ao que parece, isso é meio feio.

01:25:03.240 --> 01:25:05.580
E isso realmente começa a tirar a diversão

01:25:05.580 --> 01:25:09.422
de programação quando você tem que escrever esta seqüência de passos.

01:25:09.422 --> 01:25:11.380
Acontece que há outras maneiras de fazer isso.

01:25:11.380 --> 01:25:13.110
Mas primeiro, vamos ver, logicamente, de que outra forma

01:25:13.110 --> 01:25:16.410
você pode expressar isso porque é um pouco estranho continuarmos usando zero.

01:25:16.410 --> 01:25:19.890
Então, a outra maneira de fazer isso seria inverter a lógica.

01:25:19.890 --> 01:25:23.820
Você poderia absolutamente começar com sua variável, chamá-la de i igual a 1.

01:25:23.820 --> 01:25:28.290
E então você poderia fazer a pergunta: i é menor ou igual a 3?

01:25:28.290 --> 01:25:30.210
E observe um pouco da nova sintaxe aqui.

01:25:30.210 --> 01:25:33.330
Em seu teclado típico, há um número menor que

01:25:33.330 --> 01:25:35.370
ou sinal de igual ou maior ou sinal de igual

01:25:35.370 --> 01:25:37.870
como você escreveria na aula de matemática com 1 sobre o outro.

01:25:37.870 --> 01:25:42.390
E assim, em C, você usa dois caracteres, menor que seguido por um sinal de igual

01:25:42.390 --> 01:25:45.360
ou, se apropriado, maior que seguido por sinal de igual.

01:25:45.360 --> 01:25:47.370
E isso captura logicamente essa ideia.

01:25:47.370 --> 01:25:50.580
Observe que estou mudando minhas perguntas.

01:25:50.580 --> 01:25:53.910
Estou inicializando i como 1 e, em última análise, vou incrementá-lo

01:25:53.910 --> 01:25:55.830
para 2 e depois 3.

01:25:55.830 --> 01:25:57.930
Mas porque estou fazendo menos ou igual a,

01:25:57.930 --> 01:26:00.340
ainda vai passar de 1, 2, 3.

01:26:00.340 --> 01:26:01.530
Então isso também funciona.

01:26:01.530 --> 01:26:03.810
Da mesma forma, poderíamos fazer isso de outra maneira.

01:26:03.810 --> 01:26:10.320
Poderíamos inicializar i como 0 e então poderíamos dizer, bem, i é menor que 3

01:26:10.320 --> 01:26:11.640
e continue incrementando-o.

01:26:11.640 --> 01:26:14.940
E mostrei que esta última forma é realmente a mais canônica.

01:26:14.940 --> 01:26:18.420
Pode ser o mais humano pensar em termos de 1 a 3.

01:26:18.420 --> 01:26:22.620
Pode ser o mais parecido com uma bola de estresse pensar em termos de 3 para 0,

01:26:22.620 --> 01:26:23.740
contagem decrescente.

01:26:23.740 --> 01:26:26.730
Mas normalmente, a sintaxe padrão para a maioria dos programadores

01:26:26.730 --> 01:26:31.440
assim que você se sentir confortável contando a partir do 0 é sempre começar a contar a partir do 0

01:26:31.440 --> 01:26:35.610
e conte até menos do que o valor que você está contando.

01:26:35.610 --> 01:26:40.043
Então seria incorreto, por que mudar isso para menor ou igual a 3 aqui?

01:26:40.043 --> 01:26:42.960
O que aconteceria se eu mudasse de menor para menor ou igual a?

01:26:42.960 --> 01:26:44.340
AUDIÊNCIA: Só vai miar duas vezes.

01:26:44.340 --> 01:26:47.280
DAVID J. MALAN: Sim, vai miar um extra-- uma quarta vez, na verdade, total,

01:26:47.280 --> 01:26:47.780
certo?

01:26:47.780 --> 01:26:51.150
Porque você começará em 0, depois 1, depois 2 e depois 3.

01:26:51.150 --> 01:26:53.220
E menor ou igual a 3-- desculpe--

01:26:53.220 --> 01:26:55.420
3 lhe dará a quarta vez.

01:26:55.420 --> 01:26:58.650
Portanto, queremos realmente ser apenas um a menos.

01:26:58.650 --> 01:27:01.198
Tudo bem, agora que temos essas opções,

01:27:01.198 --> 01:27:02.490
deixe-me apenas dar-lhe um outro.

01:27:02.490 --> 01:27:04.907
E este demora um pouco mais, acostumando também,

01:27:04.907 --> 01:27:07.210
mas é provavelmente a maneira mais comum de escrever isso.

01:27:07.210 --> 01:27:11.590
Deixe-me prosseguir e propor que implementemos isso da seguinte maneira.

01:27:11.590 --> 01:27:13.390
Deixe-me voltar ao meu código aqui.

01:27:13.390 --> 01:27:20.040
Deixe-me entrar em meus vários printfs, livrando-me de todos, exceto um deles

01:27:20.040 --> 01:27:21.000
em última análise.

01:27:21.000 --> 01:27:22.750
E vamos implementar isso no código.

01:27:22.750 --> 01:27:30.510
Então vamos fazer int i get 0, que tal então enquanto i for menor que 3,

01:27:30.510 --> 01:27:33.960
então vamos em frente e digamos printf quote/unquote meow--

01:27:33.960 --> 01:27:36.930
melow-- miau barra invertida n.

01:27:36.930 --> 01:27:41.310
E então temos que fazer i menos menos ou mais mais?

01:27:41.310 --> 01:27:42.237
AUDIÊNCIA: Mais mais.

01:27:42.237 --> 01:27:44.570
DAVID J. MALAN: Então mais mais porque estamos começando em 0

01:27:44.570 --> 01:27:47.120
e subindo, mas não passando por 3.

01:27:47.120 --> 01:27:51.678
Então deixe-me ir em frente agora e fazer miau depois de limpar meu terminal, ./meow,

01:27:51.678 --> 01:27:52.970
e ainda é tão correto.

01:27:52.970 --> 01:27:55.400
Mas é um pouco mais--

01:27:55.400 --> 01:27:56.730
é um pouco melhor projetado.

01:27:56.730 --> 01:27:57.230
Por que?

01:27:57.230 --> 01:28:00.770
Porque agora se eu quiser mudar de 3 para 30 vezes, por exemplo,

01:28:00.770 --> 01:28:01.850
posso alterar lá.

01:28:01.850 --> 01:28:03.770
Eu posso recompilar meu código.

01:28:03.770 --> 01:28:06.020
Eu posso fazer ./meow, e pronto.

01:28:06.020 --> 01:28:09.450
Não preciso copiar e colar mais 27 vezes para obter esse efeito.

01:28:09.450 --> 01:28:13.400
E posso até mudar o que é a palavra, alterando-a em apenas um local.

01:28:13.400 --> 01:28:15.920
Mas acontece que existem outras maneiras de fazer isso também.

01:28:15.920 --> 01:28:20.502
E deixe-me propor que também apresentemos a você o que é chamado de loop for.

01:28:20.502 --> 01:28:22.460
Então, se você quiser repetir algo três vezes,

01:28:22.460 --> 01:28:25.940
você pode absolutamente usar a abordagem de loop while que acabamos de ver,

01:28:25.940 --> 01:28:27.500
ou você pode fazer isso.

01:28:27.500 --> 01:28:30.270
E este demora um pouco mais, acostumando,

01:28:30.270 --> 01:28:34.200
mas meio que se consolida em uma linha com a mesma lógica.

01:28:34.200 --> 01:28:36.830
Observe que temos a palavra-chave aqui.

01:28:36.830 --> 01:28:40.730
E para é apenas uma preposição neste caso que geralmente implica,

01:28:40.730 --> 01:28:42.110
aqui vem um loop.

01:28:42.110 --> 01:28:46.097
Dentro dos parênteses aqui não há apenas uma expressão booleana.

01:28:46.097 --> 01:28:47.930
E é aqui que as coisas ficam um pouco estranhas.

01:28:47.930 --> 01:28:50.900
Há três coisas-- à esquerda do ponto e vírgula,

01:28:50.900 --> 01:28:54.230
no meio dos dois pontos e vírgulas e à direita do ponto e vírgula.

01:28:54.230 --> 01:28:58.198
Este é realmente o único outro contexto em que veremos ponto e vírgula, e é estranho.

01:28:58.198 --> 01:28:59.990
Normalmente, tem sido no final da linha.

01:28:59.990 --> 01:29:02.030
Agora são dois deles no meio da fila,

01:29:02.030 --> 01:29:04.920
mas esta é a maneira que os humanos decidiram fazer anos atrás.

01:29:04.920 --> 01:29:06.080
Então, o que isso está fazendo?

01:29:06.080 --> 01:29:07.850
Quase a mesma coisa.

01:29:07.850 --> 01:29:12.320
Ele vai inicializar uma variável chamada i para 0.

01:29:12.320 --> 01:29:14.240
Vai então verificar.

01:29:14.240 --> 01:29:19.880
Se for menor que 3, fará o que estiver entre as chaves,

01:29:19.880 --> 01:29:22.980
e por último vai incrementar i e repetir.

01:29:22.980 --> 01:29:26.240
Então, apenas destacando aqueles por sua vez, em primeiro lugar, eu

01:29:26.240 --> 01:29:28.340
é inicializado com 0, como antes.

01:29:28.340 --> 01:29:30.170
Então esta condição é verificada.

01:29:30.170 --> 01:29:32.150
Esta é uma expressão booleana.

01:29:32.150 --> 01:29:34.610
Sim ou não, verdadeiro ou falso será sua resposta.

01:29:34.610 --> 01:29:37.970
E se i for menor que 3, o que deveria ser uma vez que começa em 0,

01:29:37.970 --> 01:29:40.550
bem, então vamos em frente e imprimir miau.

01:29:40.550 --> 01:29:42.350
Então eu vou ser incrementado.

01:29:42.350 --> 01:29:43.580
Então começa em 0.

01:29:43.580 --> 01:29:45.170
Agora vai para 1.

01:29:45.170 --> 01:29:48.150
Nesse ponto, a expressão booleana é verificada novamente.

01:29:48.150 --> 01:29:50.840
Então você não fica mudando i de volta para 0.

01:29:50.840 --> 01:29:53.210
Esse primeiro passo acontece apenas uma vez.

01:29:53.210 --> 01:29:56.270
Mas agora você repete através desses três outros destaques.

01:29:56.270 --> 01:29:57.770
Eu verifico se i é menor que 3.

01:29:57.770 --> 01:29:58.320
Isso é.

01:29:58.320 --> 01:29:59.600
Então eu imprimo miau.

01:29:59.600 --> 01:30:00.875
Em seguida, incrementa i.

01:30:00.875 --> 01:30:03.410
Verifico se i, agora 2, é menor que 3.

01:30:03.410 --> 01:30:03.980
Isso é.

01:30:03.980 --> 01:30:05.240
Eu imprimo miau.

01:30:05.240 --> 01:30:06.380
eu sou incrementado.

01:30:06.380 --> 01:30:07.100
Eu agora verifico.

01:30:07.100 --> 01:30:08.120
Eu sou menor que 3?

01:30:08.120 --> 01:30:11.360
Não, não é, porque 3 não é menor que 3.

01:30:11.360 --> 01:30:12.800
E assim a coisa toda para.

01:30:12.800 --> 01:30:15.950
E qualquer código que esteja abaixo dessa chave, se houver,

01:30:15.950 --> 01:30:17.420
começa a executar em seu lugar.

01:30:17.420 --> 01:30:21.470
Assim como no Scratch, você sai do loop e as peças do quebra-cabeça

01:30:21.470 --> 01:30:22.610
sendo abraçado.

01:30:22.610 --> 01:30:31.520
Perguntas, então, sobre essa sintaxe alternativa para loops, também conhecido como loop for?

01:30:31.520 --> 01:30:34.195
AUDIÊNCIA: Você pode explicar novamente por que não volta a 0?

01:30:34.195 --> 01:30:35.570
DAVID J. MALAN: Desculpe, diga de novo?

01:30:35.570 --> 01:30:37.400
AUDIÊNCIA: Você pode explicar novamente por que não é redefinido para 0?

01:30:37.400 --> 01:30:38.275
DAVID J. MALAN: Sim.

01:30:38.275 --> 01:30:40.400
Posso explicar novamente por que ele não é redefinido para 0?

01:30:40.400 --> 01:30:41.690
Honestamente, apenas porque.

01:30:41.690 --> 01:30:43.490
Esta foi a sintaxe que eles escolheram.

01:30:43.490 --> 01:30:45.620
Esta primeira parte antes do primeiro ponto e vírgula

01:30:45.620 --> 01:30:47.660
é executado apenas uma vez apenas porque.

01:30:47.660 --> 01:30:48.740
É assim que foi projetado.

01:30:48.740 --> 01:30:51.660
Todo o resto circula de novo e de novo.

01:30:51.660 --> 01:30:54.277
E esta é apenas uma sintaxe alternativa para usar

01:30:54.277 --> 01:30:55.610
as linhas um pouco mais de código.

01:30:55.610 --> 01:30:57.818
Foram, tipo, seis linhas de código usando o loop while.

01:30:57.818 --> 01:30:59.387
Logicamente é a mesma coisa.

01:30:59.387 --> 01:31:01.220
Os programadores, quando se sentirem mais confortáveis,

01:31:01.220 --> 01:31:04.053
tendem a preferir isso porque apenas expressa todos os seus mesmos pensamentos

01:31:04.053 --> 01:31:05.240
de forma mais sucinta.

01:31:05.240 --> 01:31:06.380
Isso é tudo.

01:31:06.380 --> 01:31:06.890
Sim?

01:31:06.890 --> 01:31:07.620
AUDIÊNCIA: Essa foi a minha pergunta.

01:31:07.620 --> 01:31:08.412
DAVID J. MALAN: OK.

01:31:08.412 --> 01:31:11.210
Então, vamos trabalhar isso no meu exemplo de miau.

01:31:11.210 --> 01:31:12.590
Deixe-me voltar ao código aqui.

01:31:12.590 --> 01:31:14.898
E observe, de fato, se eu destacar todas essas linhas,

01:31:14.898 --> 01:31:16.190
Acho que podemos apertar isso.

01:31:16.190 --> 01:31:21.350
Deixe-me me livrar de todos eles e, em vez disso, fazer for int i equals 0.

01:31:21.350 --> 01:31:22.790
E eu estou dizendo iguais.

01:31:22.790 --> 01:31:24.260
A maioria dos programadores diria que fica.

01:31:24.260 --> 01:31:28.130
Então int i get 0 significa atribuição-- a palavra get.

01:31:28.130 --> 01:31:32.360
Agora vou fazer i is less than 3 i++.

01:31:32.360 --> 01:31:37.670
Agora aqui eu vou fazer o meu printf citação/sem aspas miau barra invertida n.

01:31:37.670 --> 01:31:39.450
E então é de fato um pouco mais apertado.

01:31:39.450 --> 01:31:41.408
Quero dizer, duas das linhas são apenas chaves.

01:31:41.408 --> 01:31:43.580
Há realmente apenas duas linhas suculentas de código agora.

01:31:43.580 --> 01:31:47.460
Deixe-me ir em frente e fazer miau, ./meow.

01:31:47.460 --> 01:31:51.680
E, novamente, estamos de volta aos negócios com apenas três deles imprimindo.

01:31:51.680 --> 01:31:54.050
Tudo bem, há uma última estrutura que devemos explorar

01:31:54.050 --> 01:31:56.330
só porque às vezes é útil.

01:31:56.330 --> 01:31:58.010
Este foi um bloqueio para sempre.

01:31:58.010 --> 01:32:00.170
E isso seria um pouco estranho no Scratch

01:32:00.170 --> 01:32:02.750
para apenas dizer miau para sempre, ou pelo menos sem esperar.

01:32:02.750 --> 01:32:06.290
Mas há de fato um bloco para sempre no Scratch, o que significa fazer o seguinte,

01:32:06.290 --> 01:32:07.490
para sempre.

01:32:07.490 --> 01:32:10.485
E eu propus, eu acho, verbalmente na semana passada pelo menos um exemplo

01:32:10.485 --> 01:32:11.360
onde isso é útil.

01:32:11.360 --> 01:32:13.040
Miando para sempre, um pouco irritante.

01:32:13.040 --> 01:32:14.990
Mas você pode pensar em casos comuns em que você

01:32:14.990 --> 01:32:19.100
pode querer escrever código ou usar um programa que faz um loop para sempre?

01:32:19.100 --> 01:32:19.657
Sim?

01:32:19.657 --> 01:32:21.740
AUDIÊNCIA: Tocar música durante todo o jogo.

01:32:21.740 --> 01:32:22.970
DAVID J. MALAN: Sim, tocando música.

01:32:22.970 --> 01:32:25.370
Como playlists do Spotify, apenas repetindo de novo e de novo

01:32:25.370 --> 01:32:26.495
seria algum tipo de loop.

01:32:26.495 --> 01:32:28.310
AUDIÊNCIA: Verificando colisões.

01:32:28.310 --> 01:32:29.840
DAVID J. MALAN: Verificando colisões no Scratch,

01:32:29.840 --> 01:32:32.548
então, vendo se algo está ricocheteando na parede ou em outro sprite.

01:32:32.548 --> 01:32:33.590
Sim?

01:32:33.590 --> 01:32:36.512
AUDIÊNCIA: Oh, verificando a entrada.

01:32:36.512 --> 01:32:37.970
DAVID J. MALAN: Verificando entrada.

01:32:37.970 --> 01:32:40.900
Então, sim, get_string está essencialmente esperando lá para sempre

01:32:40.900 --> 01:32:43.300
para eu digitar alguma entrada até que eu faça.

01:32:43.300 --> 01:32:44.470
AUDIÊNCIA: Verificando o tempo.

01:32:44.470 --> 01:32:45.760
DAVID J. MALAN: Verificando a hora e realmente

01:32:45.760 --> 01:32:47.860
mantendo o tempo humano, como um relógio de parede.

01:32:47.860 --> 01:32:48.550
Atrás de você?

01:32:48.550 --> 01:32:49.420
É isso mesmo?

01:32:49.420 --> 01:32:50.590
AUDIÊNCIA: Eu ia dizer checando a hora.

01:32:50.590 --> 01:32:52.173
DAVID J. MALAN: OK, verificando a hora.

01:32:52.173 --> 01:32:52.900
E mais um?

01:32:52.900 --> 01:32:53.995
Detectar um pressionamento de tecla também.

01:32:53.995 --> 01:32:56.620
Como no Scratch, apenas esperando algum tipo de evento acontecer,

01:32:56.620 --> 01:32:58.182
assim como em um telefone ou um navegador.

01:32:58.182 --> 01:32:59.890
E há tantos exemplos em que você

01:32:59.890 --> 01:33:01.510
pode querer fazer algo para sempre--

01:33:01.510 --> 01:33:04.520
apenas para que você tenha visto o bloco de construção C correspondente.

01:33:04.520 --> 01:33:08.290
É um pouco estranho, mas esta é provavelmente a maneira mais canônica

01:33:08.290 --> 01:33:11.783
para fazê-lo em C. Se você quiser imprimir miau para sempre--

01:33:11.783 --> 01:33:14.950
o que seria um pouco louco porque literalmente imprimiria e assumiria

01:33:14.950 --> 01:33:16.990
seu computador imprimindo para sempre miau--

01:33:16.990 --> 01:33:18.850
você geralmente faria assim.

01:33:18.850 --> 01:33:19.490
Por que?

01:33:19.490 --> 01:33:22.810
Bem, um loop while espera entre parênteses uma expressão booleana,

01:33:22.810 --> 01:33:26.020
e uma expressão booleana é, novamente, uma pergunta sim/não, verdadeiro/falso.

01:33:26.020 --> 01:33:29.620
Mas se você quiser que a resposta a essa pergunta seja sempre sim...

01:33:29.620 --> 01:33:33.490
ou realmente, sempre para ser verdade, acaba em C e em muitas linguagens

01:33:33.490 --> 01:33:35.950
dirá apenas verdadeiro porque verdadeiro--

01:33:35.950 --> 01:33:38.800
VERDADEIRO-- nunca vai mudar magicamente para falso.

01:33:38.800 --> 01:33:41.570
Quero dizer, é apenas uma palavra especial na linguagem de programação.

01:33:41.570 --> 01:33:45.680
Então, ao dizer enquanto verdadeiro, significa apenas fazer o seguinte para sempre.

01:33:45.680 --> 01:33:48.580
Outro paradigma comum antes de verdadeiro e falso

01:33:48.580 --> 01:33:52.300
tornou-se lugar-comum seria fazer isso em vez disso -

01:33:52.300 --> 01:33:54.220
mudar enquanto 1.

01:33:54.220 --> 01:33:57.820
Você pode ver em exemplos e textos on-line e afins,

01:33:57.820 --> 01:33:59.770
enquanto 1 é realmente a mesma coisa.

01:33:59.770 --> 01:34:04.840
Qualquer valor que seja 0 é geralmente interpretado como falso por um computador.

01:34:04.840 --> 01:34:09.310
Qualquer valor que seja 1 ou qualquer outro valor diferente de zero

01:34:09.310 --> 01:34:11.210
é geralmente interpretado como verdadeiro.

01:34:11.210 --> 01:34:15.400
E então isso também teria o mesmo efeito, dizendo while true ou while 1.

01:34:15.400 --> 01:34:18.700
De um modo geral, embora verdadeiro seja talvez um pouco mais claro hoje em dia.

01:34:18.700 --> 01:34:20.650
Agora, miar para sempre não é uma coisa boa.

01:34:20.650 --> 01:34:23.770
Mas suponha que eu fiz isso intencionalmente ou por acidente.

01:34:23.770 --> 01:34:24.950
Bem, vamos tentar isso.

01:34:24.950 --> 01:34:26.570
Então aqui eu vou entrar no meu código.

01:34:26.570 --> 01:34:30.550
Vou me livrar do loop for e mudar meu loop while para, que tal,

01:34:30.550 --> 01:34:32.180
verdadeiro.

01:34:32.180 --> 01:34:36.100
E neste caso aqui, bem, vamos mantê-lo-- vamos fazer isso.

01:34:36.100 --> 01:34:38.230
Faça miau, entre.

01:34:38.230 --> 01:34:41.840
E você verá isso, uso de identificador não declarado verdadeiro.

01:34:41.840 --> 01:34:46.360
Na verdade, isso está insinuando minha menção de que o método antigo era 0 e 1.

01:34:46.360 --> 01:34:48.220
Hoje em dia, você pode dizer verdadeiro ou falso.

01:34:48.220 --> 01:34:53.560
Mas verdadeiro e falso são palavras especiais que você deve incluir.

01:34:53.560 --> 01:34:56.740
Acontece que, se você quiser usar valores booleanos especiais como este,

01:34:56.740 --> 01:35:00.850
há outro arquivo de cabeçalho que não vimos chamado stdbool que essencialmente

01:35:00.850 --> 01:35:03.640
cria true e false como palavras-chave.

01:35:03.640 --> 01:35:06.550
Como alternativa, o CS50 inclui esse mesmo arquivo.

01:35:06.550 --> 01:35:08.980
Então é mais comum no CS50 é ver assim.

01:35:08.980 --> 01:35:13.360
Agora, se eu limpar a janela do meu terminal e fizer miau e depois ./meow e clicar

01:35:13.360 --> 01:35:18.970
Digite, bem, infelizmente, esta não é a melhor coisa a fazer infinitamente quando

01:35:18.970 --> 01:35:21.350
você está na nuvem usando um navegador.

01:35:21.350 --> 01:35:24.970
Este é realmente um navegador, apenas em tela cheia aqui.

01:35:24.970 --> 01:35:29.462
Isso significa que estou enviando milhões de miados pela internet para o meu computador aqui.

01:35:29.462 --> 01:35:32.170
Então isso vai acontecer com você em algum momento, provavelmente não com miau.

01:35:32.170 --> 01:35:34.150
Mas você perderá o controle sobre a janela do seu terminal.

01:35:34.150 --> 01:35:34.420
Por que?

01:35:34.420 --> 01:35:35.170
Porque você estragou tudo.

01:35:35.170 --> 01:35:36.250
E você tem um loop infinito.

01:35:36.250 --> 01:35:37.090
Você realmente não pretendia isso.

01:35:37.090 --> 01:35:37.690
Ou talvez você tenha.

01:35:37.690 --> 01:35:39.232
Você estava curioso para ver o que acontece.

01:35:39.232 --> 01:35:41.590
O que você faz?

01:35:41.590 --> 01:35:43.930
Quando o miado para?

01:35:43.930 --> 01:35:45.910
Que recurso temos aqui?

01:35:45.910 --> 01:35:48.550
Bem, o Control-C será seu amigo.

01:35:48.550 --> 01:35:51.070
Às vezes você tem que bater um monte em um ambiente de nuvem.

01:35:51.070 --> 01:35:55.540
Mas Control-C para cancelar interromperá um programa em execução.

01:35:55.540 --> 01:35:58.660
E eu prometo que quase todos vocês irão em algum momento

01:35:58.660 --> 01:36:02.560
introduza acidentalmente um loop infinito porque sua matemática está um pouco errada.

01:36:02.560 --> 01:36:05.680
Em caso de dúvida, clique na janela do terminal e pressione Control-C--

01:36:05.680 --> 01:36:07.060
às vezes várias vezes--

01:36:07.060 --> 01:36:09.545
e isso realmente cancelará o que quer que esteja acontecendo lá.

01:36:09.545 --> 01:36:11.170
Neste caso, eu poderia ter pretendido isso.

01:36:11.170 --> 01:36:14.330
Mas às vezes não é, de fato, pretendido.

01:36:14.330 --> 01:36:18.010
Tudo bem, então tomamos como certo todo esse usuário gráfico

01:36:18.010 --> 01:36:22.557
interface por algum tempo e, de fato, os comandos que estou digitando

01:36:22.557 --> 01:36:23.890
e os botões em Estou clicando.

01:36:23.890 --> 01:36:25.848
E deixe-me apenas dar-lhe uma noção melhor do que

01:36:25.848 --> 01:36:29.290
é que estamos usando sob o capô o tempo todo,

01:36:29.290 --> 01:36:31.630
ou seja, um sistema operacional chamado Linux.

01:36:31.630 --> 01:36:34.270
Então continuo aludindo verbalmente, é claro, a Macs e PCs

01:36:34.270 --> 01:36:37.690
porque quase todos nós estamos executando macOS ou Windows em nossos desktops

01:36:37.690 --> 01:36:38.680
ou laptops hoje em dia.

01:36:38.680 --> 01:36:40.930
Mas há muitos outros sistemas operacionais por aí,

01:36:40.930 --> 01:36:43.330
e um dos mais populares é chamado Linux.

01:36:43.330 --> 01:36:47.680
E o Linux é muito usado em servidores hoje em dia - empresas

01:36:47.680 --> 01:36:51.610
que hospedam e-mail, empresas que hospedam sites ou aplicativos, de forma mais geral.

01:36:51.610 --> 01:36:53.980
Certos cientistas da computação ou estudantes de ciência da computação

01:36:53.980 --> 01:36:56.950
muitas vezes gostam de se gabar de rodar o Linux só porque isso é uma coisa.

01:36:56.950 --> 01:37:01.030
Mas é realmente apenas uma alternativa ao macOS ou Windows

01:37:01.030 --> 01:37:04.150
que fornece uma GUI, se você quiser,

01:37:04.150 --> 01:37:07.480
mas também um ambiente especialmente de linha de comando.

01:37:07.480 --> 01:37:12.040
Agora, curiosidade - o Windows e o macOS têm janelas de terminal ou equivalente

01:37:12.040 --> 01:37:12.550
disso.

01:37:12.550 --> 01:37:16.150
E, eventualmente, você pode usá-lo em seu próprio Mac ou PC para resolver algum problema.

01:37:16.150 --> 01:37:19.690
Mas o Linux é realmente conhecido por, junto com outros sistemas operacionais,

01:37:19.690 --> 01:37:23.530
seu ambiente de linha de comando, que, novamente, distingui anteriormente da GUI

01:37:23.530 --> 01:37:26.500
como uma interface de linha de comando ou CLI.

01:37:26.500 --> 01:37:29.450
E isso se refere, na verdade, à janela do terminal.

01:37:29.450 --> 01:37:33.790
Então, se eu voltar ao VS Code aqui, e deixe-me, de fato, ir em frente e fechar minha guia

01:37:33.790 --> 01:37:36.160
e focar inteiramente na janela do terminal,

01:37:36.160 --> 01:37:39.640
esta janela de terminal é realmente apenas sua interface de linha de comando

01:37:39.640 --> 01:37:42.390
para o seu próprio servidor na nuvem.

01:37:42.390 --> 01:37:44.140
O termo de arte aqui é cada um de vocês terá

01:37:44.140 --> 01:37:47.530
seu próprio contêiner na nuvem, que é como seu próprio computador

01:37:47.530 --> 01:37:51.430
executando em algum lugar na internet com seu próprio nome de usuário e senha

01:37:51.430 --> 01:37:54.530
ao qual você tem acesso e seu próprio disco rígido, se desejar,

01:37:54.530 --> 01:37:57.430
sua própria pasta pessoal que contém todos os arquivos da turma.

01:37:57.430 --> 01:38:01.390
E é acessível apenas para você, a menos que você habilite o compartilhamento ao vivo.

01:38:01.390 --> 01:38:03.880
Então, quando você está digitando comandos aqui, parece

01:38:03.880 --> 01:38:06.400
como se estivesse digitando, é claro, em seu próprio Mac ou PC.

01:38:06.400 --> 01:38:09.070
Mas eles estão realmente sendo enviados pelo navegador

01:38:09.070 --> 01:38:13.570
para algum servidor na nuvem onde você está controlando, realmente,

01:38:13.570 --> 01:38:15.830
sua própria conta nele.

01:38:15.830 --> 01:38:19.390
Acontece que existem outros comandos que valem a pena conhecer.

01:38:19.390 --> 01:38:21.292
E daremos a você apenas alguns deles hoje.

01:38:21.292 --> 01:38:23.500
E nas próximas semanas você terá oportunidades

01:38:23.500 --> 01:38:24.710
para jogar com os outros também.

01:38:24.710 --> 01:38:26.260
Mas estes são alguns dos princípios básicos.

01:38:26.260 --> 01:38:29.782
E todos são incrivelmente sucintos porque, de fato, para coisas que você

01:38:29.782 --> 01:38:31.990
digitando na linha de comando, os humanos geralmente não

01:38:31.990 --> 01:38:33.640
queria digitar comandos longos.

01:38:33.640 --> 01:38:35.890
Muitas delas são abreviações aqui.

01:38:35.890 --> 01:38:38.590
Agora, talvez o mais comum com o qual começarei primeiro

01:38:38.590 --> 01:38:44.480
é ls, um l minúsculo e um s minúsculo que significa, sucintamente, lista.

01:38:44.480 --> 01:38:47.380
Então, se eu for para a janela do meu terminal agora, onde até agora,

01:38:47.380 --> 01:38:51.370
Eu apenas digitei o código, que é uma coisa do VS Code para criar arquivos de abertura,

01:38:51.370 --> 01:38:56.110
e make, que aciona a compilação do meu código, e se agora eu digitar ls?

01:38:56.110 --> 01:39:00.070
Isso listará todos os arquivos na minha pasta atual--

01:39:00.070 --> 01:39:02.000
meu disco rígido na nuvem, se preferir.

01:39:02.000 --> 01:39:05.780
Então, se eu apertar Enter, você verá um monte de resultados.

01:39:05.780 --> 01:39:07.240
Agora, eles também são codificados por cores.

01:39:07.240 --> 01:39:09.910
Os brancos aqui terminam em .c.

01:39:09.910 --> 01:39:11.980
Esses são os arquivos de código-fonte que escrevi

01:39:11.980 --> 01:39:15.790
durante a aula de hoje - concordo.c, compare.c, olá.c e miau.c.

01:39:15.790 --> 01:39:19.270
E talvez você possa adivinhar, os verdes aqui que apenas por convenção

01:39:19.270 --> 01:39:24.382
têm um asterisco no final para indicar que são especiais representam o quê?

01:39:24.382 --> 01:39:25.340
Um dos outros quatro.

01:39:25.340 --> 01:39:26.315
Sim?

01:39:26.315 --> 01:39:27.800
AUDIÊNCIA: O código de máquina?

01:39:27.800 --> 01:39:29.520
DAVID J. MALAN: Sim, o código da máquina.

01:39:29.520 --> 01:39:33.710
Então, esses são meus programas reais com nomes idênticos menos o .c

01:39:33.710 --> 01:39:34.340
extensão.

01:39:34.340 --> 01:39:36.830
E o asterisco significa que eles são executáveis.

01:39:36.830 --> 01:39:39.582
Isso é no mundo do macOS ou Windows, você clicaria duas vezes.

01:39:39.582 --> 01:39:41.540
Mas no mundo de um ambiente de linha de comando,

01:39:41.540 --> 01:39:46.280
isso significa que você faz ./ e depois o nome sem o asterisco para executar ou executar

01:39:46.280 --> 01:39:47.400
o código nele contido.

01:39:47.400 --> 01:39:51.560
Então, se eu abrir meu Explorador de Arquivos e pressionar Command-B no meu computador

01:39:51.560 --> 01:39:54.990
aqui apenas como um atalho de teclado-- você verá exatamente a mesma coisa.

01:39:54.990 --> 01:39:59.210
Portanto, ls é a interface de linha de comando para listar os arquivos em sua conta.

01:39:59.210 --> 01:40:03.060
Mas aqui, porque estou usando o VS Code ou qualquer programa parecido,

01:40:03.060 --> 01:40:06.213
Eu também recebo uma interface gráfica do usuário também.

01:40:06.213 --> 01:40:07.880
Portanto, são apenas dois lugares diferentes para se estar.

01:40:07.880 --> 01:40:09.680
Você pode usar o que quiser.

01:40:09.680 --> 01:40:12.260
Mas com o tempo você naturalmente ficará mais confortável

01:40:12.260 --> 01:40:14.720
e capaz apenas com a janela do terminal.

01:40:14.720 --> 01:40:16.773
Bem, o que mais está nesta lista aqui?

01:40:16.773 --> 01:40:19.190
Bem, durante o intervalo, vi isso em pelo menos um de vocês,

01:40:19.190 --> 01:40:23.330
por exemplo, criou um arquivo chamado hello em vez de hello.c.

01:40:23.330 --> 01:40:27.230
Então você estava em uma situação em que fez isso acidentalmente e apertou Enter.

01:40:27.230 --> 01:40:30.420
E então você foi em frente e digitou todo o seu código assim.

01:40:30.420 --> 01:40:32.270
E então, na janela do seu terminal, você

01:40:32.270 --> 01:40:34.760
estavam tentando fazer olá, Enter.

01:40:34.760 --> 01:40:38.960
E isso agora não fez nada.

01:40:38.960 --> 01:40:40.820
Eu não posso-- estou batendo--

01:40:40.820 --> 01:40:42.380
Estou tentando executar o comando.

01:40:42.380 --> 01:40:44.690
Tive a permissão negada, como pelo menos um de vocês teve.

01:40:44.690 --> 01:40:45.433
Agora, por que isso?

01:40:45.433 --> 01:40:46.850
Bem, vamos fazer uma verificação rápida.

01:40:46.850 --> 01:40:50.690
Se eu fizer ls, vejo agora olá, mas olá tem

01:40:50.690 --> 01:40:53.180
nenhum asterisco próximo a ele, o que significa que não é executável.

01:40:53.180 --> 01:40:53.930
Esse é o meu código.

01:40:53.930 --> 01:40:54.470
Por que?

01:40:54.470 --> 01:40:57.540
Bem, observe o topo da minha guia confirma, oh, eu estraguei tudo.

01:40:57.540 --> 01:41:00.740
Não chamei meu arquivo de hello.c, o que tem que ser.

01:41:00.740 --> 01:41:01.920
Então, o que você faz?

01:41:01.920 --> 01:41:05.810
Bem, você poderia copiá-lo de forma bem hackeada, criar um novo arquivo e colá-lo.

01:41:05.810 --> 01:41:06.770
Ou não, não, não.

01:41:06.770 --> 01:41:09.890
Sabemos como renomear as coisas agora aqui porque essa é uma das nossas opções.

01:41:09.890 --> 01:41:11.100
Deixe-me fazer isso.

01:41:11.100 --> 01:41:17.600
Deixe-me fazer mv para mover, olá e, em seguida, olá.c e pressione Enter.

01:41:17.600 --> 01:41:20.250
Você verá que a guia fecha porque o hello não existe mais.

01:41:20.250 --> 01:41:25.130
Mas se eu digitar ls agora, você verá, ah, existe hello.c.

01:41:25.130 --> 01:41:28.910
E se eu abrir esse arquivo agora, ufa, tem todo o meu código.

01:41:28.910 --> 01:41:31.010
E agora, se eu fizer olá...

01:41:31.010 --> 01:41:37.350
make hello-- agora eu recebo um arquivo executável onde no mundo é restaurado.

01:41:37.350 --> 01:41:40.950
Então mv, é apenas um comando não apenas para renomear, mas também,

01:41:40.950 --> 01:41:43.020
eventualmente para mover arquivos também.

01:41:43.020 --> 01:41:45.230
Você também pode criar diretórios ou pastas.

01:41:45.230 --> 01:41:48.950
Então, por exemplo, se eu entrar no VS Code novamente e supor

01:41:48.950 --> 01:41:52.760
Eu passo o mouse aqui e clico não no ícone do arquivo plus, mas na pasta plus,

01:41:52.760 --> 01:41:56.210
Posso criar uma pasta chamada, por exemplo, pset1 para o problema

01:41:56.210 --> 01:41:57.620
definir 1 na classe.

01:41:57.620 --> 01:42:00.290
E você verá agora que está vazio porque todos os meus outros arquivos

01:42:00.290 --> 01:42:02.840
estão na pasta padrão da minha conta.

01:42:02.840 --> 01:42:05.460
Mas eu também poderia entrar lá assim.

01:42:05.460 --> 01:42:11.060
E eu poderia clicar em Arquivo, e agora posso criar um novo arquivo chamado mario.c,

01:42:11.060 --> 01:42:13.430
que é um dos primeiros problemas, por exemplo.

01:42:13.430 --> 01:42:18.960
Mas você notará agora que mario.c está dentro da pasta pset1.

01:42:18.960 --> 01:42:23.300
Então, se eu diminuir o zoom e digitar ls na janela do meu terminal,

01:42:23.300 --> 01:42:26.720
Não vou ver mario.c em lugar nenhum.

01:42:26.720 --> 01:42:28.688
Mas eu vejo uma pasta pset1.

01:42:28.688 --> 01:42:31.730
E está em azul claro seguido de uma barra, que você não precisa digitar.

01:42:31.730 --> 01:42:33.300
Apenas indica que é uma pasta.

01:42:33.300 --> 01:42:37.640
Agora, visualmente, no canto superior esquerdo, obviamente, vejo que pwet1 contém mario.c.

01:42:37.640 --> 01:42:40.610
Mas se eu tentar fazer algo como make mario aqui,

01:42:40.610 --> 01:42:42.800
nenhuma regra para fazer alvo mario.

01:42:42.800 --> 01:42:44.510
Simplesmente não parece existir.

01:42:44.510 --> 01:42:46.650
E isso é porque você está no diretório errado.

01:42:46.650 --> 01:42:49.010
Portanto, em uma interface de linha de comando, não é tão simples

01:42:49.010 --> 01:42:51.560
como apenas clicar em uma pasta e pronto, ela se abre.

01:42:51.560 --> 01:42:55.250
Você tem que mudar para o diretório ou pasta.

01:42:55.250 --> 01:42:57.660
E cd vai ser o comando lá.

01:42:57.660 --> 01:43:00.600
Então, se eu realmente quiser mudar para esse diretório,

01:43:00.600 --> 01:43:04.070
Eu posso fazer cd, espaço, pset1, Enter.

01:43:04.070 --> 01:43:05.960
E agora você verá minhas alterações imediatas.

01:43:05.960 --> 01:43:09.200
E esta é apenas uma convenção comum, mas não é a única por aí.

01:43:09.200 --> 01:43:12.470
Agora ainda tenho um cifrão, que indica onde posso digitar comandos.

01:43:12.470 --> 01:43:16.520
Mas antes disso, vejo constantemente um lembrete em que pasta estou.

01:43:16.520 --> 01:43:19.550
E colocamos isso lá deliberadamente, como muitos usuários do Linux

01:43:19.550 --> 01:43:23.620
fazer apenas para se lembrar de onde estão porque, ao contrário do macOS ou do Windows,

01:43:23.620 --> 01:43:26.120
onde você tem uma bela e grande janela dizendo onde você está,

01:43:26.120 --> 01:43:29.000
na linha de comando, você precisa ser lembrado textualmente.

01:43:29.000 --> 01:43:33.350
Mas agora, se eu digitar ls e pressionar Enter, o que devo ver?

01:43:33.350 --> 01:43:34.340
AUDIÊNCIA: Mario.c

01:43:34.340 --> 01:43:36.170
DAVID J. MALAN: Sim, mario.c.

01:43:36.170 --> 01:43:38.460
E agora, se eu quiser abri-lo--

01:43:38.460 --> 01:43:42.140
se eu realmente quiser compilá-lo, posso executar make mario neste diretório

01:43:42.140 --> 01:43:43.940
uma vez que eu realmente digito todo o código.

01:43:43.940 --> 01:43:46.050
Tenha certeza de que em conjuntos de problemas e laboratórios,

01:43:46.050 --> 01:43:48.800
nós quase sempre-- certamente, nas primeiras semanas de aula--

01:43:48.800 --> 01:43:50.810
dar-lhe exatamente os comandos para digitar.

01:43:50.810 --> 01:43:52.880
As probabilidades são porque é novo para muitos de vocês,

01:43:52.880 --> 01:43:55.100
você acidentalmente digitará os comandos errados.

01:43:55.100 --> 01:43:56.000
Nada demais.

01:43:56.000 --> 01:43:58.850
Apenas lembre-se de que você tem maneiras diferentes de resolver esses problemas.

01:43:58.850 --> 01:44:00.740
Você tem o File Explorer gráfico, que

01:44:00.740 --> 01:44:02.198
deve parecer um pouco mais familiar.

01:44:02.198 --> 01:44:04.940
Mas com o tempo você vai começar a saber e, honestamente,

01:44:04.940 --> 01:44:08.630
provavelmente prefere comandos como estes - então cd para Change Directory,

01:44:08.630 --> 01:44:14.420
cp para copiar um arquivo, ls para lista, mkdir para criar um diretório--

01:44:14.420 --> 01:44:17.630
crie uma nova pasta na linha de comando em vez de com o botão--

01:44:17.630 --> 01:44:21.924
mv para mover ou renomear, rm para--

01:44:21.924 --> 01:44:22.770
AUDIÊNCIA: Remover.

01:44:22.770 --> 01:44:23.728
DAVID J. MALAN: Remover.

01:44:23.728 --> 01:44:24.960
Portanto, tenha cuidado com esse.

01:44:24.960 --> 01:44:26.520
Rmdir, remova o diretório.

01:44:26.520 --> 01:44:28.860
E há dezenas, centenas de outros comandos.

01:44:28.860 --> 01:44:30.780
Você não vai precisar de muitos deles, mas vamos começar

01:44:30.780 --> 01:44:33.310
para arranhar a superfície ainda mais ao longo do tempo.

01:44:33.310 --> 01:44:35.280
Mas, em última análise, essa interface de linha de comando

01:44:35.280 --> 01:44:38.630
vai ser um mecanismo mais poderoso, um mecanismo mais capaz,

01:44:38.630 --> 01:44:40.380
e, finalmente, um mecanismo mais eficiente

01:44:40.380 --> 01:44:43.980
para escrever código, executar comandos, resolver problemas, analisar dados mais

01:44:43.980 --> 01:44:46.050
geralmente, mesmo sabendo que está acontecendo

01:44:46.050 --> 01:44:49.680
ser algumas dores de crescimento no início só porque é

01:44:49.680 --> 01:44:51.880
provavelmente tão novo para muitos de vocês.

01:44:51.880 --> 01:44:55.020
Então, com isso dito, ainda temos alguns problemas para resolver,

01:44:55.020 --> 01:44:56.475
mas prometemos biscoitos hoje.

01:44:56.475 --> 01:44:58.350
Então vamos em frente e fazer uma pausa de 10 minutos.

01:44:58.350 --> 01:45:00.150
Os biscoitos agora são servidos no transepto.

01:45:00.150 --> 01:45:02.910
E estaremos de volta aqui em 10.

01:45:02.910 --> 01:45:04.740
Tudo bem, estamos de volta.

01:45:04.740 --> 01:45:08.400
E até agora, cada um dos exemplos de código em C que fizemos

01:45:08.400 --> 01:45:10.740
foram projetados para mostrar um tópico específico.

01:45:10.740 --> 01:45:14.190
Mas pensamos em tentar dar um passo atrás e resolver um problema mais geral

01:45:14.190 --> 01:45:17.880
e dar a você uma noção de quando foi dado um conjunto de problemas, por exemplo, ou apenas

01:45:17.880 --> 01:45:20.670
um problema de programação de forma mais geral, onde você começa

01:45:20.670 --> 01:45:23.280
e como você aborda isso quando não é óbvio

01:45:23.280 --> 01:45:25.260
qual é o objetivo do exercício.

01:45:25.260 --> 01:45:27.330
Então, um dos meus jogos favoritos do passado

01:45:27.330 --> 01:45:30.510
é esse aqui, "Super Mario Brothers" que já veio em tantos

01:45:30.510 --> 01:45:31.500
diferentes formas desde então.

01:45:31.500 --> 01:45:35.250
Mas neste jogo de rolagem lateral bidimensional original,

01:45:35.250 --> 01:45:37.450
havia muitas obras de arte como esta.

01:45:37.450 --> 01:45:40.260
Então, por exemplo, aqui no céu havia quatro pontos de interrogação.

01:45:40.260 --> 01:45:44.370
E descobriremos isso em C e em muitas linguagens de programação inicialmente,

01:45:44.370 --> 01:45:48.030
é muito mais fácil, muito mais acessível focar realmente no tipo preto e branco

01:45:48.030 --> 01:45:49.920
programas interativos textualmente em oposição

01:45:49.920 --> 01:45:51.900
para gráficos completos e similares, mas mais

01:45:51.900 --> 01:45:55.830
no tipo de programas acústicos mais gráficos em pouco tempo.

01:45:55.830 --> 01:45:58.500
Mas, por enquanto, deixe-me prosseguir e propor que nós

01:45:58.500 --> 01:46:00.720
tente apenas implementar na arte ASCII--

01:46:00.720 --> 01:46:03.150
ASCII, novamente, sendo o código que mapeia números

01:46:03.150 --> 01:46:08.250
às cartas, pelo menos para o inglês, em uma versão textual destas para a pergunta

01:46:08.250 --> 01:46:09.120
marcas no céu.

01:46:09.120 --> 01:46:11.130
Então, para isso, deixe-me ir para o VS Code.

01:46:11.130 --> 01:46:13.680
Vou criar minha própria versão do mario.c que

01:46:13.680 --> 01:46:16.923
será diferente daquele com o qual você foi desafiado no conjunto de problemas 1.

01:46:16.923 --> 01:46:18.840
De fato, no conjunto de problemas 1, você será desafiado

01:46:18.840 --> 01:46:22.860
para construir uma coisinha assim, embora com hashtags

01:46:22.860 --> 01:46:24.810
para arte ASCII em vez de gráficos.

01:46:24.810 --> 01:46:28.120
E em mario.c, quero apenas resolver esse problema simples primeiro.

01:46:28.120 --> 01:46:29.710
Portanto, tudo envolve saída.

01:46:29.710 --> 01:46:33.090
Vou incluir stdio.h para poder usar printf.

01:46:33.090 --> 01:46:37.043
Farei meu int main(void)-- mais sobre por que continuamos fazendo isso nas próximas semanas.

01:46:37.043 --> 01:46:39.210
E eu vou fazer algo simples inicialmente,

01:46:39.210 --> 01:46:42.210
como 1, 2, 3, 4, barra invertida n.

01:46:42.210 --> 01:46:46.530
Esta é a maneira mais simples de implementar quatro perguntas

01:46:46.530 --> 01:46:50.410
marcas no céu como estas aqui usando texto puro como este.

01:46:50.410 --> 01:46:54.180
Então deixe-me ir em frente e fazer mario, ./mario e pronto.

01:46:54.180 --> 01:46:55.830
Temos esses quatro pontos de interrogação.

01:46:55.830 --> 01:46:58.830
Mas vimos, é claro, que existem maneiras melhores de fazer isso.

01:46:58.830 --> 01:47:03.150
E se você quiser generalizar isso para cinco pontos de interrogação, seis,

01:47:03.150 --> 01:47:06.450
60 pontos de interrogação diferentes, loop sempre foi a resposta

01:47:06.450 --> 01:47:08.100
por não nos repetirmos.

01:47:08.100 --> 01:47:12.570
Então, talvez eu deva reescrever isso com um pouco mais de flexibilidade e dizer algo

01:47:12.570 --> 01:47:17.100
assim, pois em i obtenho 0, i menor que 4, i++.

01:47:17.100 --> 01:47:21.900
E então, dentro de um loop for, agora posso apenas fazer um único ponto de interrogação,

01:47:21.900 --> 01:47:25.800
mas não acho que o que acabei de fazer está correto.

01:47:25.800 --> 01:47:29.280
Alguém já detectou o bug estético?

01:47:29.280 --> 01:47:34.200
Sim, por que isso está errado se eu quiser imprimir a mesma coisa?

01:47:34.200 --> 01:47:34.710
Sim?

01:47:34.710 --> 01:47:38.275
AUDIÊNCIA: A barra invertida n, você disse para usá-la em [INAUDÍVEL].

01:47:38.275 --> 01:47:39.150
DAVID J. MALAN: Sim.

01:47:39.150 --> 01:47:41.800
Acho que não quero uma barra invertida após cada ponto de interrogação

01:47:41.800 --> 01:47:44.760
porque o objetivo é, novamente, essa fileira de pontos de interrogação no céu.

01:47:44.760 --> 01:47:50.700
Então, se eu agora recompilar isso, faça mario, ./mario, OK, está quase lá.

01:47:50.700 --> 01:47:54.820
Mas agora eu tenho aquela regressão para onde o cifrão não está em sua própria linha.

01:47:54.820 --> 01:47:58.265
Então acho que preciso de uma nova linha, mas acho que não quero aqui

01:47:58.265 --> 01:47:59.890
porque isso não ia acabar bem.

01:47:59.890 --> 01:48:01.015
Onde eu quero em vez disso?

01:48:03.310 --> 01:48:03.960
Algum instinto?

01:48:03.960 --> 01:48:05.610
Sim?

01:48:05.610 --> 01:48:07.380
Sim, então fora do loop.

01:48:07.380 --> 01:48:11.640
Então, de fato, posso ir abaixo da linha 8 e acima da linha 9, criando uma nova.

01:48:11.640 --> 01:48:15.273
E agora está tudo bem apenas imprimir uma nova linha como essa.

01:48:15.273 --> 01:48:17.190
Você não precisa imprimir mais nada com ele.

01:48:17.190 --> 01:48:18.970
É de fato um personagem em si.

01:48:18.970 --> 01:48:21.900
Então vamos fazer mario uma última vez, ./mario.

01:48:21.900 --> 01:48:24.010
OK, então agora estamos de volta aos negócios lá.

01:48:24.010 --> 01:48:28.020
Bem, e se quiséssemos fazer alguma outra cena de "Mario", como esta

01:48:28.020 --> 01:48:31.380
aqui onde tem muitos obstáculos verticais como esses tijolos aqui?

01:48:31.380 --> 01:48:34.410
Se eu quisesse imprimir agora uma coluna de três tijolos--

01:48:34.410 --> 01:48:38.160
e usarei hashtags para isso em vez de qualquer coisa gráfica-- bem,

01:48:38.160 --> 01:48:40.650
Acho que estamos quase lá, né?

01:48:40.650 --> 01:48:42.240
Acho que agora posso...

01:48:42.240 --> 01:48:44.080
é quase talvez um pouco mais fácil.

01:48:44.080 --> 01:48:46.342
eu posso voltar aqui, mudar o ponto de interrogação

01:48:46.342 --> 01:48:49.050
para algo que se parece mais com um tijolo, como este símbolo de hash.

01:48:49.050 --> 01:48:52.890
E eu acho que agora eu quero o novo caractere de linha porque quando eu fizer

01:48:52.890 --> 01:48:56.368
mario, ./mario, OK, aqui está minha parede de quatro.

01:48:56.368 --> 01:48:56.910
Ah, mas espere.

01:48:56.910 --> 01:48:58.050
Eu não queria quatro.

01:48:58.050 --> 01:49:01.150
Eu queria ser consistente apenas com esta cena em particular aqui,

01:49:01.150 --> 01:49:02.320
então eu só quero três.

01:49:02.320 --> 01:49:04.780
Então eu ainda posso mudá-lo em um só lugar.

01:49:04.780 --> 01:49:06.330
E aqui, novamente, está esse paradigma.

01:49:06.330 --> 01:49:08.970
Mesmo se você estiver usando 4 ou 3, se conseguir

01:49:08.970 --> 01:49:11.670
no hábito de começar a contar a partir de 0,

01:49:11.670 --> 01:49:15.870
você continua até, mas não até o valor que deseja contar.

01:49:15.870 --> 01:49:20.055
Então é por isso que estou usando menos que em vez de menos ou igual a lá.

01:49:20.055 --> 01:49:22.680
Portanto, este seria o paradigma comum, embora você possa contá-lo

01:49:22.680 --> 01:49:25.360
como vimos anteriormente de maneiras diferentes.

01:49:25.360 --> 01:49:27.965
Mas e se as coisas aumentarem um nível ainda mais?

01:49:27.965 --> 01:49:30.840
E quando você está na versão underground de "Super Mario Brothers",

01:49:30.840 --> 01:49:32.840
há muitas dessas obstruções subterrâneas,

01:49:32.840 --> 01:49:35.400
incluindo grades de tijolos como este.

01:49:35.400 --> 01:49:38.400
E deixe-me conjeturar que se você cortar isso, é aproximadamente um 3

01:49:38.400 --> 01:49:43.560
por 3 grades de tijolos que se encaixam lindamente para nos dar apenas um

01:49:43.560 --> 01:49:45.400
tijolo grande, grande como este.

01:49:45.400 --> 01:49:50.160
Então, se eu quiser imprimir uma grade 3 por 3, agora as coisas estão ficando um pouco mais

01:49:50.160 --> 01:49:54.510
interessante porque, até agora, eu imprimi uma linha horizontalmente

01:49:54.510 --> 01:49:56.580
ou uma coluna verticalmente.

01:49:56.580 --> 01:49:58.380
Mas nós realmente não vimos nenhum código onde

01:49:58.380 --> 01:50:02.670
Estou imprimindo ou vivendo em duas dimensões diferentes, como o jogo sugere.

01:50:02.670 --> 01:50:05.560
Mas deixe-me propor que poderíamos fazer isso.

01:50:05.560 --> 01:50:08.640
Deixe-me ir em frente e dizer, tudo bem, suponha que eu queira imprimir um 3

01:50:08.640 --> 01:50:10.500
por 3 grade de tijolos.

01:50:10.500 --> 01:50:16.590
É realmente que eu quero imprimir, o quê, três fileiras de tijolos.

01:50:16.590 --> 01:50:18.063
Uma grade é três linhas.

01:50:18.063 --> 01:50:19.980
Então, se eu pegar a ideia de alto nível e reduzi-la

01:50:19.980 --> 01:50:22.345
para algo um pouco mais simples, como faço isso?

01:50:22.345 --> 01:50:24.720
Bem, deixe-me me livrar do printf por um momento, como fiz.

01:50:24.720 --> 01:50:27.090
E deixe-me apenas estipular que este loop for,

01:50:27.090 --> 01:50:29.230
mesmo que ainda não faça nada de útil,

01:50:29.230 --> 01:50:33.390
fará algo quantas vezes apenas por design?

01:50:33.390 --> 01:50:34.530
Tudo bem, três vezes.

01:50:34.530 --> 01:50:35.850
Este loop for é bom para ir.

01:50:35.850 --> 01:50:39.390
Ele fará algo três vezes usando apenas i para fazer a contagem.

01:50:39.390 --> 01:50:44.070
Tudo bem, bem, se eu quiser imprimir agora uma linha de três tijolos todos

01:50:44.070 --> 01:50:46.710
na mesma linha, isso é bem parecido com o que

01:50:46.710 --> 01:50:49.170
fizemos antes, quando eu só queria imprimir

01:50:49.170 --> 01:50:51.090
quatro pontos de interrogação no céu.

01:50:51.090 --> 01:50:52.960
Então, vimos uma solução lá.

01:50:52.960 --> 01:50:55.450
E ouso dizer que podemos compor um no outro.

01:50:55.450 --> 01:50:58.590
Então, se eu quiser imprimir uma linha de tijolos,

01:50:58.590 --> 01:51:05.310
Eu poderia fazer isso para obter 0 i menor que 3 i++,

01:51:05.310 --> 01:51:08.310
e então dentro deste loop interno, se você quiser,

01:51:08.310 --> 01:51:11.700
deixe-me imprimir um único tijolo como este.

01:51:11.700 --> 01:51:16.862
E então eu não gosto de onde isso está indo, mas acho que peguei duas ideias

01:51:16.862 --> 01:51:17.820
e eu os combinei.

01:51:17.820 --> 01:51:23.080
Mas o que pode ser problemático nas linhas 5 e 7 no momento?

01:51:23.080 --> 01:51:24.700
O que pode estar errado aqui?

01:51:24.700 --> 01:51:25.345
Sim, atrás?

01:51:25.345 --> 01:51:27.665
AUDIÊNCIA: Você usou o mesmo inteiro i.

01:51:27.665 --> 01:51:30.040
DAVID J. MALAN: Sim, estou usando o mesmo inteiro i, que

01:51:30.040 --> 01:51:32.080
Eu sinto que poderia me colocar em apuros.

01:51:32.080 --> 01:51:34.480
Se estou tentando contar três coisas aqui,

01:51:34.480 --> 01:51:38.470
mas então estou sequestrando essa variável e usando-a dentro do loop,

01:51:38.470 --> 01:51:41.560
Sinto que devo evitar essa colisão de nomes.

01:51:41.560 --> 01:51:43.930
E então, qual é uma boa alternativa para i?

01:51:43.930 --> 01:51:46.390
Bem, um programador, se aninhar loops dessa maneira,

01:51:46.390 --> 01:51:47.980
normalmente iria com j.

01:51:47.980 --> 01:51:50.975
Você certamente poderia mudar isso para linhas e colunas

01:51:50.975 --> 01:51:52.600
se você quiser variáveis ​​mais descritivas.

01:51:52.600 --> 01:51:54.940
Mas i e j é bastante canônico.

01:51:54.940 --> 01:51:59.020
Então, vou seguir em frente e fazer isso, j++ em vez de i++ em todos os lugares.

01:51:59.020 --> 01:52:00.280
E deixe-me tentar compilar isso.

01:52:00.280 --> 01:52:04.330
Então faça mario, Enter, ./mario.

01:52:04.330 --> 01:52:06.560
OK, então algumas coisas estão erradas aqui.

01:52:06.560 --> 01:52:08.480
Esta não é uma grade 3 por 3.

01:52:08.480 --> 01:52:12.855
Mas se você contar essas coisas, quantas eu realmente imprimi pelo menos?

01:52:12.855 --> 01:52:14.485
Você provavelmente pode adivinhar logicamente.

01:52:14.485 --> 01:52:15.110
AUDIÊNCIA: Nove.

01:52:15.110 --> 01:52:17.110
DAVID J. MALAN: Sim, há nove hashes lá.

01:52:17.110 --> 01:52:18.940
Infelizmente, eles estão todos na mesma linha

01:52:18.940 --> 01:52:21.340
em vez de três linhas diferentes.

01:52:21.340 --> 01:52:24.910
Então, onde logicamente posso consertar isso?

01:52:24.910 --> 01:52:26.535
Estou definitivamente imprimindo todos os tijolos.

01:52:26.535 --> 01:52:28.077
Eles simplesmente não estão nos níveis certos.

01:52:28.077 --> 01:52:28.646
Sim?

01:52:28.646 --> 01:52:31.078
AUDIÊNCIA: Se você colocar uma nova linha no primeiro loop,

01:52:31.078 --> 01:52:32.620
então você terá três linhas separadas.

01:52:32.620 --> 01:52:33.495
DAVID J. MALAN: Sim.

01:52:33.495 --> 01:52:36.580
Então coloque uma nova linha após o primeiro loop, este loop interno, se você quiser,

01:52:36.580 --> 01:52:38.000
o loop aninhado, se preferir.

01:52:38.000 --> 01:52:41.030
Então deixe-me ir em frente e imprimir apenas uma barra invertida n aqui.

01:52:41.030 --> 01:52:42.073
E o que isso está fazendo?

01:52:42.073 --> 01:52:43.990
Bem, acho que isso vai resolver isso apenas

01:52:43.990 --> 01:52:47.270
movendo o cursor para a próxima linha depois de ter feito uma linha.

01:52:47.270 --> 01:52:50.770
Então deixe-me ir em frente e fazer mario, Enter, ./mario,

01:52:50.770 --> 01:52:52.070
e agora estamos no negócio.

01:52:52.070 --> 01:52:54.850
Portanto, é uma versão muito simplista desse mesmo gráfico,

01:52:54.850 --> 01:52:57.400
mas estou aproveitando duas ideias diferentes agora--

01:52:57.400 --> 01:52:59.350
ou a mesma ideia duas vezes agora.

01:52:59.350 --> 01:53:03.970
Estou usando um loop para controlar meu cursor indo linha, por linha, por linha.

01:53:03.970 --> 01:53:06.100
Mas dentro desse loop, estou fazendo da esquerda para a direita,

01:53:06.100 --> 01:53:08.290
ponto, ponto, ponto, ponto, ponto, com impressão

01:53:08.290 --> 01:53:10.960
cada um desses tijolos individuais assim.

01:53:10.960 --> 01:53:13.600
Agora, ainda há um pouco de desleixo aqui.

01:53:13.600 --> 01:53:16.630
Se eu quiser que isso seja sempre um quadrado só porque é

01:53:16.630 --> 01:53:20.800
o que parece no jogo, bem, eu poderia mudar para 4 por 4

01:53:20.800 --> 01:53:24.430
quadrado fazendo isso ou uma grade de 5 por 5 -

01:53:24.430 --> 01:53:26.420
whoops-- fazendo isso.

01:53:26.420 --> 01:53:30.010
Por que talvez esse não seja o melhor design para continuar mudando os números quando

01:53:30.010 --> 01:53:33.330
quero mudar o tamanho?

01:53:33.330 --> 01:53:34.440
Onde isso pode dar errado?

01:53:34.440 --> 01:53:35.010
Sim?

01:53:35.010 --> 01:53:38.255
AUDIÊNCIA: Se for um quadrado, [INAUDÍVEL]

01:53:38.255 --> 01:53:39.130
DAVID J. MALAN: Sim.

01:53:39.130 --> 01:53:40.630
Se sempre vai ser um quadrado e altura

01:53:40.630 --> 01:53:43.060
vai ser o mesmo que a largura, estou apenas criando problemas aqui, certo?

01:53:43.060 --> 01:53:44.110
Eventualmente, eu vou estragar tudo.

01:53:44.110 --> 01:53:45.680
Vou mudar um, mas não o outro.

01:53:45.680 --> 01:53:48.070
Então vai sair um retângulo em vez de um quadrado apropriado.

01:53:48.070 --> 01:53:50.410
Então eu provavelmente deveria resolver isso um pouco diferente.

01:53:50.410 --> 01:53:51.160
Então deixe-me fazer isso.

01:53:51.160 --> 01:53:54.700
No topo da minha função principal aqui, deixe-me ir em frente e me dar

01:53:54.700 --> 01:53:59.980
uma variável chamada talvez n para o número de tijolos que eu quero horizontalmente

01:53:59.980 --> 01:54:01.000
e verticalmente.

01:54:01.000 --> 01:54:03.550
E vou apenas inicializar isso para 3 inicialmente.

01:54:03.550 --> 01:54:06.610
E em vez de colocar 3 aqui, vou literalmente usar apenas n.

01:54:06.610 --> 01:54:09.100
Mas o farei nos dois lugares para que agora, doravante,

01:54:09.100 --> 01:54:13.000
se eu quiser mudar isso e mudar para 4, ou 5, ou qualquer outra coisa,

01:54:13.000 --> 01:54:13.845
Eu terminei.

01:54:13.845 --> 01:54:16.720
É melhor projetado porque há uma menor probabilidade de erros.

01:54:16.720 --> 01:54:19.840
Mas eu ainda poderia tecnicamente estragar tudo de alguma forma.

01:54:19.840 --> 01:54:24.460
Eu poderia escrever acidentalmente uma linha de código como n++,

01:54:24.460 --> 01:54:28.360
ou eu poderia apenas mudar o valor dessa variável mesmo que eu não queira

01:54:28.360 --> 01:54:28.985
para sempre mudar.

01:54:28.985 --> 01:54:31.693
E talvez seja porque sou um péssimo programador, copiei/colei errado,

01:54:31.693 --> 01:54:34.240
Estou trabalhando com alguém que não sabe o que n representa,

01:54:34.240 --> 01:54:38.440
Eu posso me defender e defender meu código contra erro humano

01:54:38.440 --> 01:54:41.020
assim, subindo aqui para a linha 5.

01:54:41.020 --> 01:54:44.170
E ao invés de apenas declarar uma variável simples como fizemos no Scratch,

01:54:44.170 --> 01:54:47.360
Posso fortalecer ainda mais meu código, por assim dizer,

01:54:47.360 --> 01:54:50.740
declarando-o como uma constante usando a palavra-chave const.

01:54:50.740 --> 01:54:53.980
Agora, isso é apenas um recurso do C e de algumas outras linguagens

01:54:53.980 --> 01:54:57.220
para protegê-lo contra si mesmo, dizendo proativamente,

01:54:57.220 --> 01:55:02.320
n é uma constante, especificamente o número 5 ou, anteriormente, o número 3.

01:55:02.320 --> 01:55:05.530
Você não pode acidentalmente escrever código em outro lugar que o altere.

01:55:05.530 --> 01:55:08.420
O computador lançará um erro e detectará esse erro.

01:55:08.420 --> 01:55:12.160
Portanto, é apenas uma maneira de programar um pouco mais defensivamente.

01:55:12.160 --> 01:55:13.235
Algumas línguas têm isso.

01:55:13.235 --> 01:55:14.110
Algumas línguas não.

01:55:14.110 --> 01:55:15.970
Mas, em geral, é uma boa prática.

01:55:15.970 --> 01:55:18.790
Isso torna seu código melhor projetado porque é apenas

01:55:18.790 --> 01:55:22.570
como menos vulnerável a erros cometidos por você, colegas ou qualquer outra pessoa

01:55:22.570 --> 01:55:23.570
usando o código.

01:55:23.570 --> 01:55:26.420
Deixe-me mudar isso de volta para 3 apenas para ser nosso padrão.

01:55:26.420 --> 01:55:28.580
Mas agora estou usando n em ambos os lugares.

01:55:28.580 --> 01:55:33.250
E se eu fizer mario, ./mario, voltaremos para onde começamos originalmente.

01:55:33.250 --> 01:55:35.560
Mas o código é um pouco melhor projetado.

01:55:35.560 --> 01:55:37.330
E deixe-me observar isso também.

01:55:37.330 --> 01:55:40.720
Todo esse tempo venho mencionando que a correção é importante.

01:55:40.720 --> 01:55:41.740
O design é importante.

01:55:41.740 --> 01:55:43.700
Há também essa questão de estilo.

01:55:43.700 --> 01:55:46.107
Eu tenho escrito um código bonito deliberadamente,

01:55:46.107 --> 01:55:48.940
se você quiser-- não apenas o realce da sintaxe, que é automático.

01:55:48.940 --> 01:55:52.060
Mas observe que continuo recuando tudo bem.

01:55:52.060 --> 01:55:55.450
Sempre que tenho chaves, como nas linhas 4 e 14,

01:55:55.450 --> 01:55:57.400
tudo é recuado um nível.

01:55:57.400 --> 01:56:01.420
Quando eu tenho chaves adicionais nas linhas 7 e 13,

01:56:01.420 --> 01:56:04.520
tudo está bem recuado também.

01:56:04.520 --> 01:56:09.250
Tecnicamente falando, o computador não se importa com esse tipo de espaço em branco,

01:56:09.250 --> 01:56:10.090
por assim dizer.

01:56:10.090 --> 01:56:12.280
E você poderia realmente fazer uma bagunça das coisas

01:56:12.280 --> 01:56:15.205
assim porque você tem um estranho senso de estilo

01:56:15.205 --> 01:56:17.080
ou apenas porque você está sendo um pouco desleixado.

01:56:17.080 --> 01:56:20.170
Mas esse código ainda está correto.

01:56:20.170 --> 01:56:23.260
Se eu recompilar-- deixe-me abrir a janela do meu terminal--

01:56:23.260 --> 01:56:28.270
make mario, sem erros, ./mario, funciona perfeitamente bem.

01:56:28.270 --> 01:56:30.910
Mas você pode imaginar o quão irritante isso agora

01:56:30.910 --> 01:56:34.693
é ler, certamente para um TA, mas certamente para você no dia seguinte,

01:56:34.693 --> 01:56:36.860
certamente para um colega que precisa ler seu código.

01:56:36.860 --> 01:56:38.020
Este é apenas um estilo ruim.

01:56:38.020 --> 01:56:42.670
Ele ainda funciona e é bem projetado porque você está escrevendo o código

01:56:42.670 --> 01:56:44.230
defensivamente, você está usando uma constante.

01:56:44.230 --> 01:56:46.420
Mas, meu deus, o estilo é atroz.

01:56:46.420 --> 01:56:48.310
Agora, muitas vezes você descobrirá que existem ferramentas

01:56:48.310 --> 01:56:50.440
que podem ajudá-lo a formatar seu código para você

01:56:50.440 --> 01:56:53.710
de maneira consistente com os cursos ou o estilo da empresa.

01:56:53.710 --> 01:56:57.220
Mas esse é o tipo de memória muscular que você também deseja desenvolver com o tempo.

01:56:57.220 --> 01:57:00.940
Aceite estas sugestões do VS Code enquanto ele gera linhas de código para você

01:57:00.940 --> 01:57:03.565
porque está tentando formatar seu código de forma legível.

01:57:03.565 --> 01:57:06.940
E, oh, meu Deus, se e quando você tiver bugs em seu código

01:57:06.940 --> 01:57:08.717
e as coisas nem estão indentadas corretamente,

01:57:08.717 --> 01:57:11.800
não há como você, o humano, ser capaz de envolver sua mente

01:57:11.800 --> 01:57:13.690
o que está acontecendo e onde.

01:57:13.690 --> 01:57:16.060
Você está apenas tornando o problema mais difícil para si mesmo.

01:57:16.060 --> 01:57:21.190
Portanto, adquira o hábito de manifestar um bom estilo também.

01:57:21.190 --> 01:57:24.880
Tudo bem, bem, deixe-me propor que não queremos apenas uma grade de 3 por 3.

01:57:24.880 --> 01:57:26.840
Queremos que seja um pouco mais dinâmico.

01:57:26.840 --> 01:57:32.020
Então, suponha que passamos de uma constante para apenas usar um número inteiro chamado n.

01:57:32.020 --> 01:57:35.230
E vamos perguntar ao usuário o tamanho dessa grade

01:57:35.230 --> 01:57:38.320
como solicitando-os com get_int, como fizemos antes.

01:57:38.320 --> 01:57:40.150
E eu vou armazená-lo em n aqui.

01:57:40.150 --> 01:57:42.880
E então eu posso ir em frente e, de forma mais dinâmica,

01:57:42.880 --> 01:57:46.450
execute o make mario para compilá-lo - opa.

01:57:46.450 --> 01:57:49.930
Oh, eu estraguei tudo acidentalmente.

01:57:49.930 --> 01:57:53.785
O que ele está sugerindo que eu faça, embora enigmaticamente?

01:57:53.785 --> 01:57:56.660
AUDIÊNCIA: Você tem que incluir o cs50.h.

01:57:56.660 --> 01:57:59.930
DAVID J. MALAN: Sim, esqueci de incluir o arquivo de cabeçalho CS50 na parte superior.

01:57:59.930 --> 01:58:03.420
E é por isso que ele não sabe que get_int é, de fato, válido.

01:58:03.420 --> 01:58:04.880
Portanto, é uma solução fácil.

01:58:04.880 --> 01:58:07.730
Vou subir aqui e incluir cs50.h.

01:58:07.730 --> 01:58:10.790
Agora vou limpar meu terminal e executar novamente o make mario.

01:58:10.790 --> 01:58:12.800
Agora estamos bem-- ./mario.

01:58:12.800 --> 01:58:14.550
E agora observe que o tamanho é solicitado.

01:58:14.550 --> 01:58:16.490
Então, se eu digitar 3, é o mesmo de antes.

01:58:16.490 --> 01:58:20.900
Se eu digitar 10, fica ainda maior, mas agora acontece tudo automaticamente.

01:58:20.900 --> 01:58:23.360
Mas há algumas coisas que não estamos detectando.

01:58:23.360 --> 01:58:25.940
Por exemplo, suponha que eu digite cat.

01:58:25.940 --> 01:58:28.770
Bem, isso é tratado pela função get_int, como afirmei anteriormente.

01:58:28.770 --> 01:58:30.687
Essa é uma das características de usar uma biblioteca.

01:58:30.687 --> 01:58:32.570
Você não precisa lidar com entradas incorretas.

01:58:32.570 --> 01:58:36.200
Mas projetamos apenas uma função chamada get_int para obter um número inteiro.

01:58:36.200 --> 01:58:39.050
Não sabemos se você quer que seja positivo, negativo, zero,

01:58:39.050 --> 01:58:40.680
ou alguma combinação dos mesmos.

01:58:40.680 --> 01:58:43.940
E é meio estranho permitir que o usuário digite 1 negativo

01:58:43.940 --> 01:58:48.440
para o tamanho da grade ou menos 3 para o tamanho da grade.

01:58:48.440 --> 01:58:51.230
E, de fato, seu código não faz nada, então pelo menos não está travando.

01:58:51.230 --> 01:58:52.730
Mas isso é meio estúpido, certo?

01:58:52.730 --> 01:58:54.530
Seria bom forçar o usuário se ele quiser

01:58:54.530 --> 01:58:57.150
uma grade para nos dar um valor positivo.

01:58:57.150 --> 01:58:58.530
Então, como poderíamos fazer isso?

01:58:58.530 --> 01:59:03.920
Bem, eu poderia subir aqui e dizer algo como se n for menor que 1 -

01:59:03.920 --> 01:59:08.190
então se for 0 ou negativo, o que eu não quero, o que eu poderia fazer?

01:59:08.190 --> 01:59:12.380
Bem, eu poderia dizer, bem, solicitar novamente ao usuário o tamanho.

01:59:12.380 --> 01:59:16.613
E agora observe, não estou declarando n novamente porque uma vez que existe,

01:59:16.613 --> 01:59:18.530
você não precisa mencionar o tipo de dados novamente.

01:59:18.530 --> 01:59:19.790
Dissemos isso antes.

01:59:19.790 --> 01:59:21.510
Mas isso é meio estúpido.

01:59:21.510 --> 01:59:22.010
Por que?

01:59:22.010 --> 01:59:25.190
Porque agora, quando você deu ao usuário uma segunda chance, OK, agora talvez

01:59:25.190 --> 01:59:29.720
Eu farei-- tudo bem, se esta versão de n for menor que 1, bem,

01:59:29.720 --> 01:59:33.020
vamos apenas solicitar ao usuário uma terceira vez.

01:59:33.020 --> 01:59:35.240
Quero dizer, você pode ver onde isso está indo estupidamente.

01:59:35.240 --> 01:59:38.510
Esta não pode ser a solução certa para continuar digitando recursivamente

01:59:38.510 --> 01:59:39.860
a mesma coisa de novo e de novo.

01:59:39.860 --> 01:59:40.790
Onde isso iria parar?

01:59:40.790 --> 01:59:42.873
Você teria que dar a eles um número finito de chances

01:59:42.873 --> 01:59:44.810
ou apenas bagunçar seu código.

01:59:44.810 --> 01:59:48.170
Então, qual seria intuitivamente uma solução melhor aqui?

01:59:48.170 --> 01:59:49.128
AUDIÊNCIA: Um loop while.

01:59:49.128 --> 01:59:50.920
DAVID J. MALAN: Sim, algum tipo de loop.

01:59:50.920 --> 01:59:52.160
Vimos um loop while.

01:59:52.160 --> 01:59:54.240
Vimos um loop for, então talvez um desses.

01:59:54.240 --> 01:59:55.290
Então deixe-me tentar isso.

01:59:55.290 --> 01:59:58.760
Deixe-me deletar essa bagunça e voltar para a primeira pergunta.

01:59:58.760 --> 01:59:59.790
E deixe-me fazer isso.

01:59:59.790 --> 02:00:02.780
Então, enquanto n é menor que 1 -

02:00:02.780 --> 02:00:05.190
então, embora o número não seja o que queremos -

02:00:05.190 --> 02:00:09.560
vamos apenas solicitar ao usuário em um loop, desta vez, o tamanho novamente.

02:00:09.560 --> 02:00:15.470
Agora, aqui também é melhor porque são apenas dois pedidos de informação.

02:00:15.470 --> 02:00:19.640
Mas, claramente, as linhas 6 e 9 são praticamente idênticas, exceto o int.

02:00:19.640 --> 02:00:23.120
E se eu entrasse e mudasse o tamanho, se eu

02:00:23.120 --> 02:00:26.300
adicione isso, se eu mudar o texto aqui, mude para um idioma diferente,

02:00:26.300 --> 02:00:27.350
Eu tenho que mudar isso em dois lugares.

02:00:27.350 --> 02:00:27.850
Isso é ruim.

02:00:27.850 --> 02:00:29.330
Copiar/colar, ruim.

02:00:29.330 --> 02:00:31.040
Então, o que pode ser melhor?

02:00:31.040 --> 02:00:33.890
Bem, acontece que há outro paradigma em C

02:00:33.890 --> 02:00:37.730
que você pode usar para contornar esse problema, essa duplicação de código.

02:00:37.730 --> 02:00:41.210
Seria muito melhor se eu apenas escrevesse o código uma vez.

02:00:41.210 --> 02:00:45.510
E posso fazer isso usando um terceiro tipo de loop chamado loop do while.

02:00:45.510 --> 02:00:48.000
Acontece que, em C, você pode fazer isso.

02:00:48.000 --> 02:00:50.210
Se você deseja obter o valor de uma variável como n,

02:00:50.210 --> 02:00:53.370
primeiro apenas para criar a variável sem um valor inicial.

02:00:53.370 --> 02:00:56.870
Então int n ponto e vírgula significa que não sabemos qual é o valor, sim.

02:00:56.870 --> 02:00:57.590
Mas tudo bem.

02:00:57.590 --> 02:00:59.840
Nós vamos adicionar um valor a ele eventualmente.

02:00:59.840 --> 02:01:02.870
Então eu vou dizer isso, faça, literalmente.

02:01:02.870 --> 02:01:04.460
Vou abrir minhas chaves.

02:01:04.460 --> 02:01:05.930
E o que eu quero fazer?

02:01:05.930 --> 02:01:09.920
Eu quero atribuir a n o valor de retorno de get_int,

02:01:09.920 --> 02:01:11.750
solicitando o tamanho do usuário.

02:01:11.750 --> 02:01:14.040
Bem, quando você quer fazer isso?

02:01:14.040 --> 02:01:17.900
Eu quero fazer isso enquanto n é menor que 1.

02:01:17.900 --> 02:01:21.410
E esse código agora atinge exatamente o mesmo objetivo,

02:01:21.410 --> 02:01:23.570
mas nunca me repetindo.

02:01:23.570 --> 02:01:24.230
Por que?

02:01:24.230 --> 02:01:29.210
Bem, observe nestas linhas de código agora, estou literalmente dizendo na linha 6,

02:01:29.210 --> 02:01:31.175
dê-me uma variável chamada n do tipo inteiro.

02:01:31.175 --> 02:01:33.300
Não tem um valor inicialmente, mas tudo bem.

02:01:33.300 --> 02:01:34.640
Você pode fazer isso.

02:01:34.640 --> 02:01:36.380
A linha 7 diz, faça o seguinte.

02:01:36.380 --> 02:01:39.890
O que você quer fazer? get_int, solicitando ao usuário o tamanho da palavra,

02:01:39.890 --> 02:01:41.660
e apenas armazene esse valor em n.

02:01:41.660 --> 02:01:45.210
Mas como o código C é executado de cima para baixo, da esquerda para a direita,

02:01:45.210 --> 02:01:49.040
agora é razoável na linha 11 fazer essa pergunta, OK, é

02:01:49.040 --> 02:01:53.670
o valor atual de n, que definitivamente ficou na linha 8, menor que 1?

02:01:53.670 --> 02:01:56.420
E se o usuário não cooperar, ele digita 0, ou 1 negativo,

02:01:56.420 --> 02:01:58.400
ou menos 3-- o que vai acontecer?

02:01:58.400 --> 02:02:02.510
Vai voltar aqui e repetir, repetir, repetir tudo

02:02:02.510 --> 02:02:04.530
no loop do while.

02:02:04.530 --> 02:02:06.438
Então, um loop do while em C--

02:02:06.438 --> 02:02:08.480
o que não é algo que algumas outras línguas têm.

02:02:08.480 --> 02:02:10.730
O Python, se você o conhece, não possui um loop do while.

02:02:10.730 --> 02:02:13.310
Esta é talvez a maneira mais limpa de conseguir isso,

02:02:13.310 --> 02:02:16.790
mesmo que seja um pouco estranho você ter que declarar sua variável,

02:02:16.790 --> 02:02:20.570
crie sua variável no topo e, em seguida, verifique abaixo.

02:02:20.570 --> 02:02:22.980
Mas, caso contrário, é semelhante a um loop while.

02:02:22.980 --> 02:02:26.150
Apenas inverte a ordem em que você está fazendo a pergunta.

02:02:26.150 --> 02:02:28.820
Alguma dúvida sobre essa construção?

02:02:28.820 --> 02:02:30.827
E do while, em geral, é super útil quando

02:02:30.827 --> 02:02:32.660
você deseja obter entrada do usuário e fazer

02:02:32.660 --> 02:02:35.640
certeza de que atende a certos requisitos.

02:02:35.640 --> 02:02:39.530
Então, tudo bem, agora que temos esse bloco de construção após esse interlúdio.

02:02:39.530 --> 02:02:41.750
Como posso limpar esse código?

02:02:41.750 --> 02:02:45.230
E então vamos concluir dando uma olhada nas coisas que nosso código não pode fazer

02:02:45.230 --> 02:02:47.720
ou não pode fazer muito bem ou corretamente.

02:02:47.720 --> 02:02:50.930
Deixe-me propor que em uma versão final do Mario,

02:02:50.930 --> 02:02:53.520
deixe-me apenas adicionar o que são chamados agora de alguns comentários.

02:02:53.520 --> 02:02:56.880
Acontece que, no código em C, você pode definir

02:02:56.880 --> 02:02:59.173
o que são chamados de comentários, que são apenas notas para si mesmo.

02:02:59.173 --> 02:03:00.840
Alguns de vocês descobriram isso no Scratch.

02:03:00.840 --> 02:03:02.590
Há pequenas notas adesivas amarelas que você pode

02:03:02.590 --> 02:03:04.680
use para adicionar citações ou explicações.

02:03:04.680 --> 02:03:07.020
Em C, há algumas maneiras de escrever comentários.

02:03:07.020 --> 02:03:09.960
E, em geral, os comentários são notas para você, para o seu TA,

02:03:09.960 --> 02:03:13.860
para seu colega sobre o que seu código está fazendo e por que ou como.

02:03:13.860 --> 02:03:15.660
É uma pequena nota explicativa em inglês

02:03:15.660 --> 02:03:17.860
ou qualquer que seja a sua linguagem humana.

02:03:17.860 --> 02:03:23.220
Então, por exemplo, o que eu poderia fazer aqui na minha implementação

02:03:23.220 --> 02:03:27.870
desta versão do mario, eu poderia primeiro me fazer uma pergunta como--

02:03:27.870 --> 02:03:30.420
Eu poderia primeiro fazer uma anotação para mim mesmo como esta em uma nova linha,

02:03:30.420 --> 02:03:34.350
acima deste primeiro bloco de código, obtenha o tamanho da grade.

02:03:34.350 --> 02:03:38.100
É apenas uma observação explicativa em qualquer inglês conciso

02:03:38.100 --> 02:03:41.820
que geralmente explica as próximas seis ou mais linhas, o próximo pedaço

02:03:41.820 --> 02:03:43.560
ou bloco de código, se preferir.

02:03:43.560 --> 02:03:46.500
Seria um pouco excessivo comentar cada linha.

02:03:46.500 --> 02:03:49.680
Em algum momento, o programador deve saber o que cada linha de código faz.

02:03:49.680 --> 02:03:53.700
Mas é bom poder dar uma olhada neste comentário na linha 6

02:03:53.700 --> 02:03:56.818
que começa com duas barras e fica cinza

02:03:56.818 --> 02:03:58.110
devido ao realce da sintaxe.

02:03:58.110 --> 02:03:59.070
Não é lógica.

02:03:59.070 --> 02:04:00.440
É apenas uma nota para si mesmo.

02:04:00.440 --> 02:04:02.190
Geralmente me dá uma pequena folha de dicas

02:04:02.190 --> 02:04:05.160
sobre o que as seguintes linhas de código devem fazer e/ou por quê.

02:04:05.160 --> 02:04:07.910
E aqui embaixo, bem, há um segundo bloco de código

02:04:07.910 --> 02:04:08.910
isso é um monte de linhas.

02:04:08.910 --> 02:04:14.130
Mas juntos, isso apenas, o que, imprime grade de tijolos.

02:04:14.130 --> 02:04:16.350
E então é outro comentário para mim mesmo que

02:04:16.350 --> 02:04:18.540
apenas torna um pouco mais compreensível o que

02:04:18.540 --> 02:04:20.880
essas 20 e tantas linhas de código estão fazendo adicionando

02:04:20.880 --> 02:04:23.760
algumas explicações em inglês.

02:04:23.760 --> 02:04:26.970
Mas agora que eu tenho isso, não seria bom

02:04:26.970 --> 02:04:31.140
se eu pudesse abstrair essas partes de funcionalidade, isso

02:04:31.140 --> 02:04:33.600
ficando do tamanho e essa impressão da grade?

02:04:33.600 --> 02:04:37.590
Em outras palavras, suponha que você não saiba por onde começar com esse problema.

02:04:37.590 --> 02:04:39.960
E o problema em questão foi literalmente implementado

02:04:39.960 --> 02:04:43.530
um programa que imprime uma grade de tijolos de algum tamanho variável--

02:04:43.530 --> 02:04:46.440
3, ou 4, ou 5, ou qualquer que seja o tipo humano.

02:04:46.440 --> 02:04:48.810
Se você realmente não tem ideia de por onde começar,

02:04:48.810 --> 02:04:51.540
os comentários são, na verdade, uma boa maneira de obter

02:04:51.540 --> 02:04:55.680
começou porque os comentários podem ser uma aproximação do que chamamos na semana passada

02:04:55.680 --> 02:04:56.310
pseudo-código.

02:04:56.310 --> 02:05:00.360
Pseudocódigo é um inglês conciso que mostra seu ponto de vista, como para o telefone

02:05:00.360 --> 02:05:02.080
pesquisa de livros como da última vez.

02:05:02.080 --> 02:05:04.050
Então, se você realmente não sabia por onde começar,

02:05:04.050 --> 02:05:06.910
você poderia fazer algo assim.

02:05:06.910 --> 02:05:11.730
Eu poderia, por exemplo, apenas dizer: Obtenha o tamanho da grade como meu primeiro passo

02:05:11.730 --> 02:05:14.610
e, em seguida, Imprimir grade de tijolos como minha segunda etapa.

02:05:14.610 --> 02:05:16.410
E é isso para o meu programa até agora.

02:05:16.410 --> 02:05:18.690
Isso agora é implementado em pseudocódigo.

02:05:18.690 --> 02:05:20.910
Eu tenho alguns espaços reservados enormes lá.

02:05:20.910 --> 02:05:22.380
Eu ainda tenho trabalho a ser feito.

02:05:22.380 --> 02:05:26.050
Mas pelo menos tenho uma solução de alto nível para o problema nos comentários.

02:05:26.050 --> 02:05:28.230
E agora eu posso até ir tão longe.

02:05:28.230 --> 02:05:32.010
Eu poderia dizer, bem, vamos supor que já exista apenas uma função

02:05:32.010 --> 02:05:34.650
que existe chamado get size.

02:05:34.650 --> 02:05:36.220
Eu poderia fazer algo assim.

02:05:36.220 --> 02:05:38.790
Eu poderia fazer int n igual a get_size.

02:05:38.790 --> 02:05:41.010
E agora eu só tenho que assumir no momento

02:05:41.010 --> 02:05:43.000
que existe alguma abstração chamada get_size.

02:05:43.000 --> 02:05:43.500
Não.

02:05:43.500 --> 02:05:45.420
Isso não vem com a biblioteca CS50.

02:05:45.420 --> 02:05:47.520
Mas eu poderia inventar, aposto.

02:05:47.520 --> 02:05:49.110
De que outra forma eu poderia proceder?

02:05:49.110 --> 02:05:51.930
Bem, vamos supor por enquanto que também há

02:05:51.930 --> 02:05:57.060
uma função chamada print_grid que apenas imprime uma grade desse tamanho n.

02:05:57.060 --> 02:05:58.950
Portanto, aqui também há uma abstração.

02:05:58.950 --> 02:06:00.330
Essas peças do quebra-cabeça não existem.

02:06:00.330 --> 02:06:01.800
Essas funções ainda não existem.

02:06:01.800 --> 02:06:06.240
Mas em C, assim como no Scratch, posso criar minhas próprias funções.

02:06:06.240 --> 02:06:07.600
Como faço isso?

02:06:07.600 --> 02:06:09.630
Bem, deixe-me descer mais tarde no arquivo.

02:06:09.630 --> 02:06:12.810
E por convenção, você geralmente quer deixar main no início do seu código.

02:06:12.810 --> 02:06:13.110
Por que?

02:06:13.110 --> 02:06:15.235
Porque é a função principal, e é exatamente onde

02:06:15.235 --> 02:06:18.090
o olho humano vai olhar para ver o que algum arquivo de código faz.

02:06:18.090 --> 02:06:19.360
E deixe-me fazer isso.

02:06:19.360 --> 02:06:23.910
Eu quero criar uma função própria chamada get_size cujo propósito na vida

02:06:23.910 --> 02:06:26.010
é obter o tamanho que o usuário deseja.

02:06:26.010 --> 02:06:28.380
Eu quero que esta função retorne um número inteiro.

02:06:28.380 --> 02:06:30.420
E a sintaxe para fazer isso é esta, certo,

02:06:30.420 --> 02:06:34.920
semelhante a uma variável, o tipo de dados que esta função retorna.

02:06:34.920 --> 02:06:37.450
Eu não preciso dessa função para receber nenhuma entrada.

02:06:37.450 --> 02:06:40.500
Vou usar uma nova palavra-chave que estamos usando

02:06:40.500 --> 02:06:42.292
longe-- mais sobre isso em outro momento-- acabei de ligar

02:06:42.292 --> 02:06:45.810
void, o que significa apenas que esta função get_size não aceita nenhuma entrada.

02:06:45.810 --> 02:06:46.950
Ele tem uma saída.

02:06:46.950 --> 02:06:48.138
Ele gera um int.

02:06:48.138 --> 02:06:50.430
E esta é apenas a estranha ordem em que você escreve.

02:06:50.430 --> 02:06:54.000
Você escreve o formato de saída, o nome da função e, em seguida, as entradas,

02:06:54.000 --> 02:06:55.920
se houver, entre parênteses.

02:06:55.920 --> 02:06:57.727
E agora posso implementar get_size.

02:06:57.727 --> 02:06:59.310
Mas eu já implementei get_size.

02:06:59.310 --> 02:07:01.140
Ou pelo menos agora neste ponto da história,

02:07:01.140 --> 02:07:03.180
Eu pelo menos sei concretamente o que fazer.

02:07:03.180 --> 02:07:05.730
E eu poderia descobrir eventualmente, com algumas tentativas e erros

02:07:05.730 --> 02:07:08.040
talvez, tudo bem, se eu declarar uma variável

02:07:08.040 --> 02:07:12.270
e eu faço o seguinte n igual a get_int, solicitando o tamanho do usuário,

02:07:12.270 --> 02:07:17.910
e continuo fazendo isso enquanto n é menor que 1, uma vez que o bloco de código

02:07:17.910 --> 02:07:22.830
é feito, aqui está uma nova palavra-chave em C onde você pode retornar esse valor n.

02:07:22.830 --> 02:07:27.330
Então continuo me referindo a esses valores que algumas funções retornam como valores de retorno.

02:07:27.330 --> 02:07:30.870
Em C, há literalmente uma palavra-chave chamada return

02:07:30.870 --> 02:07:33.930
que retornará a qualquer função que use

02:07:33.930 --> 02:07:36.970
que funcionam o valor em questão.

02:07:36.970 --> 02:07:41.220
Então, em poucas palavras, entre as linhas 15 e 21 agora,

02:07:41.220 --> 02:07:45.270
aqui está um código idêntico à nossa solução anterior que obtém um valor

02:07:45.270 --> 02:07:47.280
n do usuário que é positivo.

02:07:47.280 --> 02:07:48.720
É 1, ou 2, ou superior.

02:07:48.720 --> 02:07:51.180
Não é 0, ou não é menor que 1.

02:07:51.180 --> 02:07:56.360
E assim que obtivermos esse valor, nós o devolvemos como um valor de retorno.

02:07:56.360 --> 02:07:58.990
Observe como estou usando essa função na linha 7.

02:07:58.990 --> 02:08:01.630
Assim como com get_int, assim como com get_string,

02:08:01.630 --> 02:08:04.650
Estou chamando a função-- nada entre parênteses neste caso.

02:08:04.650 --> 02:08:06.400
Mas então estou usando o operador de atribuição

02:08:06.400 --> 02:08:09.970
para copiar qualquer que seja seu valor de retorno para minha variável n.

02:08:09.970 --> 02:08:13.570
E agora eu tenho uma função que não usei

02:08:13.570 --> 02:08:19.090
para existir chamado get_size que me dá um número inteiro positivo, não importa o quê.

02:08:19.090 --> 02:08:21.710
E agora para a grade, como faço isso?

02:08:21.710 --> 02:08:23.860
Como faço para inventar uma função chamada print_grid

02:08:23.860 --> 02:08:27.160
que pega um único argumento, um número e imprime uma grade desse tamanho?

02:08:27.160 --> 02:08:29.180
Bem, vamos descer aqui.

02:08:29.180 --> 02:08:32.050
Vou escrever o nome desta função print_grid.

02:08:32.050 --> 02:08:33.590
Esta função só precisa imprimir.

02:08:33.590 --> 02:08:35.440
Tem um efeito colateral, como sempre dizemos.

02:08:35.440 --> 02:08:38.230
Então, só vou dizer que não tem valor de retorno.

02:08:38.230 --> 02:08:39.040
É apenas vazio.

02:08:39.040 --> 02:08:40.820
Não tem uma saída, por si só.

02:08:40.820 --> 02:08:42.670
É apenas um efeito colateral estético.

02:08:42.670 --> 02:08:44.660
Mas leva em um argumento.

02:08:44.660 --> 02:08:47.830
Um argumento é uma entrada e a sintaxe para isso em C

02:08:47.830 --> 02:08:52.337
é para nomear o tipo de entrada que leva e o nome da variável.

02:08:52.337 --> 02:08:53.920
E eu poderia chamar isso do que eu quiser.

02:08:53.920 --> 02:08:54.940
Vou chamá-lo de tamanho.

02:08:54.940 --> 02:08:56.140
Eu poderia chamá-lo de n.

02:08:56.140 --> 02:08:58.840
E não há problema em usar a mesma variável em diferentes funções,

02:08:58.840 --> 02:09:01.030
mas vou chamá-lo de tamanho apenas para ser distinto.

02:09:01.030 --> 02:09:03.010
E então, nesta função, vou apenas

02:09:03.010 --> 02:09:07.210
para copiar da memória o mesmo código é antes. para int eu recebo 0,

02:09:07.210 --> 02:09:09.250
eu sou menor que o tamanho--

02:09:09.250 --> 02:09:18.790
em vez de 3-- i++, dentro disso, para int j obtém 0, j é menor que o tamanho j++,

02:09:18.790 --> 02:09:23.500
e dentro disso, imprima com printf um único hash,

02:09:23.500 --> 02:09:28.660
imprima depois desse loop uma única nova linha, e é isso.

02:09:28.660 --> 02:09:30.370
Agora, eu fiz isso rápido, admito.

02:09:30.370 --> 02:09:32.860
Mas é o mesmo código que escrevi anteriormente.

02:09:32.860 --> 02:09:34.750
Mas agora, assim como fiz com o Scratch, vamos

02:09:34.750 --> 02:09:36.910
eu apenas apertei Enter arbitrariamente um monte de vezes

02:09:36.910 --> 02:09:39.190
para mover o código fora da vista, fora da mente.

02:09:39.190 --> 02:09:40.900
Agora eu tenho abstrações.

02:09:40.900 --> 02:09:44.350
Eu tenho peças de quebra-cabeça que agora existem chamadas get_size e print_grid,

02:09:44.350 --> 02:09:48.160
sintaxe para a qual leva algum tempo para se acostumar, mas agora eles simplesmente existem.

02:09:48.160 --> 02:09:50.590
Só que preciso fazer uma coisa.

02:09:50.590 --> 02:09:56.260
Porque C é um pouco ingênuo, se eu tentar fazer mario agora e apertar Enter,

02:09:56.260 --> 02:09:59.500
declaração implícita da função get_size é inválida.

02:09:59.500 --> 02:10:03.460
E já vimos isso antes, quando não incluí um arquivo.

02:10:03.460 --> 02:10:06.362
Quando não incluí a biblioteca CS50, get_int não funcionou.

02:10:06.362 --> 02:10:09.070
Mas esse não é o problema aqui porque não é de uma biblioteca.

02:10:09.070 --> 02:10:10.270
Acabei de inventar isso.

02:10:10.270 --> 02:10:12.580
C leva você literalmente.

02:10:12.580 --> 02:10:15.610
E se você definir essas funções na parte inferior do seu arquivo,

02:10:15.610 --> 02:10:18.910
eles não existem na linha 7 ou 10.

02:10:18.910 --> 02:10:20.690
Então eu poderia fazer isso.

02:10:20.690 --> 02:10:23.590
Eu poderia, tudo bem, bem, deixe-me destacar tudo isso,

02:10:23.590 --> 02:10:26.342
corte na minha área de transferência e cole aqui.

02:10:26.342 --> 02:10:27.550
Isso resolveria o problema.

02:10:27.550 --> 02:10:30.280
Eu poderia apenas mover todas essas funções no topo do meu arquivo.

02:10:30.280 --> 02:10:33.380
Isso é irritante porque agora main está na parte inferior do arquivo.

02:10:33.380 --> 02:10:34.930
Vai demorar mais para encontrá-lo.

02:10:34.930 --> 02:10:36.560
Essa não é uma solução limpa.

02:10:36.560 --> 02:10:39.170
Então deixe-me colocá-lo de volta onde estava no fundo.

02:10:39.170 --> 02:10:40.730
E deixe-me fazer isso.

02:10:40.730 --> 02:10:44.110
Esta é a única vez no CS50 e, realmente, na programação C

02:10:44.110 --> 02:10:46.060
onde copiar/colar é razoável.

02:10:46.060 --> 02:10:50.320
Se você copiar e colar a primeira linha de código de cada função

02:10:50.320 --> 02:10:55.000
e, em seguida, termine com um ponto e vírgula, você pode provocar o compilador

02:10:55.000 --> 02:10:58.270
dando apenas uma dica suficiente na parte superior do arquivo

02:10:58.270 --> 02:11:01.010
que, OK, essas funções não existem até mais tarde.

02:11:01.010 --> 02:11:03.190
Mas aqui está uma dica de que eles existirão.

02:11:03.190 --> 02:11:07.660
É assim que você pode convencer o compilador a confiar em você.

02:11:07.660 --> 02:11:11.830
Portanto, essas outras funções ainda podem estar mais abaixo no arquivo, abaixo de main.

02:11:11.830 --> 02:11:14.440
Mas agora, quando eu faço mario--

02:11:14.440 --> 02:11:15.190
Oh droga.

02:11:15.190 --> 02:11:17.260
Oh, eu disse print em vez de printf.

02:11:17.260 --> 02:11:20.860
Esse é o meu mal-- printf.

02:11:20.860 --> 02:11:26.665
Então, se eu fizer mario, ./mario, agora posso digitar 3,

02:11:26.665 --> 02:11:27.790
e estamos de volta aos negócios.

02:11:27.790 --> 02:11:30.190
Agora, este foi um caminho muito pesado em um longo caminho

02:11:30.190 --> 02:11:32.800
para chegar a uma solução muito mais complicada.

02:11:32.800 --> 02:11:35.240
Mas esta solução, em certo sentido, é melhor projetada.

02:11:35.240 --> 02:11:35.740
Por que?

02:11:35.740 --> 02:11:38.050
Porque agora, especialmente sem os comentários,

02:11:38.050 --> 02:11:40.060
Quero dizer, veja como meu código é curto.

02:11:40.060 --> 02:11:42.430
Minha função principal é literalmente duas linhas de código.

02:11:42.430 --> 02:11:42.940
Por que?

02:11:42.940 --> 02:11:46.338
Bem, eu fatorei as coisas suculentas em suas próprias funções.

02:11:46.338 --> 02:11:48.880
E agora, especialmente se estou trabalhando com colegas ou outras pessoas,

02:11:48.880 --> 02:11:52.297
você poderia imaginar dividir grandes programas em partes menores,

02:11:52.297 --> 02:11:54.380
ter pessoas diferentes implementando peças diferentes,

02:11:54.380 --> 02:11:58.750
contanto que todos concordem com antecedência sobre o que essas entradas e saídas

02:11:58.750 --> 02:12:00.410
realmente são.

02:12:00.410 --> 02:12:04.300
Tudo bem, agora vamos considerar o que os computadores podem fazer bem e não tão bem.

02:12:04.300 --> 02:12:07.360
C realmente suporta um monte de operadores, matematicamente,

02:12:07.360 --> 02:12:10.610
através do qual podemos fazer adição e subtração, multiplicação, divisão,

02:12:10.610 --> 02:12:14.025
e até calcular o resto quando você divide um número por outro.

02:12:14.025 --> 02:12:16.900
Na verdade, por que não vamos em frente e usá-los em um programa muito simples

02:12:16.900 --> 02:12:19.130
e fazer nossa própria calculadora?

02:12:19.130 --> 02:12:21.400
Então deixe-me passar aqui para o VS Code.

02:12:21.400 --> 02:12:25.030
Deixe-me criar um novo arquivo chamado calculadora.c.

02:12:25.030 --> 02:12:27.550
E neste arquivo, vamos em frente e primeiro incluir

02:12:27.550 --> 02:12:33.670
alguns arquivos de cabeçalho agora familiares - cs50.h e stdio.h.

02:12:33.670 --> 02:12:37.540
Vamos então declarar main com int main(void).

02:12:37.540 --> 02:12:40.250
E então dentro do main, vamos fazer algo relativamente simples.

02:12:40.250 --> 02:12:42.790
Vamos declarar um int e chamá-lo de x, e definir

02:12:42.790 --> 02:12:45.670
é igual a qualquer que seja o valor de retorno de get int,

02:12:45.670 --> 02:12:48.040
solicitando ao usuário um valor para x.

02:12:48.040 --> 02:12:50.240
Vamos então nos dar uma segunda variável.

02:12:50.240 --> 02:12:51.490
Vamos chamá-lo, digamos, y.

02:12:51.490 --> 02:12:55.230
Defina isso igual ao valor de retorno de outra chamada para get_int,

02:12:55.230 --> 02:12:57.780
solicitando ao usuário, desta vez, esse valor y.

02:12:57.780 --> 02:13:00.360
E então vamos simplesmente prosseguir no final

02:13:00.360 --> 02:13:05.080
e apenas imprima, digamos, a soma de x mais y, uma calculadora super simples.

02:13:05.080 --> 02:13:08.640
Então, usarei printf, aspas/sem aspas, %i para inteiro,

02:13:08.640 --> 02:13:10.930
barra invertida n para me dar a nova linha.

02:13:10.930 --> 02:13:14.640
Então eu vou em frente e faço x mais y para realmente imprimir a soma.

02:13:14.640 --> 02:13:16.710
Deixe-me descer para a janela do meu terminal agora.

02:13:16.710 --> 02:13:20.340
Deixe-me fazer uma calculadora para compilar o código.

02:13:20.340 --> 02:13:22.080
Nenhuma mensagem de erro, então isso é bom.

02:13:22.080 --> 02:13:23.880
Deixe-me fazer ./calculator.

02:13:23.880 --> 02:13:28.500
E vamos fazer algo como 2 mais 2, que, obviamente, deve ser igual a 4.

02:13:28.500 --> 02:13:29.340
E ele faz.

02:13:29.340 --> 02:13:33.660
Mas acontece que às vezes haverá limitações

02:13:33.660 --> 02:13:34.677
contra quem nos chocamos.

02:13:34.677 --> 02:13:36.510
E deixe-me ser um pouco mais ambicioso aqui.

02:13:36.510 --> 02:13:37.890
Deixe-me limpar a janela do meu terminal.

02:13:37.890 --> 02:13:39.990
E deixe-me ir em frente e reexecutar a calculadora novamente.

02:13:39.990 --> 02:13:47.280
E desta vez, vamos, oh, 2 bilhões para x, e vamos digitar o mesmo para y.

02:13:47.280 --> 02:13:49.740
E, claro, agora a resposta de 2 bilhões mais 2 bilhões

02:13:49.740 --> 02:13:52.560
deve, é claro, ser de 4 bilhões.

02:13:52.560 --> 02:13:53.970
E, no entanto, não é.

02:13:53.970 --> 02:13:56.790
Curiosamente, vemos, de todas as coisas, um número negativo

02:13:56.790 --> 02:14:00.060
aqui, o que sugere que, de alguma forma, o operador de mais não

02:14:00.060 --> 02:14:02.070
funcionar tão bem quanto gostaríamos.

02:14:02.070 --> 02:14:04.240
Agora, por que isso pode realmente ser?

02:14:04.240 --> 02:14:07.770
Bem, acontece que dentro do seu computador está, é claro, a memória, ou RAM,

02:14:07.770 --> 02:14:08.850
Memória de acesso aleatório.

02:14:08.850 --> 02:14:11.160
E dependendo do tamanho do seu computador e do tipo de computador,

02:14:11.160 --> 02:14:13.410
pode muito bem parecer algo assim -

02:14:13.410 --> 02:14:15.930
uma pequena placa de circuito com esses pequenos módulos pretos

02:14:15.930 --> 02:14:19.320
que realmente contém todos os bytes da memória do seu computador.

02:14:19.320 --> 02:14:22.200
Infelizmente, você e eu só temos uma quantidade finita

02:14:22.200 --> 02:14:25.080
desta memória dentro de nossos computadores, que

02:14:25.080 --> 02:14:27.250
significa que não importa o quão alto queremos contar,

02:14:27.250 --> 02:14:29.670
em última análise, haverá uma limitação de quão alto nós

02:14:29.670 --> 02:14:32.790
podemos contar porque temos apenas uma quantidade finita de memória.

02:14:32.790 --> 02:14:35.800
Não temos um número infinito de zeros e uns para brincar.

02:14:35.800 --> 02:14:38.640
Nós temos que realmente ser limitados em última instância.

02:14:38.640 --> 02:14:40.072
Então, qual é a implicação disso?

02:14:40.072 --> 02:14:42.030
Bem, acontece que os computadores normalmente usam

02:14:42.030 --> 02:14:46.110
até 32 bits em zeros ou uns para representar algo

02:14:46.110 --> 02:14:48.120
como um inteiro, ou em C, em int.

02:14:48.120 --> 02:14:50.010
Assim, por exemplo, o menor número que poderíamos

02:14:50.010 --> 02:14:53.830
represente usando 32 ints, claro, usando 32 bits, claro,

02:14:53.830 --> 02:14:55.020
seria zero--

02:14:55.020 --> 02:14:56.970
32 zeros assim aqui.

02:14:56.970 --> 02:14:59.100
E o maior número que poderíamos representar

02:14:59.100 --> 02:15:03.180
é trocando todos esses zeros por uns, que, neste caso,

02:15:03.180 --> 02:15:07.200
idealmente nos dará um número que equivale a aproximadamente 4 bilhões no total.

02:15:07.200 --> 02:15:15.390
Na verdade, é 4.294.967.295 no máximo se você definir todos os 32 desses bits como um

02:15:15.390 --> 02:15:17.160
e, em seguida, faça a matemática real.

02:15:17.160 --> 02:15:20.520
O problema, porém, é que nós, humanos e computadores em geral,

02:15:20.520 --> 02:15:24.730
às vezes também deseja e precisa ser capaz de representar números negativos.

02:15:24.730 --> 02:15:28.230
Então, se você quiser representar números negativos, bem como números positivos

02:15:28.230 --> 02:15:30.960
em 0, você não pode simplesmente começar a contar em 0

02:15:30.960 --> 02:15:33.360
e ir até cerca de 4 bilhões.

02:15:33.360 --> 02:15:35.280
Você tem que dividir a diferença e talvez

02:15:35.280 --> 02:15:39.390
aloque metade desses padrões de zeros e dois números negativos

02:15:39.390 --> 02:15:41.890
e a outra metade aproximadamente para números positivos.

02:15:41.890 --> 02:15:46.260
Na verdade, na prática, quando você usa até 32 bits,

02:15:46.260 --> 02:15:49.740
o mais alto que a maioria dos computadores poderia contar, certamente em um programa como este em C

02:15:49.740 --> 02:15:52.500
usando um int, seria aproximadamente 2 bilhões.

02:15:52.500 --> 02:15:57.180
Isso é 2.147.483.647.

02:15:57.180 --> 02:15:59.880
Mas o outro lado disso é que também poderíamos agora,

02:15:59.880 --> 02:16:03.420
usando diferentes padrões de bits, representam números negativos tão baixos

02:16:03.420 --> 02:16:06.630
como 2 bilhões negativos, mais ou menos.

02:16:06.630 --> 02:16:09.240
Mas a implicação então, é claro, é que se apenas

02:16:09.240 --> 02:16:13.530
têm um número finito de bits e só podem contar até certo ponto,

02:16:13.530 --> 02:16:16.360
vamos ficar sem bits, por assim dizer.

02:16:16.360 --> 02:16:20.280
Em outras palavras, encontramos o que geralmente é conhecido como estouro de número inteiro

02:16:20.280 --> 02:16:23.080
onde você deseja usar mais bits do que os disponíveis.

02:16:23.080 --> 02:16:26.767
E como resultado, você transborda o espaço disponível.

02:16:26.767 --> 02:16:28.600
O que isso significa, de fato, em termos reais?

02:16:28.600 --> 02:16:30.683
Bem, vamos supor que você tenha apenas três bits,

02:16:30.683 --> 02:16:32.910
mas vou esmaecer uma quarta parte apenas

02:16:32.910 --> 02:16:37.080
para transmitir onde gostaríamos de colocar um bit adicional no final das contas.

02:16:37.080 --> 02:16:40.230
Se isso, é claro, for 0, por discussão da semana 0,

02:16:40.230 --> 02:16:45.360
isso é 1, 2, 3, 4, 5, 6, 7.

02:16:45.360 --> 02:16:50.100
Agora, idealmente, em binário, se você quiser adicionar mais um a esse valor 7,

02:16:50.100 --> 02:16:53.070
você vai ter que carregar o 1 matematicamente,

02:16:53.070 --> 02:16:56.250
e isso daria idealmente 1000.

02:16:56.250 --> 02:17:00.420
Mas se você não tiver quatro bits e seu computador for sofisticado o suficiente

02:17:00.420 --> 02:17:03.270
ter três bits, nem mesmo 32, mas três,

02:17:03.270 --> 02:17:07.799
a implicação é que você está efetivamente representando não 1000,

02:17:07.799 --> 02:17:10.620
mas sim, 000.

02:17:10.620 --> 02:17:13.770
Simplesmente não há espaço para armazenar o quarto bit

02:17:13.770 --> 02:17:17.850
que eu esmaguei aqui, o que significa que seu número inteiro pode estourar.

02:17:17.850 --> 02:17:21.540
E assim que chegar a 7, o próximo número depois de adicionar 1

02:17:21.540 --> 02:17:24.299
na verdade será 0, ou pior, como vimos aqui

02:17:24.299 --> 02:17:27.129
no meu código, um valor negativo.

02:17:27.129 --> 02:17:30.209
Então, o que poderíamos fazer para talvez abordar esse tipo de preocupação?

02:17:30.209 --> 02:17:32.490
Bem, C não tem apenas inteiros ou ints.

02:17:32.490 --> 02:17:34.559
Também possui longs, que, como o nome sugere,

02:17:34.559 --> 02:17:38.469
são apenas números inteiros mais longos, o que significa que eles têm mais bits disponíveis para eles.

02:17:38.469 --> 02:17:40.080
Então deixe-me voltar para o meu código aqui.

02:17:40.080 --> 02:17:41.430
Vou limpar a janela do terminal.

02:17:41.430 --> 02:17:43.590
E deixe-me ir em frente e mudar meus números inteiros para

02:17:43.590 --> 02:17:47.010
literalmente longo aqui, longo aqui.

02:17:47.010 --> 02:17:51.600
vou ter que mudar minha função na biblioteca do CS50

02:17:51.600 --> 02:17:53.228
não ser get_int, mas get_long.

02:17:53.228 --> 02:17:55.770
E essa é de fato outra função que fornecemos na biblioteca.

02:17:55.770 --> 02:17:57.809
Deixe-me mudar este get_int para get_long também.

02:17:57.809 --> 02:18:01.480
Manterei meus nomes de variáveis ​​iguais, mas preciso fazer outra alteração.

02:18:01.480 --> 02:18:05.190
Acontece que printf também suporta outros códigos de formato--

02:18:05.190 --> 02:18:09.629
então não apenas %i para números inteiros ou %s para strings, mas também, por exemplo,

02:18:09.629 --> 02:18:15.780
%li para um inteiro longo, bem como %f para valores de ponto flutuante com

02:18:15.780 --> 02:18:16.379
decimais.

02:18:16.379 --> 02:18:20.280
Então, com isso dito, vamos em frente e mudar minha linha printf para não ser %i,

02:18:20.280 --> 02:18:21.690
mas %li.

02:18:21.690 --> 02:18:26.219
Agora deixe-me ir em frente e fazer a calculadora novamente, Enter--

02:18:26.219 --> 02:18:29.160
sem erros aparentes agora-- ./calculator.

02:18:29.160 --> 02:18:31.740
E 2 mais 2 ainda é igual a 4 como antes.

02:18:31.740 --> 02:18:36.910
Mas agora se eu fizer a calculadora de novo, e vamos fazer 2 bilhões

02:18:36.910 --> 02:18:41.170
novamente, bem como 2 bilhões para y, anteriormente, nós

02:18:41.170 --> 02:18:44.629
transbordou o tamanho de um inteiro e obteve algum número negativo estranho

02:18:44.629 --> 02:18:47.830
porque o padrão foi mal interpretado, por assim dizer, como um número negativo

02:18:47.830 --> 02:18:48.340
em vez de.

02:18:48.340 --> 02:18:51.340
Mas um longo, em vez de usar 32 bits, convencionalmente

02:18:51.340 --> 02:18:55.240
usa 64 bits, o que significa que temos bits sobressalentes mais do que suficientes

02:18:55.240 --> 02:18:57.850
para ir quando adicionarmos 2 bilhões mais 2 bilhões.

02:18:57.850 --> 02:19:01.190
E agora, de fato, obtemos a resposta correta de 4 bilhões,

02:19:01.190 --> 02:19:04.840
que cabe dentro do tamanho de um longo.

02:19:04.840 --> 02:19:07.459
Agora, um longo pode contar bem alto.

02:19:07.459 --> 02:19:12.340
E, de fato, pode contar até isso, 9 quintilhões.

02:19:12.340 --> 02:19:14.889
E isso nos dará um pouco mais de pista.

02:19:14.889 --> 02:19:17.837
Mas, é claro, também será finito.

02:19:17.837 --> 02:19:20.170
Portanto, se você tiver números que precisam ser maiores do que isso,

02:19:20.170 --> 02:19:22.930
você ainda pode muito bem ter um problema.

02:19:22.930 --> 02:19:25.430
Agora, há outro problema que podemos encontrar também.

02:19:25.430 --> 02:19:28.660
E podemos ver isso no contexto desta simples calculadora.

02:19:28.660 --> 02:19:32.520
Os computadores também sofrem potencialmente do que é chamado de truncamento,

02:19:32.520 --> 02:19:35.770
onde especialmente quando você está fazendo matemática envolvendo valores de ponto flutuante - isso

02:19:35.770 --> 02:19:40.420
são números com decimais - você pode truncar acidentalmente sem saber

02:19:40.420 --> 02:19:43.610
o valor-- que é perder tudo após o ponto decimal.

02:19:43.610 --> 02:19:45.549
Então, na verdade, deixe-me voltar ao VS Code aqui.

02:19:45.549 --> 02:19:46.900
Vou limpar a janela do meu terminal.

02:19:46.900 --> 02:19:49.630
E ainda vamos usar longs, mas vamos em frente e usar

02:19:49.630 --> 02:19:52.520
divisão em vez de adição aqui.

02:19:52.520 --> 02:19:55.090
Deixe-me mudar este sinal de adição para um operador de divisão.

02:19:55.090 --> 02:19:59.020
Deixe-me ir em frente e recompilar o código aqui com a calculadora make.

02:19:59.020 --> 02:20:02.620
Deixe-me ir em frente e executar ./calculator, e deixe-me ir em frente e fazer algo

02:20:02.620 --> 02:20:06.370
como 1 para x e 3 para y.

02:20:06.370 --> 02:20:07.547
E veremos isso--

02:20:07.547 --> 02:20:08.380
bem, espere um minuto.

02:20:08.380 --> 02:20:11.500
1 dividido por 3, aprendi, deve ser 1/3.

02:20:11.500 --> 02:20:18.348
Mas em um valor de ponto flutuante, deve ser 0,33333, talvez

02:20:18.348 --> 02:20:20.140
com uma pequena linha sobre ele na escola primária,

02:20:20.140 --> 02:20:21.890
mas, realmente, um número infinito de três.

02:20:21.890 --> 02:20:26.140
E, no entanto, parece que perdemos até mesmo um desses três após o ponto decimal

02:20:26.140 --> 02:20:30.040
porque a resposta está voltando aqui como apenas 0.

02:20:30.040 --> 02:20:31.700
Então, por que isso pode ser?

02:20:31.700 --> 02:20:35.740
Bem, se eu sei que dois números inteiros, quando divididos um pelo outro,

02:20:35.740 --> 02:20:38.920
deve me dar uma fração, um valor de ponto flutuante

02:20:38.920 --> 02:20:42.640
com um ponto decimal, não posso continuar a usar números inteiros ou mesmo,

02:20:42.640 --> 02:20:46.370
neste caso, longs, que não possuem suporte para casas decimais.

02:20:46.370 --> 02:20:51.040
Então deixe-me ir em frente e mudar este código de formato aqui de %li para %f,

02:20:51.040 --> 02:20:55.090
que, novamente, representará um valor de ponto flutuante em vez de um longo

02:20:55.090 --> 02:20:56.560
inteiro ou mesmo um inteiro.

02:20:56.560 --> 02:21:03.400
E deixe-me prosseguir e definir talvez uma terceira variável, z, como um float

02:21:03.400 --> 02:21:04.100
em si.

02:21:04.100 --> 02:21:07.300
Então eu vou me dar uma variável z igual a x dividido por y.

02:21:07.300 --> 02:21:10.720
E agora, em vez de imprimir x dividido por y, vamos imprimir z.

02:21:10.720 --> 02:21:13.060
Agora estou operando em um mundo de valores de ponto flutuante

02:21:13.060 --> 02:21:17.230
porque eu proativamente que um long ou um int dividido

02:21:17.230 --> 02:21:20.260
por outro tal valor, se for para ter uma fração,

02:21:20.260 --> 02:21:24.710
precisa ser armazenado em um valor de ponto flutuante, algo com um ponto decimal.

02:21:24.710 --> 02:21:27.730
Bem, deixe-me ir até a janela do meu terminal aqui e executar novamente o make

02:21:27.730 --> 02:21:31.120
de calculadora-- parece funcionar bem-- ./calculator,

02:21:31.120 --> 02:21:34.180
e vamos fazer 1 dividido por 3 novamente.

02:21:34.180 --> 02:21:36.868
E ainda aqui, vemos todos os zeros.

02:21:36.868 --> 02:21:39.910
Portanto, vemos pelo menos um ponto decimal, então fizemos algum progresso. Obrigado

02:21:39.910 --> 02:21:41.350
para o %f e o float.

02:21:41.350 --> 02:21:46.570
Mas parece que já truncamos o valor 1 dividido por 3.

02:21:46.570 --> 02:21:48.520
Então, como realmente contornamos esse problema?

02:21:48.520 --> 02:21:50.050
Bem, se você, o programador, sabe que é

02:21:50.050 --> 02:21:52.467
lidando com um mundo que vai te dar ponto flutuante

02:21:52.467 --> 02:21:54.760
valores com pontos decimais, você pode muito bem

02:21:54.760 --> 02:21:57.340
precisa usar o que é chamado de recurso conhecido

02:21:57.340 --> 02:22:02.050
como typecasting-- que é converter um tipo de dados para outro explicitamente

02:22:02.050 --> 02:22:04.390
dizendo ao compilador que você deseja fazer isso.

02:22:04.390 --> 02:22:05.480
Agora, como faço isso?

02:22:05.480 --> 02:22:07.100
Bem, vamos voltar ao meu código aqui.

02:22:07.100 --> 02:22:11.260
E se a questão fundamentalmente é que C ainda é

02:22:11.260 --> 02:22:14.920
tratando x e y como inteiros-- ou tecnicamente,

02:22:14.920 --> 02:22:18.310
longs sem ponto decimal - e dividindo um pelo outro,

02:22:18.310 --> 02:22:22.330
portanto, não há espaço, por assim dizer, para quaisquer números após um ponto decimal,

02:22:22.330 --> 02:22:24.830
por que não faço isso proativamente?

02:22:24.830 --> 02:22:28.030
Deixe-me, usando uma sintaxe ligeiramente nova com parênteses,

02:22:28.030 --> 02:22:33.910
especifique que desejo converter x proativamente de long para float.

02:22:33.910 --> 02:22:39.100
Deixe-me especificar proativamente que desejo converter y de long para float

02:22:39.100 --> 02:22:39.950
também.

02:22:39.950 --> 02:22:42.910
E agora deixe-me seguir em frente e confiar nisso nz

02:22:42.910 --> 02:22:46.870
deve ser o resultado da divisão de not a long por long ou int por int,

02:22:46.870 --> 02:22:49.330
mas sim, um flutuador por um flutuador.

02:22:49.330 --> 02:22:52.630
Deixe-me limpar a janela do meu terminal, execute o makecalculator novamente--

02:22:52.630 --> 02:22:55.300
parece funcionar bem-- ./calculator.

02:22:55.300 --> 02:23:00.760
E agora 1, 3, e esperamos que agora realmente vejamos

02:23:00.760 --> 02:23:05.380
que meu código gerou 0,333333.

02:23:05.380 --> 02:23:08.380
E acho que se continuássemos mostrando mais números depois da vírgula,

02:23:08.380 --> 02:23:11.710
Teoricamente, veríamos quantos desses três quisermos.

02:23:11.710 --> 02:23:13.900
Mas ainda há mais uma captura.

02:23:13.900 --> 02:23:16.240
E especialmente quando estamos manipulando números

02:23:16.240 --> 02:23:19.090
desta forma em um computador usando uma quantidade finita de memória,

02:23:19.090 --> 02:23:22.180
outro desafio que podemos enfrentar - além de números inteiros

02:23:22.180 --> 02:23:27.100
estouro, além de truncamento-- isso é conhecido como imprecisão de ponto flutuante.

02:23:27.100 --> 02:23:31.480
Assim como não podemos representar um inteiro tão grande quanto queremos usando int

02:23:31.480 --> 02:23:34.060
ou muito tempo sozinho porque haverá um limite superior,

02:23:34.060 --> 02:23:39.220
Da mesma forma, haverá um limite de quão precisos nossos números podem ser.

02:23:39.220 --> 02:23:41.560
E, de fato, vamos voltar ao VS Code aqui.

02:23:41.560 --> 02:23:43.430
Vou limpar a janela do meu terminal mais uma vez.

02:23:43.430 --> 02:23:46.900
E desta vez, deixe-me usar uma sintaxe ligeiramente improvável para especificar que eu

02:23:46.900 --> 02:23:49.970
não quer ver o número padrão de números após o ponto decimal,

02:23:49.970 --> 02:23:52.250
que %f nos dá automaticamente.

02:23:52.250 --> 02:23:57.520
Vamos em frente e me mostre 20 números decimais após o ponto decimal.

02:23:57.520 --> 02:24:00.700
E a sintaxe estranha para isso é não %f,

02:24:00.700 --> 02:24:05.950
mas %.20 para indicar para ver que eu quero ver 20 dígitos,

02:24:05.950 --> 02:24:08.440
não é o padrão depois, agora, do ponto decimal.

02:24:08.440 --> 02:24:10.390
Deixe-me executar novamente a calculadora.

02:24:10.390 --> 02:24:12.550
Deixe-me fazer ./calculator novamente.

02:24:12.550 --> 02:24:14.890
E vamos fazer 1, vamos fazer 3.

02:24:14.890 --> 02:24:17.560
E agora isso é ainda mais estranho, certo?

02:24:17.560 --> 02:24:20.590
Na escola primária, você presumivelmente aprendeu que 1 dividido por 3

02:24:20.590 --> 02:24:21.580
é, claro, 1/3.

02:24:21.580 --> 02:24:26.890
Mas isso deveria ser 0,33333, infinitas vezes, ou, no papel,

02:24:26.890 --> 02:24:28.180
com uma pequena linha sobre ele.

02:24:28.180 --> 02:24:31.660
Mas o computador está fazendo uma aproximação estranha aqui.

02:24:31.660 --> 02:24:37.480
É um monte de 3 e depois 4326744079590.

02:24:37.480 --> 02:24:39.380
Bem, o que realmente está acontecendo sob o capô,

02:24:39.380 --> 02:24:42.100
bem, novamente, é essa questão de imprecisão de ponto flutuante.

02:24:42.100 --> 02:24:45.220
Se você tiver apenas um número finito de bits e, por sua vez,

02:24:45.220 --> 02:24:48.100
uma quantidade finita de memória, o computador só pode realmente

02:24:48.100 --> 02:24:52.300
ser tão preciso intuitivamente.

02:24:52.300 --> 02:24:55.000
Equivalentemente, o computador é decidido de alguma forma

02:24:55.000 --> 02:24:57.190
de representar valores de ponto flutuante.

02:24:57.190 --> 02:24:59.470
Mas o problema é que, de acordo com a matemática da escola primária, há

02:24:59.470 --> 02:25:02.800
um número infinito de números lá fora e um número infinito

02:25:02.800 --> 02:25:06.460
de valores de ponto flutuante porque você pode continuar adicionando mais e mais dígitos se você

02:25:06.460 --> 02:25:07.040
querer.

02:25:07.040 --> 02:25:10.120
Assim, o computador, dada a forma como está implementando esses pontos flutuantes

02:25:10.120 --> 02:25:14.500
valores, está essencialmente nos dando a aproximação mais próxima possível.

02:25:14.500 --> 02:25:17.740
Agora, como podemos melhorar a situação?

02:25:17.740 --> 02:25:19.180
Bem, há uma alternativa.

02:25:19.180 --> 02:25:21.115
Em vez de usar float, posso usar algo

02:25:21.115 --> 02:25:22.990
chamado de duplo, que, como o nome sugere,

02:25:22.990 --> 02:25:24.760
usa o dobro de bits que um float.

02:25:24.760 --> 02:25:27.820
Então, em vez de 32 normalmente, ele usará 64.

02:25:27.820 --> 02:25:30.570
E isso é como a diferença entre um long e um int,

02:25:30.570 --> 02:25:31.570
que nos deu mais bits.

02:25:31.570 --> 02:25:34.480
Mas, neste caso, isso será usado para maior precisão.

02:25:34.480 --> 02:25:36.850
Vamos em frente e converter x para um duplo.

02:25:36.850 --> 02:25:38.740
Vamos converter y para um duplo.

02:25:38.740 --> 02:25:41.530
E agora vamos em frente e, usando o mesmo código de formato--

02:25:41.530 --> 02:25:45.220
%.20f ainda está OK para duplas.

02:25:45.220 --> 02:25:46.990
Deixe-me fazer uma calculadora.

02:25:46.990 --> 02:25:48.970
Deixe-me fazer ./calculator.

02:25:48.970 --> 02:25:51.460
E agora deixe-me fazer 1 dividido por 3.

02:25:51.460 --> 02:25:53.770
E ainda temos um pouco dessa imprecisão.

02:25:53.770 --> 02:25:56.590
E é ainda mais se olharmos para mais do que apenas 20 dígitos.

02:25:56.590 --> 02:25:59.900
Mas agora temos mais três após a vírgula.

02:25:59.900 --> 02:26:03.640
Portanto, é pelo menos mais, e mais, e mais preciso, mas não é perfeito.

02:26:03.640 --> 02:26:06.520
Mas é pelo menos mais preciso.

02:26:06.520 --> 02:26:08.500
Então, esses tipos de questões vão

02:26:08.500 --> 02:26:10.360
ser necessário ter em mente sempre que você

02:26:10.360 --> 02:26:12.640
fazer algo numericamente, cientificamente, pelo menos

02:26:12.640 --> 02:26:14.980
com uma linguagem C onde você vai bater

02:26:14.980 --> 02:26:18.910
contra essas limitações do mundo real de hardware e, por sua vez, linguagem.

02:26:18.910 --> 02:26:21.952
Agora, no final do semestre, faremos a transição para uma linguagem chamada Python.

02:26:21.952 --> 02:26:24.660
E isso vai resolver pelo menos um desses problemas

02:26:24.660 --> 02:26:26.950
para nós apenas nos dando automaticamente mais bits,

02:26:26.950 --> 02:26:29.470
por assim dizer, como precisamos deles, pelo menos para números inteiros.

02:26:29.470 --> 02:26:33.140
Mas mesmo a questão da imprecisão do ponto flutuante permanecerá.

02:26:33.140 --> 02:26:35.170
Agora, quão reais são esses problemas?

02:26:35.170 --> 02:26:37.780
Bem, no ano de 1999, experimentamos

02:26:37.780 --> 02:26:40.840
disso quando o mundo percebeu nos anos que antecederam aquela data

02:26:40.840 --> 02:26:45.010
que talvez não tenha sido a melhor ideia implementar computadores

02:26:45.010 --> 02:26:48.910
e software nele armazenando engrenagens usando apenas dois dígitos.

02:26:48.910 --> 02:26:53.440
Como, em vez de armazenar 1999 para representar o ano de 1999,

02:26:53.440 --> 02:26:56.470
muitos computadores, por questões de espaço e custo,

02:26:56.470 --> 02:26:59.200
tinham o hábito de cortar uma esquina e apenas usar

02:26:59.200 --> 02:27:01.400
dois dígitos para acompanhar o ano.

02:27:01.400 --> 02:27:06.850
O problema é que se os sistemas não fossem atualizados até o ano de 1999

02:27:06.850 --> 02:27:11.560
para apoiar o ano de 2000, 2001 e assim por diante, é que, assim como antes

02:27:11.560 --> 02:27:14.290
com estouro de número inteiro, alguns computadores podem

02:27:14.290 --> 02:27:16.990
adicione 1 ao ano em sua memória, '99.

02:27:16.990 --> 02:27:19.540
Deveria ser o ano 2000, mas se forem apenas

02:27:19.540 --> 02:27:22.090
usando dois dígitos para representar anos, eles

02:27:22.090 --> 02:27:25.330
pode confundir o ano-- como alguns sistemas podem muito bem ter--

02:27:25.330 --> 02:27:28.390
para o ano de 1900, tomando literalmente

02:27:28.390 --> 02:27:30.740
um grande passo para trás, se você quiser.

02:27:30.740 --> 02:27:32.622
Agora, você gostaria de pensar que esse tipo de problema

02:27:32.622 --> 02:27:34.330
está atrás de nós, especialmente quando entendemos

02:27:34.330 --> 02:27:37.240
ainda mais sobre as limitações de código e computação.

02:27:37.240 --> 02:27:40.390
Mas, na verdade, vamos nos deparar com esse mesmo tipo de problema

02:27:40.390 --> 02:27:42.160
novamente em poucos anos.

02:27:42.160 --> 02:27:48.850
Em 19 de janeiro de 2038, teremos esgotado os bits na maioria dos computadores

02:27:48.850 --> 02:27:50.800
agora para acompanhar o tempo.

02:27:50.800 --> 02:27:55.330
Acontece que, anos atrás, os humanos decidiram usar um número inteiro de 32 bits

02:27:55.330 --> 02:27:58.870
para manter o controle de quantos segundos se passaram ao longo do tempo.

02:27:58.870 --> 02:28:01.090
Eles escolheram uma data um tanto arbitrária no passado--

02:28:01.090 --> 02:28:03.350
1º de janeiro de 1970 -

02:28:03.350 --> 02:28:06.860
E eles começaram a contar os segundos a partir daí.

02:28:06.860 --> 02:28:09.100
E assim, se um computador armazena algum número de segundos,

02:28:09.100 --> 02:28:11.350
que diz ao computador quantos segundos

02:28:11.350 --> 02:28:14.710
passou desde aquela data específica, 1º de janeiro de 1970.

02:28:14.710 --> 02:28:17.380
Infelizmente, usando um inteiro de 32 bits, como vimos

02:28:17.380 --> 02:28:20.480
visto, você só pode contar tão alto, em que ponto,

02:28:20.480 --> 02:28:23.470
você ultrapassa o tamanho dessa variável.

02:28:23.470 --> 02:28:27.250
E potencialmente, se não nos anteciparmos a isso como humanos, como sociedade,

02:28:27.250 --> 02:28:32.080
como cientistas da computação, na data de 19 de janeiro de 2038,

02:28:32.080 --> 02:28:36.910
esse bit pode virar, transbordando o tamanho desses inteiros,

02:28:36.910 --> 02:28:42.460
trazendo-nos de volta computacionalmente para 13 de dezembro de 1901.

02:28:42.460 --> 02:28:45.970
Então, isso quer dizer agora, com toda essa capacidade computacional e código

02:28:45.970 --> 02:28:48.560
vem a responsabilidade de realmente escrever o código correto.

02:28:48.560 --> 02:28:50.560
Na próxima semana, vamos descascar algumas dessas camadas.

02:28:50.560 --> 02:28:54.550
Mas, por enquanto, esta foi a semana 1 e boa sorte no conjunto de problemas 1.

02:28:54.550 --> 02:28:57.850
[APLAUSOS]

02:28:57.850 --> 02:29:01.500
[MÚSICA, TOCANDO]