WEBVTT

00:00:02.982 --> 00:00:06.461
[MÚSICA, TOCANDO]

00:01:12.065 --> 00:01:13.210
DAVID MALAN: Tudo bem.

00:01:13.210 --> 00:01:18.700
Este é o CS50, e esta é a sexta semana, quando finalmente fazemos a transição

00:01:18.700 --> 00:01:20.935
do Scratch para C para, agora, Python.

00:01:20.935 --> 00:01:22.735
E, de fato, isso vai ser um pouco

00:01:22.735 --> 00:01:27.370
de uma experiência única nisso, assim como algumas semanas atrás -

00:01:27.370 --> 00:01:30.605
talvez, pela primeira vez - e agora, hoje, você está

00:01:30.605 --> 00:01:31.855
vai aprender um novo idioma.

00:01:31.855 --> 00:01:35.935
Mas o objetivo não é apenas lançar mais uma mangueira de incêndio de conteúdo e sintaxe

00:01:35.935 --> 00:01:39.568
e tudo mais para você, mas sim, para realmente equipar todos vocês para realmente ensinar

00:01:39.568 --> 00:01:41.110
você mesmo novos idiomas no futuro.

00:01:41.110 --> 00:01:43.902
E então, de fato, o que faremos hoje, o que faremos na próxima semana

00:01:43.902 --> 00:01:46.580
é prepará-lo para ficar por conta própria.

00:01:46.580 --> 00:01:48.527
E uma vez que o Python é ultrapassado e o mundo tem

00:01:48.527 --> 00:01:50.860
passou para algum outro idioma em alguns anos,

00:01:50.860 --> 00:01:52.568
você estará bem equipado para descobrir como

00:01:52.568 --> 00:01:55.027
para envolver sua mente em alguma nova sintaxe, alguma nova linguagem

00:01:55.027 --> 00:01:56.280
e resolver problemas também.

00:01:56.280 --> 00:01:59.320
Agora, você se lembra, na semana zero, foi aqui que começamos...

00:01:59.320 --> 00:02:01.390
apenas dizendo olá para o mundo.

00:02:01.390 --> 00:02:03.850
E isso aumentou rapidamente apenas uma semana depois em C

00:02:03.850 --> 00:02:06.250
ser algo muito, muito mais enigmático.

00:02:06.250 --> 00:02:09.234
E se você ainda tiver dificuldades com parte da sintaxe,

00:02:09.234 --> 00:02:11.723
encontre-se verificando suas anotações ou seu código anterior,

00:02:11.723 --> 00:02:12.640
isso é totalmente normal.

00:02:12.640 --> 00:02:16.675
E essa é uma das razões pelas quais existem linguagens além de C

00:02:16.675 --> 00:02:18.970
por aí-- entre eles, esta linguagem chamada Python.

00:02:18.970 --> 00:02:21.520
Os seres humanos ao longo das décadas perceberam, caramba,

00:02:21.520 --> 00:02:25.167
essa não foi necessariamente a melhor decisão de design, ou os humanos perceberam, uau,

00:02:25.167 --> 00:02:25.750
Você sabe o que?

00:02:25.750 --> 00:02:30.160
Agora que os computadores ficaram mais rápidos com mais memória e CPUs mais rápidas,

00:02:30.160 --> 00:02:33.070
podemos realmente fazer mais com nossas linguagens de programação.

00:02:33.070 --> 00:02:36.985
Assim como as linguagens humanas evoluem, o mesmo acontece com as linguagens de programação reais.

00:02:36.985 --> 00:02:40.810
E mesmo dentro de uma linguagem de programação, normalmente existem versões diferentes.

00:02:40.810 --> 00:02:43.870
Nós, por exemplo, temos usado a versão C11

00:02:43.870 --> 00:02:46.720
of C, que foi atualizado em 2011.

00:02:46.720 --> 00:02:50.800
Mas o próprio Python continua a evoluir e agora está na versão 3 ou mais.

00:02:50.800 --> 00:02:53.680
E assim também, essas coisas vão evoluir nos próximos dias.

00:02:53.680 --> 00:02:56.560
Felizmente, o que você está prestes a ver é "Hello, World!"

00:02:56.560 --> 00:02:59.440
pela terceira vez, mas vai ser literalmente isso.

00:02:59.440 --> 00:03:04.930
Nada da sintaxe maluca acima ou abaixo, menos ponto e vírgula, se houver, menos

00:03:04.930 --> 00:03:05.770
atualmente aparelho.

00:03:05.770 --> 00:03:08.630
E, realmente, muitas das distrações saem do caminho.

00:03:08.630 --> 00:03:11.200
Então, para chegar lá, vamos considerar exatamente como

00:03:11.200 --> 00:03:13.000
temos programado até agora.

00:03:13.000 --> 00:03:16.300
Então você escreve um programa em C e você tem, esperançosamente,

00:03:16.300 --> 00:03:19.135
nenhum erro de sintaxe, então você está pronto para construí-lo-- isto é, compilá-lo.

00:03:19.135 --> 00:03:22.135
E assim, você executou make e, em seguida, executou o programa, como ./hello.

00:03:22.135 --> 00:03:24.850
Ou se você pensar na segunda semana, onde

00:03:24.850 --> 00:03:27.100
deu uma espiada sob o capô do que o make está fazendo,

00:03:27.100 --> 00:03:29.710
está realmente executando o compilador real--

00:03:29.710 --> 00:03:32.800
algo chamado clang-- talvez com alguns argumentos de linha de comando criando

00:03:32.800 --> 00:03:34.090
um programa chamado hello.

00:03:34.090 --> 00:03:36.128
E então, você poderia fazer ./hello.

00:03:36.128 --> 00:03:38.920
Então, hoje, você vai começar a fazer algo semelhante em espírito,

00:03:38.920 --> 00:03:40.270
mas menos passos.

00:03:40.270 --> 00:03:42.270
Você não precisará mais compilar seu código

00:03:42.270 --> 00:03:45.520
e, em seguida, execute-o e, talvez, corrija-o ou altere-o e, em seguida, compile seu código

00:03:45.520 --> 00:03:47.470
e executá-lo e, em seguida, repita, repita.

00:03:47.470 --> 00:03:50.200
O processo de execução do seu código está indo

00:03:50.200 --> 00:03:52.542
para ser destilado em apenas uma única etapa.

00:03:52.542 --> 00:03:54.250
E a maneira de pensar nisso, por enquanto, é

00:03:54.250 --> 00:03:58.420
que, enquanto C é freqüentemente usado como, de fato, uma linguagem compilada pela qual

00:03:58.420 --> 00:04:01.045
você o converte primeiro em 0s e 1s, Python's

00:04:01.045 --> 00:04:04.400
vai deixar você acelerar as coisas por meio do qual você, o programador humano,

00:04:04.400 --> 00:04:05.740
não precisa compilar.

00:04:05.740 --> 00:04:09.400
Você apenas executará o que chamamos de interpretador-- que, por design,

00:04:09.400 --> 00:04:12.190
é nomeado exatamente a mesma coisa que o próprio idioma -

00:04:12.190 --> 00:04:14.860
e executando este programa instalado no VS Code

00:04:14.860 --> 00:04:17.230
ou, eventualmente, em seus próprios Macs ou PCs.

00:04:17.230 --> 00:04:20.320
Isso só vai dizer ao seu computador para interpretar este código

00:04:20.320 --> 00:04:23.800
e descobrir como chegar a esse nível inferior de 0s e 1s.

00:04:23.800 --> 00:04:26.626
Mas você não precisa mais compilar o código sozinho.

00:04:26.626 --> 00:04:31.000
Dito isso, vamos considerar a aparência do código,

00:04:31.000 --> 00:04:31.690
lado a lado.

00:04:31.690 --> 00:04:33.850
Na verdade, vamos olhar para trás em alguns blocos do Scratch,

00:04:33.850 --> 00:04:36.582
assim como fizemos com C na primeira semana, e alguns lado a lado.

00:04:36.582 --> 00:04:39.040
Porque embora parte da sintaxe desta semana e além

00:04:39.040 --> 00:04:42.705
vai ser diferente, as ideias vão ser realmente as mesmas.

00:04:42.705 --> 00:04:45.565
Ainda não há tanta coisa intelectualmente nova.

00:04:45.565 --> 00:04:48.190
Considerando que, na semana zero, poderíamos ter dito olá ao mundo

00:04:48.190 --> 00:04:51.220
com esta peça roxa do quebra-cabeça, hoje, é claro...

00:04:51.220 --> 00:04:56.080
ou melhor, na primeira semana, ficou assim em C. Mas hoje, seguindo em frente,

00:04:56.080 --> 00:04:58.665
vai, simplesmente, ficar assim.

00:04:58.665 --> 00:05:00.610
E se formos para frente e para trás por apenas um momento,

00:05:00.610 --> 00:05:03.580
aqui, novamente, está a versão em C, notando

00:05:03.580 --> 00:05:05.500
as características muito semelhantes a C.

00:05:05.500 --> 00:05:09.200
E apenas de relance aqui, em Python, afirmo que agora é isso.

00:05:09.200 --> 00:05:13.190
Com o que você aparentemente não precisa mais se preocupar?

00:05:13.190 --> 00:05:14.940
O que foi?

00:05:14.940 --> 00:05:15.990
Portanto, o ponto e vírgula desapareceu.

00:05:15.990 --> 00:05:19.073
E, de fato, você não precisa mais deles para terminar a maioria dos seus pensamentos.

00:05:19.073 --> 00:05:19.830
Algo mais?

00:05:19.830 --> 00:05:20.860
AUDIÊNCIA: Barra invertida n.

00:05:20.860 --> 00:05:22.690
DAVID MALAN: Então a barra invertida n está ausente.

00:05:22.690 --> 00:05:25.140
E isso é curioso porque ainda teremos uma nova linha,

00:05:25.140 --> 00:05:26.985
mas veremos que se tornou o padrão.

00:05:26.985 --> 00:05:29.402
E este é um pouco mais sutil, mas agora, a função

00:05:29.402 --> 00:05:31.185
é chamado de impressão em vez de printf.

00:05:31.185 --> 00:05:33.610
Então é um pouco mais familiar nesse sentido.

00:05:33.610 --> 00:05:34.110
Tudo bem.

00:05:34.110 --> 00:05:37.050
Então, quando se trata de usar bibliotecas - isso

00:05:37.050 --> 00:05:39.300
é, código que outras pessoas escreveram-- no passado,

00:05:39.300 --> 00:05:43.350
fizemos coisas como #include cs50.h para usar o próprio cabeçalho do CS50

00:05:43.350 --> 00:05:47.730
arquivo ou I/O padrão ou lib padrão ou string ou qualquer outro cabeçalho

00:05:47.730 --> 00:05:49.440
arquivos que todos vocês usaram.

00:05:49.440 --> 00:05:52.635
Seguindo em frente, vamos dar a você, nesta primeira semana, um CS50 semelhante

00:05:52.635 --> 00:05:53.280
biblioteca--

00:05:53.280 --> 00:05:55.920
apenas rodinhas de treinamento de curto prazo que vamos rapidamente

00:05:55.920 --> 00:05:59.370
decolar porque, na verdade, é muito mais fácil fazer as coisas em Python,

00:05:59.370 --> 00:06:00.267
como veremos.

00:06:00.267 --> 00:06:02.100
Mas a sintaxe para isso, agora, será

00:06:02.100 --> 00:06:05.165
para importar a biblioteca CS50 dessa maneira.

00:06:05.165 --> 00:06:08.452
E quando tivermos, agora, essa habilidade, podemos realmente

00:06:08.452 --> 00:06:09.910
comece a escrever algum código imediatamente.

00:06:09.910 --> 00:06:12.420
Na verdade, deixe-me mudar para o VS Code aqui.

00:06:12.420 --> 00:06:14.760
E assim como no passado, criarei um novo arquivo.

00:06:14.760 --> 00:06:17.230
Mas em vez de criar algo chamado .c,

00:06:17.230 --> 00:06:19.980
Vou seguir em frente e criar meu primeiro programa chamado hello.py,

00:06:19.980 --> 00:06:22.260
usando o espaço de código hello dot py.

00:06:22.260 --> 00:06:24.000
Isso, é claro, me dá essa nova aba.

00:06:24.000 --> 00:06:28.185
E deixe-me, simplesmente, fazer o que propus - imprimir, citar, fechar aspas,

00:06:28.185 --> 00:06:33.780
"Hello, world" sem o /n, sem o ponto e vírgula, sem o f na impressão.

00:06:33.780 --> 00:06:36.270
E agora, deixe-me ir até a janela do meu terminal.

00:06:36.270 --> 00:06:37.792
E não preciso compilar.

00:06:37.792 --> 00:06:39.000
Eu não tenho que fazer barra de ponto.

00:06:39.000 --> 00:06:43.140
Eu, em vez disso, executo um programa chamado python, cujo propósito na vida

00:06:43.140 --> 00:06:46.180
é, agora, interpretar meu código de cima para baixo, da esquerda para a direita.

00:06:46.180 --> 00:06:50.130
E se eu executar python de hello.py, cruzando os dedos, como sempre--

00:06:50.130 --> 00:06:51.000
voilá.

00:06:51.000 --> 00:06:53.190
Agora imprimi "olá, mundo".

00:06:53.190 --> 00:06:56.460
Parece que recebemos a nova linha de graça, no sentido em que

00:06:56.460 --> 00:06:57.735
está acontecendo automaticamente.

00:06:57.735 --> 00:06:59.880
O cifrão não está estranhamente na mesma linha,

00:06:59.880 --> 00:07:02.220
como já foi na primeira semana.

00:07:02.220 --> 00:07:04.493
Mas isso é apenas um pequeno detalhe aqui.

00:07:04.493 --> 00:07:06.660
Se voltarmos para, agora, algumas outras capacidades--

00:07:06.660 --> 00:07:09.780
bem, de fato, com a biblioteca CS50, você também não pode

00:07:09.780 --> 00:07:12.795
basta importar a própria biblioteca, mas funções específicas.

00:07:12.795 --> 00:07:14.850
E você verá que, temporariamente, vamos

00:07:14.850 --> 00:07:19.080
para dar a você uma função auxiliar chamada get_string, assim como em C, que apenas

00:07:19.080 --> 00:07:20.872
faz funcionar exatamente da mesma maneira que em C.

00:07:20.872 --> 00:07:22.580
E veremos algumas outras funções

00:07:22.580 --> 00:07:24.660
isso apenas tornará a vida mais fácil, inicialmente.

00:07:24.660 --> 00:07:26.910
Mas, rapidamente, vamos tirar essas rodinhas

00:07:26.910 --> 00:07:29.295
para que nada seja, de fato, específico do CS50.

00:07:29.295 --> 00:07:29.970
Tudo bem.

00:07:29.970 --> 00:07:32.640
Bem, e as funções, de forma mais geral, em Python?

00:07:32.640 --> 00:07:34.710
Vamos fazer um tour rápido, se você quiser, muito

00:07:34.710 --> 00:07:38.940
como fizemos naquela primeira semana de C, comparando um com o outro.

00:07:38.940 --> 00:07:42.270
De volta ao nosso mundo do Scratch, um dos primeiros programas que escrevemos

00:07:42.270 --> 00:07:45.360
foi este aqui, por meio do qual perguntamos ao humano seu nome.

00:07:45.360 --> 00:07:49.110
Em seguida, usamos o valor de retorno que foi armazenado automaticamente

00:07:49.110 --> 00:07:53.130
nesta variável de resposta como um segundo argumento

00:07:53.130 --> 00:07:56.265
para entrar para que pudéssemos dizer "Olá, David" ou "Olá, Carter".

00:07:56.265 --> 00:07:59.340
Então, isso foi na semana zero.

00:07:59.340 --> 00:08:01.143
Na primeira semana, convertemos para isso.

00:08:01.143 --> 00:08:03.810
E aqui está um exemplo perfeito de coisas como escalar rapidamente.

00:08:03.810 --> 00:08:05.910
E, novamente, é por isso que começamos no Scratch.

00:08:05.910 --> 00:08:09.060
Há tanta distração aqui para alcançar a mesma ideia.

00:08:09.060 --> 00:08:12.010
Mas ainda hoje, vamos eliminar parte dessa sintaxe.

00:08:12.010 --> 00:08:17.940
Então, em C, tivemos que declarar a variável como uma string, aqui.

00:08:17.940 --> 00:08:19.935
É claro que tínhamos o ponto e vírgula e muito mais.

00:08:19.935 --> 00:08:22.650
Bem, em Python, o código comparável, agora,

00:08:22.650 --> 00:08:26.100
vai ficar, de forma mais simples, assim.

00:08:26.100 --> 00:08:29.250
Portanto, o ponto-e-vírgula, novamente, desapareceu em ambas as linhas.

00:08:29.250 --> 00:08:30.450
Então isso é bom.

00:08:30.450 --> 00:08:33.100
O que mais parece ter mudado ou desaparecido?

00:08:33.100 --> 00:08:33.600
Sim.

00:08:33.600 --> 00:08:35.340
PÚBLICO: [? Você tem ?] o mesmo tipo de variável?

00:08:35.340 --> 00:08:36.090
DAVID MALAN: Sim.

00:08:36.090 --> 00:08:39.419
Portanto, não precisei dizer especificamente que a resposta agora é uma string.

00:08:39.419 --> 00:08:41.820
E, de fato, o Python é tipado dinamicamente.

00:08:41.820 --> 00:08:45.270
E, de fato, inferirá do contexto exatamente o que

00:08:45.270 --> 00:08:48.000
é você que está armazenando nessa variável.

00:08:48.000 --> 00:08:50.775
Outros detalhes que parecem um pouco diferentes?

00:08:53.640 --> 00:08:54.607
Um pouco diferente.

00:08:54.607 --> 00:08:55.940
O que mais salta para você aqui?

00:08:55.940 --> 00:08:56.482
Eu vou voltar.

00:08:56.482 --> 00:08:58.690
Esta foi a versão C.

00:08:58.690 --> 00:09:01.570
E talvez focar, agora, na segunda linha porque preferimos

00:09:01.570 --> 00:09:02.740
esgotou o primeiro.

00:09:02.740 --> 00:09:04.690
Aqui está, agora, a versão Python.

00:09:04.690 --> 00:09:05.720
O que há de diferente aqui?

00:09:05.720 --> 00:09:06.220
Sim?

00:09:06.220 --> 00:09:08.845
AUDIÊNCIA: Você não precisa se preocupar com %s ou por cento de nada.

00:09:08.845 --> 00:09:10.930
Você só tem a variável depois de [? eles. ?]

00:09:10.930 --> 00:09:11.680
DAVID MALAN: Sim.

00:09:11.680 --> 00:09:12.820
Não há mais %s.

00:09:12.820 --> 00:09:16.480
Não há segundo argumento, no momento, per se, para imprimir.

00:09:16.480 --> 00:09:17.818
Agora, ainda é um pouco estranho.

00:09:17.818 --> 00:09:20.485
É como se eu tivesse implantado alguma adição aqui, aritmeticamente.

00:09:20.485 --> 00:09:21.860
Mas esse não é o caso.

00:09:21.860 --> 00:09:23.230
Alguns de vocês já programaram antes.

00:09:23.230 --> 00:09:27.377
E mais, alguns de vocês devem saber, significa o que neste contexto?

00:09:27.377 --> 00:09:29.960
Então, para combinar ou, mais tecnicamente-- alguém conhece a palavra da moda?

00:09:29.960 --> 00:09:30.390
Sim.

00:09:30.390 --> 00:09:31.040
AUDIÊNCIA: Concatenar.

00:09:31.040 --> 00:09:32.460
DAVID MALAN: Para concatenar.

00:09:32.460 --> 00:09:35.753
Portanto, concatenar é a maneira elegante do que o Scratch chama de juntar,

00:09:35.753 --> 00:09:38.420
que é pegar uma corda à esquerda, uma corda à direita

00:09:38.420 --> 00:09:40.100
e juntá-los.

00:09:40.100 --> 00:09:41.880
Para colá-los, se você quiser.

00:09:41.880 --> 00:09:43.080
Então isso não é adição.

00:09:43.080 --> 00:09:45.080
Seria se fossem números envolvidos em seu lugar.

00:09:45.080 --> 00:09:46.413
Mas porque temos uma string--

00:09:46.413 --> 00:09:49.430
Olá vírgula-- e outra string implicitamente nesta variável

00:09:49.430 --> 00:09:53.540
com base no que o humano digitou em resposta a esta função get_string.

00:09:53.540 --> 00:09:58.130
Isso vai concatenar Olá vírgula espaço e, em seguida, David ou Carter

00:09:58.130 --> 00:09:59.637
ou o que quer que o humano tenha digitado.

00:09:59.637 --> 00:10:02.720
Mas acontece que haverá maneiras diferentes de fazer isso em Python.

00:10:02.720 --> 00:10:04.387
E mostraremos alguns diferentes.

00:10:04.387 --> 00:10:06.380
E aqui também, tente não ficar muito preso

00:10:06.380 --> 00:10:09.255
ou frustrado por todas as diferentes maneiras de resolver problemas.

00:10:09.255 --> 00:10:12.130
As probabilidades são de que você aprenderá dicas e técnicas por anos

00:10:12.130 --> 00:10:14.100
para vir se você continuar programando.

00:10:14.100 --> 00:10:16.710
Então, vamos apenas dar-lhe algumas das maneiras possíveis.

00:10:16.710 --> 00:10:20.900
Então, aqui está uma segunda maneira de imprimir olá vírgula David ou olá vírgula

00:10:20.900 --> 00:10:21.680
Carter.

00:10:21.680 --> 00:10:22.655
Mas o que mudou?

00:10:22.655 --> 00:10:26.030
Na versão anterior, usei a concatenação explicitamente.

00:10:26.030 --> 00:10:28.445
E o espaço aqui é importante, gramaticalmente,

00:10:28.445 --> 00:10:30.485
apenas para obtermos isso na frase final.

00:10:30.485 --> 00:10:33.410
Agora, estou propondo me livrar desse espaço

00:10:33.410 --> 00:10:36.985
para adicionar uma vírgula fora das aspas duplas também.

00:10:36.985 --> 00:10:39.020
Mas se você pensar em C, isso provavelmente

00:10:39.020 --> 00:10:42.620
apenas significa que print, semelhante em espírito a printf,

00:10:42.620 --> 00:10:45.200
pode levar não apenas um argumento, mas até mesmo dois.

00:10:45.200 --> 00:10:47.510
E de fato, por causa dessa vírgula no meio que é

00:10:47.510 --> 00:10:50.390
fora das aspas, é olá vírgula,

00:10:50.390 --> 00:10:52.655
e então, será automaticamente concatenado

00:10:52.655 --> 00:10:56.420
com-- mesmo sem usar o mais, seja qual for o valor da resposta.

00:10:56.420 --> 00:10:59.630
E por padrão, apenas para beleza gramatical,

00:10:59.630 --> 00:11:01.850
a função de impressão sempre lhe dá um espaço

00:11:01.850 --> 00:11:05.120
gratuitamente entre cada um dos vários argumentos que você passar.

00:11:05.120 --> 00:11:07.290
Veremos como você pode substituir isso no futuro.

00:11:07.290 --> 00:11:09.248
Mas, por enquanto, essa é apenas outra maneira de fazer isso.

00:11:09.248 --> 00:11:12.680
Agora, talvez a maneira melhor, embora ligeiramente enigmática, de fazer isso -

00:11:12.680 --> 00:11:14.420
ou apenas a maneira cada vez mais comum--

00:11:14.420 --> 00:11:18.290
é, provavelmente, a terceira versão, que também parece um pouco estranha.

00:11:18.290 --> 00:11:20.555
E, provavelmente, a estranheza salta à tona.

00:11:20.555 --> 00:11:24.060
De repente, introduzimos essas chaves,

00:11:24.060 --> 00:11:25.518
que eu prometi quase desapareceram.

00:11:25.518 --> 00:11:26.060
E eles são.

00:11:26.060 --> 00:11:29.270
Mas dentro desta string aqui, eu fiz

00:11:29.270 --> 00:11:31.520
uma chaveta, o que pode significar o quê?

00:11:31.520 --> 00:11:32.918
Apenas intuitivamente.

00:11:32.918 --> 00:11:35.210
E aqui está um exemplo de como você aprende um novo idioma.

00:11:35.210 --> 00:11:39.945
Basta inferir, a partir do contexto, como o Python provavelmente funciona.

00:11:39.945 --> 00:11:40.820
O que isso pode significar?

00:11:40.820 --> 00:11:41.320
Sim?

00:11:41.320 --> 00:11:45.160
AUDIÊNCIA: [INAUDÍVEL]

00:11:45.160 --> 00:11:45.910
DAVID MALAN: Sim.

00:11:45.910 --> 00:11:48.610
Portanto, esta é uma indicação, porque as chaves -

00:11:48.610 --> 00:11:50.740
porque esta foi a forma como o Python foi projetado--

00:11:50.740 --> 00:11:55.340
que queremos inserir o valor de resposta, não literalmente RESPOSTA.

00:11:55.340 --> 00:11:59.688
E a palavra chique aqui é que a variável de resposta será interpolada -

00:11:59.688 --> 00:12:01.480
isto é, substituído por seu valor real.

00:12:01.480 --> 00:12:04.435
Mas, mas, mas-- e isso é realmente estranho;

00:12:04.435 --> 00:12:06.820
isso foi introduzido há alguns anos no Python.

00:12:06.820 --> 00:12:11.230
O que mais eu tive que mudar para fazer essas chaves funcionarem, aparentemente?

00:12:11.230 --> 00:12:11.935
Sim?

00:12:11.935 --> 00:12:13.510
AUDIÊNCIA: Solte o f antes do...

00:12:13.510 --> 00:12:14.260
DAVID MALAN: Sim.

00:12:14.260 --> 00:12:15.160
Há este estranho f.

00:12:15.160 --> 00:12:17.245
E assim, é como parte do printf.

00:12:17.245 --> 00:12:20.950
Mas agora, está dentro dos parênteses ali.

00:12:20.950 --> 00:12:22.945
Esta é apenas a maneira como o Python projetou isso.

00:12:22.945 --> 00:12:24.820
Então, alguns anos atrás, quando eles introduziram o que

00:12:24.820 --> 00:12:30.070
são chamados de strings de formato ou fstrings, você literalmente prefixa sua string entre aspas

00:12:30.070 --> 00:12:32.080
com a letra f.

00:12:32.080 --> 00:12:34.570
E então, você pode usar truques como este,

00:12:34.570 --> 00:12:36.640
como colocar chaves para que o valor seja

00:12:36.640 --> 00:12:38.170
ser substituído automaticamente.

00:12:38.170 --> 00:12:41.530
Se você esquecer o f, verá literalmente olá vírgula encaracolado

00:12:41.530 --> 00:12:43.330
chave resposta chave fechada.

00:12:43.330 --> 00:12:45.355
Se você adicionar o f, é, de fato, interpolado.

00:12:45.355 --> 00:12:47.360
O valor está inserido.

00:12:47.360 --> 00:12:47.860
Tudo bem.

00:12:47.860 --> 00:12:52.510
Perguntas sobre como podemos apenas dizer olá ao mundo via Python, neste caso.

00:12:52.510 --> 00:12:53.350
Sim?

00:12:53.350 --> 00:12:55.280
AUDIÊNCIA: Se você fizer isso sem o f, o que aconteceria?

00:12:55.280 --> 00:12:56.300
DAVID MALAN: Se você fizer isso sem o--

00:12:56.300 --> 00:12:57.260
PÚBLICO: [? o f. ?]

00:12:57.260 --> 00:12:58.385
DAVID MALAN: Sem o f?

00:12:58.385 --> 00:13:02.450
Se você omitir o f, verá literalmente HELLO vírgula chave

00:13:02.450 --> 00:13:04.730
RESPOSTA Chave fechada.

00:13:04.730 --> 00:13:05.930
Então, de fato, vamos fazer isso.

00:13:05.930 --> 00:13:08.300
Deixe-me voltar ao VS Code aqui, rapidamente.

00:13:08.300 --> 00:13:11.540
Ainda tenho meu arquivo chamado hello.py aberto.

00:13:11.540 --> 00:13:14.210
E deixe-me ir em frente e mudar isso um pouco.

00:13:14.210 --> 00:13:16.700
Então eu vou em frente e--

00:13:16.700 --> 00:13:20.930
digamos de cs50 import get_string.

00:13:20.930 --> 00:13:23.615
E essa é apenas a nova sintaxe que proponho usar para importar

00:13:23.615 --> 00:13:26.150
uma função da biblioteca de outra pessoa.

00:13:26.150 --> 00:13:30.593
Eu vou agora em frente e fazer a pergunta--

00:13:30.593 --> 00:13:33.260
vamos usar get_string, armazenando o resultado em answer.

00:13:33.260 --> 00:13:37.480
Então get_string, entre aspas, "Qual é o seu nome?"

00:13:37.480 --> 00:13:41.090
E então, nesta linha, vou cometer um erro deliberadamente aqui,

00:13:41.090 --> 00:13:42.450
exatamente a sua pergunta.

00:13:42.450 --> 00:13:46.820
Deixe-me apenas dizer olá, resposta de vírgula, e apenas isso.

00:13:46.820 --> 00:13:48.980
Agora, embora a resposta seja uma variável, o Python

00:13:48.980 --> 00:13:53.150
não vai ser tão presunçoso a ponto de apenas inserir o valor de uma variável

00:13:53.150 --> 00:13:53.810
chamada resposta.

00:13:53.810 --> 00:13:56.000
O que vai fazer, é claro, é--

00:13:56.000 --> 00:13:56.985
se eu digitar meu nome--

00:13:56.985 --> 00:13:57.485
opa.

00:13:57.485 --> 00:13:58.880
Eu digitei muito rápido.

00:13:58.880 --> 00:14:00.470
Deixe-me ir em frente e repetir isso novamente.

00:14:00.470 --> 00:14:04.550
Se eu executar python com hello.py, digite meu nome e pressione Enter,

00:14:04.550 --> 00:14:06.035
Eu recebo Olá resposta vírgula.

00:14:06.035 --> 00:14:07.160
Bem, deixe-me fazer um melhor.

00:14:07.160 --> 00:14:10.680
Deixe-me aplicar essas chaves como antes.

00:14:10.680 --> 00:14:13.340
Deixe-me executar novamente o python de hello.py.

00:14:13.340 --> 00:14:14.060
Qual o seu nome?

00:14:14.060 --> 00:14:14.405
DAVID.

00:14:14.405 --> 00:14:16.363
E aqui está, novamente, a resposta para sua pergunta.

00:14:16.363 --> 00:14:18.780
Agora, obtemos, literalmente, as chaves.

00:14:18.780 --> 00:14:20.780
Portanto, a solução aqui, em última análise, é apenas ir

00:14:20.780 --> 00:14:24.640
para adicionar o f lá, execute novamente meu programa novamente com David.

00:14:24.640 --> 00:14:26.482
E agora, olá vírgula David.

00:14:26.482 --> 00:14:28.940
Então, isso é, reconhecidamente, um pouco mais enigmático do que os

00:14:28.940 --> 00:14:31.858
com o sinal de mais ou a vírgula, mas isso é cada vez mais comum.

00:14:31.858 --> 00:14:33.650
Por que? porque você pode ler da esquerda para a direita.

00:14:33.650 --> 00:14:34.720
É bom e conveniente.

00:14:34.720 --> 00:14:36.125
É menos enigmático que o de %s.

00:14:36.125 --> 00:14:40.130
Portanto, é uma versão nova e aprimorada, se preferir, de printf em C,

00:14:40.130 --> 00:14:44.780
baseado em décadas de experiência de programadores fazendo coisas como esta.

00:14:44.780 --> 00:14:49.540
Dúvidas sobre como imprimir desta forma?

00:14:49.540 --> 00:14:52.780
Estamos agora a caminho da programação em Python.

00:14:52.780 --> 00:14:53.280
Qualquer coisa?

00:14:53.280 --> 00:14:53.780
Tudo bem.

00:14:53.780 --> 00:14:56.825
Bem, o que mais podemos fazer com esta linguagem, aqui?

00:14:56.825 --> 00:15:00.000
Bem, deixe-me propor que consideremos que

00:15:00.000 --> 00:15:07.200
tem, por exemplo, alguns outros recursos que podemos adicionar à mistura, bem--

00:15:07.200 --> 00:15:12.640
ou seja, digamos alguns tipos de dados também.

00:15:12.640 --> 00:15:15.600
Então deixe-me virar aqui, para voltar aos slides.

00:15:15.600 --> 00:15:18.318
E há diferentes tipos de dados em Python, como veremos em breve.

00:15:18.318 --> 00:15:19.485
Mas eles não são tão explícitos.

00:15:19.485 --> 00:15:23.070
Como já vimos, usando uma string de get_string,

00:15:23.070 --> 00:15:25.050
você não precisa declarar explicitamente o que é.

00:15:25.050 --> 00:15:29.130
Mas você viu-- lembre-se, em C-- todos esses vários tipos de dados.

00:15:29.130 --> 00:15:33.720
E então, em Python, muito bem, esta lista está prestes a ficar mais curta.

00:15:33.720 --> 00:15:37.740
E assim, aqui está nossa lista em C. Aqui está uma lista abreviada em Python.

00:15:37.740 --> 00:15:41.220
Ainda teremos strings, mas elas serão mais sucintas

00:15:41.220 --> 00:15:45.032
chamado strs agora, STR. Ainda teremos ints para números inteiros.

00:15:45.032 --> 00:15:47.490
Ainda teremos floats para valores de ponto flutuante.

00:15:47.490 --> 00:15:49.900
Teremos até bools para true e false.

00:15:49.900 --> 00:15:53.550
Mas o que falta, agora, na lista é longo e flutuante.

00:15:53.550 --> 00:15:54.420
E por que isto?

00:15:54.420 --> 00:15:56.220
Ou melhor, longo e duplo.

00:15:56.220 --> 00:15:58.650
Lembremos que, em C, aqueles usavam mais bits.

00:15:58.650 --> 00:16:02.550
Bem, em Python, os tipos de dados menores, anteriormente-- int e float,

00:16:02.550 --> 00:16:04.950
eles mesmos-- apenas usaram mais bits para você.

00:16:04.950 --> 00:16:08.010
E assim, você não precisa distinguir entre pequeno e grande.

00:16:08.010 --> 00:16:10.290
Você usa apenas um tipo de dados e o idioma

00:16:10.290 --> 00:16:12.345
dá-lhe um alcance maior do que antes.

00:16:12.345 --> 00:16:15.510
Acontece que haverá alguns outros recursos também,

00:16:15.510 --> 00:16:17.610
do Python, e esses tipos de dados-- um dos quais

00:16:17.610 --> 00:16:20.010
será chamado de intervalo, outro dos quais será lista.

00:16:20.010 --> 00:16:21.402
Assim, desaparecerão os arrays.

00:16:21.402 --> 00:16:23.610
Na verdade, usaremos algo chamado literalmente de lista.

00:16:23.610 --> 00:16:28.110
Tuplas-- uma espécie de pares x, y para coordenadas e coisas assim.

00:16:28.110 --> 00:16:31.260
Dicts para dicionários - então teremos recursos integrados

00:16:31.260 --> 00:16:34.270
para armazenar chaves e valores veremos, e até mesmo um conjunto.

00:16:34.270 --> 00:16:36.270
Matematicamente, um conjunto é uma coleção de valores,

00:16:36.270 --> 00:16:38.790
mas elimina automaticamente as duplicatas para você.

00:16:38.790 --> 00:16:43.470
Então, todas essas coisas, poderíamos implementar absolutamente em C se quiséssemos.

00:16:43.470 --> 00:16:47.940
E, de fato, no conjunto de problemas cinco, você implementou seu próprio feitiço

00:16:47.940 --> 00:16:50.400
verificador usando alguma forma de tabela de hash.

00:16:50.400 --> 00:16:54.060
Bem, acontece que, em Python, você pode resolver esses mesmos problemas,

00:16:54.060 --> 00:16:56.070
mas talvez um pouco mais facilmente.

00:16:56.070 --> 00:16:58.980
Na verdade, deixe-me voltar aqui para o VS Code,

00:16:58.980 --> 00:17:01.895
e deixe-me propor que eu faça o seguinte.

00:17:01.895 --> 00:17:06.210
Deixe-me ir em frente e criar um arquivo chamado dictionary.py.

00:17:06.210 --> 00:17:09.510
Deixe-me propor que eu tente implementar, digamos-- conjunto de problemas cinco--

00:17:09.510 --> 00:17:14.220
nosso corretor ortográfico em Python em vez de C e alcançar, em última análise,

00:17:14.220 --> 00:17:17.443
o mesmo tipo de comportamento pelo qual estarei

00:17:17.443 --> 00:17:19.235
capaz de verificar a ortografia de um monte de palavras.

00:17:19.235 --> 00:17:21.480
Então, isso é pular um pouco a arma porque você está

00:17:21.480 --> 00:17:23.897
prestes a ver a sintaxe será revisitada ao longo de hoje.

00:17:23.897 --> 00:17:26.580
Mas, por enquanto, tenho um novo arquivo chamado dictionary.py.

00:17:26.580 --> 00:17:30.810
E deixe-me começar a criar alguns espaços reservados para funções.

00:17:30.810 --> 00:17:34.710
Veremos daqui a pouco que, em Python, você pode definir uma função chamada check,

00:17:34.710 --> 00:17:38.000
e essa função de verificação pode receber uma palavra como entrada.

00:17:38.000 --> 00:17:40.292
E voltarei a isso daqui a pouco.

00:17:40.292 --> 00:17:42.000
Em Python, posso definir uma segunda função

00:17:42.000 --> 00:17:44.865
como load, que por si só levará um dicionário inteiro,

00:17:44.865 --> 00:17:47.010
exatamente como no conjunto de problemas cinco.

00:17:47.010 --> 00:17:51.010
E eu irei em frente e voltarei para a implementação disso.

00:17:51.010 --> 00:17:53.130
Enquanto isso, podemos implementar de forma semelhante uma função

00:17:53.130 --> 00:17:57.090
chamado size, que não aceita argumentos, mas, em última instância, retornará

00:17:57.090 --> 00:17:59.100
do tamanho do meu dicionário de palavras.

00:17:59.100 --> 00:18:02.370
E então, por último, para consistência com o conjunto de problemas cinco,

00:18:02.370 --> 00:18:05.130
podemos definir uma função de descarga, cujo propósito na vida

00:18:05.130 --> 00:18:07.770
é liberar qualquer memória que você esteja usando, apenas

00:18:07.770 --> 00:18:09.390
para devolvê-lo ao computador.

00:18:09.390 --> 00:18:11.790
Agora, as probabilidades são, se você ainda está trabalhando no soletrador

00:18:11.790 --> 00:18:15.660
ou terminou o soletrador, você escreveu uma quantidade decente de linhas de código.

00:18:15.660 --> 00:18:18.550
E, de fato, tem sido, por design, um desafio.

00:18:18.550 --> 00:18:22.620
Mas uma das razões para essas linguagens de alto nível como Python

00:18:22.620 --> 00:18:25.680
é que você pode se apoiar nos ombros dos programadores antes de

00:18:25.680 --> 00:18:28.703
e resolver problemas muito comuns muito mais rapidamente.

00:18:28.703 --> 00:18:31.620
Para que você possa se concentrar na criação de seu novo aplicativo ou aplicativo da web

00:18:31.620 --> 00:18:34.690
ou seu próprio projeto para resolver problemas de seu interesse.

00:18:34.690 --> 00:18:38.490
Então, correndo o risco de esmagar alguns espíritos, vamos

00:18:38.490 --> 00:18:42.540
proponho que, em Python, se você quiser um dicionário para algo como um feitiço

00:18:42.540 --> 00:18:44.070
verificador, bem, tudo bem.

00:18:44.070 --> 00:18:48.030
Vá em frente e dê a si mesmo uma variável, como palavras, para armazenar todas essas palavras

00:18:48.030 --> 00:18:52.410
e apenas atribua igual a um dicionário-- ou dict, para abreviar,

00:18:52.410 --> 00:18:53.220
em Python.

00:18:53.220 --> 00:18:55.140
Isso lhe dará uma tabela de hash.

00:18:55.140 --> 00:18:57.690
Agora, ao que parece, na memória ortográfica, você

00:18:57.690 --> 00:18:59.720
não precisa se preocupar com palavras e definições.

00:18:59.720 --> 00:19:01.763
Trata-se apenas de verificar a ortografia das palavras.

00:19:01.763 --> 00:19:03.930
Portanto, estritamente falando, não precisamos de chaves e valores.

00:19:03.930 --> 00:19:05.610
Só precisamos de chaves.

00:19:05.610 --> 00:19:07.980
Então, vou economizar mais algumas teclas

00:19:07.980 --> 00:19:11.055
apenas dizendo que, tecnicamente, em Python, usar um conjunto é suficiente.

00:19:11.055 --> 00:19:13.770
Novamente, um conjunto é apenas uma coleção de valores sem duplicatas.

00:19:13.770 --> 00:19:16.400
Mas eles não têm necessariamente chaves e valores.

00:19:16.400 --> 00:19:18.250
É apenas um ou outro.

00:19:18.250 --> 00:19:21.420
Mas agora que eu tenho-- na linha um, reivindico o equivalente, em Python,

00:19:21.420 --> 00:19:25.720
de uma tabela de hash, posso realmente fazer algo assim.

00:19:25.720 --> 00:19:28.890
Aqui está como eu poderia implementar a função check em Python.

00:19:28.890 --> 00:19:33.840
Se a palavra passada para esta função estiver na minha variável chamada palavras,

00:19:33.840 --> 00:19:35.390
bem, retorne True.

00:19:35.390 --> 00:19:39.360
Caso contrário, vá em frente e retorne False.

00:19:39.360 --> 00:19:40.030
Feito.

00:19:40.030 --> 00:19:40.530
Não, espere.

00:19:40.530 --> 00:19:42.990
Você está pensando, se alguma coisa, talvez

00:19:42.990 --> 00:19:46.507
queremos lidar com minúsculas em vez de apenas maiúsculas e minúsculas.

00:19:46.507 --> 00:19:47.340
Bem, você sabe o que?

00:19:47.340 --> 00:19:49.725
Em Python, se você quiser forçar uma palavra inteira para letras minúsculas,

00:19:49.725 --> 00:19:51.360
você não precisa iterar com um loop.

00:19:51.360 --> 00:19:54.190
Você não precisa usar nenhuma dessas funções do tipo C nem nada.

00:19:54.190 --> 00:19:56.947
Basta dizer word.lower e isso converterá tudo

00:19:56.947 --> 00:19:58.780
para minúsculas para paridade com o dicionário.

00:19:58.780 --> 00:19:59.440
Tudo bem.

00:19:59.440 --> 00:20:02.185
Que tal algo como a função load em Python?

00:20:02.185 --> 00:20:06.130
Bem, em Python, você pode abrir arquivos como em C. Por exemplo, em Python, eu

00:20:06.130 --> 00:20:09.940
pode abrir, o argumento do dicionário no modo de leitura,

00:20:09.940 --> 00:20:11.798
assim como fopen em Python.

00:20:11.798 --> 00:20:13.090
Eu poderia fazer algo assim.

00:20:13.090 --> 00:20:20.230
Para cada linha nesse arquivo, deixe-me ir em frente e adicionar, à minha variável de palavras,

00:20:20.230 --> 00:20:21.430
aquela linha.

00:20:21.430 --> 00:20:24.790
E então, deixe-me ir em frente e fechar esse arquivo.

00:20:24.790 --> 00:20:26.320
E acho que terminei.

00:20:26.320 --> 00:20:28.457
Vou apenas seguir em frente e retornar True,

00:20:28.457 --> 00:20:30.040
só porque acho que já terminei.

00:20:30.040 --> 00:20:32.350
Agora, aqui também, eu poderia criticar um pouco.

00:20:32.350 --> 00:20:35.680
Tecnicamente, se estou lendo cada linha do arquivo,

00:20:35.680 --> 00:20:38.620
cada linha no dicionário termina com, tecnicamente, uma barra invertida n.

00:20:38.620 --> 00:20:41.140
Mas há uma maneira fácil de se livrar disso,

00:20:41.140 --> 00:20:43.360
assim como você pode ver com uma sintaxe alternativa.

00:20:43.360 --> 00:20:45.060
O que eu realmente vou fazer é isso.

00:20:45.060 --> 00:20:49.060
Deixe-me pegar da linha atual, a palavra atual,

00:20:49.060 --> 00:20:51.940
removendo com tira reversa--

00:20:51.940 --> 00:20:53.935
rstrip; uma função que veremos novamente -

00:20:53.935 --> 00:20:55.810
que apenas se livra da nova linha à direita -

00:20:55.810 --> 00:20:58.000
a barra invertida n no final dessa linha.

00:20:58.000 --> 00:21:01.900
E o que eu realmente quero fazer, então, é adicionar essa palavra a esse dicionário.

00:21:01.900 --> 00:21:05.780
Enquanto isso, se eu quiser descobrir qual é o tamanho do meu dicionário, bem...

00:21:05.780 --> 00:21:08.890
e, veja, você provavelmente está escrevendo código para iterar todas essas linhas,

00:21:08.890 --> 00:21:12.040
e você só vai contá-los usando uma variável.

00:21:12.040 --> 00:21:13.060
Não é assim em Python.

00:21:13.060 --> 00:21:15.460
Você pode apenas retornar o comprimento dessas palavras.

00:21:15.460 --> 00:21:19.360
E melhor ainda, em Python, você não precisa gerenciar sua própria memória.

00:21:19.360 --> 00:21:20.500
Não há mais malloc.

00:21:20.500 --> 00:21:21.700
Não mais livre.

00:21:21.700 --> 00:21:24.370
Não há mais pensamento manual sobre a memória.

00:21:24.370 --> 00:21:27.310
A linguagem apenas lida com tudo isso para você.

00:21:27.310 --> 00:21:28.030
Então você sabe o quê?

00:21:28.030 --> 00:21:30.760
É suficiente para mim apenas retornar True e reivindicar

00:21:30.760 --> 00:21:33.640
esse descarregamento é feito para mim.

00:21:33.640 --> 00:21:35.170
E é isso.

00:21:35.170 --> 00:21:37.840
Novamente, se você está no meio ou já terminou,

00:21:37.840 --> 00:21:39.960
isso pode, talvez, ajustar alguma frustração,

00:21:39.960 --> 00:21:45.700
mas também, esclarecimento, pois é por isso que existem linguagens de nível superior.

00:21:45.700 --> 00:21:47.605
Você pode construir sobre os mesmos princípios,

00:21:47.605 --> 00:21:50.170
as mesmas idéias, com as quais você está lidando,

00:21:50.170 --> 00:21:51.820
lutando mesmo na semana passada.

00:21:51.820 --> 00:21:55.090
Mas agora você pode se expressar de forma ainda mais sucinta.

00:21:55.090 --> 00:21:59.590
Esta linha implementa uma tabela de hash para você, e tudo isso, agora,

00:21:59.590 --> 00:22:03.250
apenas usa essa tabela de hash de uma maneira mais simples.

00:22:03.250 --> 00:22:05.980
Qualquer dúvida, agora, sobre isso, tendo em mente

00:22:05.980 --> 00:22:08.830
que o ponto, no entanto, do speller no p-set 5

00:22:08.830 --> 00:22:12.160
é entender o que realmente está acontecendo sob o capô

00:22:12.160 --> 00:22:14.860
e, melhor ainda, perceber isso.

00:22:14.860 --> 00:22:18.010
Isso pode parecer bastante surpreendente, mas deixe-me ir em frente e fazer isso.

00:22:18.010 --> 00:22:21.100
Na verdade, tenho algumas versões de speller escritas aqui,

00:22:21.100 --> 00:22:24.800
e tenho uma versão escrita em C para a qual não mostrarei o código-fonte.

00:22:24.800 --> 00:22:28.990
Mas vou seguir em frente e fazer essa versão do soletrador em C.

00:22:28.990 --> 00:22:32.470
E eu vou seguir em frente aqui e, digamos, dividir

00:22:32.470 --> 00:22:34.270
minha janela aqui por apenas um momento.

00:22:34.270 --> 00:22:37.030
E vou entrar em uma versão Python do speller,

00:22:37.030 --> 00:22:38.470
realmente, que eu acabei de escrever.

00:22:38.470 --> 00:22:42.820
E no lado esquerdo aqui, deixe-me ir em frente e executar o soletrador--

00:22:42.820 --> 00:22:44.740
a versão que compilei em C--

00:22:44.740 --> 00:22:47.890
usando um texto grande como o texto de Sherlock Holmes,

00:22:47.890 --> 00:22:50.030
que tem um monte de palavras nele.

00:22:50.030 --> 00:22:52.180
E no lado direito, deixe-me executar o python

00:22:52.180 --> 00:22:55.510
de speller.py, que é um arquivo separado que escrevi com antecedência,

00:22:55.510 --> 00:22:57.430
assim como nós lhe damos speller.c.

00:22:57.430 --> 00:23:00.790
E eu vou, da mesma forma, executar isso no texto de Sherlock Holmes.

00:23:00.790 --> 00:23:05.020
E farei o possível para pressionar Enter à esquerda e à direita da minha tela

00:23:05.020 --> 00:23:06.100
ao mesmo tempo.

00:23:06.100 --> 00:23:08.770
Mas devemos ver, esperançosamente, a mesma lista de palavras com erros ortográficos

00:23:08.770 --> 00:23:10.390
e seus horários.

00:23:10.390 --> 00:23:12.380
Então vamos para a direita.

00:23:12.380 --> 00:23:15.136
Aqui vamos nós à esquerda.

00:23:15.136 --> 00:23:16.730
Tudo bem.

00:23:16.730 --> 00:23:18.680
Uma corrida para ver quem ganha aqui.

00:23:18.680 --> 00:23:19.820
C está à esquerda.

00:23:19.820 --> 00:23:21.680
Python está à direita.

00:23:21.680 --> 00:23:23.270
OK.

00:23:23.270 --> 00:23:25.530
Interessante.

00:23:25.530 --> 00:23:28.200
Esperançosamente, o Python está logo atrás.

00:23:28.200 --> 00:23:30.330
Observe que parte disso é atraso na Internet.

00:23:30.330 --> 00:23:33.360
E assim, pode não ser necessariamente um número louco de segundos.

00:23:33.360 --> 00:23:37.050
Mas o sistema está, de fato, usando, se o medirmos, um nível baixo.

00:23:37.050 --> 00:23:39.630
Quanto tempo a CPU gastou executando meu código?

00:23:39.630 --> 00:23:41.653
C levou um total de 1,64 segundos.

00:23:41.653 --> 00:23:44.820
Isso foi bem rápido, embora tenha demorado um pouco mais para todos os bytes

00:23:44.820 --> 00:23:46.590
vir pela internet.

00:23:46.590 --> 00:23:49.050
A versão Python, porém, levou o quê?

00:23:49.050 --> 00:23:50.605
2,44 segundos.

00:23:50.605 --> 00:23:53.100
Então, qual pode ser a inferência?

00:23:53.100 --> 00:23:55.590
Um, talvez eu seja apenas melhor em programação em C

00:23:55.590 --> 00:23:59.400
do que eu em Python, o que provavelmente não é verdade.

00:23:59.400 --> 00:24:03.210
Mas o que mais você pode inferir desse exemplo?

00:24:07.541 --> 00:24:11.176
Devemos, talvez, desistir de Python, ficar com C?

00:24:11.176 --> 00:24:12.070
Não?

00:24:12.070 --> 00:24:14.410
Então, o que pode estar acontecendo aqui?

00:24:14.410 --> 00:24:16.870
Por que a versão do Python, que eu afirmo estar correta--

00:24:16.870 --> 00:24:20.620
e acho que todos os números estão alinhados, mas não os tempos.

00:24:20.620 --> 00:24:21.820
Onde está o trade-off aqui?

00:24:21.820 --> 00:24:23.915
Bem, aqui, novamente, está essa troca de design.

00:24:23.915 --> 00:24:24.415
Sim?

00:24:24.415 --> 00:24:29.310
AUDIÊNCIA: Para economizar o tempo do programador, [INAUDÍVEL]..

00:24:29.310 --> 00:24:30.690
DAVID MALAN: Sim, exatamente.

00:24:30.690 --> 00:24:32.910
A fim de economizar o tempo do programador humano,

00:24:32.910 --> 00:24:35.700
há muito mais recursos integrados ao Python-- mais funções,

00:24:35.700 --> 00:24:38.920
gerenciamento mais automático de memória e assim por diante -

00:24:38.920 --> 00:24:40.530
e você tem que pagar um preço.

00:24:40.530 --> 00:24:43.193
O código de outra pessoa está fazendo todo esse trabalho para você.

00:24:43.193 --> 00:24:45.360
Mas se eles escreveram algumas linhas de código,

00:24:45.360 --> 00:24:47.152
essas são apenas mais linhas de código que precisam

00:24:47.152 --> 00:24:50.730
para ser executado para você, enquanto aqui, o computador é

00:24:50.730 --> 00:24:54.615
correndo o risco de simplificar demais apenas executando minhas linhas de código.

00:24:54.615 --> 00:24:55.865
Portanto, há apenas menos despesas gerais.

00:24:55.865 --> 00:24:57.448
E assim, este é um trade-off perpétuo.

00:24:57.448 --> 00:25:00.990
Normalmente, ao usar uma linguagem mais amigável e mais moderna,

00:25:00.990 --> 00:25:02.983
um dos preços que você pode pagar é o desempenho.

00:25:02.983 --> 00:25:06.150
Agora, há muitos cientistas de computação inteligentes no mundo, tentando

00:25:06.150 --> 00:25:08.440
para recuar nesses mesmos trade-offs.

00:25:08.440 --> 00:25:11.220
E assim, esses intérpretes, como o comando que escrevi,

00:25:11.220 --> 00:25:15.390
Python tecnicamente pode-- especialmente se você executar um programa de novo e de novo--

00:25:15.390 --> 00:25:19.350
na verdade, secretamente, nos bastidores, compilar seu código para você,

00:25:19.350 --> 00:25:20.610
até 0s e 1s.

00:25:20.610 --> 00:25:23.640
E então, na segunda, na terceira, na quarta vez que você executa esse programa,

00:25:23.640 --> 00:25:25.010
pode muito bem ser mais rápido.

00:25:25.010 --> 00:25:27.150
Então, isso é um pouco falso aqui, nisso

00:25:27.150 --> 00:25:29.490
Estou executando-os uma vez e apenas uma vez.

00:25:29.490 --> 00:25:32.070
Mas poderíamos obter benefícios ao longo do tempo se mantivéssemos

00:25:32.070 --> 00:25:34.183
executando a versão do Python de novo e de novo

00:25:34.183 --> 00:25:35.850
e, talvez, ajustar o desempenho.

00:25:35.850 --> 00:25:38.017
Mas, em geral, haverá essa compensação.

00:25:38.017 --> 00:25:40.560
Agora, você prefere passar os 60 segundos

00:25:40.560 --> 00:25:43.620
Eu escrevi implementando um corretor ortográfico ou essas 6 horas,

00:25:43.620 --> 00:25:47.910
16 horas você pode estar ou ter gasto implementando o mesmo em C?

00:25:47.910 --> 00:25:48.720
Provavelmente não.

00:25:48.720 --> 00:25:52.650
Por uma questão de produtividade, é por isso que temos esses idiomas adicionais.

00:25:52.650 --> 00:25:57.300
Apenas por diversão, deixe-me virar para outra tela aqui e abrir

00:25:57.300 --> 00:26:00.540
uma versão do Python que é realmente-- em apenas um segundo--

00:26:00.540 --> 00:26:04.230
no meu próprio Mac em vez da nuvem para que

00:26:04.230 --> 00:26:06.490
Eu posso realmente fazer algo com gráficos.

00:26:06.490 --> 00:26:09.930
Então, aqui, eu só tenho uma janela de terminal em preto e branco no meu próprio Mac.

00:26:09.930 --> 00:26:12.450
E pré-instalei o Python, assim como fizemos

00:26:12.450 --> 00:26:14.370
para VS Code na nuvem para você.

00:26:14.370 --> 00:26:19.320
Observe que eu tenho esta foto de, talvez, uma de suas TVs favoritas

00:26:19.320 --> 00:26:21.090
shows aqui, com o elenco de The Office.

00:26:21.090 --> 00:26:24.630
Observe todos os rostos nesta imagem aqui.

00:26:24.630 --> 00:26:30.210
E deixe-me propor que tentemos encontrar um rosto na multidão, estilo CSI,

00:26:30.210 --> 00:26:33.660
por meio do qual queremos encontrar, talvez, o Scranton Strangler, por assim dizer.

00:26:33.660 --> 00:26:37.080
E então, aqui está um exemplo do rosto desse cara.

00:26:37.080 --> 00:26:40.385
Agora, como vamos encontrar esse rosto específico na multidão?

00:26:40.385 --> 00:26:42.510
Bem, nossos olhos humanos, obviamente, podem arrancá-lo,

00:26:42.510 --> 00:26:44.370
especialmente se você estiver familiarizado com o show.

00:26:44.370 --> 00:26:46.605
Mas deixe-me ir em frente e fazer isso em seu lugar.

00:26:46.605 --> 00:26:50.730
Deixe-me ir em frente e propor que executemos o código

00:26:50.730 --> 00:26:52.800
que já escrevi com antecedência aqui.

00:26:52.800 --> 00:26:55.085
Este é um programa Python com mais linhas de código

00:26:55.085 --> 00:26:56.460
sobre o qual não vamos nos deter por hoje.

00:26:56.460 --> 00:26:58.800
Mas serve para motivar o que podemos fazer.

00:26:58.800 --> 00:27:03.150
De uma biblioteca de almofadas, implicando uma biblioteca de imagens Python,

00:27:03.150 --> 00:27:07.033
Eu quero importar algum tipo de informação,

00:27:07.033 --> 00:27:09.450
algum recurso chamado imagem para que eu possa manipular imagens,

00:27:09.450 --> 00:27:12.150
não muito diferente do nosso próprio conjunto de problemas quatro.

00:27:12.150 --> 00:27:13.330
E isso é poderoso.

00:27:13.330 --> 00:27:13.830
em?

00:27:13.830 --> 00:27:14.330
Pitão.

00:27:14.330 --> 00:27:18.450
Você pode apenas [MIMICS EXPLOSION] importar o reconhecimento facial como uma biblioteca

00:27:18.450 --> 00:27:19.950
que outra pessoa escreveu.

00:27:19.950 --> 00:27:22.770
A partir daí, vou criar uma variável chamada image.

00:27:22.770 --> 00:27:25.050
Vou usar essas bibliotecas de reconhecimento facial.

00:27:25.050 --> 00:27:27.330
função load_image_file.

00:27:27.330 --> 00:27:30.030
É um pouco prolixo, mas é semelhante em espírito ao fopen.

00:27:30.030 --> 00:27:32.100
E vou abrir office.jpeg.

00:27:32.100 --> 00:27:36.990
Vou, então, declarar uma segunda variável chamada face_locations, plural,

00:27:36.990 --> 00:27:40.620
porque o que espero obter, de acordo com a documentação desta biblioteca,

00:27:40.620 --> 00:27:44.650
é uma lista de todos os locais dos rostos que são detectados.

00:27:44.650 --> 00:27:45.150
Tudo bem.

00:27:45.150 --> 00:27:48.660
Em seguida, vou iterar sobre cada uma dessas faces usando um loop for,

00:27:48.660 --> 00:27:50.460
que veremos com mais detalhes.

00:27:50.460 --> 00:27:53.475
Vou, então, inferir quais são os cantos superior, direito, inferior e esquerdo

00:27:53.475 --> 00:27:55.050
são dessa cara.

00:27:55.050 --> 00:28:00.300
E então, o que vou fazer aqui é mostrar esse rosto sozinho,

00:28:00.300 --> 00:28:03.040
se detectei o rosto em questão.

00:28:03.040 --> 00:28:08.760
Então deixe-me ir em frente, aqui, e executar detect.py.

00:28:08.760 --> 00:28:12.370
E veremos não apenas o rosto que procuramos.

00:28:12.370 --> 00:28:16.430
Mas se eu executar o Python do detect.py, ele fará toda a análise.

00:28:16.430 --> 00:28:22.380
Vou ver uma grande abertura aqui, agora, de todos os rostos que

00:28:22.380 --> 00:28:24.870
foram detectados neste programa aqui.

00:28:24.870 --> 00:28:26.870
[RISOS] OK, alguns melhores que outros, eu acho,

00:28:26.870 --> 00:28:28.560
se você aumentar o zoom para pegar alguém.

00:28:28.560 --> 00:28:29.970
Típica Ângela.

00:28:29.970 --> 00:28:32.700
Se você quiser, agora, encontrar aquele rosto, eu

00:28:32.700 --> 00:28:34.920
acho que precisamos treinar o software um pouco mais.

00:28:34.920 --> 00:28:37.080
Então deixe-me abrir um segundo programa chamado

00:28:37.080 --> 00:28:39.270
reconhecer que tem mais coisas acontecendo.

00:28:39.270 --> 00:28:41.370
Mas deixe-me, com um aceno de mão, apontar

00:28:41.370 --> 00:28:45.870
que agora estou carregando não só o office.jpeg, mas também o toby.jpeg

00:28:45.870 --> 00:28:49.840
para treinar o algoritmo para encontrar essa face específica.

00:28:49.840 --> 00:28:53.580
E então, agora, se eu executar esta segunda versão--reconhecer.py--

00:28:53.580 --> 00:28:56.310
com Python de reconhece.py--

00:28:56.310 --> 00:28:59.160
prendo a respiração por um momento; está analisando, presumivelmente,

00:28:59.160 --> 00:29:00.420
todos os rostos--

00:29:00.420 --> 00:29:02.070
você vê a mesma foto original.

00:29:02.070 --> 00:29:05.610
Mas você vê um desses rostos destacado aqui?

00:29:05.610 --> 00:29:09.420
Esta versão do código encontrou Toby, destacou-o

00:29:09.420 --> 00:29:12.110
com a tela e, voila, temos reconhecimento facial.

00:29:12.110 --> 00:29:14.318
Então, para o bem ou para o mal, é isso que está acontecendo,

00:29:14.318 --> 00:29:15.967
cada vez mais socialmente, hoje em dia.

00:29:15.967 --> 00:29:18.300
E honestamente, embora eu não tenha escrito o código ao vivo--

00:29:18.300 --> 00:29:21.420
porque é uma boa dúzia ou mais linhas de código-- não é muito.

00:29:21.420 --> 00:29:24.450
E literalmente, todas as autoridades-- tudo o que temos que fazer

00:29:24.450 --> 00:29:27.960
é importar o reconhecimento facial e, voila, você tem acesso.

00:29:27.960 --> 00:29:29.890
Essas tecnologias já estão aqui.

00:29:29.890 --> 00:29:31.690
Mas vamos considerar, por apenas um momento -

00:29:31.690 --> 00:29:33.820
como encontramos Toby?

00:29:33.820 --> 00:29:35.150
Como essa biblioteca...

00:29:35.150 --> 00:29:37.900
mesmo que não vamos ver os detalhes de sua implementação,

00:29:37.900 --> 00:29:40.000
como ele encontra Toby e o distingue

00:29:40.000 --> 00:29:43.960
de todos esses outros rostos na multidão?

00:29:43.960 --> 00:29:47.180
O que pode estar fazendo, intuitivamente.

00:29:47.180 --> 00:29:50.570
Pense até mesmo no p-conjunto quatro, ao que vocês mesmos têm acesso, em termos de dados.

00:29:50.570 --> 00:29:51.083
Sim?

00:29:51.083 --> 00:29:53.750
PÚBLICO: [? Já que ?] demos uma imagem do rosto de Toby antes,

00:29:53.750 --> 00:29:59.010
provavelmente os pixels em uma área são iguais aos de outra área

00:29:59.010 --> 00:30:00.720
e atribui ao mesmo -

00:30:00.720 --> 00:30:02.998
daquela imagem de referência para esta imagem.

00:30:02.998 --> 00:30:06.870
E então, vai dizer, ei, muitos intervalos de consulta semelhantes

00:30:06.870 --> 00:30:09.292
estão aqui e aqui, então podemos adivinhar com segurança

00:30:09.292 --> 00:30:10.750
que este é o mesmo [? pessoa. ?]

00:30:10.750 --> 00:30:11.875
DAVID MALAN: Sim, exatamente.

00:30:11.875 --> 00:30:15.610
E para resumir para a câmera aqui, treinamos o software, se preferir,

00:30:15.610 --> 00:30:17.560
dando-lhe uma foto do rosto de Toby.

00:30:17.560 --> 00:30:20.218
Então, olhando para os mesmos pixels ou, na verdade, semelhantes -

00:30:20.218 --> 00:30:22.510
especialmente se for uma imagem ligeiramente diferente de Toby--

00:30:22.510 --> 00:30:24.970
podemos, talvez, identificá-lo na multidão.

00:30:24.970 --> 00:30:26.412
E o que realmente é um rosto humano?

00:30:26.412 --> 00:30:28.120
Bem, no final das contas, o computador

00:30:28.120 --> 00:30:30.340
só o conhece como um padrão de bits ou, na verdade,

00:30:30.340 --> 00:30:32.110
em um nível superior, um padrão de pixels.

00:30:32.110 --> 00:30:35.170
Então talvez um rosto humano seja, talvez, melhor definido, em geral,

00:30:35.170 --> 00:30:39.295
como dois olhos e um nariz e uma boca que, embora todos pareçamos semelhantes,

00:30:39.295 --> 00:30:43.268
estruturalmente, as probabilidades são, a medida entre os olhos e o nariz

00:30:43.268 --> 00:30:45.310
e a largura da boca, o tom da pele e tudo

00:30:45.310 --> 00:30:47.920
dessas outras características físicas são padrões

00:30:47.920 --> 00:30:51.280
esse software poderia, talvez, detectar e, em seguida, procurar, estatisticamente,

00:30:51.280 --> 00:30:53.920
através da imagem, procurando a correspondência mais próxima possível

00:30:53.920 --> 00:30:57.422
a essas várias formas de medição, cores e tamanhos e afins.

00:30:57.422 --> 00:30:59.130
E, de fato, essa pode ser a intuição.

00:30:59.130 --> 00:31:03.520
Mas o que é poderoso aqui, novamente, é o quão fácil e prontamente disponível

00:31:03.520 --> 00:31:06.280
esta tecnologia agora é.

00:31:06.280 --> 00:31:06.820
Tudo bem.

00:31:06.820 --> 00:31:10.605
Dito isso, vamos nos propor a considerar o que mais

00:31:10.605 --> 00:31:13.480
pode fazer com o próprio Python, volte aos fundamentos, para que você,

00:31:13.480 --> 00:31:16.990
vocês mesmos podem começar a implementar algo nessa mesma linha.

00:31:16.990 --> 00:31:21.820
Além de ter acesso a coisas como uma função get_string,

00:31:21.820 --> 00:31:26.080
a biblioteca CS50 também fornece algumas outras coisas-- ou seja, em C,

00:31:26.080 --> 00:31:27.040
tivemos estes.

00:31:27.040 --> 00:31:29.052
Mas em Python, teremos menos.

00:31:29.052 --> 00:31:32.260
Em Python, nossa biblioteca, a curto prazo, fornecerá não apenas get_string,

00:31:32.260 --> 00:31:33.740
mas também get_int e get_float.

00:31:33.740 --> 00:31:34.240
Por que?

00:31:34.240 --> 00:31:36.310
Na verdade, é apenas irritante, pois em breve

00:31:36.310 --> 00:31:39.190
veja, para recuperar um inteiro ou um float de um usuário

00:31:39.190 --> 00:31:44.890
e apenas certifique-se de que é um int e um float e não uma palavra como gato ou cachorro,

00:31:44.890 --> 00:31:47.170
ou alguma string que não seja realmente um número.

00:31:47.170 --> 00:31:50.810
Bem, podemos importar não apenas a função específica, get_string,

00:31:50.810 --> 00:31:53.920
mas podemos importar todas essas funções uma de cada vez,

00:31:53.920 --> 00:31:55.840
assim, como veremos em breve.

00:31:55.840 --> 00:31:59.410
Ou você pode até, em Python, importar funções específicas de um arquivo.

00:31:59.410 --> 00:32:04.300
Um de vocês perguntou há algum tempo, quando você inclui algo como CS50.h

00:32:04.300 --> 00:32:08.780
ou I/O .h padrão, na verdade, você está obtendo todo o código desse arquivo,

00:32:08.780 --> 00:32:12.010
o que, potencialmente, pode adicionar volume ao seu próprio programa ou tempo.

00:32:12.010 --> 00:32:15.040
Nesse caso, ao importar funções específicas do Python,

00:32:15.040 --> 00:32:17.875
você pode ser um pouco mais preciso

00:32:17.875 --> 00:32:21.230
quanto ao que você deseja ter acesso.

00:32:21.230 --> 00:32:21.730
Tudo bem.

00:32:21.730 --> 00:32:23.890
Então, com isso dito, vamos em frente e ver

00:32:23.890 --> 00:32:25.900
como os condicionais se parecem em Python.

00:32:25.900 --> 00:32:29.470
Então, no lado esquerdo novamente, aqui, veremos o Scratch.

00:32:29.470 --> 00:32:33.190
Portanto, é apenas um exemplo artificial perguntando se x é menor que y, então,

00:32:33.190 --> 00:32:35.350
digamos, x é menor que y.

00:32:35.350 --> 00:32:37.540
Em C, ficou assim.

00:32:37.540 --> 00:32:41.050
Em Python, agora, ficará assim.

00:32:41.050 --> 00:32:44.815
E aqui está antes em C, e aqui está depois.

00:32:44.815 --> 00:32:47.320
E apenas para destacar algumas das diferenças óbvias, o que

00:32:47.320 --> 00:32:49.810
mudou, em Python, para condicionais, ao que parece?

00:32:53.013 --> 00:32:53.930
Qual é a diferença?

00:32:53.930 --> 00:32:54.230
Sim.

00:32:54.230 --> 00:32:55.920
AUDIÊNCIA: Há uma falta de chaves.

00:32:55.920 --> 00:32:56.380
DAVID MALAN: Sim.

00:32:56.380 --> 00:32:57.760
Portanto, não há mais chaves.

00:32:57.760 --> 00:32:59.170
E, de fato, você não os usa.

00:32:59.170 --> 00:33:04.138
O que parece estar tomando o lugar deles, se você pode inferir?

00:33:04.138 --> 00:33:05.680
O que parece ter tomado o lugar deles?

00:33:05.680 --> 00:33:05.890
O que você acha?

00:33:05.890 --> 00:33:06.765
AUDIÊNCIA: [INAUDÍVEL]

00:33:06.765 --> 00:33:09.560
DAVID MALAN: Então, os dois pontos no início desta linha, aqui.

00:33:09.560 --> 00:33:13.760
Mas também ainda mais importante, agora, é esse recuo abaixo dele.

00:33:13.760 --> 00:33:16.160
Então, alguns de vocês, e sabemos disso no horário de expediente,

00:33:16.160 --> 00:33:19.380
tem o hábito de recuar tudo à esquerda, certo?

00:33:19.380 --> 00:33:21.200
E é apenas uma bagunça maluca de se olhar.

00:33:21.200 --> 00:33:23.000
Frustrante para você, certamente.

00:33:23.000 --> 00:33:25.670
Mas C e Clang são bastante tolerantes quando

00:33:25.670 --> 00:33:27.860
trata de coisas como espaço em branco em um programa.

00:33:27.860 --> 00:33:29.030
Python, uh-uh.

00:33:29.030 --> 00:33:32.240
Eles perceberam, anos atrás, que-- vamos ajudar os humanos a se ajudarem e apenas

00:33:32.240 --> 00:33:34.610
exigem recuo padrão.

00:33:34.610 --> 00:33:36.620
Portanto, quatro espaços seriam a norma aqui.

00:33:36.620 --> 00:33:38.870
Mas porque está recuado abaixo dos dois pontos, isso,

00:33:38.870 --> 00:33:42.110
na verdade, indica que isso, agora, faz parte dessa condição.

00:33:42.110 --> 00:33:46.340
Algo mais está faltando, contra C, nesta condicional.

00:33:46.340 --> 00:33:47.855
O que mais é um pouco simplificado?

00:33:47.855 --> 00:33:49.660
AUDIÊNCIA: [INAUDÍVEL]

00:33:49.660 --> 00:33:50.410
DAVID MALAN: Sim.

00:33:50.410 --> 00:33:51.368
Então chega de parênteses.

00:33:51.368 --> 00:33:53.650
Você ainda pode usá-los, especialmente quando precisar,

00:33:53.650 --> 00:33:56.112
logicamente, para fazer a ordem das operações, como na matemática.

00:33:56.112 --> 00:33:57.820
Mas neste caso, se você quiser apenas perguntar

00:33:57.820 --> 00:34:01.162
uma pergunta simples, como se x for menor que y, você pode fazer assim.

00:34:01.162 --> 00:34:02.620
E quando você tem um if else?

00:34:02.620 --> 00:34:05.170
Bem, isso é quase o mesmo, aqui, com essas mesmas mudanças.

00:34:05.170 --> 00:34:06.800
Em C, isso parecia assim.

00:34:06.800 --> 00:34:08.800
E está começando a ficar um pouco volumoso-- pelo menos,

00:34:08.800 --> 00:34:10.659
se usarmos nossas chaves dessa maneira.

00:34:10.659 --> 00:34:13.060
Em Python, podemos apertar ainda mais as coisas, embora,

00:34:13.060 --> 00:34:15.727
estritamente falando, em C, você nem sempre precisa das chaves.

00:34:15.727 --> 00:34:18.280
Mas aqui, os parênteses se foram, novamente.

00:34:18.280 --> 00:34:20.020
Longe vão as chaves.

00:34:20.020 --> 00:34:23.380
O recuo é consistente e acabamos de adicionar outra palavra-chave,

00:34:23.380 --> 00:34:24.580
caso contrário, com os dois pontos.

00:34:24.580 --> 00:34:26.325
Mas sem mais ponto e vírgula também.

00:34:26.325 --> 00:34:30.010
Que tal algo maior, assim, em if, else, if else?

00:34:30.010 --> 00:34:31.960
Este é um pouco curioso.

00:34:31.960 --> 00:34:35.290
Mas em C, parecia assim-- if, else, if else.

00:34:35.290 --> 00:34:38.143
Em Python, agora se parece com isso.

00:34:38.143 --> 00:34:40.060
E há, talvez, uma curiosidade aqui que,

00:34:40.060 --> 00:34:41.977
honestamente, todos esses anos depois, ainda não consigo

00:34:41.977 --> 00:34:43.630
lembre-se de como soletrar metade do tempo.

00:34:43.630 --> 00:34:46.900
O que há de estranho nisso?

00:34:46.900 --> 00:34:50.415
O que você vê de diferente?

00:34:50.415 --> 00:34:51.230
Sim, aqui.

00:34:51.230 --> 00:34:53.520
AUDIÊNCIA: [INAUDÍVEL]

00:34:53.520 --> 00:34:54.270
DAVID MALAN: Sim.

00:34:54.270 --> 00:34:56.260
Em vez de else if, é elif.

00:34:56.260 --> 00:34:56.760
Por que?

00:34:56.760 --> 00:34:59.340
[Suspira] Aparentemente, senão o espaço era demais

00:34:59.340 --> 00:35:02.250
pressionamentos de tecla para os humanos digitarem, então eles condensaram dessa maneira.

00:35:02.250 --> 00:35:05.100
Provavelmente significa que é um pouco mais distinguível, também,

00:35:05.100 --> 00:35:07.200
para o computador entre o if e o else também.

00:35:07.200 --> 00:35:08.700
Mas apenas algo para lembrar, agora.

00:35:08.700 --> 00:35:10.620
É, de fato, elif e não else if.

00:35:10.620 --> 00:35:11.123
Tudo bem.

00:35:11.123 --> 00:35:12.540
E as variáveis ​​em Python?

00:35:12.540 --> 00:35:16.590
Eu já usei alguns deles, mas vamos

00:35:16.590 --> 00:35:19.533
destilar exatamente como você define e declara essas coisas também.

00:35:19.533 --> 00:35:22.200
Então, no Scratch, se quiséssemos criar uma variável chamada contador

00:35:22.200 --> 00:35:25.185
e defini-lo igual, inicialmente, a 0, faríamos algo

00:35:25.185 --> 00:35:28.680
assim-- especifique que é um int, use o operador de atribuição,

00:35:28.680 --> 00:35:30.060
terminar o pensamento com um ponto e vírgula.

00:35:30.060 --> 00:35:32.310
Em Python, é apenas mais simples.

00:35:32.310 --> 00:35:34.680
Você nomeia a variável, usa o operador de atribuição,

00:35:34.680 --> 00:35:37.755
como antes, você define igual a algum valor, e é isso.

00:35:37.755 --> 00:35:38.880
Você não menciona o tipo.

00:35:38.880 --> 00:35:41.250
Você não menciona o ponto e vírgula ou qualquer outra coisa.

00:35:41.250 --> 00:35:44.250
E se você quiser alterar uma variável, como contador,

00:35:44.250 --> 00:35:46.320
por 1-- isto é, incrementado por 1?

00:35:46.320 --> 00:35:47.800
Você tem algumas maneiras diferentes aqui.

00:35:47.800 --> 00:35:51.990
Em C, vimos uma sintaxe como esta, onde você pode dizer contador igual a contador mais 1,

00:35:51.990 --> 00:35:54.900
o que, novamente, parece ilógico.

00:35:54.900 --> 00:35:56.610
Como pode o contador ser igual ao contador mais 1?

00:35:56.610 --> 00:36:01.890
Mas, novamente, lemos esse código, realmente, da direita para a esquerda, atualizando seu valor em 1.

00:36:01.890 --> 00:36:03.550
Em Python, é quase o mesmo.

00:36:03.550 --> 00:36:04.535
Você acabou de se livrar do ponto e vírgula.

00:36:04.535 --> 00:36:05.580
Então essa lógica está aí.

00:36:05.580 --> 00:36:08.070
Mas lembre-se, em C, poderíamos fazer algo um pouco diferente

00:36:08.070 --> 00:36:09.840
que também podemos fazer em Python.

00:36:09.840 --> 00:36:12.060
Em Python, você também pode, de forma mais sucinta,

00:36:12.060 --> 00:36:15.420
faça isso-- mais é igual, e então, qualquer número que você queira adicionar.

00:36:15.420 --> 00:36:17.790
Ou você pode até alterar para subtrair, se preferir.

00:36:17.790 --> 00:36:21.495
Infelizmente, ido é algo que você provavelmente digitou muito.

00:36:21.495 --> 00:36:23.940
Qual era a outra maneira de adicionar 1?

00:36:23.940 --> 00:36:24.773
AUDIÊNCIA: Mais mais?

00:36:24.773 --> 00:36:26.940
DAVID MALAN: Plus plus não existe mais, infelizmente, em Python.

00:36:26.940 --> 00:36:29.600
Muitas maneiras de fazer a mesma coisa, então eles se livraram disso

00:36:29.600 --> 00:36:31.705
em favor de apenas esta sintaxe, aqui.

00:36:31.705 --> 00:36:33.140
Portanto, tenha isso em mente também.

00:36:33.140 --> 00:36:36.500
E os loops, quando você quer fazer algo em Python repetidas vezes.

00:36:36.500 --> 00:36:39.380
Bem, no Scratch, na semana zero, eis como miamos três vezes,

00:36:39.380 --> 00:36:40.700
especificamente.

00:36:40.700 --> 00:36:42.650
Em C, tínhamos algumas maneiras de fazer isso.

00:36:42.650 --> 00:36:46.460
Esta foi a abordagem mais mecânica, onde você cria uma variável chamada i.

00:36:46.460 --> 00:36:47.780
Você define igual a 0.

00:36:47.780 --> 00:36:51.230
Você então faz enquanto i é menor que 3, o seguinte.

00:36:51.230 --> 00:36:54.530
E então, você mesmo incrementa i de novo e de novo.

00:36:54.530 --> 00:36:57.920
Mecânica no sentido de que você tem que implementar todas essas engrenagens

00:36:57.920 --> 00:37:01.130
e fazê-los virar você mesmo, mas essa era a maneira correta de fazer isso.

00:37:01.130 --> 00:37:03.740
Em Python, ainda podemos alcançar a mesma ideia,

00:37:03.740 --> 00:37:05.945
mas não precisamos da palavra-chave int.

00:37:05.945 --> 00:37:07.445
Não precisamos de nenhum ponto e vírgula.

00:37:07.445 --> 00:37:08.695
Não precisamos dos parênteses.

00:37:08.695 --> 00:37:10.310
Não precisamos das chaves.

00:37:10.310 --> 00:37:12.200
Não podemos usar o plus plus, então talvez seja

00:37:12.200 --> 00:37:14.300
um pequeno passo para trás se você for um fã.

00:37:14.300 --> 00:37:17.930
Mas fora isso, o código, a lógica é exatamente a mesma.

00:37:17.930 --> 00:37:20.390
Mas há outras maneiras de alcançar essa mesma ideia.

00:37:20.390 --> 00:37:22.950
Lembre-se que, em C, também poderíamos fazer isso.

00:37:22.950 --> 00:37:25.880
Você poderia usar um loop for, que faz exatamente a mesma coisa.

00:37:25.880 --> 00:37:26.893
Ambos estão corretos.

00:37:26.893 --> 00:37:28.310
Ambos são, indiscutivelmente, bem projetados.

00:37:28.310 --> 00:37:32.000
É para cada um deles quando se trata de escolher entre eles.

00:37:32.000 --> 00:37:35.930
Em Python, porém, teremos que pensar em como fazer isso.

00:37:35.930 --> 00:37:41.300
Portanto, você não faz o mesmo loop for como em C. O mais próximo que pude chegar

00:37:41.300 --> 00:37:44.270
é isso, onde você diz para i--

00:37:44.270 --> 00:37:47.555
ou qualquer variável que você queira fazer a contagem-- em-- literalmente

00:37:47.555 --> 00:37:50.522
a preposição-- e então, você usa colchetes aqui.

00:37:50.522 --> 00:37:52.730
E já usamos colchetes antes, no contexto

00:37:52.730 --> 00:37:55.370
de matrizes e coisas assim.

00:37:55.370 --> 00:38:00.080
E o 0, 1, 2 parece uma matriz, em certo sentido, embora também tenhamos visto

00:38:00.080 --> 00:38:01.470
arrays com chaves.

00:38:01.470 --> 00:38:03.950
Mas esses colchetes, por enquanto, denotam uma lista.

00:38:03.950 --> 00:38:05.420
Python não tem matrizes.

00:38:05.420 --> 00:38:08.600
Uma matriz é aquele pedaço contíguo de memória, costas com costas,

00:38:08.600 --> 00:38:13.160
que você tem que redimensionar de alguma forma movendo as coisas na memória,

00:38:13.160 --> 00:38:14.450
como por duas semanas atrás.

00:38:14.450 --> 00:38:19.175
Em Python, porém, você pode simplesmente criar uma lista como esta usando colchetes.

00:38:19.175 --> 00:38:22.700
E melhor ainda, como veremos, você pode adicionar ou mesmo remover coisas

00:38:22.700 --> 00:38:24.920
dessa lista no futuro.

00:38:24.920 --> 00:38:27.140
Isso, porém, não será muito bem projetado.

00:38:27.140 --> 00:38:28.610
Isso vai funcionar.

00:38:28.610 --> 00:38:32.030
Isso irá iterar em Python três vezes.

00:38:32.030 --> 00:38:34.700
Mas o que pode atrapalhar você nesse design,

00:38:34.700 --> 00:38:36.860
mesmo que você nunca tenha visto Python antes?

00:38:36.860 --> 00:38:38.460
Como esse exemplo não termina bem?

00:38:38.460 --> 00:38:38.960
Sim?

00:38:38.960 --> 00:38:41.810
AUDIÊNCIA: Fazendo uma lista grande [INAUDÍVEL]..

00:38:41.810 --> 00:38:42.560
DAVID MALAN: Sim.

00:38:42.560 --> 00:38:45.830
Se você estiver fazendo uma lista grande, deverá digitar cada um desses números,

00:38:45.830 --> 00:38:50.178
como vírgula 3, vírgula 4, vírgula 5, vírgula, ponto, ponto, ponto, 50 vírgula, ponto, ponto, ponto,

00:38:50.178 --> 00:38:50.678
500.

00:38:50.678 --> 00:38:52.640
Como, certamente, essa não é a melhor solução,

00:38:52.640 --> 00:38:55.760
ter todos esses números na tela,

00:38:55.760 --> 00:38:57.140
envolvendo infinitamente na tela.

00:38:57.140 --> 00:39:01.100
Então, em Python, outra forma de fazer isso seria usar uma função

00:39:01.100 --> 00:39:04.160
chamado range, que, tecnicamente, é um tipo de dados sobre si mesmo.

00:39:04.160 --> 00:39:08.080
E isso devolve a você tantos valores quantos você pedir.

00:39:08.080 --> 00:39:09.830
range também aceita alguns outros argumentos.

00:39:09.830 --> 00:39:14.540
Mas o caso de uso mais simples aqui é, se você quiser de volta os números 0, 1 e 2--

00:39:14.540 --> 00:39:15.890
um total de três valores--

00:39:15.890 --> 00:39:19.070
você diz, ei, Python, por favor me dê um intervalo de três valores.

00:39:19.070 --> 00:39:21.260
E por padrão, eles começam em 0 em cima.

00:39:21.260 --> 00:39:24.320
Mas isso é mais eficiente do que seria

00:39:24.320 --> 00:39:26.390
para codificar a lista inteira de uma só vez.

00:39:26.390 --> 00:39:29.150
E a melhor metáfora que consegui inventar é algo assim.

00:39:29.150 --> 00:39:30.775
Aqui, por exemplo, está um baralho de cartas.

00:39:30.775 --> 00:39:34.430
Isso é normal, tamanho humano, e provavelmente há 52 cartas aqui.

00:39:34.430 --> 00:39:38.728
Portanto, escrever de 0 a 51 no código seria um pouco ridículo

00:39:38.728 --> 00:39:39.770
pelas razões que você conhece.

00:39:39.770 --> 00:39:44.510
E seria muito pesado e feio e envolvendo tudo isso.

00:39:44.510 --> 00:39:48.500
Seria o equivalente virtual de eu entregar a você todos esses cartões de uma vez

00:39:48.500 --> 00:39:49.430
para apenas lidar.

00:39:49.430 --> 00:39:52.760
E, certo, eles não são tão grandes, mas são muitos cartões para segurar.

00:39:52.760 --> 00:39:55.760
Requer muita memória ou armazenamento físico, se preferir.

00:39:55.760 --> 00:39:59.840
O que o range significa, metaforicamente, é, se você me pedir três cartas,

00:39:59.840 --> 00:40:04.910
Entrego-vos um de cada vez, assim, para que, a qualquer momento,

00:40:04.910 --> 00:40:08.150
você só tem um número na memória do computador

00:40:08.150 --> 00:40:09.760
até que você receba o próximo.

00:40:09.760 --> 00:40:11.840
A alternativa - a versão anterior seria

00:40:11.840 --> 00:40:15.360
seja entregar-me todas as três cartas de uma vez, ou todas as 52 cartas de uma vez.

00:40:15.360 --> 00:40:17.840
Mas, neste caso, o alcance é muito mais eficiente.

00:40:17.840 --> 00:40:19.700
Você pode fazer alcance de 1.000.

00:40:19.700 --> 00:40:22.940
Isso não fornecerá uma lista de 1.000 valores de uma só vez.

00:40:22.940 --> 00:40:25.910
Ele fornecerá 1.000 valores, um de cada vez,

00:40:25.910 --> 00:40:30.800
reduzindo significativamente a memória no próprio computador.

00:40:30.800 --> 00:40:31.310
Tudo bem.

00:40:31.310 --> 00:40:34.745
Então, além disso, que tal fazer algo para sempre no Scratch?

00:40:34.745 --> 00:40:38.060
Bem, poderíamos fazer isso, literalmente, com um bloco para sempre, o que não

00:40:38.060 --> 00:40:42.590
existem em C. Em C, tivemos que hackear dizendo while True--

00:40:42.590 --> 00:40:46.000
porque Verdadeiro é, por definição, VERDADEIRO, sempre verdadeiro.

00:40:46.000 --> 00:40:50.420
Isso induz deliberadamente um loop infinito para nós.

00:40:50.420 --> 00:40:53.375
Em Python, a lógica será quase a mesma.

00:40:53.375 --> 00:40:55.250
E loops infinitos em Python tendem a realmente

00:40:55.250 --> 00:40:58.760
ser ainda mais comum porque você sempre pode sair deles, como você poderia

00:40:58.760 --> 00:41:02.280
em C. Em Python, é assim.

00:41:02.280 --> 00:41:05.960
E isso é um pouco mais sutil, mas as chaves desapareceram.

00:41:05.960 --> 00:41:07.370
Longe vão os parênteses.

00:41:07.370 --> 00:41:10.400
Mas alguma diferença tão pequena, também?

00:41:10.400 --> 00:41:13.187
Um V maiúsculo para Verdadeiro e será um F maiúsculo para Falso.

00:41:13.187 --> 00:41:14.270
Pequenas diferenças estúpidas.

00:41:14.270 --> 00:41:16.440
Eventualmente, você vai digitar errado um ou outro.

00:41:16.440 --> 00:41:18.607
Mas esses são os tipos de coisas para ficar de olho

00:41:18.607 --> 00:41:21.770
e começar a reconhecer mentalmente quando você lê o código.

00:41:21.770 --> 00:41:25.310
Perguntas, agora, em qualquer um desses blocos de construção?

00:41:25.310 --> 00:41:26.075
Sim?

00:41:26.075 --> 00:41:31.360
AUDIÊNCIA: No loop for, fui definido como 0 uma vez para [? cada loop? ?]

00:41:31.360 --> 00:41:33.970
DAVID MALAN: No loop for, eu...

00:41:33.970 --> 00:41:37.090
foi definido como 0 na primeira iteração, depois 1 na próxima,

00:41:37.090 --> 00:41:38.530
então 2 no terceiro.

00:41:38.530 --> 00:41:39.985
E a mesma coisa para alcance.

00:41:39.985 --> 00:41:44.050
Ele simplesmente não usa tanta memória de uma só vez.

00:41:44.050 --> 00:41:49.860
Outras perguntas, agora, sobre algum desses blocos de construção do Python?

00:41:49.860 --> 00:41:50.400
Tudo bem.

00:41:50.400 --> 00:41:53.250
Bem, vamos em frente e construir algo um pouco mais do que olá.

00:41:53.250 --> 00:41:56.415
Deixe-me propor que, aqui, implementemos, talvez,

00:41:56.415 --> 00:41:58.200
a mais simples das calculadoras aqui.

00:41:58.200 --> 00:42:02.145
Então deixe-me voltar ao VS Code aqui, abra minha janela de terminal

00:42:02.145 --> 00:42:06.885
e abra, digamos, um arquivo chamado calculadora.py.

00:42:06.885 --> 00:42:09.000
E em calculadora.py, teremos a oportunidade

00:42:09.000 --> 00:42:11.340
para explorar alguns desses blocos de construção,

00:42:11.340 --> 00:42:13.890
mas vamos permitir que as coisas evoluam rapidamente

00:42:13.890 --> 00:42:17.225
a exemplos mais interessantes para que possamos fazer a mesma coisa, em última instância,

00:42:17.225 --> 00:42:17.760
também.

00:42:17.760 --> 00:42:19.510
E, de fato, deixe-me ir em frente e fazer isso.

00:42:19.510 --> 00:42:22.950
Além disso, trouxe algum código comigo com antecedência.

00:42:22.950 --> 00:42:25.725
Por exemplo, algo chamado calculadora0.c,

00:42:25.725 --> 00:42:28.860
desde a primeira semana de C. E deixe-me ir em frente

00:42:28.860 --> 00:42:34.420
e dividir minha janela aqui, de fato, para que agora eu possa fazer algo assim.

00:42:34.420 --> 00:42:37.170
Deixa eu mover isso aqui, aqui.

00:42:37.170 --> 00:42:38.105
Calculadora.py.

00:42:38.105 --> 00:42:40.920
Agora, à esquerda da minha tela, calculadora.c--

00:42:40.920 --> 00:42:43.620
ou calculadora0.c porque essa é a primeira versão que eu

00:42:43.620 --> 00:42:45.690
made-- e calculator.py à direita.

00:42:45.690 --> 00:42:48.290
Deixe-me seguir em frente e implementar, realmente, a mesma ideia aqui.

00:42:48.290 --> 00:42:51.675
Então, no lado direito, o análogo de incluir cs50.h

00:42:51.675 --> 00:42:56.390
seria de cs50 import get_int se eu quiser, de fato, usar esta função.

00:42:56.390 --> 00:42:58.140
Agora, eu vou em frente e me dou

00:42:58.140 --> 00:43:00.453
uma variável x sem definir seu tipo.

00:43:00.453 --> 00:43:02.370
Vou usar esta função get_int e estou

00:43:02.370 --> 00:43:05.302
vai solicitar x ao usuário, assim como em C.

00:43:05.302 --> 00:43:08.010
Vou, então, solicitar ao usuário outro int,

00:43:08.010 --> 00:43:12.300
como y, aqui, assim como em C. E bem no final, irei em frente

00:43:12.300 --> 00:43:14.640
e imprima x mais y.

00:43:14.640 --> 00:43:15.690
E é isso.

00:43:15.690 --> 00:43:19.020
Agora, claro, tenho alguns comentários na minha versão C do código,

00:43:19.020 --> 00:43:21.090
apenas para lembrá-lo do que cada linha está fazendo.

00:43:21.090 --> 00:43:23.878
Mas ainda destilei isso em seis linhas-- ou, na verdade, quatro

00:43:23.878 --> 00:43:25.170
se eu me livrar da linha em branco.

00:43:25.170 --> 00:43:29.580
Então já está, talvez, um pouco mais apertado aqui.

00:43:29.580 --> 00:43:33.600
É mais apertado porque algo realmente importante, historicamente, está faltando.

00:43:33.600 --> 00:43:38.240
O que pareço omitir completamente que ainda não destacamos?

00:43:38.240 --> 00:43:39.136
Sim?

00:43:39.136 --> 00:43:40.530
AUDIÊNCIA: [INAUDÍVEL]

00:43:40.530 --> 00:43:41.280
DAVID MALAN: Sim.

00:43:41.280 --> 00:43:42.910
A função principal desapareceu.

00:43:42.910 --> 00:43:45.330
E, de fato, talvez você tenha dado como certo que apenas

00:43:45.330 --> 00:43:47.580
funcionou um momento atrás quando escrevi olá, mas não

00:43:47.580 --> 00:43:49.273
também tem uma função principal em hello.

00:43:49.273 --> 00:43:52.440
E isso também é um recurso do Python e de muitas outras linguagens.

00:43:52.440 --> 00:43:55.320
Em vez de ter que aderir a essas tradições de longa data,

00:43:55.320 --> 00:43:57.400
se você quiser apenas escrever código e fazer algo, tudo bem.

00:43:57.400 --> 00:43:59.925
Basta escrever código e fazer algo sem, necessariamente,

00:43:59.925 --> 00:44:01.185
tudo isso mesmo clichê.

00:44:01.185 --> 00:44:04.380
Então, o que quer que esteja no seu arquivo Python--

00:44:04.380 --> 00:44:06.510
deixado recuado, se preferir, por padrão--

00:44:06.510 --> 00:44:10.180
será apenas o código que o interpretador executa, de cima para baixo,

00:44:10.180 --> 00:44:10.850
da esquerda para direita.

00:44:10.850 --> 00:44:14.300
Bem, deixe-me seguir em frente e executar um código como este.

00:44:14.300 --> 00:44:17.470
Deixe-me ir em frente e abrir novamente a janela do meu terminal,

00:44:17.470 --> 00:44:19.140
execute python de calculadora.py.

00:44:19.140 --> 00:44:21.570
E eu vou fazer x é 1, y é 2.

00:44:21.570 --> 00:44:23.460
E como você pode esperar, isso me dá 3.

00:44:23.460 --> 00:44:24.570
Leve bug estético.

00:44:24.570 --> 00:44:26.590
Eu coloquei meu espaço no lugar errado aqui.

00:44:26.590 --> 00:44:27.810
Então, isso é um erro de novato.

00:44:27.810 --> 00:44:29.220
Deixe-me corrigir isso, esteticamente.

00:44:29.220 --> 00:44:31.050
Deixe-me executar novamente o python de calculator.py.

00:44:31.050 --> 00:44:31.680
Digite 1.

00:44:31.680 --> 00:44:32.250
Digite 2.

00:44:32.250 --> 00:44:36.280
E, voila, agora existe minha mesma versão novamente.

00:44:36.280 --> 00:44:39.585
Mas deixe-me propor, agora, que nos livremos dessa roda de treinamento.

00:44:39.585 --> 00:44:41.460
Não queremos continuar dando um passo à frente

00:44:41.460 --> 00:44:43.793
e, em seguida, dois passos para trás, adicionando essas rodinhas,

00:44:43.793 --> 00:44:45.330
então deixe-me fazer isso.

00:44:45.330 --> 00:44:49.590
Na minha versão de calculator.py, suponha que já retiramos,

00:44:49.590 --> 00:44:53.610
a roda de treinamento que é a biblioteca CS50 aqui e deixe-me,

00:44:53.610 --> 00:44:56.910
em vez disso, use apenas a função interna do Python chamada

00:44:56.910 --> 00:44:59.020
input, que literalmente faz exatamente isso.

00:44:59.020 --> 00:45:03.600
Ele recebe a entrada do usuário e a armazena, como antes, em x e y.

00:45:03.600 --> 00:45:04.950
Portanto, isso não é específico do CS50.

00:45:04.950 --> 00:45:07.155
Esta é a programação Python do mundo real.

00:45:07.155 --> 00:45:10.740
Bem, deixe-me ir em frente e executar, novamente, python de calculadora.py.

00:45:10.740 --> 00:45:16.530
E, é claro, se x é 1 e y é 2, x mais y deve, é claro, ainda ser 3.

00:45:19.306 --> 00:45:24.285
É aparentemente 12, de acordo com Python, até que a biblioteca do CS50 se envolva.

00:45:24.285 --> 00:45:28.620
Mas alguém quer inferir o que deu errado?

00:45:28.620 --> 00:45:29.160
Sim?

00:45:29.160 --> 00:45:32.925
AUDIÊNCIA: Estamos sempre [INAUDÍVEL].

00:45:32.925 --> 00:45:33.800
DAVID MALAN: Exatamente.

00:45:33.800 --> 00:45:37.660
A função de entrada, por design, sempre retorna uma string de texto.

00:45:37.660 --> 00:45:39.410
Afinal, foi isso que o humano digitou.

00:45:39.410 --> 00:45:42.620
E mesmo assim, sim, eu digitei as teclas numéricas no teclado,

00:45:42.620 --> 00:45:44.600
ainda está voltando como todo o texto.

00:45:44.600 --> 00:45:47.090
Agora, talvez devêssemos usar como uma função get_int.

00:45:47.090 --> 00:45:48.575
Bem, isso não existe em Python.

00:45:48.575 --> 00:45:52.340
Tudo o que você pode fazer é obter entrada textual-- uma string do usuário.

00:45:52.340 --> 00:45:54.415
Mas podemos converter um para o outro.

00:45:54.415 --> 00:45:58.610
E assim, uma correção para isso para que não concatenemos acidentalmente -

00:45:58.610 --> 00:46:02.760
isto é, juntar x mais y-- seria fazer algo assim.

00:46:02.760 --> 00:46:04.595
Deixe-me voltar ao meu código Python, aqui.

00:46:04.595 --> 00:46:08.870
E considerando que, em C, poderíamos anteriormente fazer typecasting--

00:46:08.870 --> 00:46:11.060
podemos converter um tipo para outro--

00:46:11.060 --> 00:46:14.420
geralmente não era o caso quando você estava fazendo algo complexo,

00:46:14.420 --> 00:46:15.470
como uma string para um int.

00:46:15.470 --> 00:46:18.450
Você poderia fazer um char para um int e vice-versa.

00:46:18.450 --> 00:46:22.370
Mas para uma string, lembre-se, havia uma função especial na biblioteca do tipo C

00:46:22.370 --> 00:46:25.100
chamado a para I, como Ascii para inteiro.

00:46:25.100 --> 00:46:27.880
Esse é o analógico mais próximo, aqui.

00:46:27.880 --> 00:46:29.630
E, de fato, a maneira de fazer isso em Python

00:46:29.630 --> 00:46:32.740
seria usar uma função chamada int, que,

00:46:32.740 --> 00:46:34.490
de fato, é o nome do tipo de dados também,

00:46:34.490 --> 00:46:36.380
mesmo que eu ainda não tenha digitado.

00:46:36.380 --> 00:46:40.340
E posso converter a saída da função de entrada

00:46:40.340 --> 00:46:44.600
automaticamente de uma string imediatamente para um int.

00:46:44.600 --> 00:46:48.620
E agora, se eu voltar para a janela do meu terminal, execute novamente o python da calculadora.py

00:46:48.620 --> 00:46:52.770
com 1 e 2 para x e y, agora estou de volta aos negócios.

00:46:52.770 --> 00:46:55.400
Então é isso, por exemplo, o que a biblioteca CS50

00:46:55.400 --> 00:46:59.420
faz, mesmo que temporariamente esta semana, trata apenas da conversão para você.

00:46:59.420 --> 00:47:03.500
E, de fato, coisas ruins podem acontecer se eu digitar a coisa errada,

00:47:03.500 --> 00:47:05.615
como cão ou gato em vez de um número.

00:47:05.615 --> 00:47:08.400
Mas também cruzaremos essa ponte em um momento.

00:47:08.400 --> 00:47:08.900
Tudo bem.

00:47:08.900 --> 00:47:11.990
E se fizermos algo ligeiramente diferente, agora, com nossa calculadora.

00:47:16.400 --> 00:47:18.790
Em vez de adição, vamos fazer divisão.

00:47:18.790 --> 00:47:23.990
Então z é igual a x dividido por y, dando-me assim uma terceira variável z.

00:47:23.990 --> 00:47:27.320
Deixe-me ir em frente e executar o python de calculator.py novamente.

00:47:27.320 --> 00:47:29.120
Vou digitar 1.

00:47:29.120 --> 00:47:31.790
Vou digitar 3 desta vez.

00:47:31.790 --> 00:47:37.470
E que problema você acha que estamos prestes a ver?

00:47:37.470 --> 00:47:38.400
Ou acabou?

00:47:38.400 --> 00:47:41.670
O que aconteceu quando fiz isso em C, embora com um pouco mais

00:47:41.670 --> 00:47:47.680
sintaxe enigmática, quando dividi um número, como 1 dividido por 3?

00:47:47.680 --> 00:47:48.600
Alguém se lembra?

00:47:48.600 --> 00:47:49.100
Sim?

00:47:49.100 --> 00:47:51.310
AUDIÊNCIA: Você arredondaria para o inteiro mais próximo.

00:47:51.310 --> 00:47:52.060
DAVID MALAN: Sim.

00:47:52.060 --> 00:47:55.030
Então seria arredondado para o inteiro mais próximo,

00:47:55.030 --> 00:47:57.560
em que você experimenta truncamento.

00:47:57.560 --> 00:48:00.340
Então, se você pegar um número inteiro como 1, você o divide

00:48:00.340 --> 00:48:02.530
por outro inteiro como 3, que tecnicamente

00:48:02.530 --> 00:48:06.310
deve ser 0,33333, infinitamente longo.

00:48:06.310 --> 00:48:10.297
Mas em C, lembre-se, você trunca o valor.

00:48:10.297 --> 00:48:12.130
Se você dividir um int por um int, você volta

00:48:12.130 --> 00:48:14.965
um int, o que significa que você obtém apenas a parte inteira, que é o 0.

00:48:14.965 --> 00:48:18.805
Agora, o Python realmente lida com isso para nós e evita o truncamento.

00:48:18.805 --> 00:48:23.650
Mas isso nos deixa, ainda, com um outro problema aqui, que vai ser,

00:48:23.650 --> 00:48:27.453
por exemplo, não necessariamente visível à primeira vista.

00:48:27.453 --> 00:48:28.245
Isso parece correto.

00:48:28.245 --> 00:48:31.780
Isso resolveu o problema em C. Portanto, o truncamento não acontece.

00:48:31.780 --> 00:48:36.010
Os números inteiros são automaticamente convertidos em float-- um valor de ponto flutuante.

00:48:36.010 --> 00:48:41.970
Mas em que outro problema tropeçamos, na primeira semana?

00:48:44.480 --> 00:48:49.700
O que mais ficou um pouco arriscado ao lidar com aritmética simples?

00:48:49.700 --> 00:48:51.238
Alguém se lembra?

00:48:51.238 --> 00:48:53.280
Bem, a sintaxe em Python é um pouco diferente,

00:48:53.280 --> 00:48:54.780
mas deixe-me ir em frente e fazer isso.

00:48:54.780 --> 00:48:58.700
Acontece que, em Python, se você quiser ver dígitos mais significativos do que

00:48:58.700 --> 00:49:02.360
Estou vendo aqui por padrão, que é uma dúzia ou mais, deixe-me ir em frente

00:49:02.360 --> 00:49:03.715
e imprima z como segue.

00:49:03.715 --> 00:49:07.310
Deixe-me primeiro imprimir uma string de formato porque quero formatar z

00:49:07.310 --> 00:49:08.780
de uma forma interessante.

00:49:08.780 --> 00:49:11.330
E observe, isso não teria efeito na diferença.

00:49:11.330 --> 00:49:14.630
Esta é apenas uma string de formato que, sem nenhum motivo convincente no momento,

00:49:14.630 --> 00:49:19.280
está interpolando z nessas chaves usando um fstring ou string de formato.

00:49:19.280 --> 00:49:23.390
Se eu executar isso novamente com 1 e 3, veremos, de fato, exatamente a mesma coisa.

00:49:23.390 --> 00:49:25.700
Mas quando você usa um fstring, você, de fato,

00:49:25.700 --> 00:49:28.460
têm a capacidade de formatar essa string com mais precisão.

00:49:28.460 --> 00:49:32.930
Assim como com %f em Python, você pode começar a ajustar quantos

00:49:32.930 --> 00:49:35.720
dígitos que você vê--

00:49:35.720 --> 00:49:37.070
em C, sim.

00:49:37.070 --> 00:49:40.190
Em Python, você pode fazer o mesmo, mas a sintaxe é um pouco diferente.

00:49:40.190 --> 00:49:43.925
Se você quiser que o computador interpole z e mostre

00:49:43.925 --> 00:49:47.570
50 dígitos significativos - isto é, 50 números

00:49:47.570 --> 00:49:50.033
após o ponto decimal-- a sintaxe é semelhante a C,

00:49:50.033 --> 00:49:51.200
mas é um pouco diferente.

00:49:51.200 --> 00:49:54.110
Você literalmente coloca dois pontos após o nome da variável.

00:49:54.110 --> 00:49:59.090
ponto 50 significa mostrar-me o ponto decimal e, em seguida, 50 dígitos à direita,

00:49:59.090 --> 00:50:02.760
e o f apenas indica, por favor, trate isso como um valor de ponto flutuante.

00:50:02.760 --> 00:50:05.540
Agora, se eu executar novamente o python de calculator.py,

00:50:05.540 --> 00:50:11.495
divida 1 por 3, infelizmente Python não resolveu todos os problemas do mundo

00:50:11.495 --> 00:50:12.710
para nós.

00:50:12.710 --> 00:50:15.545
Isso, novamente, foi um exemplo de imprecisão de ponto flutuante.

00:50:15.545 --> 00:50:17.692
Então esse problema ainda é latente.

00:50:17.692 --> 00:50:20.150
Então, só porque o mundo avançou, não significa necessariamente

00:50:20.150 --> 00:50:22.317
significa que todos os nossos problemas de C foram embora.

00:50:22.317 --> 00:50:26.418
Existem soluções usando bibliotecas de terceiros para cálculos científicos

00:50:26.418 --> 00:50:26.960
e similar.

00:50:26.960 --> 00:50:31.445
Mas fora da caixa, a imprecisão do ponto flutuante ainda é um problema.

00:50:31.445 --> 00:50:35.780
Enquanto isso, havia um outro problema em C

00:50:35.780 --> 00:50:39.890
que encontramos envolvendo números, e isso foi isso-- estouro de número inteiro.

00:50:39.890 --> 00:50:41.930
Lembre-se de que um inteiro em C só ocupava,

00:50:41.930 --> 00:50:45.140
o que, 32 bits normalmente, o que significava que você poderia contar até 4 bilhões

00:50:45.140 --> 00:50:48.140
ou, talvez, se você estiver fazendo positivo e negativo, até 2 bilhões,

00:50:48.140 --> 00:50:50.030
depois disso, coisas estranhas aconteceriam.

00:50:50.030 --> 00:50:54.798
O número iria para 0 ou negativo ou transbordaria ou retornaria.

00:50:54.798 --> 00:50:56.840
Bem, maravilhosamente, em Python, eles fizeram, pelo menos,

00:50:56.840 --> 00:51:00.800
resolva isso, onde você pode contar o quanto quiser.

00:51:00.800 --> 00:51:03.830
E o Python apenas usará mais e mais e mais e mais

00:51:03.830 --> 00:51:08.000
bits e bytes para armazenar números realmente grandes, de modo que o estouro de número inteiro não seja

00:51:08.000 --> 00:51:09.020
uma coisa.

00:51:09.020 --> 00:51:13.820
Com isso dito, o Python está limitado a quantos dígitos ele mostrará a você

00:51:13.820 --> 00:51:15.410
na tela de uma só vez como uma string.

00:51:15.410 --> 00:51:18.560
Mas, matematicamente, sua matemática estará correta agora.

00:51:18.560 --> 00:51:21.860
Então, demos alguns passos à frente, um passo para o lado.

00:51:21.860 --> 00:51:25.530
Mas, de fato, resolvemos alguns de nossos problemas aqui.

00:51:25.530 --> 00:51:26.030
Tudo bem.

00:51:26.030 --> 00:51:32.230
Perguntas, agora, sobre algum desses exemplos até agora?

00:51:32.230 --> 00:51:34.400
Pergunta?

00:51:34.400 --> 00:51:35.000
Tudo bem.

00:51:35.000 --> 00:51:40.250
Bem, que tal outro problema que encontramos em C. Vamos

00:51:40.250 --> 00:51:41.720
revisite-o aqui em Python também.

00:51:41.720 --> 00:51:43.595
Então deixe-me ir em frente e, no lado esquerdo

00:51:43.595 --> 00:51:54.020
aqui, deixe-me abrir um arquivo chamado, digamos, compare3.c à esquerda,

00:51:54.020 --> 00:51:57.640
e deixe-me criar um novo arquivo à direita chamado compare.py.

00:51:57.640 --> 00:52:00.070
Porque lembre-se que coisas ruins aconteceram quando

00:52:00.070 --> 00:52:03.580
precisávamos comparar dois valores em C. À esquerda,

00:52:03.580 --> 00:52:06.550
aqui, é um lembrete do que fizemos uma vez em C,

00:52:06.550 --> 00:52:11.230
pelo qual, se quisermos comparar valores, podemos obter um int em C, armazená-lo em x.

00:52:11.230 --> 00:52:13.450
Um get_int em C, armazene-o em y.

00:52:13.450 --> 00:52:16.180
Temos então nossa familiar lógica condicional aqui,

00:52:16.180 --> 00:52:19.210
apenas imprimindo se x x menor que y ou não.

00:52:19.210 --> 00:52:23.080
Bem, certamente podemos fazer a mesma coisa, em última análise, em Python

00:52:23.080 --> 00:52:25.720
usando alguma sintaxe bastante familiar.

00:52:25.720 --> 00:52:27.640
E vamos demonstrar isso rapidamente.

00:52:27.640 --> 00:52:29.500
Deixa eu ir aqui também.

00:52:29.500 --> 00:52:34.690
Farei de cs50 import get_int, mesmo que eu pudesse fazer isso, em vez disso,

00:52:34.690 --> 00:52:36.700
com a própria função de entrada.

00:52:36.700 --> 00:52:39.700
x é igual a get_int, e solicitarei isso ao usuário.

00:52:39.700 --> 00:52:42.880
y é igual a get_int, e solicitarei isso ao usuário.

00:52:42.880 --> 00:52:45.910
Depois disso, lembre-se que posso dizer, sem parênteses,

00:52:45.910 --> 00:52:52.010
se x for menor que y, imprima, sem o f, "x é menor que y".

00:52:52.010 --> 00:52:58.570
Então, posso prosseguir e dizer, se x for maior que y, posso imprimir,

00:52:58.570 --> 00:53:01.270
entre aspas, "x é maior que y."

00:53:01.270 --> 00:53:05.320
Se você gostaria de intervir agora, o que eu estraguei?

00:53:05.320 --> 00:53:05.820
Qualquer um?

00:53:05.820 --> 00:53:06.150
Sim?

00:53:06.150 --> 00:53:06.915
AUDIÊNCIA: Elif.

00:53:06.915 --> 00:53:07.957
DAVID MALAN: Elif, certo?

00:53:07.957 --> 00:53:13.965
Então elif x é maior que y, caso contrário-- esta parte é a mesma-- imprima

00:53:13.965 --> 00:53:18.000
"x é igual a y."

00:53:18.000 --> 00:53:19.805
Não há nenhuma nova lógica acontecendo aqui.

00:53:19.805 --> 00:53:21.960
Mas, pelo menos sintaticamente, é um pouco mais limpo.

00:53:21.960 --> 00:53:25.500
De fato, este programa tem apenas 11 linhas, embora sem comentários.

00:53:25.500 --> 00:53:27.765
Deixe-me prosseguir e executar o python de compare.py.

00:53:27.765 --> 00:53:28.350
Vamos ver.

00:53:28.350 --> 00:53:30.235
1 é menor que 2?

00:53:30.235 --> 00:53:30.735
De fato.

00:53:30.735 --> 00:53:32.070
Vamos executá-lo novamente.

00:53:32.070 --> 00:53:33.330
2 é menor que 1?

00:53:33.330 --> 00:53:34.890
Não, é maior que.

00:53:34.890 --> 00:53:37.740
E vamos, por último, digitar 1 e 1 duas vezes.

00:53:37.740 --> 00:53:38.910
x é igual a y.

00:53:38.910 --> 00:53:42.030
Portanto, temos uma bela conversão lado a lado, um para um aqui.

00:53:42.030 --> 00:53:44.190
Vamos fazer algo um pouco mais interessante, então.

00:53:44.190 --> 00:53:48.270
Em C, que tal eu abrir, em vez disso, algo onde realmente

00:53:48.270 --> 00:53:49.310
comparado para um propósito?

00:53:49.310 --> 00:53:54.150
Então, se eu abrir, desde o início do curso -

00:53:54.150 --> 00:54:00.320
que tal concordar.c, que solicita ao usuário que concorde com algo ou não?

00:54:00.320 --> 00:54:03.860
E deixe-me codificar uma nova versão aqui, chamada concordo.py.

00:54:03.860 --> 00:54:06.720
E farei isso no lado direito, com concordo.py.

00:54:06.720 --> 00:54:08.830
Mas em concordo.c à esquerda--

00:54:08.830 --> 00:54:12.210
observe que foi assim que fizemos essa coisa de sim-não em C--

00:54:12.210 --> 00:54:16.590
comparamos c, um caractere, igual a aspas simples 'Y'

00:54:16.590 --> 00:54:18.840
ou igual a aspas simples minúsculo 'y.'

00:54:18.840 --> 00:54:20.430
E então, a mesma coisa para n.

00:54:20.430 --> 00:54:22.470
Agora, em Python, este vai realmente

00:54:22.470 --> 00:54:23.960
ser um pouco diferente, aqui.

00:54:23.960 --> 00:54:27.310
Deixe-me ir em frente e, na versão Python disso,

00:54:27.310 --> 00:54:29.640
deixe-me fazer algo assim.

00:54:29.640 --> 00:54:31.258
Usaremos get_string.

00:54:31.258 --> 00:54:31.800
Na verdade não.

00:54:31.800 --> 00:54:33.217
Usaremos apenas input neste caso.

00:54:33.217 --> 00:54:36.780
Então vamos fazer s igual a entrada.

00:54:36.780 --> 00:54:38.940
E vamos perguntar ao usuário a mesma coisa--

00:54:38.940 --> 00:54:40.875
Você concorda, ponto de interrogação.

00:54:40.875 --> 00:54:46.110
Então, vamos em frente e digamos, se s é igual a -

00:54:46.110 --> 00:54:48.940
que tal Y?

00:54:48.940 --> 00:54:49.740
Huh.

00:54:49.740 --> 00:54:50.758
Como eu faço isso?

00:54:50.758 --> 00:54:51.550
Bem, algumas coisas.

00:54:51.550 --> 00:54:54.660
Acontece que eu vou fazer isso-- s igual a pouco y.

00:54:54.660 --> 00:54:57.210
Então, vou imprimir "Concordo".

00:54:57.210 --> 00:55:03.390
E elif s é igual a N maiúsculo ou s é igual a n minúsculo,

00:55:03.390 --> 00:55:05.520
Vou prosseguir e imprimir "Não aceito".

00:55:05.520 --> 00:55:08.820
E eu afirmo, no momento, que isso é idêntico, agora,

00:55:08.820 --> 00:55:13.760
ao programa à esquerda em C. Mas o que há de diferente?

00:55:13.760 --> 00:55:17.280
Ainda estamos fazendo o mesmo tipo de lógica, esses iguais são iguais

00:55:17.280 --> 00:55:18.780
para comparar por igualdade.

00:55:18.780 --> 00:55:21.922
Mas observe que, muito bem, o Python se livrou das duas barras verticais,

00:55:21.922 --> 00:55:23.505
e é literalmente a palavra "ou".

00:55:23.505 --> 00:55:27.933
Se você se lembra de ter visto e comercial para expressar um e lógico em C, [GRUNTS]

00:55:27.933 --> 00:55:29.850
você pode simplesmente escrever, literalmente, a palavra "e".

00:55:29.850 --> 00:55:33.390
E então, aqui está uma dica de por que o Python tende a ser bastante popular.

00:55:33.390 --> 00:55:35.640
Gente assim é um pouco mais próximo do inglês.

00:55:35.640 --> 00:55:38.520
Há um pouco menos da sintaxe enigmática aqui.

00:55:38.520 --> 00:55:41.850
Agora, isso está correto, pois esse código agora funcionará.

00:55:41.850 --> 00:55:45.750
Mas também usei aspas duplas em vez de aspas simples,

00:55:45.750 --> 00:55:48.780
e também omiti, há alguns minutos, da minha lista de dados

00:55:48.780 --> 00:55:51.180
digita em Python a palavra "char".

00:55:51.180 --> 00:55:53.430
Em Python, não há caracteres.

00:55:53.430 --> 00:55:55.320
Não há personagens individuais.

00:55:55.320 --> 00:55:58.830
Se você quiser manipular um caractere individual, use uma string--

00:55:58.830 --> 00:56:00.510
ou seja, um str--

00:56:00.510 --> 00:56:01.680
de tamanho 1.

00:56:01.680 --> 00:56:04.930
Agora, em Python, você pode usar aspas simples ou duplas.

00:56:04.930 --> 00:56:06.930
Estou usando deliberadamente aspas duplas em todos os lugares,

00:56:06.930 --> 00:56:09.715
apenas para consistência com a forma como tratamos strings em C.

00:56:09.715 --> 00:56:12.090
É bastante comum, no entanto, usar aspas simples,

00:56:12.090 --> 00:56:14.190
apenas porque, na maioria dos teclados, você não

00:56:14.190 --> 00:56:16.320
tem que segurar a tecla Shift mais.

00:56:16.320 --> 00:56:18.288
Os humanos realmente começaram a otimizar a forma como

00:56:18.288 --> 00:56:19.830
rapidamente eles querem ser capazes de codificar.

00:56:19.830 --> 00:56:22.110
Portanto, usar uma única citação tende a ser bastante popular

00:56:22.110 --> 00:56:24.270
em Python e outras linguagens também.

00:56:24.270 --> 00:56:29.520
Eles são fundamentalmente os mesmos, simples ou duplos, ao contrário de C,

00:56:29.520 --> 00:56:30.570
onde eles têm significado.

00:56:30.570 --> 00:56:33.120
Portanto, isso está correto, eu afirmo.

00:56:33.120 --> 00:56:34.830
E, de fato, deixe-me fazer isso bem rápido.

00:56:34.830 --> 00:56:37.090
Vou abrir a janela do meu terminal aqui.

00:56:37.090 --> 00:56:40.230
Deixe-me livrar-me da versão em C e executar python de Concorde.py.

00:56:40.230 --> 00:56:42.420
E eu vou digitar Y. OK.

00:56:42.420 --> 00:56:44.220
Vou executá-lo novamente e digitar pouco y.

00:56:44.220 --> 00:56:46.780
E vou estipular que vai funcionar para não, também.

00:56:46.780 --> 00:56:49.840
Mas esta não é necessariamente a única maneira de fazer isso.

00:56:49.840 --> 00:56:52.350
Existem outras maneiras de implementar a mesma ideia.

00:56:52.350 --> 00:56:57.630
E, de fato, posso fazer isso em vez disso.

00:56:57.630 --> 00:56:59.910
Deixe-me voltar ao meu código aqui.

00:56:59.910 --> 00:57:03.240
E vimos uma dica disso antes.

00:57:03.240 --> 00:57:06.240
Sabemos que existem listas em Python e você pode criá-las

00:57:06.240 --> 00:57:08.040
apenas usando colchetes.

00:57:08.040 --> 00:57:10.380
E daí se eu simplificar um pouco o código e apenas

00:57:10.380 --> 00:57:14.940
dizer se s está na seguinte lista de valores--

00:57:14.940 --> 00:57:17.850
Y maiúsculo ou y minúsculo.

00:57:17.850 --> 00:57:21.090
Não é tão diferente, logicamente, mas é um pouco mais apertado.

00:57:21.090 --> 00:57:22.440
É um pouco mais compacto.

00:57:22.440 --> 00:57:29.040
Portanto, elif s está em N maiúsculo ou n minúsculo, também posso expressar a mesma ideia.

00:57:29.040 --> 00:57:32.220
Então aqui, novamente, está ficando um pouco mais agradável escrever código.

00:57:32.220 --> 00:57:33.960
Há menos impacto no teclado.

00:57:33.960 --> 00:57:36.090
Você pode se expressar um pouco mais sucintamente.

00:57:36.090 --> 00:57:40.020
E usando a palavra-chave in, o Python descobrirá

00:57:40.020 --> 00:57:44.370
como pesquisar em toda a lista qualquer que seja o valor de s.

00:57:44.370 --> 00:57:47.010
E se encontrar, retornará True automaticamente.

00:57:47.010 --> 00:57:48.230
Caso contrário, retornará False.

00:57:48.230 --> 00:57:54.960
Portanto, se eu executar ogree.py novamente e digitar Y maiúsculo ou y minúsculo, ainda assim

00:57:54.960 --> 00:57:55.695
agora, funciona.

00:57:55.695 --> 00:58:00.330
Bem, posso apertar ainda mais se quiser adicionar mais recursos.

00:58:00.330 --> 00:58:04.710
Bem, e se eu quiser apoiar não apenas o grande Y e o pequeno y,

00:58:04.710 --> 00:58:10.050
mas que tal "Sim" ou "sim" ou, caso o usuário

00:58:10.050 --> 00:58:14.357
está gritando ou alguém que não é bom com o CapsLock digita "SIM?"

00:58:14.357 --> 00:58:14.940
Espere um minuto.

00:58:14.940 --> 00:58:16.020
Mas pode ser estranho.

00:58:16.020 --> 00:58:20.850
Queremos apoiar isso ou aquilo?

00:58:20.850 --> 00:58:23.480
Isso se torna muito tedioso, rapidamente, combinatorialmente,

00:58:23.480 --> 00:58:25.710
se você considerar todas essas permutações possíveis.

00:58:25.710 --> 00:58:27.990
O que seria mais inteligente do que fazer algo

00:58:27.990 --> 00:58:30.120
assim, se você quiser apenas ser capaz de tolerar

00:58:30.120 --> 00:58:33.570
"sim" em qualquer forma de capitalização?

00:58:33.570 --> 00:58:35.370
Logicamente, o que seria bom?

00:58:35.370 --> 00:58:38.232
AUDIÊNCIA: Talvez, qualquer que seja a entrada, você apenas a transfere

00:58:38.232 --> 00:58:40.357
para tudo minúsculo enquanto maiúsculo e depois refazê-lo?

00:58:40.357 --> 00:58:41.125
DAVID MALAN: Exatamente.

00:58:41.125 --> 00:58:42.042
Paradigma super comum.

00:58:42.042 --> 00:58:46.510
Por que simplesmente não forçamos a entrada do usuário para todas as letras minúsculas ou todas as letras maiúsculas--

00:58:46.510 --> 00:58:49.570
não importa, contanto que sejamos autoconsistentes - e apenas compare

00:58:49.570 --> 00:58:52.030
contra todas as maiúsculas ou todas as minúsculas.

00:58:52.030 --> 00:58:55.760
E isso eliminará todas as permutações possíveis, caso contrário.

00:58:55.760 --> 00:58:58.510
Agora, em C, poderíamos ter feito algo assim.

00:58:58.510 --> 00:59:01.820
Poderíamos ter simplificado toda esta lista e apenas dito--

00:59:01.820 --> 00:59:04.940
digamos que faremos...

00:59:04.940 --> 00:59:06.220
que tal letras minúsculas?

00:59:06.220 --> 00:59:10.490
Então y ou sim, e vamos deixar por isso mesmo.

00:59:10.490 --> 00:59:12.370
Mas precisamos forçar, agora, s para minúsculas.

00:59:12.370 --> 00:59:15.970
Bem, em C, teríamos usado a biblioteca do tipo C.

00:59:15.970 --> 00:59:19.660
Teríamos feito to.lower e chamar essa função, passando-a.

00:59:19.660 --> 00:59:22.330
Embora, não exatamente porque, no tipo C, aqueles

00:59:22.330 --> 00:59:25.870
operam em caracteres ou caracteres individuais, não em strings inteiras.

00:59:25.870 --> 00:59:29.920
Na verdade, não vimos uma função que pudesse converter uma string inteira em C

00:59:29.920 --> 00:59:31.030
para minúsculas.

00:59:31.030 --> 00:59:34.910
Mas em Python, também vamos nos beneficiar de algum outro recurso.

00:59:34.910 --> 00:59:39.330
Acontece que o Python suporta o que é chamado de programação orientada a objetos.

00:59:39.330 --> 00:59:41.830
E vamos apenas arranhar a superfície disso no CS50.

00:59:41.830 --> 00:59:44.740
Mas se você fizer um curso C de nível superior em programação ou CS,

00:59:44.740 --> 00:59:46.750
você explora isso como um paradigma diferente.

00:59:46.750 --> 00:59:49.930
Até agora, em C, temos nos concentrado no que é chamado, realmente,

00:59:49.930 --> 00:59:51.025
programação processual.

00:59:51.025 --> 00:59:52.210
Você escreve procedimentos.

00:59:52.210 --> 00:59:55.250
Você escreve funções, de cima para baixo, da esquerda para a direita.

00:59:55.250 --> 00:59:57.790
E quando você quiser alterar algum valor, nós

00:59:57.790 --> 01:00:00.550
tinham o hábito de usar um procedimento-- isto é, uma função.

01:00:00.550 --> 01:00:03.670
Você passaria algo, como uma variável, para uma função,

01:00:03.670 --> 01:00:07.600
como toupper ou tolower, e faria seu trabalho e devolveria um valor.

01:00:07.600 --> 01:00:12.610
Bem, acontece que seria melhor, em termos de programação, se alguns dados

01:00:12.610 --> 01:00:15.250
tipos apenas tinham funcionalidade interna.

01:00:15.250 --> 01:00:18.220
Por que temos nossas variáveis ​​aqui e todas as nossas funções auxiliares,

01:00:18.220 --> 01:00:21.010
como toupper e tolower aqui, de modo que constantemente

01:00:21.010 --> 01:00:22.660
tem que passar um para o outro.

01:00:22.660 --> 01:00:27.590
Seria bom inserir em nosso tipo de dados algumas funcionalidades integradas

01:00:27.590 --> 01:00:33.267
para que você possa alterar as variáveis ​​usando seus próprios padrões embutidos

01:00:33.267 --> 01:00:33.850
funcionalidade.

01:00:33.850 --> 01:00:37.510
E assim, a Programação Orientada a Objetos, também conhecida como OOP,

01:00:37.510 --> 01:00:41.635
é uma técnica pela qual certos tipos de valores, como uma string--

01:00:41.635 --> 01:00:47.230
AKA str-- não só tem propriedades dentro deles--

01:00:47.230 --> 01:00:49.900
atributos, assim como uma estrutura em C--

01:00:49.900 --> 01:00:54.480
seus dados também podem ter funções incorporadas a eles.

01:00:54.480 --> 01:00:57.955
Então, enquanto em C, que não é orientado a objetos, você tem structs.

01:00:57.955 --> 01:01:01.150
E structs só podem armazenar dados, como um nome e um número

01:01:01.150 --> 01:01:02.620
ao implementar uma pessoa.

01:01:02.620 --> 01:01:07.210
Em Python, você pode, por exemplo, não ter apenas uma estrutura--

01:01:07.210 --> 01:01:09.010
também conhecido como uma classe--

01:01:09.010 --> 01:01:10.930
armazenar um nome e um número.

01:01:10.930 --> 01:01:15.460
Você pode fazer com que uma função chame essa pessoa ou envie um e-mail para essa pessoa

01:01:15.460 --> 01:01:19.510
ou verbos ou ações reais associados a esse dado.

01:01:19.510 --> 01:01:21.910
Agora, no contexto de strings, verifica-se

01:01:21.910 --> 01:01:24.565
que as strings vêm com muitas funcionalidades úteis.

01:01:24.565 --> 01:01:28.900
E, de fato, nesta URL aqui, que está em docs.python.org,

01:01:28.900 --> 01:01:31.720
que é a documentação oficial do Python,

01:01:31.720 --> 01:01:34.300
você verá uma lista completa de métodos--

01:01:34.300 --> 01:01:37.705
isto é, funções-- que vêm com strings que você pode realmente

01:01:37.705 --> 01:01:40.150
use para modificar seus valores.

01:01:40.150 --> 01:01:42.440
E o que quero dizer com isso é o seguinte.

01:01:42.440 --> 01:01:44.900
Se examinarmos a documentação, vasculharmos,

01:01:44.900 --> 01:01:48.163
Acontece que as strings vêm com uma função chamada lower.

01:01:48.163 --> 01:01:50.080
E se você quiser usar essa função, basta

01:01:50.080 --> 01:01:54.850
tem que usar uma sintaxe ligeiramente diferente do que em C. Você não precisa diminuir,

01:01:54.850 --> 01:01:59.140
e você não diz, como acabei de dizer, menor porque esta função é

01:01:59.140 --> 01:02:01.150
construído em si.

01:02:01.150 --> 01:02:05.770
E assim como em C, quando você quer entrar em uma variável, como uma estrutura,

01:02:05.770 --> 01:02:09.790
e acessar um dado dentro dele, como nome ou número,

01:02:09.790 --> 01:02:12.370
quando você também tem funções embutidas em tipos de dados--

01:02:12.370 --> 01:02:17.530
Métodos AKA; um método é apenas uma função que é construída em um pedaço de dados--

01:02:17.530 --> 01:02:23.480
você pode fazer s dot abaixar parêntese aberto, parêntese fechado neste caso.

01:02:23.480 --> 01:02:25.480
E eu posso fazer isso aqui também.

01:02:25.480 --> 01:02:33.280
Se for mais lento, entre aspas, "n" ou "não", a coisa toda,

01:02:33.280 --> 01:02:35.455
Eu posso forçar tudo isso para letras minúsculas.

01:02:35.455 --> 01:02:38.620
Portanto, a única diferença aqui, agora, como uma programação orientada a objetos,

01:02:38.620 --> 01:02:41.840
em vez de passar constantemente um valor para uma função,

01:02:41.840 --> 01:02:45.910
você apenas acessa uma função que está dentro do valor.

01:02:45.910 --> 01:02:48.928
Funciona apenas por causa de como a própria linguagem é definida.

01:02:48.928 --> 01:02:51.220
E a única maneira de saber se essas funções existem

01:02:51.220 --> 01:02:55.495
é a documentação-- uma classe, um livro, um site ou algo semelhante.

01:02:55.495 --> 01:03:00.490
Dúvidas, agora, sobre essa técnica?

01:03:00.490 --> 01:03:01.070
Tudo bem.

01:03:01.070 --> 01:03:02.513
Eu afirmo que isso está correto.

01:03:02.513 --> 01:03:05.180
Agora, mesmo que você nunca tenha programado, a maioria de vocês, em Python

01:03:05.180 --> 01:03:07.655
antes, não super bem desenhado.

01:03:07.655 --> 01:03:12.140
Há uma sutil ineficiência, agora, nas linhas 3 e 5 juntas.

01:03:12.140 --> 01:03:18.150
O que é estúpido sobre como eu usei mais baixo, você pode pensar?

01:03:18.150 --> 01:03:18.720
Sim?

01:03:18.720 --> 01:03:21.975
AUDIÊNCIA: Eu sinto que, usando duas vezes, você só quer outro [? variável. ?]

01:03:21.975 --> 01:03:22.440
DAVID MALAN: Sim.

01:03:22.440 --> 01:03:25.482
Se você for usar a mesma função duas vezes e fizer a mesma pergunta,

01:03:25.482 --> 01:03:29.248
esperando a mesma resposta, por que você está chamando a própria função duas vezes?

01:03:29.248 --> 01:03:31.415
Talvez devêssemos apenas armazenar o resultado em uma variável.

01:03:31.415 --> 01:03:33.030
Então, poderíamos fazer isso de duas maneiras diferentes.

01:03:33.030 --> 01:03:36.360
Nós, por exemplo, poderíamos subir aqui e criar outra variável chamada t

01:03:36.360 --> 01:03:38.040
e iguale a s.lower.

01:03:38.040 --> 01:03:41.330
E então, poderíamos apenas mudar isso para ser t, aqui.

01:03:41.330 --> 01:03:43.080
Mas, honestamente, não acho que tecnicamente

01:03:43.080 --> 01:03:45.480
precisa de outra variável completamente, aqui.

01:03:45.480 --> 01:03:47.410
Eu poderia simplesmente fazer algo assim.

01:03:47.410 --> 01:03:52.360
Vamos alterar o valor de s para ser a versão minúscula dele.

01:03:52.360 --> 01:03:55.920
E então, agora, posso simplesmente me referir a s de novo e de novo assim,

01:03:55.920 --> 01:03:57.550
reaproveitando esse mesmo valor.

01:03:57.550 --> 01:04:01.380
Agora, para ter certeza, acabei de perder a entrada original do usuário.

01:04:01.380 --> 01:04:05.430
E se eu me importo com isso-- se eles digitaram tudo em maiúsculas, não faço mais ideia.

01:04:05.430 --> 01:04:08.070
Então talvez eu queira usar uma variável separada, completamente.

01:04:08.070 --> 01:04:10.830
Mas uma lição aqui também é que strings em Python

01:04:10.830 --> 01:04:13.590
são tecnicamente o que chamaremos de imutáveis--

01:04:13.590 --> 01:04:15.640
ou seja, eles não podem ser alterados.

01:04:15.640 --> 01:04:19.830
Isso não era verdade em C. Uma vez, demos a você arrays na segunda semana

01:04:19.830 --> 01:04:22.800
ou memória na quarta semana, você pode ir para a cidade em uma corda

01:04:22.800 --> 01:04:25.780
e altere qualquer um dos caracteres que desejar-- maiúsculas, minúsculas,

01:04:25.780 --> 01:04:27.560
mudando-o, encurtando-o e assim por diante.

01:04:27.560 --> 01:04:33.690
Mas, neste caso, retorna uma cópia de s, forçada a entrar em minúsculas.

01:04:33.690 --> 01:04:35.790
Não altera a string original--

01:04:35.790 --> 01:04:38.700
ou seja, os bytes na memória do computador.

01:04:38.700 --> 01:04:41.580
Quando você atribui de volta para s, você está essencialmente

01:04:41.580 --> 01:04:43.703
esquecendo a versão antiga do s.

01:04:43.703 --> 01:04:46.620
Mas como o Python faz o gerenciamento de memória para você - não há malloc,

01:04:46.620 --> 01:04:47.820
não há livre--

01:04:47.820 --> 01:04:52.200
Python libera automaticamente os bytes originais, como YES,

01:04:52.200 --> 01:04:54.750
e os devolve para o sistema operacional para você.

01:04:54.750 --> 01:04:55.340
Tudo bem.

01:04:55.340 --> 01:04:59.640
Dúvidas, agora, sobre essa técnica?

01:04:59.640 --> 01:05:02.310
Perguntas sobre isso?

01:05:02.310 --> 01:05:05.145
Em geral, chamarei -- a documentação do Python

01:05:05.145 --> 01:05:07.927
vai começar a ser seu amigo porque, na aula, a gente só vai arranhar

01:05:07.927 --> 01:05:09.510
a superfície com algumas dessas coisas.

01:05:09.510 --> 01:05:12.210
Mas em docs.python.org, por exemplo, há

01:05:12.210 --> 01:05:15.630
uma referência completa de todas as funções integradas que acompanham o idioma,

01:05:15.630 --> 01:05:18.135
bem como, por exemplo, aqueles com uma corda.

01:05:18.135 --> 01:05:19.620
Tudo bem.

01:05:19.620 --> 01:05:23.205
Antes de fazermos uma pausa, vamos em frente e criar algo um pouco familiar

01:05:23.205 --> 01:05:27.030
também com base em nossas semanas aqui, em C. Deixe-me

01:05:27.030 --> 01:05:30.690
propomos que revisitemos esses exemplos envolvendo alguns miados.

01:05:30.690 --> 01:05:34.260
Então, por exemplo, quando nosso gato miou na primeira semana

01:05:34.260 --> 01:05:37.650
e, então, em segundo lugar em C, fizemos algo que foi um pouco estúpido no começo

01:05:37.650 --> 01:05:41.960
por meio do qual criamos um arquivo, como farei aqui-- desta vez, chamado meow.py.

01:05:41.960 --> 01:05:44.550
E se eu quiser que um gato mie três vezes, eu

01:05:44.550 --> 01:05:47.190
poderia executá-lo uma vez, assim, um pequeno copiar e colar.

01:05:47.190 --> 01:05:50.580
E agora, python de meow.py, e pronto.

01:05:50.580 --> 01:05:53.100
Agora, visitamos este exemplo duas vezes, pelo menos,

01:05:53.100 --> 01:05:54.690
agora em Scratch e em C.

01:05:54.690 --> 01:06:00.080
Está correto, vou estipular, mas o que é, obviamente, mal desenhado?

01:06:00.080 --> 01:06:01.655
Qual é a culpa aqui?

01:06:01.655 --> 01:06:02.212
Sim?

01:06:02.212 --> 01:06:03.670
AUDIÊNCIA: Deve ser apenas um loop.

01:06:03.670 --> 01:06:04.990
DAVID MALAN: Deve ser apenas um loop, certo?

01:06:04.990 --> 01:06:05.990
Por que digitá-lo três vezes?

01:06:05.990 --> 01:06:08.560
Literalmente, copiar e colar é quase sempre uma coisa ruim--

01:06:08.560 --> 01:06:11.440
exceto em C, quando você tem os protótipos de função que precisa pegar emprestado.

01:06:11.440 --> 01:06:13.232
Mas, neste caso, isso é apenas ineficiente.

01:06:13.232 --> 01:06:15.652
Então, o que poderíamos fazer melhor aqui, em Python?

01:06:15.652 --> 01:06:18.610
Bem, em Python, provavelmente poderíamos mudar isso de algumas maneiras diferentes.

01:06:18.610 --> 01:06:21.280
Poderíamos pegar emprestado um pouco da sintaxe que propusemos em forma de slide

01:06:21.280 --> 01:06:23.710
anteriormente, como me dê uma variável chamada i.

01:06:23.710 --> 01:06:26.080
Defina-o como 0, sem ponto-e-vírgula.

01:06:26.080 --> 01:06:29.510
Enquanto i for menor que 3-- se eu quiser fazer isso três vezes--

01:06:29.510 --> 01:06:31.280
Posso ir em frente e imprimir "miau".

01:06:31.280 --> 01:06:33.580
E então, posso fazer i mais igual a 1.

01:06:33.580 --> 01:06:35.080
E eu acho que isso faria o truque.

01:06:35.080 --> 01:06:38.650
Python de meow.py, e já estamos de volta aos negócios.

01:06:38.650 --> 01:06:41.463
Bem, se eu quisesse mudar isso para um loop for, bem, em Python,

01:06:41.463 --> 01:06:44.380
seria um pouco mais apertado, mas esta não seria a melhor abordagem.

01:06:44.380 --> 01:06:52.510
Então, para i em 0, 1, 2, eu poderia apenas imprimir "miau", assim.

01:06:52.510 --> 01:06:54.250
E isso também faria o trabalho.

01:06:54.250 --> 01:06:58.390
Mas, para nossa discussão anterior, isso ficaria estúpido rapidamente

01:06:58.390 --> 01:07:00.970
se você tivesse que continuar enumerando todos esses valores.

01:07:00.970 --> 01:07:03.880
O que introduzimos em vez disso?

01:07:03.880 --> 01:07:04.940
A função gama.

01:07:04.940 --> 01:07:05.440
Exatamente.

01:07:05.440 --> 01:07:09.040
Então isso me devolve, de forma mais eficiente, apenas os valores que eu quero,

01:07:09.040 --> 01:07:10.635
na verdade, um de cada vez.

01:07:10.635 --> 01:07:14.745
Mesmo assim, se eu executar uma terceira ou quarta vez, teremos o mesmo resultado.

01:07:14.745 --> 01:07:18.220
Mas agora, vamos fazer a transição para onde fomos com isso no passado.

01:07:18.220 --> 01:07:20.650
Como podemos começar a modularizar isso?

01:07:20.650 --> 01:07:24.100
Seria bom, afirmei, se o MIT tivesse nos dado uma função miau.

01:07:24.100 --> 01:07:27.370
Não seria bom se o Python tivesse nos dado uma função miau?

01:07:27.370 --> 01:07:30.580
Talvez menos atraente em Python, mas como posso construir minha própria função?

01:07:30.580 --> 01:07:33.618
Bem, eu fiz isso brevemente com o corretor ortográfico anteriormente,

01:07:33.618 --> 01:07:36.160
mas deixe-me ir em frente e propor que poderíamos implementar, agora,

01:07:36.160 --> 01:07:40.280
nossa própria versão disso em Python da seguinte maneira.

01:07:40.280 --> 01:07:44.050
Deixe-me ir em frente e começar de novo aqui e usar a palavra-chave def.

01:07:44.050 --> 01:07:47.860
Então isso não existia em C. Você tinha o valor de retorno, a função

01:07:47.860 --> 01:07:48.850
nome, os argumentos.

01:07:48.850 --> 01:07:52.120
Em Python, você literalmente diz def para definir uma função.

01:07:52.120 --> 01:07:54.757
Você dá um nome, como miau.

01:07:54.757 --> 01:07:57.840
E agora, vou em frente e, nesta função, apenas imprima miau.

01:07:57.840 --> 01:08:01.460
E isso me permite mudá-lo para qualquer outra coisa que eu queira no futuro.

01:08:01.460 --> 01:08:03.400
Mas, por enquanto, é uma abstração.

01:08:03.400 --> 01:08:07.773
E, de fato, posso tirá-lo da vista, longe da mente...

01:08:07.773 --> 01:08:09.940
só vou apertar Enter várias vezes para fingir,

01:08:09.940 --> 01:08:13.382
agora, existe, mas não me importa como é implementado.

01:08:13.382 --> 01:08:15.340
E aqui em cima, agora, posso fazer algo assim.

01:08:15.340 --> 01:08:20.590
Para i no intervalo de 3, deixe-me prosseguir e não imprimir mais "miau".

01:08:20.590 --> 01:08:25.359
Deixe-me chamar de miau e apertar ainda mais meu código.

01:08:25.359 --> 01:08:25.960
Vamos ver.

01:08:25.960 --> 01:08:26.859
Python de meow.py.

01:08:26.859 --> 01:08:31.240
Acho que esta será a primeira vez que não funcionará corretamente.

01:08:31.240 --> 01:08:32.680
OK.

01:08:32.680 --> 01:08:36.310
Então aqui temos, infelizmente, nosso primeiro erro de Python.

01:08:36.310 --> 01:08:37.569
E vamos ver.

01:08:37.569 --> 01:08:40.300
A sintaxe será diferente da saída C ou Clangs.

01:08:40.300 --> 01:08:41.920
Traceback é o termo da arte aqui.

01:08:41.920 --> 01:08:44.859
Isso é como um rastreamento de todas as linhas de código

01:08:44.859 --> 01:08:47.560
que acabaram de ser executadas ou, na verdade, funções que você chamou.

01:08:47.560 --> 01:08:49.090
O nome do arquivo é desinteressante.

01:08:49.090 --> 01:08:52.149
Este é o meu espaço de código, especificamente, mas o nome do arquivo

01:08:52.149 --> 01:08:53.890
é importante aqui-- meow.py.

01:08:53.890 --> 01:08:55.675
Nossa linha 2 é o problema--

01:08:55.675 --> 01:08:58.060
OK, eu não fui muito longe antes de estragar tudo...

01:08:58.060 --> 01:08:59.470
e então, há um erro de nome.

01:08:59.470 --> 01:09:03.430
E você verá, em Python, normalmente há essas palavras-chave em letras maiúsculas

01:09:03.430 --> 01:09:05.350
essa dica de qual é o problema.

01:09:05.350 --> 01:09:09.260
É algo relacionado a nomes de variáveis. "miau" não está definido.

01:09:09.260 --> 01:09:09.760
Tudo bem.

01:09:09.760 --> 01:09:11.635
Você está programando Python pela primeira vez.

01:09:11.635 --> 01:09:12.399
Você estragou tudo.

01:09:12.399 --> 01:09:14.560
Você está seguindo algum tutorial online.

01:09:14.560 --> 01:09:16.149
Você está vendo isso.

01:09:16.149 --> 01:09:18.010
Raciocine através disso.

01:09:18.010 --> 01:09:20.680
Por que "miau" não pode ser definido?

01:09:20.680 --> 01:09:24.779
O que podemos inferir sobre o Python?

01:09:24.779 --> 01:09:27.240
Como solucionar problemas, logicamente?

01:09:27.240 --> 01:09:29.147
AUDIÊNCIA: [INAUDÍVEL]

01:09:29.147 --> 01:09:29.939
DAVID MALAN: Talvez.

01:09:29.939 --> 01:09:32.520
É porque "miau" é definido depois?

01:09:32.520 --> 01:09:34.890
Tão inteligente quanto o Python parece ser, vis-a-vis C,

01:09:34.890 --> 01:09:37.055
eles têm algumas características de design semelhantes.

01:09:37.055 --> 01:09:37.920
Então vamos tentar isso.

01:09:37.920 --> 01:09:41.729
Então, deixe-me rolar todo o caminho de volta para onde movi isso antes.

01:09:41.729 --> 01:09:43.649
Deixe-me me livrar disso--

01:09:43.649 --> 01:09:44.279
lá embaixo.

01:09:44.279 --> 01:09:46.410
Vou copiá-lo para a minha área de transferência.

01:09:46.410 --> 01:09:48.180
E deixe-me apenas hackear algo.

01:09:48.180 --> 01:09:49.963
Deixa eu colocar aqui.

01:09:49.963 --> 01:09:51.130
E vamos ver se isso funciona.

01:09:51.130 --> 01:09:54.120
Agora, deixe-me limpar meu terminal, execute python de meow.py.

01:09:54.120 --> 01:09:55.110
OK.

01:09:55.110 --> 01:09:56.198
Estamos de volta aos negócios.

01:09:56.198 --> 01:09:57.990
Então essa foi realmente uma boa intuição.

01:09:57.990 --> 01:10:00.180
Boa técnica de depuração, apenas raciocine através dela.

01:10:00.180 --> 01:10:02.430
Agora, isso está contradizendo o que eu reivindiquei de volta

01:10:02.430 --> 01:10:05.325
na primeira semana, que era a parte principal do seu programa,

01:10:05.325 --> 01:10:07.470
idealmente, deve estar apenas no topo do arquivo.

01:10:07.470 --> 01:10:08.580
Não me faça procurar.

01:10:08.580 --> 01:10:10.497
Não é grande coisa com um programa de quatro linhas,

01:10:10.497 --> 01:10:13.290
mas se você tiver 40 linhas ou 400 linhas, você

01:10:13.290 --> 01:10:15.480
não quer a parte interessante do seu programa

01:10:15.480 --> 01:10:18.455
estar aqui embaixo, e todas essas funções aqui em cima.

01:10:18.455 --> 01:10:22.085
Seria bom, talvez, se tivéssemos uma função principal.

01:10:22.085 --> 01:10:25.260
E assim, acaba sendo uma convenção em Python

01:10:25.260 --> 01:10:27.460
para definir uma função principal.

01:10:27.460 --> 01:10:30.720
Não é uma função especial chamada automaticamente, como em C.

01:10:30.720 --> 01:10:32.340
Mas os humanos perceberam, quer saber?

01:10:32.340 --> 01:10:34.120
Esse foi um recurso bastante útil.

01:10:34.120 --> 01:10:36.540
Deixe-me definir uma função chamada main.

01:10:36.540 --> 01:10:39.000
Deixe-me recuar essas linhas abaixo dele.

01:10:39.000 --> 01:10:41.070
Deixe-me praticar o que estou pregando, que é colocado

01:10:41.070 --> 01:10:43.290
o código principal na parte superior do arquivo.

01:10:43.290 --> 01:10:47.730
E, maravilhosamente, em Python, agora, você não precisa de protótipos.

01:10:47.730 --> 01:10:49.920
Não tem nada daquele copiar e colar hackeado

01:10:49.920 --> 01:10:52.462
do tipo de retorno, o nome e os argumentos para uma função,

01:10:52.462 --> 01:10:58.485
como precisávamos em C. Agora está OK, exceto por um pequeno detalhe.

01:10:58.485 --> 01:11:01.290
Deixe-me prosseguir e executar o python de meow.py.

01:11:01.290 --> 01:11:05.940
Espero que agora eu tenha resolvido esse problema tendo [GROANS] uma função principal.

01:11:05.940 --> 01:11:08.170
Mas agora, nada aconteceu.

01:11:08.170 --> 01:11:08.670
Tudo bem.

01:11:08.670 --> 01:11:12.200
Mesmo que você nunca tenha programado em Python antes,

01:11:12.200 --> 01:11:17.855
o que pode explicar esse comportamento e como faço para corrigir?

01:11:17.855 --> 01:11:20.730
Novamente, quando você está no mundo real, aprendendo um novo idioma,

01:11:20.730 --> 01:11:23.790
tudo o que você tem é lógica dedutiva para depurar.

01:11:23.790 --> 01:11:24.300
Sim?

01:11:24.300 --> 01:11:28.656
AUDIÊNCIA: Eu me lembro em C, embora nós [INAUDÍVEL]..

01:11:31.708 --> 01:11:32.500
DAVID MALAN: Certo.

01:11:32.500 --> 01:11:34.510
Então a solução, para ser claro, em C foi que nós

01:11:34.510 --> 01:11:35.650
tive que colocar o protótipo aqui.

01:11:35.650 --> 01:11:36.790
Caso contrário, receberíamos uma mensagem de erro.

01:11:36.790 --> 01:11:39.123
Nesse caso, na verdade não estou recebendo uma mensagem de erro.

01:11:39.123 --> 01:11:42.610
E, de fato, vou afirmar que você não precisa dos protótipos em Python.

01:11:42.610 --> 01:11:46.910
Só não é necessário porque isso era irritante, se nada mais.

01:11:46.910 --> 01:11:48.820
Mas o que mais poderia explicar?

01:11:48.820 --> 01:11:49.570
Sim, na parte de trás?

01:11:49.570 --> 01:11:51.030
AUDIÊNCIA: [INAUDÍVEL]

01:11:51.030 --> 01:11:51.780
DAVID MALAN: Sim.

01:11:51.780 --> 01:11:53.880
Talvez você tenha que chamar o próprio main.

01:11:53.880 --> 01:11:58.410
Se main não for algum status especial em Python, talvez apenas porque exista

01:11:58.410 --> 01:11:59.040
não é suficiente.

01:11:59.040 --> 01:12:02.580
E, de fato, se você quiser chamar main, a nova convenção

01:12:02.580 --> 01:12:05.460
será na verdade-- como a última linha do seu programa,

01:12:05.460 --> 01:12:07.350
normalmente-- para literalmente chamar main.

01:12:07.350 --> 01:12:10.950
É um pouco estúpido, mas eles tomaram uma decisão de design.

01:12:10.950 --> 01:12:13.200
E é assim que, agora, contornamos isso.

01:12:13.200 --> 01:12:14.610
Python de meow.py.

01:12:14.610 --> 01:12:16.890
Agora estamos de volta aos negócios.

01:12:16.890 --> 01:12:19.560
Mas agora, logicamente, por que isso funciona do jeito que funciona?

01:12:19.560 --> 01:12:22.320
Bem, neste caso-- de cima para baixo--

01:12:22.320 --> 01:12:25.350
linha 1 está dizendo ao Python para definir uma função chamada main

01:12:25.350 --> 01:12:27.660
e, então, defina-o da seguinte forma, linhas 2 e 3.

01:12:27.660 --> 01:12:29.610
Mas ainda não está chamando main.

01:12:29.610 --> 01:12:33.210
A linha 6 está dizendo ao Python como definir uma função chamada meow,

01:12:33.210 --> 01:12:35.580
mas ainda não está chamando essas linhas.

01:12:35.580 --> 01:12:38.730
Agora, na linha 10, você está dizendo ao Python, chame main.

01:12:38.730 --> 01:12:41.310
E nesse ponto, o Python foi treinado, se preferir,

01:12:41.310 --> 01:12:45.390
para saber o que é main na linha 1, para saber o que é miau na linha 6.

01:12:45.390 --> 01:12:49.650
E então, agora é perfeitamente normal que main esteja acima de miau

01:12:49.650 --> 01:12:51.150
porque você nunca ligou para eles ainda.

01:12:51.150 --> 01:12:54.340
Você definiu, definiu e então, você chamou.

01:12:54.340 --> 01:12:56.380
E essa é a lógica por trás disso.

01:12:56.380 --> 01:13:01.250
Alguma dúvida, agora, sobre a estrutura dessa técnica, aqui?

01:13:01.250 --> 01:13:03.000
Agora, vamos fazer mais um, então.

01:13:03.000 --> 01:13:07.740
Lembre-se de que a última coisa que fizemos no Scratch e no C foi,

01:13:07.740 --> 01:13:10.940
na verdade, parametrize essas mesmas funções.

01:13:10.940 --> 01:13:14.070
Portanto, suponha que você não queira que main seja responsável pelo loop aqui.

01:13:14.070 --> 01:13:17.580
Em vez disso, você deseja, simplesmente, fazer algo como "miau" três vezes

01:13:17.580 --> 01:13:18.660
e pronto.

01:13:18.660 --> 01:13:21.427
Bem, em Python, será semelhante em espírito a C.

01:13:21.427 --> 01:13:23.760
Mas, novamente, não precisamos continuar mencionando tipos de dados.

01:13:23.760 --> 01:13:26.310
Se você quiser que "miau" aceite algum argumento--

01:13:26.310 --> 01:13:27.930
como um número n--

01:13:27.930 --> 01:13:30.792
você pode apenas especificar n como o nome desse argumento.

01:13:30.792 --> 01:13:33.250
Ou você pode chamá-lo de qualquer outra coisa, é claro, que você quiser.

01:13:33.250 --> 01:13:35.700
Você não precisa especificar int ou qualquer outra coisa.

01:13:35.700 --> 01:13:40.890
No seu código, agora, dentro do meow, você pode fazer algo como for i in,

01:13:40.890 --> 01:13:41.670
Digamos--

01:13:41.670 --> 01:13:45.690
Eu definitivamente, agora, não posso fazer isso porque seria estranho, para começar a lista

01:13:45.690 --> 01:13:46.590
e termine com n.

01:13:46.590 --> 01:13:49.360
Então, se eu puder voltar aqui, qual é a solução?

01:13:49.360 --> 01:13:51.270
Como posso fazer algo n vezes?

01:13:51.270 --> 01:13:52.410
AUDIÊNCIA: [INAUDÍVEL]

01:13:52.410 --> 01:13:53.160
DAVID MALAN: Sim.

01:13:53.160 --> 01:13:54.340
Usando intervalo.

01:13:54.340 --> 01:13:58.140
Então range é bom porque eu posso passar, agora, esta variável n.

01:13:58.140 --> 01:13:59.940
E agora, posso miar-- opa.

01:13:59.940 --> 01:14:03.195
Agora posso imprimir, entre aspas, "miau".

01:14:03.195 --> 01:14:05.820
Então é quase igual ao Scratch, quase igual ao C.

01:14:05.820 --> 01:14:06.903
Mas é um pouco mais simples.

01:14:06.903 --> 01:14:12.210
E se, agora, eu executar meow.py, terei a capacidade, agora, de fazer isso aqui,

01:14:12.210 --> 01:14:13.110
também.

01:14:13.110 --> 01:14:13.770
Tudo bem.

01:14:13.770 --> 01:14:16.590
Dúvidas sobre isso?

01:14:16.590 --> 01:14:19.800
No momento, estamos dando esse passeio durante a primeira semana.

01:14:19.800 --> 01:14:22.050
Vamos, momentaneamente, escalar as coisas

01:14:22.050 --> 01:14:24.840
olhar não apenas para alguns desses fundamentos,

01:14:24.840 --> 01:14:27.390
mas também, outros recursos, como vimos com o reconhecimento facial

01:14:27.390 --> 01:14:28.920
com o soletrador ou algo semelhante.

01:14:28.920 --> 01:14:31.962
Por causa de quantos de nós estamos aqui, temos uma quantidade enorme de doces

01:14:31.962 --> 01:14:32.670
no saguão.

01:14:32.670 --> 01:14:34.440
Então, por que não fazemos uma pausa de 10 minutos?

01:14:34.440 --> 01:14:37.230
E quando voltarmos, faremos coisas ainda mais sofisticadas e poderosas

01:14:37.230 --> 01:14:38.595
com Python em 10.

01:14:38.595 --> 01:14:40.020
Tudo bem.

01:14:40.020 --> 01:14:41.730
Então estamos de volta.

01:14:41.730 --> 01:14:44.280
Entre as nossas metas, agora, estão introduzir mais algumas construções

01:14:44.280 --> 01:14:47.880
blocos para que possamos resolver problemas mais interessantes no final,

01:14:47.880 --> 01:14:49.560
muito parecidos com aqueles com os quais começamos.

01:14:49.560 --> 01:14:52.830
Você deve se lembrar, de algumas semanas atrás, nós brincamos com este Super bidimensional

01:14:52.830 --> 01:14:53.670
mundo Mário.

01:14:53.670 --> 01:14:57.380
E tentamos imprimir uma coluna vertical de três ou mais tijolos.

01:14:57.380 --> 01:15:00.210
Bem, deixe-me propor que usemos isso como uma oportunidade para, agora,

01:15:00.210 --> 01:15:02.880
mexer com alguns dos recursos mais úteis e mais

01:15:02.880 --> 01:15:04.470
funcionalidade amigável ao usuário também.

01:15:04.470 --> 01:15:09.265
Deixe-me codificar um arquivo chamado mario.py e vamos imprimir

01:15:09.265 --> 01:15:10.890
o equivalente a essa coluna vertical.

01:15:10.890 --> 01:15:12.690
Então é de altura 3.

01:15:12.690 --> 01:15:16.740
Cada um é um hash, então vamos fazer para i no intervalo de 3 inicialmente,

01:15:16.740 --> 01:15:18.600
e vamos apenas imprimir um único hash.

01:15:18.600 --> 01:15:21.790
E eu acho, agora, python de mario.py--

01:15:21.790 --> 01:15:22.290
voilá.

01:15:22.290 --> 01:15:27.480
Estamos no negócio, imprimindo exatamente aquela mesma coluna ali.

01:15:27.480 --> 01:15:31.110
E se, porém, quisermos imprimir uma coluna de alguma altura variável

01:15:31.110 --> 01:15:33.510
onde o usuário nos diz o quão alto eles querem que seja?

01:15:33.510 --> 01:15:39.600
Bem, deixe-me subir aqui, por exemplo, e, em vez disso, que tal...

01:15:39.600 --> 01:15:40.920
vamos fazer isso.

01:15:40.920 --> 01:15:45.210
Que tal da importação do cs50?

01:15:45.210 --> 01:15:47.620
Que tal a função get_int, como antes?

01:15:47.620 --> 01:15:50.430
Portanto, ele tratará de garantir que o usuário nos forneça um número inteiro.

01:15:50.430 --> 01:15:54.750
E agora, no passado, sempre que queríamos obter um número de um usuário,

01:15:54.750 --> 01:15:56.780
na verdade, seguimos um certo paradigma.

01:15:56.780 --> 01:16:02.895
Na verdade, se eu abrir aqui, por exemplo,

01:16:02.895 --> 01:16:06.630
que tal mario1.c de um tempo atrás, você

01:16:06.630 --> 01:16:11.430
deve se lembrar que tínhamos um código como este.

01:16:11.430 --> 01:16:13.800
E usamos especificamente o loop do while em C

01:16:13.800 --> 01:16:16.410
sempre que queremos obter algo do usuário,

01:16:16.410 --> 01:16:18.858
talvez, de novo e de novo e de novo, até que eles cooperem.

01:16:18.858 --> 01:16:20.900
Nesse ponto, finalmente saímos do loop.

01:16:20.900 --> 01:16:22.830
Acontece que o Python tem loops while,

01:16:22.830 --> 01:16:25.698
tem for loops, não tem loops do while.

01:16:25.698 --> 01:16:27.990
No entanto, praticamente sempre que você obtém informações do usuário,

01:16:27.990 --> 01:16:30.100
você provavelmente já usou esse paradigma.

01:16:30.100 --> 01:16:33.930
Acontece que o equivalente Python disso é fazer,

01:16:33.930 --> 01:16:36.450
semelhante em espírito, mas usando apenas um loop while.

01:16:36.450 --> 01:16:39.300
E um paradigma comum em Python, como aludi anteriormente,

01:16:39.300 --> 01:16:43.440
é realmente induzir deliberadamente um loop infinito enquanto True--

01:16:43.440 --> 01:16:48.240
T maiúsculo - e então, faça o que você quer fazer, como obter um int do usuário

01:16:48.240 --> 01:16:51.690
e solicitar-lhes a altura, por exemplo, em questão.

01:16:51.690 --> 01:16:56.070
E então, se você tem certeza de que o usuário lhe deu o que você quer--

01:16:56.070 --> 01:16:59.220
como n é maior que 0, que é o que eu quero, neste caso,

01:16:59.220 --> 01:17:02.610
porque eu quero um número inteiro positivo; caso contrário, não há nada para imprimir--

01:17:02.610 --> 01:17:04.505
você literalmente apenas sai do loop.

01:17:04.505 --> 01:17:08.070
E assim, poderíamos realmente usar essa técnica em C. Não é apenas

01:17:08.070 --> 01:17:10.260
realmente feito em C. Você poderia absolutamente, em C,

01:17:10.260 --> 01:17:13.590
fiz um loop while True com os parênteses, true em minúsculas.

01:17:13.590 --> 01:17:15.670
Você poderia sair disso, e assim por diante.

01:17:15.670 --> 01:17:18.312
Mas em Python, esse é o jeito Python.

01:17:18.312 --> 01:17:19.770
E isso é realmente um termo de arte.

01:17:19.770 --> 01:17:24.017
Desta forma em Python é pythonic Esta é "a forma como todos fazem,"

01:17:24.017 --> 01:17:24.600
entre áspas.

01:17:24.600 --> 01:17:28.830
Não significa que você precise, mas é assim que os programadores legais do Python fariam

01:17:28.830 --> 01:17:31.980
implementar uma ideia como esta-- tentar fazer algo de novo e de novo

01:17:31.980 --> 01:17:34.607
e novamente até que o usuário realmente coopere.

01:17:34.607 --> 01:17:36.690
Mas tudo o que fizemos foi remover o loop do while.

01:17:36.690 --> 01:17:39.790
Mas ainda assim, logicamente, podemos implementar a mesma ideia.

01:17:39.790 --> 01:17:44.580
Agora, abaixo disso, deixe-me ir em frente e apenas imprimir, para i no intervalo de n

01:17:44.580 --> 01:17:47.370
desta vez-- porque eu quero que seja variável e não 3.

01:17:47.370 --> 01:17:49.920
Eu posso ir em frente e imprimir o hash--

01:17:49.920 --> 01:17:52.260
deixe-me ir em frente e me livrar da versão C aqui--

01:17:52.260 --> 01:17:55.920
abra minha janela de terminal e executarei, novamente, Python de mario.py.

01:17:55.920 --> 01:17:58.530
Vou digitar 3 e recebo de volta esses três hashes.

01:17:58.530 --> 01:18:02.635
Mas se eu, em vez disso, digitar 4, agora recebo quatro hashes.

01:18:02.635 --> 01:18:04.640
Portanto, a conclusão aqui é, simplesmente, que este

01:18:04.640 --> 01:18:08.030
seria o caminho, por exemplo, para realmente voltar

01:18:08.030 --> 01:18:11.615
um valor em Python que seja consistente com algum parâmetro,

01:18:11.615 --> 01:18:13.160
como maior que 0.

01:18:13.160 --> 01:18:13.950
Que tal agora?

01:18:13.950 --> 01:18:17.810
Vamos realmente praticar o que pregamos há pouco com nossos exemplos de miados

01:18:17.810 --> 01:18:19.830
e fatorando tudo isso.

01:18:19.830 --> 01:18:23.220
Deixe-me prosseguir e definir uma função principal, como antes.

01:18:23.220 --> 01:18:25.190
Deixe-me seguir em frente e assumir, por enquanto,

01:18:25.190 --> 01:18:28.673
que existe uma função get_height, o que não existe em Python.

01:18:28.673 --> 01:18:30.340
Eu vou inventá-lo em apenas um momento.

01:18:30.340 --> 01:18:33.620
E agora, vou seguir em frente e fazer algo assim. para mim

01:18:33.620 --> 01:18:39.470
no intervalo dessa altura, bem, vamos em frente e imprimir esses hashes.

01:18:39.470 --> 01:18:41.760
Portanto, estou assumindo que get_height existe.

01:18:41.760 --> 01:18:44.725
Deixe-me seguir em frente e implementar essa abstração, então defina uma função,

01:18:44.725 --> 01:18:46.100
agora, chamado get_height.

01:18:46.100 --> 01:18:48.830
Não vai levar nenhum argumento neste design.

01:18:48.830 --> 01:18:52.820
Enquanto True, posso seguir em frente e fazer a mesma coisa de antes...

01:18:52.820 --> 01:18:55.880
atribuir uma variável n, o valor de retorno de get_int

01:18:55.880 --> 01:18:58.140
solicitando ao usuário essa altura.

01:18:58.140 --> 01:19:03.980
E então, se n for maior que 0, posso ir em frente e quebrar.

01:19:03.980 --> 01:19:08.390
Mas se eu quebrar aqui, eu, logicamente-- assim como em C--

01:19:08.390 --> 01:19:11.360
acabam executando abaixo do loop em questão.

01:19:11.360 --> 01:19:12.690
Mas não há nada lá.

01:19:12.690 --> 01:19:16.820
Mas se eu quiser que get_height retorne a altura, o que devo fazer?

01:19:16.820 --> 01:19:18.650
Eu digito aqui na linha 14, logicamente?

01:19:21.580 --> 01:19:23.380
O que eu quero devolver, para ficar claro?

01:19:23.380 --> 01:19:23.995
AUDIÊNCIA: [INAUDÍVEL]

01:19:23.995 --> 01:19:24.745
DAVID MALAN: Sim.

01:19:24.745 --> 01:19:26.890
Então eu realmente quero retornar n.

01:19:26.890 --> 01:19:30.880
E aqui vai mais uma curiosidade do Python, vis-à-vis C.

01:19:30.880 --> 01:19:33.670
Não parece mais haver uma questão de escopo, certo?

01:19:33.670 --> 01:19:37.180
Em C, era super importante não apenas declarar suas variáveis ​​com os dados

01:19:37.180 --> 01:19:39.550
tipos, você também tinha que estar ciente de onde eles existem -

01:19:39.550 --> 01:19:41.200
dentro dessas chaves.

01:19:41.200 --> 01:19:45.238
Em Python, você pode ser um pouco mais flexível com as coisas, para melhor

01:19:45.238 --> 01:19:45.780
ou para pior.

01:19:45.780 --> 01:19:50.020
E assim, na linha 11, se eu criar uma variável chamada n,

01:19:50.020 --> 01:19:57.170
ele existe na linha 11, 12 e até 13, fora do loop while.

01:19:57.170 --> 01:19:59.710
Então, para ficar claro, em C, com um loop while, nós

01:19:59.710 --> 01:20:03.040
normalmente não teria dois pontos.

01:20:03.040 --> 01:20:05.920
Teríamos a chave, como aqui e aqui.

01:20:05.920 --> 01:20:08.770
E uma semana atrás, eu teria afirmado que, em C, n

01:20:08.770 --> 01:20:12.130
não existe fora do loop while, por natureza dessas chaves.

01:20:12.130 --> 01:20:15.250
Mesmo que as chaves tenham desaparecido, Python realmente

01:20:15.250 --> 01:20:20.685
permite que você use uma variável a qualquer momento depois de atribuir um valor a ela.

01:20:20.685 --> 01:20:23.625
Então, um pouco mais poderoso, como tal.

01:20:23.625 --> 01:20:26.830
No entanto, posso restringir isso um pouco, logicamente.

01:20:26.830 --> 01:20:30.700
E isso é verdade em C. Eu realmente não preciso sair do loop

01:20:30.700 --> 01:20:32.020
usando pausa.

01:20:32.020 --> 01:20:36.070
Lembre-se disso ou saiba que eu posso - quando estiver pronto para ir,

01:20:36.070 --> 01:20:40.030
Posso apenas retornar o valor que me interessa, mesmo dentro do loop.

01:20:40.030 --> 01:20:43.000
E isso terá o efeito colateral de me tirar do circuito

01:20:43.000 --> 01:20:46.590
e, também, me tirando e voltando de toda a função.

01:20:46.590 --> 01:20:50.470
Portanto, nada muito novo aqui, em termos de C versus Python, exceto por este problema

01:20:50.470 --> 01:20:51.490
com escopo.

01:20:51.490 --> 01:20:53.770
E eu, de fato, voltei n lá embaixo,

01:20:53.770 --> 01:20:56.360
apenas para deixar claro que n ainda existiria.

01:20:56.360 --> 01:20:58.170
Portanto, qualquer um deles está correto.

01:20:58.170 --> 01:21:02.350
Agora, eu só tenho um programa Python que eu acho

01:21:02.350 --> 01:21:05.590
vai me permitir implementar essa mesma ideia do Mario.

01:21:05.590 --> 01:21:07.450
Então, vamos executar o python de mario.py.

01:21:07.450 --> 01:21:09.820
E-- OK, então nada aconteceu.

01:21:09.820 --> 01:21:13.390
Python de mario.py.

01:21:13.390 --> 01:21:14.260
O que eu fiz errado?

01:21:14.260 --> 01:21:14.965
AUDIÊNCIA: [INAUDÍVEL]

01:21:14.965 --> 01:21:16.590
DAVID MALAN: Sim, tenho que ligar para o main.

01:21:16.590 --> 01:21:19.720
Então, na parte inferior do meu código, tenho que chamar main aqui.

01:21:19.720 --> 01:21:22.720
E este é um detalhe estilístico que tem sido sutil.

01:21:22.720 --> 01:21:26.050
De um modo geral, quando você está escrevendo em Python,

01:21:26.050 --> 01:21:28.360
não há um guia de estilo CS50, por si só.

01:21:28.360 --> 01:21:33.700
Na verdade, existe um guia de estilo do Python que a maioria das pessoas segue.

01:21:33.700 --> 01:21:37.480
E, neste caso, linhas em branco duplas entre as funções são a norma.

01:21:37.480 --> 01:21:41.890
Estou fazendo isso deliberadamente, embora possa, caso contrário, não ser óbvio.

01:21:41.890 --> 01:21:45.130
Mas agora que chamei main na linha 16, vamos rodar mario.py mais uma vez.

01:21:45.130 --> 01:21:46.690
Ah.

01:21:46.690 --> 01:21:47.560
Agora nós vemos isso.

01:21:47.560 --> 01:21:51.730
Digite 3 e estou de volta aos negócios, imprimindo os valores lá.

01:21:51.730 --> 01:21:52.330
Sim?

01:21:52.330 --> 01:21:54.146
AUDIÊNCIA: Por que você [INAUDÍVEL]?

01:21:54.146 --> 01:21:56.120
Por que não [INAUDÍVEL]?

01:21:56.120 --> 01:21:56.870
DAVID MALAN: Claro.

01:21:56.870 --> 01:21:58.453
Por que preciso da condição if?

01:21:58.453 --> 01:22:02.390
Por que não posso simplesmente retornar n aqui como retornando n.

01:22:02.390 --> 01:22:06.890
Ou, se eu realmente quiser ser sucinto, posso tecnicamente fazer isso.

01:22:06.890 --> 01:22:09.512
A única razão pela qual adicionei a condição if é

01:22:09.512 --> 01:22:11.720
porque, se o usuário digitar negativo 1, negativo 2,

01:22:11.720 --> 01:22:13.850
Eu queria alertá-los de novo e de novo.

01:22:13.850 --> 01:22:14.390
Isso é tudo.

01:22:14.390 --> 01:22:17.660
Mas isso também seria totalmente aceitável, se você concordasse com esse resultado

01:22:17.660 --> 01:22:18.630
em vez de.

01:22:18.630 --> 01:22:21.170
Bem, deixe-me fazer outra coisa aqui para apontar

01:22:21.170 --> 01:22:23.870
por que estamos usando get_int com tanta frequência.

01:22:23.870 --> 01:22:26.030
Esta nova roda de treinamento, ainda que temporariamente.

01:22:26.030 --> 01:22:28.490
Então deixe-me voltar para o jeito que era um momento atrás

01:22:28.490 --> 01:22:32.510
e deixe-me propor, agora, remover get_int.

01:22:32.510 --> 01:22:35.840
Afirmei anteriormente que, se você não estiver usando get_int,

01:22:35.840 --> 01:22:40.400
você pode simplesmente usar a própria função de entrada do Python.

01:22:40.400 --> 01:22:43.250
Mas isso sempre retorna uma string ou uma str.

01:22:43.250 --> 01:22:48.110
E assim, lembre-se de que você deve passar a saída da função de entrada para um int,

01:22:48.110 --> 01:22:51.930
na mesma linha ou, se preferir, em outra linha.

01:22:51.930 --> 01:22:54.110
Mas acontece que o que eu não fiz foi mostrar

01:22:54.110 --> 01:22:59.250
você o que acontece se você não cooperar com o programa.

01:22:59.250 --> 01:23:02.540
Então, se eu executar python de mario.py agora, funciona muito bem, mesmo

01:23:02.540 --> 01:23:04.252
sem a função get_int.

01:23:04.252 --> 01:23:05.210
E eu posso fazer isso com 4.

01:23:05.210 --> 01:23:06.575
Ainda funciona muito bem.

01:23:06.575 --> 01:23:09.122
Mas deixe-me limpar meu terminal e ser difícil, agora,

01:23:09.122 --> 01:23:11.330
como usuário e digite "gato" para a altura.

01:23:11.330 --> 01:23:12.560
Digitar.

01:23:12.560 --> 01:23:14.540
Agora, vemos um desses vestígios novamente.

01:23:14.540 --> 01:23:15.900
Este é diferente.

01:23:15.900 --> 01:23:18.780
Este não é um erro de nome, mas, aparentemente, um erro de valor.

01:23:18.780 --> 01:23:20.870
E se eu ignorar as coisas que não entendo,

01:23:20.870 --> 01:23:24.440
Eu posso ver "literal inválido para int com base 10--"cat.""

01:23:24.440 --> 01:23:27.800
Essa é uma maneira super enigmática de dizer que o CAT não é

01:23:27.800 --> 01:23:29.640
um número em notação decimal.

01:23:29.640 --> 01:23:32.600
E assim, eu teria que, de alguma forma, lidar com este caso.

01:23:32.600 --> 01:23:34.490
E se você quiser ser mais curioso, você vai

01:23:34.490 --> 01:23:36.350
veja que isso é, de fato, um traceback.

01:23:36.350 --> 01:23:40.100
E C tende a fazer isso também, ou o depurador faria isso por você também.

01:23:40.100 --> 01:23:41.960
Você pode ver todas as funções que têm

01:23:41.960 --> 01:23:43.502
chamado para levá-lo a este ponto.

01:23:43.502 --> 01:23:48.170
Então, aparentemente, meu problema está, inicialmente, na linha 14.

01:23:48.170 --> 01:23:50.375
Mas a linha 14, se eu continuar rolando, é desinteressante.

01:23:50.375 --> 01:23:51.410
Seu principal.

01:23:51.410 --> 01:23:55.820
Mas a linha 14 me leva a executar a linha 2, que está, de fato, em main.

01:23:55.820 --> 01:23:59.225
Isso me leva a executar a linha 9, que está em get_height.

01:23:59.225 --> 01:24:00.880
E então, OK, aqui está o problema.

01:24:00.880 --> 01:24:02.960
Portanto, o número da linha mais próxima da mensagem de erro

01:24:02.960 --> 01:24:05.360
é o que provavelmente mais revela.

01:24:05.360 --> 01:24:06.950
A linha 9 é onde está o meu problema.

01:24:06.950 --> 01:24:10.940
Portanto, não posso simplesmente pedir entrada cegamente ao usuário e, em seguida, convertê-la em um int

01:24:10.940 --> 01:24:12.620
se eles não vão me dar um int.

01:24:12.620 --> 01:24:13.870
Agora, como lidamos com isso?

01:24:13.870 --> 01:24:16.010
Bem, de volta ao conjunto de problemas dois, você deve se lembrar

01:24:16.010 --> 01:24:18.380
validando que o usuário digitou um número

01:24:18.380 --> 01:24:19.862
e usando um loop for e similares.

01:24:19.862 --> 01:24:22.445
Bem, acontece que há uma maneira melhor de fazer isso em Python,

01:24:22.445 --> 01:24:24.830
e a semântica está lá.

01:24:24.830 --> 01:24:29.600
Se você quiser tentar converter algo em um número que pode não ser realmente

01:24:29.600 --> 01:24:32.780
ser um número, acontece, Python e algumas outras linguagens

01:24:32.780 --> 01:24:35.060
literalmente tem uma palavra-chave chamada try.

01:24:35.060 --> 01:24:37.820
E se ao menos isso existisse nas últimas semanas, eu sei.

01:24:37.820 --> 01:24:40.583
Mas você pode tentar fazer o seguinte com seu código.

01:24:40.583 --> 01:24:41.750
O que eu quero tentar fazer?

01:24:41.750 --> 01:24:46.980
Bem, quero tentar executar essas poucas linhas, exceto se houver um erro.

01:24:46.980 --> 01:24:50.225
Posso dizer, exceto se houver um erro de valor - especificamente,

01:24:50.225 --> 01:24:53.065
aquele que eu estraguei e criei há pouco.

01:24:53.065 --> 01:24:56.480
E se houver um erro de valor, posso imprimir uma mensagem informativa

01:24:56.480 --> 01:25:00.920
para o usuário, como "não é um número inteiro" ou qualquer outra coisa.

01:25:00.920 --> 01:25:05.270
E o que está acontecendo aqui, agora, é literalmente esta palavra operativa, tente.

01:25:05.270 --> 01:25:09.920
Python vai tentar obter entrada e tentar convertê-la em um int,

01:25:09.920 --> 01:25:12.470
e vai tentar verificar se é maior que 0

01:25:12.470 --> 01:25:14.750
e depois tente devolvê-lo.

01:25:14.750 --> 01:25:15.467
Por que?

01:25:15.467 --> 01:25:17.300
Três dessas linhas estão dentro de, recuadas

01:25:17.300 --> 01:25:20.780
embaixo do bloco try, exceto se algo der errado--

01:25:20.780 --> 01:25:23.540
especificamente, ocorre um erro de valor.

01:25:23.540 --> 01:25:24.560
Então, ele imprime isso.

01:25:24.560 --> 01:25:26.110
Mas não retorna nada.

01:25:26.110 --> 01:25:30.335
E porque estou em um loop, isso significa que vai fazer isso de novo e de novo

01:25:30.335 --> 01:25:33.980
e novamente até que o humano realmente coopere e me dê

01:25:33.980 --> 01:25:35.360
um número real.

01:25:35.360 --> 01:25:38.210
E então, isso também é o que o mundo chamaria de pitônico.

01:25:38.210 --> 01:25:41.420
Em Python, você não necessariamente tenta validar rigorosamente

01:25:41.420 --> 01:25:43.940
a entrada do usuário, certifique-se de que eles não erraram.

01:25:43.940 --> 01:25:46.160
Você honestamente adota uma abordagem mais indiferente

01:25:46.160 --> 01:25:50.300
e apenas tente fazer algo, mas pegue um erro se isso acontecer.

01:25:50.300 --> 01:25:53.720
Portanto, pegar também é um termo artístico, embora não seja uma palavra-chave aqui.

01:25:53.720 --> 01:25:55.760
Exceto se algo acontecer, você lida com isso.

01:25:55.760 --> 01:25:57.470
Então você tenta e você lida com isso.

01:25:57.470 --> 01:25:59.480
Sua programação de melhor esforço, se preferir.

01:25:59.480 --> 01:26:04.200
Mas isso está embutido na mentalidade da comunidade de programação Python.

01:26:04.200 --> 01:26:08.630
Então agora, se eu fizer python de mario.py e cooperar, funcionará muito bem como antes.

01:26:08.630 --> 01:26:09.830
Tente e tenha sucesso.

01:26:09.830 --> 01:26:10.670
3 obras.

01:26:10.670 --> 01:26:11.345
4 trabalhos.

01:26:11.345 --> 01:26:17.243
Se, no entanto, eu tentar e falhar digitando "gato", ele não travará por si só.

01:26:17.243 --> 01:26:18.410
Não me mostra nenhum erro.

01:26:18.410 --> 01:26:20.695
Isso me mostra algo mais amigável, como "não é um número inteiro".

01:26:20.695 --> 01:26:22.610
E então, posso tentar novamente com "cachorro".

01:26:22.610 --> 01:26:23.390
"Não é um número inteiro."

01:26:23.390 --> 01:26:24.980
Posso tentar novamente com 5.

01:26:24.980 --> 01:26:26.240
E agora, funciona.

01:26:26.240 --> 01:26:28.160
Portanto, geralmente não faremos você escrever muito

01:26:28.160 --> 01:26:30.500
no caminho desses blocos try-except, apenas porque eles

01:26:30.500 --> 01:26:33.080
ficar um pouco sofisticado rapidamente.

01:26:33.080 --> 01:26:35.777
Mas isso é para revelar o que a função get_int está fazendo.

01:26:35.777 --> 01:26:37.610
É por isso que oferecemos as rodinhas,

01:26:37.610 --> 01:26:39.420
para que, quando você quiser obter um int, você

01:26:39.420 --> 01:26:41.990
não precisa passar por todos esses obstáculos irritantes para fazer isso.

01:26:41.990 --> 01:26:45.965
Mas isso é tudo o que a biblioteca realmente está fazendo por você, apenas tente e exceto.

01:26:45.965 --> 01:26:48.980
Você não ficará com nenhuma rodinha, no final das contas.

01:26:48.980 --> 01:26:52.760
Perguntas, agora, sobre obter informações e tentar dessa maneira?

01:26:55.433 --> 01:26:56.100
Nada mesmo?

01:26:56.100 --> 01:26:56.610
Sim?

01:26:56.610 --> 01:27:03.643
AUDIÊNCIA: Ainda estou [INAUDÍVEL] tentando bloquear.

01:27:03.643 --> 01:27:06.560
DAVID MALAN: Oh, você poderia colocar a condição fora do bloco try?

01:27:06.560 --> 01:27:07.310
Resposta curta, sim.

01:27:07.310 --> 01:27:09.227
E, de fato, lutei com isso ontem à noite

01:27:09.227 --> 01:27:11.750
ao ajustar este exemplo para mostrar a versão mais simples.

01:27:11.750 --> 01:27:17.180
Vou negar que, realmente, eu deveria estar apenas tentando, literalmente,

01:27:17.180 --> 01:27:18.470
para fazer a parte frágil.

01:27:18.470 --> 01:27:21.710
E então, aqui embaixo, eu deveria estar realmente fazendo

01:27:21.710 --> 01:27:24.380
o que você está propondo, que é fazer a condição aqui.

01:27:24.380 --> 01:27:27.380
O problema, porém, é que, logicamente, isso fica confuso rapidamente, certo?

01:27:27.380 --> 01:27:31.205
Porque, exceto se houver um erro de valor, quero imprimir "não é um número inteiro".

01:27:31.205 --> 01:27:33.920
Não posso comparar n contra 0, então, porque n não

01:27:33.920 --> 01:27:35.752
existe porque houve um erro.

01:27:35.752 --> 01:27:37.460
Acontece que -- e eu vou te mostrar isso;

01:27:37.460 --> 01:27:39.350
esta é agora a versão avançada do Python--

01:27:39.350 --> 01:27:42.620
na verdade, há uma palavra-chave else que você pode usar em Python

01:27:42.620 --> 01:27:44.570
que não acompanha if ou elif.

01:27:44.570 --> 01:27:48.680
Ele acompanha try e except, o que eu acho estranhamente confuso.

01:27:48.680 --> 01:27:50.640
Uma palavra diferente teria sido melhor.

01:27:50.640 --> 01:27:53.692
Mas se você realmente preferisse, eu poderia ter feito isso.

01:27:53.692 --> 01:27:56.900
E esta é uma dessas coisas de design em que pessoas razoáveis ​​discordarão.

01:27:56.900 --> 01:27:58.775
De um modo geral, você só deve tentar fazer

01:27:58.775 --> 01:28:00.980
a única linha que pode muito bem falhar.

01:28:00.980 --> 01:28:02.420
Mas honestamente, isso parece estúpido.

01:28:02.420 --> 01:28:04.850
Não, é apenas desnecessariamente complicado.

01:28:04.850 --> 01:28:08.560
E então, minha preferência era na verdade o original, que era-- sim,

01:28:08.560 --> 01:28:10.310
Estou tentando algumas linhas extras que, realmente,

01:28:10.310 --> 01:28:11.973
não vão falhar, matematicamente.

01:28:11.973 --> 01:28:12.890
Mas é apenas mais apertado.

01:28:12.890 --> 01:28:14.030
É mais limpo assim.

01:28:14.030 --> 01:28:16.580
E aqui está, novamente, o tipo de argumento que você

01:28:16.580 --> 01:28:18.530
comece a se tornar à medida que se sentir mais confortável com a programação.

01:28:18.530 --> 01:28:19.280
Você terá uma opinião.

01:28:19.280 --> 01:28:20.488
Você vai discordar de alguém.

01:28:20.488 --> 01:28:25.200
E contanto que você possa sustentar seu argumento, é bastante razoável, provavelmente.

01:28:25.200 --> 01:28:25.700
Tudo bem.

01:28:25.700 --> 01:28:30.222
Então, que tal nós, agora, tirarmos algum pedaço de mágica

01:28:30.222 --> 01:28:31.430
já faz um tempo que está aqui.

01:28:31.430 --> 01:28:33.950
Deixe-me ir em frente e deletar tudo isso aqui.

01:28:33.950 --> 01:28:38.855
E deixe-me propor que revisitemos não aquela coluna vertical e as exceções

01:28:38.855 --> 01:28:42.110
que pode resultar da entrada, mas esses pontos de interrogação horizontais

01:28:42.110 --> 01:28:43.130
que vimos há pouco.

01:28:43.130 --> 01:28:45.980
Quero todos esses pontos de interrogação na mesma linha.

01:28:45.980 --> 01:28:48.860
E, no entanto, temo que estejamos prestes a ver um desafio aqui porque impressão,

01:28:48.860 --> 01:28:51.830
até agora, tem colocado novas linhas em todos os lugares automaticamente,

01:28:51.830 --> 01:28:53.570
mesmo sem aquelas barras invertidas n's.

01:28:53.570 --> 01:28:56.360
Bem, deixe-me propor que façamos isso.

01:28:56.360 --> 01:28:58.130
para i no intervalo de 4.

01:28:58.130 --> 01:29:02.165
Se eu quiser quatro pontos de interrogação, deixe-me imprimir quatro pontos de interrogação.

01:29:02.165 --> 01:29:04.370
Infelizmente, não acho que isso esteja correto ainda.

01:29:04.370 --> 01:29:06.530
Deixe-me executar o python de mario.py.

01:29:06.530 --> 01:29:11.510
E, claro, isso me dá uma coluna em vez da linha de pontos de interrogação

01:29:11.510 --> 01:29:12.630
que eu quero.

01:29:12.630 --> 01:29:13.550
Então, como fazemos isso?

01:29:13.550 --> 01:29:17.785
Bem, ao que parece, se você ler a documentação da função de impressão,

01:29:17.785 --> 01:29:19.910
verifica-se que a impressão, não surpreendentemente, talvez,

01:29:19.910 --> 01:29:22.000
leva muitos argumentos diferentes, também.

01:29:22.000 --> 01:29:24.590
E, de fato, se você for à documentação,

01:29:24.590 --> 01:29:27.650
você verá que não é preciso apenas posicional

01:29:27.650 --> 01:29:30.685
argumentos-- isto é, da esquerda para a direita, separados por vírgulas.

01:29:30.685 --> 01:29:32.810
Acontece que o Python oferece suporte a um recurso mais sofisticado

01:29:32.810 --> 01:29:36.860
com argumentos onde você também pode passar os nomes dos argumentos para as funções.

01:29:36.860 --> 01:29:38.470
Então, o que quero dizer com isso?

01:29:38.470 --> 01:29:43.430
Se eu voltar ao VS Code aqui e ler a documentação,

01:29:43.430 --> 01:29:48.995
acontece que, sim, como antes, você pode passar vários argumentos para Python,

01:29:48.995 --> 01:29:49.700
assim.

01:29:49.700 --> 01:29:53.030
Olá vírgula David vírgula Nalan, isso será automaticamente

01:29:53.030 --> 01:29:56.553
concatenar todos os três desses argumentos posicionais juntos.

01:29:56.553 --> 01:29:59.720
Eles são posicionais no sentido de que literalmente fluem da esquerda para a direita,

01:29:59.720 --> 01:30:01.238
separados por vírgulas.

01:30:01.238 --> 01:30:03.530
Mas se você não quiser apenas passar valores assim,

01:30:03.530 --> 01:30:07.370
você deseja realmente imprimir, como fiz antes, um ponto de interrogação.

01:30:07.370 --> 01:30:11.240
Mas você deseja substituir o comportamento padrão de impressão

01:30:11.240 --> 01:30:14.610
alterando o final da linha, você pode realmente fazer isso.

01:30:14.610 --> 01:30:18.890
Você pode usar o nome de um argumento que você sabe que existe na documentação

01:30:18.890 --> 01:30:22.130
e defini-lo igual a algum valor alternativo.

01:30:22.130 --> 01:30:24.770
E, de fato, mesmo que pareça enigmático,

01:30:24.770 --> 01:30:30.380
é assim que eu substituiria o final de cada linha, para ser citado, sem aspas.

01:30:30.380 --> 01:30:32.900
Isso não é nada porque, se você ler a documentação,

01:30:32.900 --> 01:30:37.190
o valor padrão para este argumento final-- alguém quer adivinhar--

01:30:37.190 --> 01:30:38.750
é--

01:30:38.750 --> 01:30:39.800
é barra invertida n.

01:30:39.800 --> 01:30:41.690
Portanto, se você ler a documentação, verá

01:30:41.690 --> 01:30:46.550
essa barra invertida n é o padrão implícito para esse argumento final.

01:30:46.550 --> 01:30:49.810
E assim, se você quiser alterá-lo, basta dizer que final é igual a outra coisa.

01:30:49.810 --> 01:30:57.057
E então, aqui, posso mudá-lo para nada e, agora, executar novamente python de mario.py.

01:30:57.057 --> 01:30:58.640
E agora, eles estão todos na mesma linha.

01:30:58.640 --> 01:31:01.190
Agora, parece um pouco estúpido porque fiz naquela semana

01:31:01.190 --> 01:31:04.190
um erro em que ainda preciso mover o cursor para a próxima linha.

01:31:04.190 --> 01:31:05.570
Isso é apenas um problema diferente.

01:31:05.570 --> 01:31:07.612
Eu só vou passar aqui e imprimir nada.

01:31:07.612 --> 01:31:10.550
Eu nem preciso imprimir barra invertida n porque, se imprimir automaticamente

01:31:10.550 --> 01:31:13.970
dá a você uma barra invertida n, basta chamar print sem nada,

01:31:13.970 --> 01:31:15.420
e você receberá isso de graça.

01:31:15.420 --> 01:31:16.940
Então, deixe-me executar novamente o python de mario.py.

01:31:16.940 --> 01:31:19.895
E agora, parece um pouco mais bonito no prompt.

01:31:19.895 --> 01:31:21.770
E para ser super claro sobre o que está acontecendo--

01:31:21.770 --> 01:31:24.300
suponha que eu queira fazer uma exclamação aqui.

01:31:24.300 --> 01:31:27.320
Eu poderia mudar a barra invertida n padrão para um ponto de exclamação,

01:31:27.320 --> 01:31:28.680
apenas por diversão.

01:31:28.680 --> 01:31:31.550
E se eu executar python de mario.py Novamente, agora, eu

01:31:31.550 --> 01:31:36.662
obtenha esta exclamação com pontos de interrogação e pontos de exclamação também.

01:31:36.662 --> 01:31:38.120
Então isso é tudo que está acontecendo aqui.

01:31:38.120 --> 01:31:40.670
E isso é o que chamamos de argumento nomeado.

01:31:40.670 --> 01:31:43.670
Ele literalmente tem um nome que você pode especificar ao chamá-lo.

01:31:43.670 --> 01:31:47.787
E é diferente de posicional porque você está literalmente usando o nome.

01:31:47.787 --> 01:31:49.370
Deixe-me propor outra coisa, no entanto.

01:31:49.370 --> 01:31:50.828
E é por isso que as pessoas gostam de Python.

01:31:50.828 --> 01:31:52.550
Existem maneiras legais de fazer as coisas.

01:31:55.724 --> 01:32:00.740
Essa é uma maneira detalhada de três linhas de imprimir quatro pontos de interrogação.

01:32:00.740 --> 01:32:04.002
Eu certamente poderia pegar o atalho e apenas fazer isso.

01:32:04.002 --> 01:32:06.085
Mas isso não é realmente interessante para ninguém,

01:32:06.085 --> 01:32:08.720
especialmente se eu quiser fazer isso um número variável de vezes.

01:32:08.720 --> 01:32:10.390
Mas o Python permite que você faça isso.

01:32:10.390 --> 01:32:15.110
Se você quiser multiplicar um caractere algumas vezes,

01:32:15.110 --> 01:32:18.020
você não só pode usar mais para concatenação,

01:32:18.020 --> 01:32:23.930
você pode usar asterisco ou um asterisco para multiplicação, se quiser -- isto é,

01:32:23.930 --> 01:32:26.250
concatenação de novo e de novo e de novo.

01:32:26.250 --> 01:32:29.030
Então, se eu apenas imprimir, entre aspas, "?"

01:32:29.030 --> 01:32:34.190
vezes 4, esse será o caminho mais estreito, o caminho mais distinto

01:32:34.190 --> 01:32:36.020
Em vez disso, posso imprimir quatro pontos de interrogação.

01:32:36.020 --> 01:32:39.095
E se eu não usar 4, eu uso n, onde recebo n do usuário.

01:32:39.095 --> 01:32:39.830
Bang.

01:32:39.830 --> 01:32:42.320
Agora, eu me livrei totalmente do loop for,

01:32:42.320 --> 01:32:48.000
e estou usando o operador estrela para manipulá-lo.

01:32:48.000 --> 01:32:50.120
E, para ser super claro aqui, na medida em que Python

01:32:50.120 --> 01:32:54.440
não tem malloc ou free ou gerenciamento de memória que tem que fazer,

01:32:54.440 --> 01:32:56.060
adivinhe o que o Python também não tem.

01:32:59.760 --> 01:33:03.110
Alguma coisa em sua mente nas últimas duas semanas?

01:33:03.110 --> 01:33:03.875
Não tem--

01:33:03.875 --> 01:33:04.853
AUDIÊNCIA: Ponteiros.

01:33:04.853 --> 01:33:06.020
DAVID MALAN: Indicadores, sim.

01:33:06.020 --> 01:33:09.295
Portanto, o Python não possui ponteiros, o que significa apenas que tudo isso

01:33:09.295 --> 01:33:11.420
acontece para você automaticamente, sob o capô,

01:33:11.420 --> 01:33:14.150
novamente, por meio de código que outra pessoa escreveu.

01:33:14.150 --> 01:33:15.950
Que tal mais um retrocesso com Mario?

01:33:15.950 --> 01:33:20.450
Falamos sobre, na primeira semana, essa estrutura bidimensional onde

01:33:20.450 --> 01:33:24.302
é como se eu reivindicasse 3 por 3-- uma grade de tijolos, se preferir.

01:33:24.302 --> 01:33:25.760
Bem, como podemos fazer isso em Python?

01:33:25.760 --> 01:33:27.590
Podemos fazer isso de duas maneiras, agora.

01:33:27.590 --> 01:33:32.810
Deixe-me voltar ao meu mario.py e fazer algo como for i in range

01:33:32.810 --> 01:33:36.200
de-- faremos apenas 3, embora eu saiba, agora, eu poderia usar get_int

01:33:36.200 --> 01:33:38.453
ou eu poderia usar input e int.

01:33:38.453 --> 01:33:41.120
E se eu quiser fazer algo bidimensional, como em C,

01:33:41.120 --> 01:33:42.590
você pode aninhar seus loops for.

01:33:42.590 --> 01:33:45.980
Então talvez eu possa fazer para j no intervalo de 3.

01:33:45.980 --> 01:33:50.690
E então, aqui, eu poderia imprimir um símbolo de hash.

01:33:50.690 --> 01:33:53.210
E então, vamos ver se isso me dá 9 no total.

01:33:53.210 --> 01:33:56.870
Então, se eu tiver um loop aninhado como este, python de mario.py

01:33:56.870 --> 01:33:58.625
espero que me dê uma grade.

01:33:58.625 --> 01:34:01.710
Não, isso me deu uma coluna de 9.

01:34:01.710 --> 01:34:09.280
Por que, logicamente, embora eu tenha minha linha e minhas colunas?

01:34:09.280 --> 01:34:10.210
Sim.

01:34:10.210 --> 01:34:11.542
AUDIÊNCIA: [INAUDÍVEL]

01:34:11.542 --> 01:34:13.000
DAVID MALAN: Sim, a linha terminando.

01:34:13.000 --> 01:34:17.380
Portanto, na minha linha, não posso deixar a impressão continuar adicionando nova linha, adicionando nova linha.

01:34:17.380 --> 01:34:20.740
Então eu só tenho que substituir isso aqui e não me deixar estragar como antes.

01:34:20.740 --> 01:34:24.250
Deixe-me imprimir um no final de toda a linha, apenas para mover o cursor para baixo.

01:34:24.250 --> 01:34:28.090
E acho que agora, juntos, temos nosso 3 por 3.

01:34:28.090 --> 01:34:29.950
Claro, poderíamos apertar isso ainda mais.

01:34:29.950 --> 01:34:33.730
Se eu não gostar do loop aninhado, provavelmente poderia entrar aqui

01:34:33.730 --> 01:34:37.975
e imprima, por exemplo, um tijolo vezes 3.

01:34:37.975 --> 01:34:41.055
Ou eu poderia mudar o 3 para uma variável se eu obtivesse do usuário.

01:34:41.055 --> 01:34:42.582
Então eu posso apertar isso ainda mais.

01:34:42.582 --> 01:34:45.790
Então, novamente, apenas maneiras diferentes de resolver o mesmo problema e, novamente, evidências

01:34:45.790 --> 01:34:47.575
de por que muitas pessoas gostam de Python.

01:34:47.575 --> 01:34:49.825
Há apenas algumas maneiras mais agradáveis ​​de resolver problemas

01:34:49.825 --> 01:34:52.330
sem entrar no mato, constantemente, de fazer coisas,

01:34:52.330 --> 01:34:56.845
como com loops for e while loops infinitamente.

01:34:56.845 --> 01:34:57.430
Tudo bem.

01:34:57.430 --> 01:34:59.222
Bem, que tal alguns outros blocos de construção?

01:34:59.222 --> 01:35:02.983
Listas serão incrivelmente úteis em Python, assim como arrays

01:35:02.983 --> 01:35:04.900
estavam em C. Mas arrays são irritantes porque você

01:35:04.900 --> 01:35:06.410
tem que gerenciar a memória você mesmo.

01:35:06.410 --> 01:35:08.327
Você tem que saber com antecedência o tamanho deles ou você

01:35:08.327 --> 01:35:11.440
tem que usar ponteiros e malloc ou realloc para redimensioná-los.

01:35:11.440 --> 01:35:12.100
Oh meu Deus.

01:35:12.100 --> 01:35:14.267
As últimas duas semanas foram dolorosas, nesse sentido.

01:35:14.267 --> 01:35:17.298
Mas o Python faz tudo isso de graça para você.

01:35:17.298 --> 01:35:19.090
Na verdade, há um monte de funções

01:35:19.090 --> 01:35:22.030
que vêm com o Python que envolvem listas,

01:35:22.030 --> 01:35:29.678
e eles nos permitirão, em última análise, fazer as coisas de novo e de novo e de novo

01:35:29.678 --> 01:35:30.970
dentro da mesma estrutura de dados.

01:35:30.970 --> 01:35:33.220
E, por exemplo, poderemos obter o comprimento de uma lista.

01:35:33.220 --> 01:35:35.560
Você não precisa se lembrar disso em uma variável.

01:35:35.560 --> 01:35:39.085
Você pode simplesmente perguntar ao Python quantos elementos existem nesta lista.

01:35:39.085 --> 01:35:42.850
E com isso, acho que podemos resolver alguns problemas antigos também.

01:35:42.850 --> 01:35:45.250
Então deixe-me voltar aqui, para o VS Code.

01:35:45.250 --> 01:35:50.890
Deixe-me fechar o mario e nos dar um novo programa chamado scores.py.

01:35:50.890 --> 01:35:54.535
E em vez de mostrar o C e o Python agora, vamos nos concentrar apenas no Python.

01:35:54.535 --> 01:35:59.390
E em Scores.c, quando, acabamos de tirar a média de três notas de teste ou algo assim

01:35:59.390 --> 01:35:59.890
assim--

01:35:59.890 --> 01:36:01.900
72, 73 e 33--

01:36:01.900 --> 01:36:03.230
algumas semanas atrás.

01:36:03.230 --> 01:36:07.450
Então, se eu quiser criar uma lista nesta versão do Python de 72, 73, 33,

01:36:07.450 --> 01:36:09.220
Eu apenas uso minha notação de colchetes.

01:36:09.220 --> 01:36:12.640
C permite usar chaves se você souber os valores com antecedência,

01:36:12.640 --> 01:36:14.170
mas Python é apenas isso.

01:36:14.170 --> 01:36:16.855
E agora, se eu quiser calcular a média -

01:36:16.855 --> 01:36:19.360
em C, lembre-se, fiz algo com um loop.

01:36:19.360 --> 01:36:21.140
Juntei todos os valores.

01:36:21.140 --> 01:36:23.230
Eu, então, divido pelo número total de valores

01:36:23.230 --> 01:36:26.110
assim como você faria na escola primária, e isso me deu a média.

01:36:26.110 --> 01:36:29.085
Bem, o Python vem com muitas funções super úteis--

01:36:29.085 --> 01:36:31.395
não apenas comprimento, mas outros também.

01:36:31.395 --> 01:36:34.150
E então, de fato, se você quiser calcular a média,

01:36:34.150 --> 01:36:36.970
você pode pegar a soma de todas essas pontuações

01:36:36.970 --> 01:36:40.010
e divida-o pelo comprimento de todas essas pontuações.

01:36:40.010 --> 01:36:42.490
Então Python vem com comprimento, vem com soma.

01:36:42.490 --> 01:36:45.310
Você pode simplesmente passar uma lista inteira de qualquer tamanho

01:36:45.310 --> 01:36:47.590
e deixe que ele resolva esse problema para você.

01:36:47.590 --> 01:36:49.900
Então, se eu quiser, agora, imprimir esta média,

01:36:49.900 --> 01:36:51.760
Eu posso imprimir média de dois pontos--

01:36:51.760 --> 01:36:55.570
e, em seguida, inserirei minha variável média para interpolação.

01:36:55.570 --> 01:36:58.900
Deixe-me fazer disso um fstring para que seja formatado,

01:36:58.900 --> 01:37:01.530
e deixe-me executar o python de scores.py.

01:37:01.530 --> 01:37:02.800
E aí está a minha média.

01:37:02.800 --> 01:37:05.890
É estranho arredondar porque ainda estamos vulneráveis ​​a algum ponto flutuante

01:37:05.890 --> 01:37:09.340
imprecisão, mas pelo menos não precisei de loops

01:37:09.340 --> 01:37:11.575
e não precisei escrever todo esse maldito código apenas

01:37:11.575 --> 01:37:15.130
para fazer algo que o Excel e o Google Spreadsheets podem fazer assim.

01:37:15.130 --> 01:37:17.950
Bem, o Python está mais próximo desses tipos de ferramentas,

01:37:17.950 --> 01:37:21.790
mas mais poderoso porque você mesmo pode manipular os dados.

01:37:21.790 --> 01:37:25.510
Que tal, porém, se eu quiser obter um monte de pontuações manualmente do usuário

01:37:25.510 --> 01:37:27.280
e, a seguir, soma-los.

01:37:27.280 --> 01:37:28.920
Bem, vamos combinar algumas ideias aqui.

01:37:28.920 --> 01:37:29.830
Que tal agora?

01:37:29.830 --> 01:37:36.070
Primeiro, deixe-me importar a função get_int da biblioteca CS50,

01:37:36.070 --> 01:37:39.340
só para não termos que lidar com try e except ou tudo isso.

01:37:39.340 --> 01:37:42.340
E deixe-me ir em frente e me dar uma lista vazia.

01:37:42.340 --> 01:37:44.410
E isso é poderoso.

01:37:44.410 --> 01:37:48.068
Em C, [SIGHS] não há ponto para uma matriz vazia

01:37:48.068 --> 01:37:50.860
porque, se você criar uma matriz vazia com notação de colchetes,

01:37:50.860 --> 01:37:52.600
não serve para nada.

01:37:52.600 --> 01:37:55.780
Mas em Python, você pode criá-lo vazio porque Python

01:37:55.780 --> 01:37:59.590
aumentará e diminuirá a lista para você automaticamente, à medida que você adicionar itens a ela.

01:37:59.590 --> 01:38:01.600
Então, se eu quiser obter três pontuações do usuário,

01:38:01.600 --> 01:38:04.840
Eu poderia fazer algo assim-- para i no intervalo de 3.

01:38:04.840 --> 01:38:08.680
E então, posso pegar uma variável chamada "pontuação" ou qualquer outra coisa.

01:38:08.680 --> 01:38:11.467
Eu poderia chamar get_int, solicitar ao humano a pontuação

01:38:11.467 --> 01:38:12.550
que eles desejam digitar.

01:38:12.550 --> 01:38:15.060
E então, assim que o fizerem, eu posso fazer isso.

01:38:15.060 --> 01:38:19.450
Pensando agora em nossa capacidade de programação orientada a objetos,

01:38:19.450 --> 01:38:24.358
Eu poderia fazer scores.append e acrescentar essa pontuação a ele.

01:38:24.358 --> 01:38:27.400
E você só saberia disso por ter lido a documentação, ouvido

01:38:27.400 --> 01:38:30.040
na aula, em um livro ou algo assim, mas acontece

01:38:30.040 --> 01:38:33.880
que, assim como as strings, têm funções como lower embutidas nelas,

01:38:33.880 --> 01:38:37.735
as listas têm funções como anexar incorporadas que apenas acrescentam literalmente

01:38:37.735 --> 01:38:40.165
ao final da lista para você, e Python

01:38:40.165 --> 01:38:42.250
vai crescer ou encolher conforme necessário.

01:38:42.250 --> 01:38:44.760
Não há mais malloc ou realloc ou similares.

01:38:44.760 --> 01:38:49.120
Portanto, isso apenas acrescenta à lista de pontuações.

01:38:49.120 --> 01:38:51.740
Essa pontuação, e então de novo e de novo e de novo.

01:38:51.740 --> 01:38:52.990
Assim, a matriz começa em--

01:38:52.990 --> 01:38:57.640
desculpe, a lista começa no tamanho 0, depois cresce para 1, depois 2 e depois 3

01:38:57.640 --> 01:38:59.320
sem você ter que fazer mais nada.

01:38:59.320 --> 01:39:02.845
E agora, aqui em baixo, posso calcular uma média

01:39:02.845 --> 01:39:05.620
com a soma dessas pontuações dividida pelo comprimento

01:39:05.620 --> 01:39:07.455
do número total de pontuações.

01:39:07.455 --> 01:39:11.830
E para ser claro, comprimento é o número total de elementos na lista.

01:39:11.830 --> 01:39:14.200
Não importa o tamanho dos valores em si.

01:39:14.200 --> 01:39:18.160
Agora posso ir em frente e imprimir um fstring com algo

01:39:18.160 --> 01:39:22.100
como Média média de dois pontos entre chaves.

01:39:22.100 --> 01:39:24.680
E se eu executar python de scores.py--

01:39:24.680 --> 01:39:27.505
Vou digitar, apenas para fins de discussão, os três valores,

01:39:27.505 --> 01:39:29.440
Eu ainda recebo a mesma resposta.

01:39:29.440 --> 01:39:31.390
Mas isso teria sido doloroso de fazer em C

01:39:31.390 --> 01:39:35.770
a menos que você se comprometa, antecipadamente, com uma matriz de tamanho fixo-- que já

01:39:35.770 --> 01:39:41.830
decidiu, semanas atrás, era irritante-- ou você cresceu dinamicamente

01:39:41.830 --> 01:39:44.740
usando malloc ou realloc ou similares.

01:39:44.740 --> 01:39:45.400
Tudo bem.

01:39:45.400 --> 01:39:46.240
O que mais eu posso fazer?

01:39:46.240 --> 01:39:49.990
Bem, há algumas coisas legais que você deve saber que existem.

01:39:49.990 --> 01:39:54.340
Em vez de scores.append, você pode fazer uma pequena fantasia como esta.

01:39:54.340 --> 01:39:57.290
Se você quiser acrescentar algo a uma lista,

01:39:57.290 --> 01:40:00.100
você pode realmente fazer mais igual, e então

01:40:00.100 --> 01:40:03.620
colocar essa coisa em uma lista temporária própria

01:40:03.620 --> 01:40:05.740
e apenas use o que é essencialmente concatenação--

01:40:05.740 --> 01:40:09.410
mas não concatenação de strings, mas concatenação de listas.

01:40:09.410 --> 01:40:13.480
Portanto, esta nova linha 6 é anexada à lista de partituras--

01:40:13.480 --> 01:40:15.640
esta pequena lista que estou criando temporariamente

01:40:15.640 --> 01:40:17.670
apenas com a nova pontuação atual.

01:40:17.670 --> 01:40:20.260
Então, apenas outra parte da sintaxe que vale a pena ver

01:40:20.260 --> 01:40:23.290
permite que você faça algo assim também.

01:40:23.290 --> 01:40:23.890
Tudo bem.

01:40:23.890 --> 01:40:26.093
Bem, que tal voltarmos às cordas por um momento?

01:40:26.093 --> 01:40:29.260
E todos esses exemplos, como sempre, estão no site do curso posteriormente.

01:40:29.260 --> 01:40:32.860
Suponha que queremos fazer algo como converter caracteres em maiúsculas.

01:40:32.860 --> 01:40:35.170
Bem, para ser claro, eu poderia fazer algo assim.

01:40:35.170 --> 01:40:38.080
Deixe-me criar um programa chamado uppercase.py.

01:40:38.080 --> 01:40:42.280
Deixe-me solicitar ao usuário uma string antes usando a função de entrada

01:40:42.280 --> 01:40:44.510
ou get_string, que é quase o mesmo.

01:40:44.510 --> 01:40:47.110
E solicitarei ao usuário uma string de antemão.

01:40:47.110 --> 01:40:52.750
Então, deixe-me ir em frente e imprimir, que tal, a palavra-chave "Depois",

01:40:52.750 --> 01:40:56.650
e, em seguida, terminar a nova linha com nada, apenas para

01:40:56.650 --> 01:41:00.010
que posso ver "Antes" em uma linha e "Depois" na linha seguinte.

01:41:00.010 --> 01:41:01.240
E então, deixe-me fazer isso--

01:41:01.240 --> 01:41:04.450
e aqui é onde Python fica agradável também, com loops--

01:41:04.450 --> 01:41:07.270
para c antes--

01:41:07.270 --> 01:41:11.110
print c.upper end é igual a aspas, sem aspas.

01:41:11.110 --> 01:41:12.580
E então, vou imprimir isso aqui.

01:41:12.580 --> 01:41:13.120
Tudo bem.

01:41:13.120 --> 01:41:15.950
Isso foi rápido, mas vamos tentar inferir o que está acontecendo.

01:41:15.950 --> 01:41:19.600
Portanto, a linha 1 apenas obtém a entrada do usuário e a armazena em uma variável chamada anteriormente.

01:41:19.600 --> 01:41:22.510
A linha dois literalmente apenas imprime "Depois", mas não

01:41:22.510 --> 01:41:25.300
mova o cursor para a próxima linha.

01:41:25.300 --> 01:41:27.015
O que ele faz, então, é isso.

01:41:27.015 --> 01:41:29.875
E, em C, isso era um pouco mais irritante.

01:41:29.875 --> 01:41:31.450
Você precisava de um loop for com i.

01:41:31.450 --> 01:41:34.690
Você precisava de notação de matriz com os colchetes.

01:41:34.690 --> 01:41:39.850
Mas, Python, se você disser para variável em string--

01:41:39.850 --> 01:41:42.670
então para c, para caractere, em string, Python

01:41:42.670 --> 01:41:46.060
vai atribuir automaticamente c à primeira letra

01:41:46.060 --> 01:41:47.110
que o usuário digita.

01:41:47.110 --> 01:41:49.120
Então, na próxima iteração, a segunda letra, a terceira letra,

01:41:49.120 --> 01:41:49.745
e o quarto.

01:41:49.745 --> 01:41:52.360
Portanto, você não precisa de nenhuma notação de colchetes, basta usar c,

01:41:52.360 --> 01:41:55.180
e o Python fará isso por você e apenas o devolverá,

01:41:55.180 --> 01:41:59.000
uma de cada vez, cada uma das letras que o usuário digitou.

01:41:59.000 --> 01:42:04.720
Então, se eu voltar aqui e executar, por exemplo, python de uppercase.py

01:42:04.720 --> 01:42:09.760
e eu vou digitar, que tal, "david" em letras minúsculas e apertar Enter,

01:42:09.760 --> 01:42:13.630
agora você verá que está tudo em letras maiúsculas iterando sobre ele,

01:42:13.630 --> 01:42:15.372
na verdade, um personagem de cada vez.

01:42:15.372 --> 01:42:17.830
Mas já sabemos, graças à programação orientada a objetos,

01:42:17.830 --> 01:42:20.027
as próprias strings têm a funcionalidade construída

01:42:20.027 --> 01:42:24.100
in para não apenas caracteres únicos maiúsculos, mas toda a string.

01:42:24.100 --> 01:42:26.530
Então, honestamente, esse foi um exercício meio bobo.

01:42:26.530 --> 01:42:31.360
Não preciso mais usar um loop, como em C. E assim, alguns dos hábitos

01:42:31.360 --> 01:42:34.720
você acabou de desenvolver nas últimas semanas, é hora de começar a quebrá-los

01:42:34.720 --> 01:42:36.130
quando não são necessários.

01:42:36.130 --> 01:42:40.470
Posso criar uma variável chamada depois, defini-la como antes.superior--

01:42:40.470 --> 01:42:43.600
que, de fato, existe, assim como existe o ponto inferior.

01:42:43.600 --> 01:42:47.490
E então, o que posso imprimir é, por exemplo...

01:42:47.490 --> 01:42:49.990
vamos nos livrar dessa linha de impressão aqui e fazer no final--

01:42:49.990 --> 01:42:53.900
"Depois" e imprima o valor dessa variável.

01:42:53.900 --> 01:42:58.005
Agora, se eu executar novamente uppercase.py, digite "david" em letras minúsculas,

01:42:58.005 --> 01:43:03.400
Posso apenas colocar tudo em maiúsculas de uma vez porque, novamente, em Python,

01:43:03.400 --> 01:43:07.000
você não precisa operar os personagens individualmente.

01:43:07.000 --> 01:43:13.310
Dúvidas sobre algum desses truques até agora?

01:43:13.310 --> 01:43:13.810
Não?

01:43:13.810 --> 01:43:14.290
Tudo bem.

01:43:14.290 --> 01:43:17.290
Que tal algumas outras técnicas que vimos em C que traremos de volta,

01:43:17.290 --> 01:43:18.145
agora, em Python.

01:43:18.145 --> 01:43:22.860
Acontece que, em Python, existem outras bibliotecas que você também pode usar,

01:43:22.860 --> 01:43:24.360
que desbloqueiam ainda mais funcionalidades.

01:43:24.360 --> 01:43:27.040
Então, em C, se você quiser argumentos de linha de comando,

01:43:27.040 --> 01:43:32.410
você apenas muda a assinatura de main para ser, em vez de void,

01:43:32.410 --> 01:43:38.515
int argc vírgula string argv, colchetes abertos para uma matriz ou estrela de caracteres,

01:43:38.515 --> 01:43:39.130
eventualmente.

01:43:39.130 --> 01:43:41.770
Bem, acontece que, em Python, se você quiser acessar a linha de comando

01:43:41.770 --> 01:43:44.770
argumentos, é um pouco mais simples, mas eles estão guardados em uma biblioteca--

01:43:44.770 --> 01:43:46.990
também conhecido como módulo--

01:43:46.990 --> 01:43:49.552
chamado sys, o módulo do sistema.

01:43:49.552 --> 01:43:51.760
Agora, isso é semelhante, em espírito, à biblioteca CS50,

01:43:51.760 --> 01:43:53.802
e isso tem um monte de funcionalidades incorporadas.

01:43:53.802 --> 01:43:55.725
Mas este vem com o próprio Python.

01:43:55.725 --> 01:43:59.710
Então, se eu quiser criar um programa como o greet.py, no VS Code,

01:43:59.710 --> 01:44:01.510
aqui, deixe-me ir em frente e fazer isso.

01:44:01.510 --> 01:44:05.785
Da biblioteca sys, vamos importar argv.

01:44:05.785 --> 01:44:07.850
E isso é apenas uma coisa que existe.

01:44:07.850 --> 01:44:10.660
Não está embutido no main porque não existe mais o main per se.

01:44:10.660 --> 01:44:12.590
Então está escondido naquela biblioteca.

01:44:12.590 --> 01:44:14.330
E agora, posso fazer algo assim.

01:44:14.330 --> 01:44:16.925
Se o comprimento de argv for igual a 2, bem,

01:44:16.925 --> 01:44:19.090
vamos em frente e imprimir algo amigável,

01:44:19.090 --> 01:44:24.955
como olá vírgula argv colchete 1 e, em seguida, feche as aspas.

01:44:24.955 --> 01:44:28.360
Caso contrário, se o comprimento de argv não for igual a 2,

01:44:28.360 --> 01:44:30.400
Vamos imprimir olá, mundo.

01:44:30.400 --> 01:44:32.525
Agora, à primeira vista, isso pode parecer um pouco enigmático,

01:44:32.525 --> 01:44:35.050
mas é idêntico ao que fizemos algumas semanas atrás.

01:44:35.050 --> 01:44:39.570
Quando eu executo isso, python de greet.py, sem argumentos,

01:44:39.570 --> 01:44:40.950
apenas diz "olá, mundo".

01:44:40.950 --> 01:44:46.180
Mas se eu, em vez disso, adicionar um argumento de linha de comando, como meu primeiro nome e clicar

01:44:46.180 --> 01:44:49.825
Digite, agora, o comprimento de argv não é mais 1.

01:44:49.825 --> 01:44:51.700
vai ser 2.

01:44:51.700 --> 01:44:54.680
E assim, imprime "Olá, David".

01:44:54.680 --> 01:44:57.880
Portanto, a conclusão aqui é que, enquanto em C,

01:44:57.880 --> 01:45:03.955
argv continha tecnicamente o nome do seu programa, como ./hello ou ./greet,

01:45:03.955 --> 01:45:05.455
e então tudo o que o humano digitou.

01:45:05.455 --> 01:45:08.410
Python é um pouco diferente nisso, porque estamos

01:45:08.410 --> 01:45:10.150
usando o interpretador desta forma--

01:45:10.150 --> 01:45:16.090
tecnicamente, quando você executa python de greet.py, o comprimento de argv é apenas 1.

01:45:16.090 --> 01:45:18.760
Ele contém apenas greet.py, portanto, o nome do arquivo.

01:45:18.760 --> 01:45:21.670
Não contém desnecessariamente o próprio Python

01:45:21.670 --> 01:45:24.460
porque de que adianta isso estar ali, onipresente?

01:45:24.460 --> 01:45:28.760
Ele contém o número de palavras que o humano digitou após o próprio Python.

01:45:28.760 --> 01:45:32.230
Então argv é comprimento 1 aqui. argv é comprimento 2 aqui.

01:45:32.230 --> 01:45:35.350
E é por isso que, quando igualou 2, vi "Olá, David" em vez

01:45:35.350 --> 01:45:37.240
do padrão "Olá, mundo".

01:45:37.240 --> 01:45:41.440
Portanto, a mesma capacidade de acessar argumentos de linha de comando, adicione esses tipos de entradas

01:45:41.440 --> 01:45:43.570
para suas funções, mas você tem que desbloqueá-lo

01:45:43.570 --> 01:45:47.830
por meio do uso de argv, desta forma.

01:45:47.830 --> 01:45:51.910
Se você quiser ver todas as palavras, você pode fazer algo assim.

01:45:51.910 --> 01:45:57.760
Assim como-- se combinarmos ideias, aqui-- para i na faixa de, que tal, comprimento

01:45:57.760 --> 01:45:59.610
de argv.

01:45:59.610 --> 01:46:02.260
Então, eu posso fazer isso-- imprimir argv colchete i.

01:46:02.260 --> 01:46:02.860
Tudo bem.

01:46:02.860 --> 01:46:06.385
Um pouco enigmático, mas a linha 3 é apenas uma iteração de loop for

01:46:06.385 --> 01:46:08.410
sobre o intervalo de comprimento de argv.

01:46:08.410 --> 01:46:12.640
Portanto, se o humano digitar em duas palavras, o comprimento de argv será 2.

01:46:12.640 --> 01:46:16.885
Portanto, esta é apenas uma maneira de repetir todas as palavras em argv,

01:46:16.885 --> 01:46:18.380
imprimindo-os um de cada vez.

01:46:18.380 --> 01:46:22.810
Então python de greet.py, Enter apenas imprime o nome do programa.

01:46:22.810 --> 01:46:27.340
python de greet.py com David imprime greet.py e, em seguida, David.

01:46:27.340 --> 01:46:29.470
Eu posso continuar executando com mais palavras,

01:46:29.470 --> 01:46:32.650
e cada um deles será impresso um de cada vez.

01:46:32.650 --> 01:46:35.440
Mas o que é bom, também, sobre o Python--

01:46:35.440 --> 01:46:38.920
e este é o objetivo deste exercício-- honestamente, isso parece bastante enigmático.

01:46:38.920 --> 01:46:40.720
Isso não é muito agradável de se olhar.

01:46:40.720 --> 01:46:46.150
Se você quiser apenas iterar cada palavra em uma lista, que é argv,

01:46:46.150 --> 01:46:47.680
observe o que posso fazer.

01:46:47.680 --> 01:46:52.090
Eu posso fazer para arg ou qualquer nome de variável em argv.

01:46:52.090 --> 01:46:54.147
Deixe-me apenas, agora, imprimir esse argumento.

01:46:54.147 --> 01:46:56.980
Eu poderia continuar chamando de i, mas parece estranho quando não é um número.

01:46:56.980 --> 01:46:59.710
Em vez disso, estou mudando para arg como uma palavra.

01:46:59.710 --> 01:47:03.970
Se eu agora fizer python de greet.py, ele fará isso.

01:47:03.970 --> 01:47:06.460
Se eu fizer python de greet.py, David, ele faz isso de novo.

01:47:06.460 --> 01:47:08.690
David Malan, faz isso de novo.

01:47:08.690 --> 01:47:10.898
Então, novamente, é por isso que o Python é tão atraente.

01:47:10.898 --> 01:47:13.482
Você quer fazer algo tantas vezes, iterar em uma lista?

01:47:13.482 --> 01:47:15.820
Basta dizer, e ele se parece um pouco mais com o inglês.

01:47:15.820 --> 01:47:18.130
E há ainda outras fantasias também, se me permitem.

01:47:18.130 --> 01:47:21.820
É um pouco estúpido que eu continue vendo o nome do programa, greet.py,

01:47:21.820 --> 01:47:24.640
então seria bom se eu pudesse remover isso.

01:47:24.640 --> 01:47:28.960
O Python também suporta o que chamamos de fatias de arrays--

01:47:28.960 --> 01:47:30.340
desculpe, fatias de listas.

01:47:30.340 --> 01:47:32.050
Até eu confundo a terminologia.

01:47:32.050 --> 01:47:36.400
Se argv for uma lista, ele imprimirá tudo nela.

01:47:36.400 --> 01:47:41.950
Mas se eu quiser uma fatia que comece no local 1 até o fim,

01:47:41.950 --> 01:47:45.500
você pode usar esta sintaxe divertida entre os colchetes, que

01:47:45.500 --> 01:47:48.700
ainda não vimos, isso vai começar no item 1

01:47:48.700 --> 01:47:50.220
e ir até o fim.

01:47:50.220 --> 01:47:53.830
E então, esta é uma maneira legal e inteligente de cortar,

01:47:53.830 --> 01:47:56.170
se preferir, o primeiro elemento porque agora,

01:47:56.170 --> 01:48:01.900
quando executo o greet.py, David Malan, devo ver apenas David e Malan.

01:48:01.900 --> 01:48:04.940
Se eu quiser apenas um elemento, posso fazer 1 para 2.

01:48:04.940 --> 01:48:08.260
Se eu quiser todos eles, posso fazer 0 em diante.

01:48:08.260 --> 01:48:10.900
Eu poderia me dar apenas um deles dessa maneira.

01:48:10.900 --> 01:48:14.380
Então você pode jogar com o valor inicial e o valor final desta forma,

01:48:14.380 --> 01:48:17.020
para cortar e cortar essas listas de maneiras diferentes.

01:48:17.020 --> 01:48:20.620
Isso teria sido uma dor em C, só porque nós realmente não

01:48:20.620 --> 01:48:26.840
têm o suporte integrado para manipular matrizes de maneira tão limpa quanto esta.

01:48:26.840 --> 01:48:27.340
Tudo bem.

01:48:27.340 --> 01:48:31.440
Só para você ver também - embora este seja menos emocionante de se ver ao vivo -

01:48:31.440 --> 01:48:33.940
se eu for em frente e criar um programa rápido aqui, verifica-se,

01:48:33.940 --> 01:48:37.630
há algo mais na biblioteca sys, a capacidade de sair de programas--

01:48:37.630 --> 01:48:41.590
saindo com o código de status 1 ou 0, como temos feito sempre que algo

01:48:41.590 --> 01:48:42.673
dá certo ou errado.

01:48:42.673 --> 01:48:45.340
Então, por exemplo, deixe-me criar um programa rápido que apenas diga:

01:48:45.340 --> 01:48:52.300
se o comprimento de sys.argv não for igual a 2, vamos gritar com o usuário

01:48:52.300 --> 01:48:54.970
e diga que está faltando um argumento de linha de comando.

01:48:54.970 --> 01:48:57.380
Caso contrário, argumento de linha de comando.

01:48:57.380 --> 01:49:01.360
E vamos, então, retornar sys.exit(1).

01:49:01.360 --> 01:49:05.590
Caso contrário, vamos em frente e, logicamente, apenas diga imprimir uma string formatada que

01:49:05.590 --> 01:49:07.450
diz olá-- como antes--

01:49:07.450 --> 01:49:09.640
sys.argv 1.

01:49:09.640 --> 01:49:11.770
Agora, as coisas parecem diferentes de repente,

01:49:11.770 --> 01:49:13.312
mas estou fazendo algo deliberadamente.

01:49:13.312 --> 01:49:14.870
Primeiro, vamos ver o que isso faz.

01:49:14.870 --> 01:49:18.730
Então, na linha 1, estou importando não argv, especificamente.

01:49:18.730 --> 01:49:22.150
Estou importando toda a biblioteca sys e veremos o porquê em um segundo.

01:49:22.150 --> 01:49:27.220
Bem, acontece que a biblioteca sys não tem apenas a lista argv,

01:49:27.220 --> 01:49:30.580
ele também tem uma função chamada exit, que eu gostaria de poder usar,

01:49:30.580 --> 01:49:31.370
também.

01:49:31.370 --> 01:49:35.200
Acontece que, se você importar uma biblioteca inteira dessa maneira, tudo bem.

01:49:35.200 --> 01:49:37.840
Mas você tem que se referir às coisas dentro dele

01:49:37.840 --> 01:49:42.980
usando o nome da mesma biblioteca e um ponto para nomeá-la, por assim dizer.

01:49:42.980 --> 01:49:47.002
Então aqui, estou apenas dizendo, se o usuário não digitar duas palavras,

01:49:47.002 --> 01:49:49.960
grite com eles com o argumento de linha de comando ausente e, em seguida, saia com 1.

01:49:49.960 --> 01:49:52.975
Assim como em C, quando você sai 1, significa apenas que algo deu errado.

01:49:52.975 --> 01:49:54.785
Caso contrário, imprima olá para isso.

01:49:54.785 --> 01:49:57.910
E isso está começando a parecer enigmático, mas é apenas uma combinação de ideias.

01:49:57.910 --> 01:50:02.080
As chaves significam interpolar este valor, conecte-o aqui.

01:50:02.080 --> 01:50:05.740
sys.argv é apenas a maneira detalhada de dizer vá para a biblioteca sys

01:50:05.740 --> 01:50:09.010
e obtenha a variável argv nele.

01:50:09.010 --> 01:50:11.860
E colchete 1, é claro, assim como arrays em C,

01:50:11.860 --> 01:50:15.440
é apenas o segundo elemento no prompt.

01:50:15.440 --> 01:50:18.700
Então, quando executo esta versão, agora-- python de exit.py--

01:50:18.700 --> 01:50:21.340
sem argumentos, gritam comigo dessa maneira.

01:50:21.340 --> 01:50:24.640
Se, no entanto, eu digitar dois argumentos no total -

01:50:24.640 --> 01:50:26.950
o nome do arquivo e meu próprio nome--

01:50:26.950 --> 01:50:29.050
agora, sou saudado com olá, David.

01:50:29.050 --> 01:50:30.310
E é a mesma ideia antes.

01:50:30.310 --> 01:50:33.160
Esta foi uma técnica de nível muito baixo, mas a mesma coisa aqui.

01:50:33.160 --> 01:50:36.310
Se você ecoar sinal de dólar, ponto de interrogação Enter,

01:50:36.310 --> 01:50:39.170
você verá o código de saída do seu programa.

01:50:39.170 --> 01:50:41.270
Então, se eu fizer isso incorretamente de novo--

01:50:41.270 --> 01:50:43.953
deixe-me executá-lo novamente sem o meu nome, Enter--

01:50:43.953 --> 01:50:44.620
Eu recebo gritos.

01:50:44.620 --> 01:50:47.320
Mas se eu ecoar o cifrão de interrogação,

01:50:47.320 --> 01:50:50.170
há o segredo que é devolvido.

01:50:50.170 --> 01:50:54.160
Novamente, apenas para mostrar paridade com C, neste caso.

01:50:54.160 --> 01:50:56.320
Dúvidas, agora, sobre alguma dessas técnicas, aqui?

01:50:58.900 --> 01:50:59.400
Não.

01:50:59.400 --> 01:51:00.030
Tudo bem.

01:51:00.030 --> 01:51:02.580
Que tal algo um pouco mais poderoso também?

01:51:02.580 --> 01:51:05.880
Passamos tanto tempo nas semanas 0 e 1 pesquisando

01:51:05.880 --> 01:51:07.830
e, então, eventualmente, classificação na semana 3.

01:51:07.830 --> 01:51:10.288
Bem, acontece que o Python também pode ajudar com isso.

01:51:10.288 --> 01:51:12.720
Deixe-me ir em frente e criar um programa chamado names.py

01:51:12.720 --> 01:51:15.053
será apenas uma oportunidade para, talvez, pesquisar

01:51:15.053 --> 01:51:16.650
sobre um monte de nomes.

01:51:16.650 --> 01:51:21.060
Deixe-me ir em frente e importar sys, apenas para ter acesso à saída.

01:51:21.060 --> 01:51:22.920
E deixe-me ir em frente e criar uma variável

01:51:22.920 --> 01:51:26.756
chamou nomes que vai ser uma lista com um monte de nomes.

01:51:26.756 --> 01:51:27.660
Que tal aqui?

01:51:27.660 --> 01:51:34.740
Charlie e Fred e George e Ginny e Percy e, por último, Ron.

01:51:34.740 --> 01:51:36.290
Então, um monte de nomes aqui.

01:51:36.290 --> 01:51:38.040
E seria um pouco chato implementar

01:51:38.040 --> 01:51:42.540
código que itera sobre isso, da esquerda para a direita, em C, procurando por um

01:51:42.540 --> 01:51:43.165
desses nomes.

01:51:43.165 --> 01:51:43.957
Aliás, que nome?

01:51:43.957 --> 01:51:46.290
Bem, vamos em frente e pedir ao usuário para inserir o nome

01:51:46.290 --> 01:51:48.498
que eles desejam pesquisar para que possamos dizer a eles

01:51:48.498 --> 01:51:50.460
se o nome está lá ou não.

01:51:50.460 --> 01:51:54.670
E poderíamos fazer isso, semelhante a C, em Python, fazendo algo assim.

01:51:54.670 --> 01:52:00.600
Então, para n em nomes, onde n é apenas uma variável para iterar sobre cada nome--

01:52:00.600 --> 01:52:05.595
se o nome que estou procurando for igual ao nome atual na lista--

01:52:05.595 --> 01:52:09.060
AKA n-- bem, vamos imprimir algo amigável, como "Encontrado".

01:52:09.060 --> 01:52:14.250
E então, vamos fazer sys.exit 0 para indicar que encontramos quem quer que seja.

01:52:14.250 --> 01:52:17.460
Caso contrário, se chegarmos ao fundo aqui, fora deste loop,

01:52:17.460 --> 01:52:20.340
vamos apenas imprimir "Não encontrado" porque se ainda não saímos.

01:52:20.340 --> 01:52:22.800
E então, vamos sair com 1.

01:52:22.800 --> 01:52:25.980
Só para esclarecer, posso continuar importando todos os sistemas,

01:52:25.980 --> 01:52:31.920
ou eu poderia fazer de sys import exit e, em seguida, poderia me livrar de sys dot

01:52:31.920 --> 01:52:33.240
em qualquer outro lugar.

01:52:33.240 --> 01:52:36.540
Mas, às vezes, é útil saber exatamente de onde vieram as funções.

01:52:36.540 --> 01:52:39.675
Portanto, isso também é apenas uma questão de estilo, neste caso.

01:52:39.675 --> 01:52:40.230
Tudo bem.

01:52:40.230 --> 01:52:41.522
Então, vamos em frente e executar isso.

01:52:41.522 --> 01:52:46.540
python de names.py, e vamos procurar por Ron, até o final.

01:52:46.540 --> 01:52:47.040
Tudo bem.

01:52:47.040 --> 01:52:47.910
Ele foi encontrado.

01:52:47.910 --> 01:52:51.570
E vamos procurar alguém fora da família aqui, como Hermione.

01:52:51.570 --> 01:52:52.700
Não encontrado.

01:52:52.700 --> 01:52:53.200
OK.

01:52:53.200 --> 01:52:54.783
Então parece estar funcionando dessa maneira.

01:52:54.783 --> 01:52:58.548
Mas eu essencialmente implementei qual algoritmo?

01:52:58.548 --> 01:53:05.247
Que algoritmo parece ser, por linha 7 e 8 a 9 e 10?

01:53:05.247 --> 01:53:05.955
AUDIÊNCIA: Linear.

01:53:05.955 --> 01:53:06.450
DAVID MALAN: Sim.

01:53:06.450 --> 01:53:07.350
Portanto, é apenas uma pesquisa linear.

01:53:07.350 --> 01:53:10.185
É um loop, mesmo que a sintaxe dele seja um pouco mais sucinta hoje,

01:53:10.185 --> 01:53:12.060
e é apenas uma iteração sobre a coisa toda.

01:53:12.060 --> 01:53:15.240
Bem, honestamente, vimos uma maneira ainda mais concisa de fazer isso em Python.

01:53:15.240 --> 01:53:19.230
E isso, novamente, é o que a torna uma linguagem mais agradável, às vezes.

01:53:19.230 --> 01:53:20.630
Por que não faço isso?

01:53:20.630 --> 01:53:24.790
Em vez de iterar um de cada vez, por que não digo isso?

01:53:24.790 --> 01:53:27.840
Deixe-me ir em frente e mudar minha condição para apenas

01:53:27.840 --> 01:53:33.270
be-- que tal se o nome que estamos procurando estiver na lista de nomes, estamos prontos.

01:53:33.270 --> 01:53:33.960
Nós achamos.

01:53:33.960 --> 01:53:36.570
Use a preposição final que vimos algumas vezes,

01:53:36.570 --> 01:53:40.710
agora, isso mesmo faz a pergunta, algo está em outra coisa?

01:53:40.710 --> 01:53:44.050
E o Python cuidará da pesquisa linear para nós.

01:53:44.050 --> 01:53:46.080
E vai funcionar exatamente da mesma forma se eu

01:53:46.080 --> 01:53:48.030
faça python de names.py, procure por Ron.

01:53:48.030 --> 01:53:50.077
Ainda vai encontrá-lo e ainda é

01:53:50.077 --> 01:53:51.660
vai fazê-lo linearmente, neste caso.

01:53:51.660 --> 01:53:58.060
Mas não preciso escrever todo o código de nível inferior sozinho, neste caso.

01:53:58.060 --> 01:54:02.430
Perguntas, agora, sobre tudo isso?

01:54:02.430 --> 01:54:05.380
O código está ficando cada vez mais curto.

01:54:05.380 --> 01:54:05.880
Não?

01:54:05.880 --> 01:54:07.740
Que tal-- vamos ver.

01:54:07.740 --> 01:54:09.250
O que mais podemos ter aqui?

01:54:09.250 --> 01:54:10.770
Que tal agora?

01:54:10.770 --> 01:54:12.780
Vamos em frente e implementar essa lista telefônica

01:54:12.780 --> 01:54:15.690
que começamos, metaforicamente, no início do curso.

01:54:15.690 --> 01:54:17.940
Vamos codificar um programa chamado phonebook.py.

01:54:17.940 --> 01:54:22.440
E neste caso, vamos criar um dicionário desta vez.

01:54:22.440 --> 01:54:25.470
Lembre-se de que um dicionário é uma coisinha que

01:54:25.470 --> 01:54:27.060
implementa algo assim--

01:54:27.060 --> 01:54:31.140
uma tabela de duas colunas com chaves e valores, palavras

01:54:31.140 --> 01:54:33.240
e definições, nomes e números.

01:54:33.240 --> 01:54:36.367
E vamos nos concentrar no último deles, nomes e números, neste caso.

01:54:36.367 --> 01:54:38.700
Bem, eu afirmei anteriormente que o Python tem suporte integrado

01:54:38.700 --> 01:54:42.780
para dicionários-- objetos dict-- que você pode criar com uma linha.

01:54:42.780 --> 01:54:45.120
Eu não precisava disso para soletrar porque um conjunto é suficiente

01:54:45.120 --> 01:54:47.610
quando você deseja apenas uma das chaves ou valores, não ambos.

01:54:47.610 --> 01:54:49.680
Mas agora, quero alguns nomes e números.

01:54:49.680 --> 01:54:53.220
Acontece que, em Python, você pode criar um dicionário vazio

01:54:53.220 --> 01:54:55.680
ao dizer dict parênteses abertos, fechados.

01:54:55.680 --> 01:54:58.080
E isso apenas fornece, essencialmente, um gráfico que

01:54:58.080 --> 01:54:59.640
parece com isso, sem nada nele.

01:54:59.640 --> 01:55:01.725
Ou há uma sintaxe mais sucinta.

01:55:01.725 --> 01:55:06.858
Você pode, alternativamente, fazer isso, com duas chaves, em vez disso.

01:55:06.858 --> 01:55:09.150
E, na verdade, tenho usado um atalho todo esse tempo.

01:55:09.150 --> 01:55:15.885
Quando eu tinha uma lista, anteriormente, onde minha variável se chamava escores,

01:55:15.885 --> 01:55:19.860
e eu fiz isso, que foi na verdade a versão abreviada disso--

01:55:19.860 --> 01:55:21.637
ei, Python, me dê uma lista vazia.

01:55:21.637 --> 01:55:23.970
Portanto, há uma sintaxe diferente para atingir o mesmo objetivo.

01:55:23.970 --> 01:55:27.540
Neste caso, se eu quiser um dicionário para pessoas,

01:55:27.540 --> 01:55:32.530
Posso fazer isso ou, mais comumente, apenas duas chaves, assim.

01:55:32.530 --> 01:55:33.030
Tudo bem.

01:55:33.030 --> 01:55:34.360
Bem, o que eu quero colocar nisso?

01:55:34.360 --> 01:55:36.360
Bem, deixe-me colocar algumas coisas nisso.

01:55:36.360 --> 01:55:39.360
E vou apenas mover minha chave fechada para uma nova linha.

01:55:39.360 --> 01:55:42.580
Se eu quiser implementar essa ideia de chaves e valores,

01:55:42.580 --> 01:55:47.220
a maneira como você faz isso em Python é a vírgula do valor dos dois pontos chave.

01:55:47.220 --> 01:55:48.230
Valor chave de dois pontos.

01:55:48.230 --> 01:55:50.410
Portanto, você o implementaria mais no código.

01:55:50.410 --> 01:55:54.270
Então, por exemplo, se eu quiser que Carter seja a primeira chave na minha lista telefônica e eu

01:55:54.270 --> 01:56:00.135
quer que seu número seja +1-617-495-1000, posso colocar isso como o correspondente

01:56:00.135 --> 01:56:00.960
valor.

01:56:00.960 --> 01:56:02.010
O cólon está no meio.

01:56:02.010 --> 01:56:05.970
Ambos são strings, ou strs, então citei ambos deliberadamente.

01:56:05.970 --> 01:56:07.762
Se eu quiser me adicionar, posso colocar uma vírgula.

01:56:07.762 --> 01:56:10.970
E então, só para manter as coisas bonitas, estou movendo o cursor para a próxima linha.

01:56:10.970 --> 01:56:12.990
Mas isso não é estritamente necessário, esteticamente.

01:56:12.990 --> 01:56:13.865
É apenas um bom estilo.

01:56:13.865 --> 01:56:19.500
E aqui, posso ligar para +1-949-468-2750.

01:56:19.500 --> 01:56:24.270
E agora, eu tenho um dicionário que, essencialmente, tem duas linhas, aqui--

01:56:24.270 --> 01:56:27.322
Carter e seu número e David e seu número também.

01:56:27.322 --> 01:56:30.405
E se eu continuasse adicionando a isso, este gráfico ficaria cada vez mais longo.

01:56:30.405 --> 01:56:32.430
Suponha que eu queira procurar um de nossos números.

01:56:32.430 --> 01:56:34.950
Bem, vamos solicitar ao usuário o nome,

01:56:34.950 --> 01:56:37.470
cujo número você deseja pesquisar obtendo string.

01:56:37.470 --> 01:56:38.560
Ou você sabe o quê?

01:56:38.560 --> 01:56:39.893
Não precisamos dessa biblioteca CS50.

01:56:39.893 --> 01:56:43.090
Vamos apenas usar a entrada e solicitar um nome ao usuário.

01:56:43.090 --> 01:56:49.230
E agora, podemos usar essa sintaxe super concisa e apenas dizer se nome em pessoas,

01:56:49.230 --> 01:56:53.700
imprima os dois pontos do número da string formatada e--

01:56:53.700 --> 01:56:57.160
aqui, podemos fazer isso-- nomes de colchetes de pessoas.

01:56:57.160 --> 01:56:57.930
OK.

01:56:57.930 --> 01:57:01.800
Então isso está ficando legal rapidamente, de forma confusa.

01:57:01.800 --> 01:57:02.805
Então deixe-me executar isso.

01:57:02.805 --> 01:57:06.810
python de phonebook.py Vamos digitar Carter.

01:57:06.810 --> 01:57:08.910
E, de fato, vejo o número dele.

01:57:08.910 --> 01:57:12.910
Vamos rodar de novo com David, e vejo meu número aqui.

01:57:12.910 --> 01:57:14.590
Então o que está acontecendo?

01:57:14.590 --> 01:57:19.320
Bem, acontece que um dicionário é muito semelhante, em espírito, a uma lista.

01:57:19.320 --> 01:57:22.350
Na verdade, é muito semelhante, em espírito, a um array em C.

01:57:22.350 --> 01:57:27.150
Mas, em vez de se limitar a chaves que são números, como colchetes 0,

01:57:27.150 --> 01:57:30.690
colchete 1, colchete 2, você pode realmente usar palavras.

01:57:30.690 --> 01:57:33.060
E isso é tudo que estou fazendo aqui na linha 8.

01:57:33.060 --> 01:57:36.765
Se eu quiser verificar o nome Carter, que está atualmente

01:57:36.765 --> 01:57:39.555
nesta variável chamada nome, posso indexar

01:57:39.555 --> 01:57:42.660
no meu dicionário de pessoas usando não um número,

01:57:42.660 --> 01:57:44.830
mas usando, literalmente, uma string--

01:57:44.830 --> 01:57:48.000
o nome Carter ou David ou qualquer outra coisa.

01:57:48.000 --> 01:57:50.640
Para tornar isso mais claro, observe que estou, no momento,

01:57:50.640 --> 01:57:54.095
usando esta string de formato, que está adicionando alguma complexidade indevida.

01:57:54.095 --> 01:57:56.220
Mas eu poderia esclarecer isso, talvez, ainda mais.

01:57:56.220 --> 01:57:58.080
Eu poderia me dar outra variável chamada

01:57:58.080 --> 01:58:01.320
número, defina-o igual ao dicionário de pessoas,

01:58:01.320 --> 01:58:03.875
indexando nele usando o nome atual.

01:58:03.875 --> 01:58:07.230
E agora, posso encurtar isso para deixar mais claro que tudo o que estou fazendo

01:58:07.230 --> 01:58:09.910
está imprimindo o valor disso.

01:58:09.910 --> 01:58:12.930
E, de fato, posso fazer isso de maneira ainda mais enigmática.

01:58:12.930 --> 01:58:16.710
Seria estranho fazer isso, mas se eu quiser apenas mostrar o número de telefone de David

01:58:16.710 --> 01:58:21.150
e nunca de Carter, posso literalmente, entre aspas, "indexar" as pessoas

01:58:21.150 --> 01:58:24.930
dicionário porque, agora, quando eu executo isso, mesmo se eu digitar Carter,

01:58:24.930 --> 01:58:27.020
Em vez disso, vou recuperar meu número.

01:58:27.020 --> 01:58:31.080
Mas isso é tudo o que acontecerá se eu desfazer isso, porque agora é um bug.

01:58:31.080 --> 01:58:35.250
Mas eu indexo nele usando o valor de name.

01:58:35.250 --> 01:58:37.230
Os dicionários são tão maravilhosamente convenientes

01:58:37.230 --> 01:58:39.688
porque, agora, você pode associar qualquer coisa com qualquer outra coisa

01:58:39.688 --> 01:58:43.420
mas não usando números, mas palavras-chave inteiras.

01:58:43.420 --> 01:58:46.770
Então aqui está como, se, no speller, demos a você não apenas palavras,

01:58:46.770 --> 01:58:50.340
mas também centenas de milhares de definições,

01:58:50.340 --> 01:58:52.385
você poderia essencialmente armazená-los como este.

01:58:52.385 --> 01:58:55.680
E então, quando o humano quiser procurar uma definição em um dicionário adequado,

01:58:55.680 --> 01:58:57.750
não apenas para verificação ortográfica, você pode indexar

01:58:57.750 --> 01:59:00.290
no dicionário usando colchetes

01:59:00.290 --> 01:59:04.240
e recupere a definição em inglês também.

01:59:04.240 --> 01:59:06.770
Perguntas sobre isso?

01:59:06.770 --> 01:59:07.280
Sim?

01:59:07.280 --> 01:59:09.760
AUDIÊNCIA: É a forma como este código faz, conforme apresentado,

01:59:09.760 --> 01:59:11.744
dizendo que o Python tem [INAUDÍVEL]?

01:59:21.390 --> 01:59:22.890
DAVID MALAN: Uma pergunta muito boa.

01:59:22.890 --> 01:59:27.330
Então, para resumir, como o Python encontra esse nome nesse dicionário?

01:59:27.330 --> 01:59:31.110
É aqui que, honestamente, speller no p-set 5 é o que o Python tem a ver.

01:59:31.110 --> 01:59:34.215
Então você lutou, está lutando para implementar seu próprio feitiço

01:59:34.215 --> 01:59:36.090
verificador e implementando sua própria tabela de hash.

01:59:36.090 --> 01:59:39.210
E lembre-se que, na semana passada, o objetivo de uma tabela hash é,

01:59:39.210 --> 01:59:41.190
idealmente, obtenha acesso de tempo constante.

01:59:41.190 --> 01:59:45.435
Não algo linear, que é lento e ainda melhor do que algo logarítmico,

01:59:45.435 --> 01:59:47.400
como log base 2 de n.

01:59:47.400 --> 01:59:50.130
Python e as pessoas realmente inteligentes que o inventaram,

01:59:50.130 --> 01:59:53.310
eles escreveram o código que faz o possível para fornecer a você

01:59:53.310 --> 01:59:55.853
buscas em tempo constante de dicionários.

01:59:55.853 --> 01:59:58.020
E nem sempre terão sucesso, assim como você

01:59:58.020 --> 01:59:59.430
e seu próprio conjunto de problemas provavelmente vai

01:59:59.430 --> 02:00:01.805
ter algumas colisões de vez em quando e começar a ter

02:00:01.805 --> 02:00:03.440
cadeias de comprimento listas de palavras.

02:00:03.440 --> 02:00:05.940
Mas é aqui que, novamente, você se submete a outra pessoa, alguém

02:00:05.940 --> 02:00:07.800
mais inteligente que você, alguém com mais tempo que você

02:00:07.800 --> 02:00:09.270
para resolver esses problemas para você.

02:00:09.270 --> 02:00:11.490
E se você ler a documentação do Python, você

02:00:11.490 --> 02:00:13.650
veja que não garante tempo constante,

02:00:13.650 --> 02:00:15.990
mas vai, idealmente, otimizar a estrutura de dados

02:00:15.990 --> 02:00:19.320
para você chegar o mais rápido possível.

02:00:19.320 --> 02:00:22.690
E de todas as estruturas de dados como um dicionário,

02:00:22.690 --> 02:00:25.380
uma tabela de hash é, realmente, como o canivete suíço da computação

02:00:25.380 --> 02:00:28.260
porque apenas permite que você associe algo a outra coisa.

02:00:28.260 --> 02:00:30.510
E mesmo que continuemos focando em nomes e números,

02:00:30.510 --> 02:00:32.400
isso é uma coisa muito poderosa porque é

02:00:32.400 --> 02:00:34.230
mais poderoso do que listas e arrays, que

02:00:34.230 --> 02:00:35.910
são apenas números e algo mais.

02:00:35.910 --> 02:00:38.690
Agora, você pode ter qualquer tipo de relacionamento.

02:00:38.690 --> 02:00:39.270
Tudo bem.

02:00:39.270 --> 02:00:41.178
Deixe-me mostrar alguns outros exemplos antes de

02:00:41.178 --> 02:00:43.470
culminar com algumas técnicas mais poderosas em Python,

02:00:43.470 --> 02:00:45.000
graças às bibliotecas.

02:00:45.000 --> 02:00:49.480
Que tal esse problema que encontramos na semana 4, que foi isso.

02:00:49.480 --> 02:00:54.120
Deixe-me codificar um programa chamado, novamente, compare.py aqui, mas, desta vez,

02:00:54.120 --> 02:00:56.770
compare com strings e não com números.

02:00:56.770 --> 02:01:01.230
Deixe-me, por exemplo, pegar uma string do usuário chamada s.

02:01:01.230 --> 02:01:04.890
Apenas para fins de discussão, deixe-me pegar outra string do usuário

02:01:04.890 --> 02:01:07.830
chamado t para que possamos realmente fazer alguma comparação aqui.

02:01:07.830 --> 02:01:12.780
E se s é igual a t, vamos imprimir que eles são iguais.

02:01:12.780 --> 02:01:15.640
Caso contrário, vamos imprimir que são diferentes.

02:01:15.640 --> 02:01:17.910
Portanto, isso é muito semelhante ao que fizemos na semana 4.

02:01:17.910 --> 02:01:20.580
Mas na semana 4, lembre-se de que fizemos isso especificamente

02:01:20.580 --> 02:01:23.800
porque encontramos um problema.

02:01:23.800 --> 02:01:28.680
Por exemplo, se eu correr-- opa.

02:01:28.680 --> 02:01:34.970
Se eu correr... o que está acontecendo?

02:01:34.970 --> 02:01:40.396
[INAUDÍVEL] Vamos.

02:01:40.396 --> 02:01:41.390
Oh.

02:01:41.390 --> 02:01:41.890
OK.

02:01:41.890 --> 02:01:43.240
Uau OK.

02:01:43.240 --> 02:01:43.840
Longo dia.

02:01:43.840 --> 02:01:44.380
Tudo bem.

02:01:44.380 --> 02:01:48.670
Se eu executar o comando adequado, python de compare.py, vamos em frente

02:01:48.670 --> 02:01:53.785
e digite algo como "gato" em minúsculas, "gato" em minúsculas.

02:01:53.785 --> 02:01:56.110
E eles são os mesmos.

02:01:56.110 --> 02:01:59.565
Se, porém, eu fizer isso novamente com "cachorro" e "cachorro", eles serão iguais.

02:01:59.565 --> 02:02:01.690
E, claro, "gato" e "cachorro" são diferentes.

02:02:01.690 --> 02:02:06.430
Mas alguém se lembra, de duas semanas atrás, quando digitei meu nome duas vezes,

02:02:06.430 --> 02:02:08.680
ambas com letras maiúsculas idênticas.

02:02:08.680 --> 02:02:10.360
O que ele disse?

02:02:10.360 --> 02:02:13.390
Que eles eram, de fato, diferentes.

02:02:13.390 --> 02:02:14.110
E por que isso?

02:02:14.110 --> 02:02:16.660
Por que duas strings em C são diferentes, embora eu tenha digitado literalmente

02:02:16.660 --> 02:02:17.410
a mesma coisa?

02:02:20.040 --> 02:02:21.540
Dois lugares diferentes na memória.

02:02:21.540 --> 02:02:24.560
Assim, cada corda pode parecer a mesma, esteticamente, mas, é claro,

02:02:24.560 --> 02:02:25.852
foi armazenado em outro lugar na memória.

02:02:25.852 --> 02:02:29.970
E, no entanto, Python parece estar usando o operador de igualdade -

02:02:29.970 --> 02:02:33.510
iguais iguais - como você e eu esperaríamos, como humanos - na verdade

02:02:33.510 --> 02:02:38.510
comparando para nós char por char em cada uma dessas strings para [? qualidade. ?]

02:02:38.510 --> 02:02:41.610
Portanto, este é um recurso do Python, pois é mais fácil de fazer.

02:02:41.610 --> 02:02:42.210
E porque?

02:02:42.210 --> 02:02:44.627
Bem, isso deriva da realidade de que, em Python, há

02:02:44.627 --> 02:02:45.630
não são mais ponteiros.

02:02:45.630 --> 02:02:47.297
Não há gerenciamento de memória subjacente.

02:02:47.297 --> 02:02:50.400
Não cabe a você, agora, se preocupar com esses detalhes de nível inferior.

02:02:50.400 --> 02:02:52.960
A própria linguagem cuida disso para você.

02:02:52.960 --> 02:02:55.050
E assim, da mesma forma, se eu fizer isso e não

02:02:55.050 --> 02:02:57.510
peça ao usuário duas strings, mas apenas uma,

02:02:57.510 --> 02:02:59.370
e então, eu faço algo assim.

02:02:59.370 --> 02:03:05.550
Que tal dar a mim mesmo uma segunda variável t, defini-la igual a s.capitalize, que,

02:03:05.550 --> 02:03:08.040
nota, não é o mesmo que superior; capitalizar, por design,

02:03:08.040 --> 02:03:12.270
de acordo com a documentação do Python, apenas capitalizará a primeira letra para você--

02:03:12.270 --> 02:03:15.240
Agora posso imprimir, digamos, dois fstrings aqui -

02:03:15.240 --> 02:03:18.240
qual é o valor de s e, então, deixe-me imprimir,

02:03:18.240 --> 02:03:20.340
com outro fstring, qual é o valor de t.

02:03:20.340 --> 02:03:22.995
E lembre-se que, em C, isso era um problema

02:03:22.995 --> 02:03:26.820
porque se você capitalizar s e armazená-lo em t,

02:03:26.820 --> 02:03:29.670
acidentalmente colocamos s e t em maiúsculas.

02:03:29.670 --> 02:03:33.510
Mas, neste caso, em Python, quando realmente executo isso e digito "cat"

02:03:33.510 --> 02:03:37.770
Em todas as letras minúsculas, o s original permanece inalterado

02:03:37.770 --> 02:03:42.780
porque, quando eu uso maiúsculas na linha 3, isso é, de fato, capitalizando s.

02:03:42.780 --> 02:03:47.550
Mas está retornando uma cópia do resultado. Ele não pode mudar s em si

02:03:47.550 --> 02:03:50.385
porque, novamente, para esse termo técnico, s é imutável.

02:03:50.385 --> 02:03:53.265
Strings, uma vez que existam, não podem ser alteradas.

02:03:53.265 --> 02:03:58.590
Mas você pode retornar cópias e modificar cópias mutantes dessas mesmas strings.

02:03:58.590 --> 02:04:02.040
Então, resumindo, todas aquelas dores de cabeça que encontramos na semana 4

02:04:02.040 --> 02:04:05.070
agora são resolvidos, realmente, da maneira que você pode esperar.

02:04:05.070 --> 02:04:07.500
E aqui está outro que abordamos na semana 4,

02:04:07.500 --> 02:04:09.660
com o líquido colorido em copos.

02:04:09.660 --> 02:04:12.150
Deixe-me codificar um programa chamado swap.py.

02:04:12.150 --> 02:04:16.690
E em swap.py, deixe-me definir x igual a 1, y igual a 2.

02:04:16.690 --> 02:04:18.690
E então, deixe-me imprimir um fstring aqui.

02:04:18.690 --> 02:04:24.360
Então que tal x é essa vírgula y é aquilo.

02:04:24.360 --> 02:04:27.735
E então, deixe-me fazer isso duas vezes, apenas para fins de demonstração.

02:04:27.735 --> 02:04:31.005
E aqui, lembre-se de que tivemos que criar uma função de troca.

02:04:31.005 --> 02:04:33.630
Mas então, tivemos que passá-lo por referência com o e comercial.

02:04:33.630 --> 02:04:38.460
E oh meu Deus, isso foi o pico de complexidade em C. Bem,

02:04:38.460 --> 02:04:41.100
se você quiser trocar x e y em Python, você

02:04:41.100 --> 02:04:43.830
poderia fazer x vírgula y igual a y vírgula x.

02:04:43.830 --> 02:04:49.020
E agora, python de swap.py.

02:04:49.020 --> 02:04:50.130
E lá vamos nós.

02:04:50.130 --> 02:04:51.840
Tudo isso é tratado para você.

02:04:51.840 --> 02:04:56.350
É como um jogo de shell sem nem mesmo uma variável temporária em mente.

02:04:56.350 --> 02:04:58.290
Então, o que mais podemos fazer aqui?

02:04:58.290 --> 02:05:00.870
Que tal alguns blocos de construção finais?

02:05:00.870 --> 02:05:03.330
E estes dizem respeito, agora, a arquivos daquela semana 4.

02:05:03.330 --> 02:05:07.710
Suponha que eu queira salvar alguns nomes e números em um arquivo CSV--

02:05:07.710 --> 02:05:11.080
Valores separados por vírgula, que é como uma planilha muito leve.

02:05:11.080 --> 02:05:15.300
Bem, primeiro, deixe-me criar um arquivo phonebook.csv

02:05:15.300 --> 02:05:19.458
que tem apenas o número da vírgula do nome como a primeira linha lá.

02:05:19.458 --> 02:05:21.750
Mas depois disso, vou prosseguir agora e codificar

02:05:21.750 --> 02:05:25.170
um programa phonebook.py que realmente permite

02:05:25.170 --> 02:05:27.040
me para adicionar coisas a esta lista telefônica.

02:05:27.040 --> 02:05:31.020
Então deixe-me dividir minha tela aqui para que possamos ver o antigo e o novo.

02:05:31.020 --> 02:05:34.050
E aqui embaixo, no meu código para phonebook.py,

02:05:34.050 --> 02:05:36.360
nesta nova e melhorada versão, vou

02:05:36.360 --> 02:05:40.020
para realmente importar toda uma outra biblioteca, esta chamada CSV.

02:05:40.020 --> 02:05:42.885
E aqui também, especialmente para pessoas em ciência de dados e afins,

02:05:42.885 --> 02:05:46.500
gosto muito de poder manipular arquivos e dados que podem muito bem ser

02:05:46.500 --> 02:05:48.060
armazenados em planilhas ou CSVs--

02:05:48.060 --> 02:05:51.510
Valores separados por vírgula, que vimos brevemente na semana 4.

02:05:51.510 --> 02:05:53.670
Em phonebook.py, então, basta apenas

02:05:53.670 --> 02:05:57.348
importar CSV depois de ler a documentação, portanto

02:05:57.348 --> 02:05:59.265
porque isso vai me dar funcionalidade

02:05:59.265 --> 02:06:02.150
no código relacionado a arquivos CSV.

02:06:02.150 --> 02:06:04.950
Então aqui está como eu poderia abrir um arquivo em Python.

02:06:04.950 --> 02:06:08.340
Eu literalmente chamo de aberto-- não está aberto agora; é apenas aberto--

02:06:08.340 --> 02:06:10.860
e abro este arquivo chamado phonebook.csv.

02:06:10.860 --> 02:06:13.470
E assim como em C, vou abri-lo no modo de acréscimo -

02:06:13.470 --> 02:06:15.930
não está certo, onde mudaria tudo.

02:06:15.930 --> 02:06:18.660
Eu quero acrescentar uma nova linha de cada vez.

02:06:18.660 --> 02:06:21.750
Depois disso, quero obter, talvez, um nome do usuário.

02:06:21.750 --> 02:06:25.350
Então, vamos solicitar ao usuário alguma entrada para seu nome.

02:06:25.350 --> 02:06:27.255
E então, vamos solicitar ao usuário um número,

02:06:27.255 --> 02:06:31.060
também, usando entrada solicitando número.

02:06:31.060 --> 02:06:31.560
Tudo bem.

02:06:31.560 --> 02:06:33.602
E agora, isso é um pouco enigmático, e você só

02:06:33.602 --> 02:06:35.050
saiba disso pela documentação.

02:06:35.050 --> 02:06:38.370
Mas se você quiser gravar linhas em um arquivo CSV

02:06:38.370 --> 02:06:41.850
que você pode, então, visualizar no Excel ou similar, você pode fazer isso--

02:06:41.850 --> 02:06:45.060
dê-me uma variável chamada escritor-- mas eu poderia chamá-la de qualquer coisa que eu quisesse.

02:06:45.060 --> 02:06:50.760
Deixe-me usar uma função csv.writer que vem com esta biblioteca CSV,

02:06:50.760 --> 02:06:51.885
passando no arquivo.

02:06:51.885 --> 02:06:56.070
Isso é como dizer, ei, Python, trate este arquivo aberto como um arquivo CSV

02:06:56.070 --> 02:06:59.340
para que as coisas sejam separadas por vírgulas e bem formatadas

02:06:59.340 --> 02:07:00.515
em linhas e colunas.

02:07:00.515 --> 02:07:02.100
Agora, eu vou fazer isso--

02:07:02.100 --> 02:07:04.030
use esse gravador para escrever uma linha.

02:07:04.030 --> 02:07:05.280
Bem, o que eu quero escrever?

02:07:05.280 --> 02:07:07.380
Eu quero escrever uma pequena lista--

02:07:07.380 --> 02:07:10.200
ou seja, o nome atual e o número atual--

02:07:10.200 --> 02:07:14.790
a esse arquivo, mas não quero usar fprintf e %s e todas essas coisas

02:07:14.790 --> 02:07:16.440
que poderíamos ter tido no passado.

02:07:16.440 --> 02:07:19.030
E agora, eu só quero fechar o arquivo.

02:07:19.030 --> 02:07:20.410
Deixe-me reabrir meu terminal.

02:07:20.410 --> 02:07:26.102
Deixe-me executar o python de phonebook.py e digite David e, em seguida,

02:07:26.102 --> 02:07:30.190
+1-949-468-2750 e, cruzando os dedos,

02:07:30.190 --> 02:07:33.430
observando o CSV real no canto superior esquerdo.

02:07:33.430 --> 02:07:35.737
Meu código acabou de me adicionar ao arquivo.

02:07:35.737 --> 02:07:37.570
E se eu fosse executá-lo novamente, por exemplo,

02:07:37.570 --> 02:07:41.770
com Carter e +1-617-495-1000, cruzando meus dedos novamente--

02:07:41.770 --> 02:07:42.820
nós atualizamos o arquivo.

02:07:42.820 --> 02:07:46.150
E acontece que agora existe um código através do qual posso até ler esse arquivo.

02:07:46.150 --> 02:07:48.850
Mas posso, primeiro, apertar isso, só para você ver.

02:07:48.850 --> 02:07:52.720
Acontece que, em Python, é muito comum abrir arquivos e fechá-los.

02:07:52.720 --> 02:07:54.610
Os seres humanos cometem erros e muitas vezes esquecem

02:07:54.610 --> 02:07:58.477
para fechar arquivos, o que pode, então, acabar usando mais memória do que você pretende.

02:07:58.477 --> 02:08:00.310
Então você pode, alternativamente, fazer isso em Python

02:08:00.310 --> 02:08:03.310
para que você não precise se preocupar em fechar arquivos.

02:08:03.310 --> 02:08:05.920
Você pode usar essa palavra-chave.

02:08:05.920 --> 02:08:09.100
Você pode dizer com a abertura deste arquivo

02:08:09.100 --> 02:08:13.420
como uma variável chamada arquivo, faça todos os procedimentos abaixo.

02:08:13.420 --> 02:08:15.470
Então, estou recuando a maior parte do meu código.

02:08:15.470 --> 02:08:18.430
Estou usando essa nova palavra-chave específica do Python chamada largura.

02:08:18.430 --> 02:08:22.330
E isso é apenas uma questão de dizer, com a seguinte abertura do arquivo,

02:08:22.330 --> 02:08:26.120
faça as próximas quatro linhas de código e, em seguida, feche-o automaticamente para mim

02:08:26.120 --> 02:08:27.370
no final do recuo.

02:08:27.370 --> 02:08:31.480
É uma otimização menor, mas esta, novamente, é a maneira pythônica

02:08:31.480 --> 02:08:33.250
para fazer as coisas, em vez disso.

02:08:33.250 --> 02:08:34.720
De que outra forma eu poderia fazer isso também?

02:08:34.720 --> 02:08:38.860
Bem, acontece que o código que escrevi aqui-- na linha 9,

02:08:38.860 --> 02:08:40.630
especialmente-- é um pouco frágil.

02:08:40.630 --> 02:08:44.350
Se alguém abrir esta planilha -- o arquivo CSV no Excel,

02:08:44.350 --> 02:08:46.000
Planilhas do Google, Números da Apple--

02:08:46.000 --> 02:08:49.390
e talvez mova as colunas apenas porque, talvez, eles estejam se preocupando.

02:08:49.390 --> 02:08:52.790
Eles o salvaram e não percebem que, agora, mudaram minhas suposições.

02:08:52.790 --> 02:08:55.120
Não quero, necessariamente, escrever nome e número

02:08:55.120 --> 02:08:58.360
sempre nessa ordem porque e se alguém estragar tudo e virar esses dois

02:08:58.360 --> 02:09:01.040
colunas literalmente arrastando e soltando?

02:09:01.040 --> 02:09:03.640
Acontece que, em vez de usar uma lista aqui,

02:09:03.640 --> 02:09:06.890
podemos usar outro recurso desta biblioteca, como segue.

02:09:06.890 --> 02:09:09.520
Em vez de usar um escritor, há algo

02:09:09.520 --> 02:09:11.530
chamado de redator de dicionário ou redator de ditado

02:09:11.530 --> 02:09:14.140
que leva o mesmo argumento como entrada--

02:09:14.140 --> 02:09:15.580
o arquivo que é aberto.

02:09:15.580 --> 02:09:18.070
Mas agora, a única diferença aqui é que você

02:09:18.070 --> 02:09:25.030
precisa dizer a este redator de dicionário que seus nomes de campo são nome e número.

02:09:25.030 --> 02:09:27.370
E deixe-me fechar o CSV aqui.

02:09:27.370 --> 02:09:32.140
Nome e número são os nomes dos campos, as colunas neste arquivo CSV.

02:09:32.140 --> 02:09:34.450
E quando chegar a hora de escrever uma nova linha,

02:09:34.450 --> 02:09:37.750
a sintaxe aqui vai ser um pouco mais feia, mas é só um dicionário.

02:09:37.750 --> 02:09:40.120
O nome que eu quero escrever no dicionário

02:09:40.120 --> 02:09:42.310
será qualquer nome que o humano digitar.

02:09:42.310 --> 02:09:45.790
O número que desejo gravar no arquivo CSV

02:09:45.790 --> 02:09:48.550
vai ser qualquer número que o humano digitou.

02:09:48.550 --> 02:09:51.010
Mas o que é diferente, agora, sobre este código é,

02:09:51.010 --> 02:09:55.960
simplesmente usando um escritor de dicionário aqui em vez do escritor genérico,

02:09:55.960 --> 02:10:00.640
agora, as colunas podem estar nesta ordem ou nesta ordem ou em qualquer ordem.

02:10:00.640 --> 02:10:03.010
E o redator do dicionário vai descobrir,

02:10:03.010 --> 02:10:06.557
com base na primeira linha de texto nesse CSV, onde colocar o nome,

02:10:06.557 --> 02:10:07.390
onde colocar número.

02:10:07.390 --> 02:10:08.883
Então, se você virar, não é grande coisa.

02:10:08.883 --> 02:10:11.050
Vai notar, oh, espere, as colunas mudaram.

02:10:11.050 --> 02:10:14.330
E vai inserir as colunas corretamente.

02:10:14.330 --> 02:10:18.970
Então, novamente, outro recurso mais poderoso que permite

02:10:18.970 --> 02:10:22.750
concentre-se no trabalho real, em vez de realmente obter

02:10:22.750 --> 02:10:27.250
amarrado nas ervas daninhas de escrever código como este, caso contrário.

02:10:27.250 --> 02:10:30.440
Dúvidas sobre esta também?

02:10:30.440 --> 02:10:33.520
Mas o que faremos, agora, é fechar o círculo

02:10:33.520 --> 02:10:37.180
a alguns dos exemplos mais sofisticados com os quais começamos,

02:10:37.180 --> 02:10:40.855
e eu vou voltar para o meu próprio laptop Mac

02:10:40.855 --> 02:10:43.743
aqui, onde tenho minha própria janela de terminal funcionando,

02:10:43.743 --> 02:10:46.285
e eu só apresentaria algumas bibliotecas finais

02:10:46.285 --> 02:10:49.788
que realmente falam sobre o quão poderoso o Python pode ser

02:10:49.788 --> 02:10:51.580
e com que rapidez você pode começar a trabalhar.

02:10:51.580 --> 02:10:54.330
Para ser justo, não é possível fazer todas essas coisas na nuvem,

02:10:54.330 --> 02:10:57.337
como em espaços de código, porque você precisa acessar seus próprios alto-falantes

02:10:57.337 --> 02:10:58.420
ou microfone ou similar.

02:10:58.420 --> 02:11:01.090
É por isso que estou fazendo isso no meu próprio Mac, aqui.

02:11:01.090 --> 02:11:05.680
Mas deixe-me ir em frente e abrir um programa chamado speech.py.

02:11:05.680 --> 02:11:07.300
E não estou usando VS Code aqui.

02:11:07.300 --> 02:11:10.150
Estou usando um programa chamado VI que é totalmente baseado em janela de terminal.

02:11:10.150 --> 02:11:13.105
Mas vai me permitir, por exemplo, importar o Python

02:11:13.105 --> 02:11:16.120
biblioteca de texto para fala versão 3.

02:11:16.120 --> 02:11:18.790
Vou me dar uma variável chamada engine que é

02:11:18.790 --> 02:11:21.610
vai ser definido igual ao text to speech do Python

02:11:21.610 --> 02:11:26.350
3 bibliotecas método init, que vai apenas inicializar esta biblioteca que

02:11:26.350 --> 02:11:28.090
refere-se ao texto para fala.

02:11:28.090 --> 02:11:32.410
Vou, então, usar a função say do motor para dizer algo

02:11:32.410 --> 02:11:35.260
tipo, que tal, olá mundo vírgula.

02:11:35.260 --> 02:11:39.850
E então, como minha última linha, direi engine.runAndWait, com letras maiúsculas

02:11:39.850 --> 02:11:44.690
como tal, para dizer ao meu programa, agora, para executar esse discurso e esperar até que seja feito.

02:11:44.690 --> 02:11:45.190
Tudo bem.

02:11:45.190 --> 02:11:46.540
Vou salvar este arquivo.

02:11:46.540 --> 02:11:49.110
Vou executar o python do speech.py.

02:11:49.110 --> 02:11:52.357
E vou cruzar os dedos, como sempre, e...

02:11:52.357 --> 02:11:53.440
INTÉRPRETE: Olá, mundo.

02:11:53.440 --> 02:11:54.398
DAVID MALAN: Tudo bem.

02:11:54.398 --> 02:11:57.130
Então agora, eu tenho um programa que está realmente sintetizando a fala

02:11:57.130 --> 02:11:58.570
usando uma biblioteca como esta.

02:11:58.570 --> 02:12:01.285
Como posso, agora, modificar isso para ser um pouco mais interessante?

02:12:01.285 --> 02:12:02.690
Bem, que tal isso?

02:12:02.690 --> 02:12:05.050
Deixe-me prosseguir e solicitar o nome do usuário,

02:12:05.050 --> 02:12:08.680
como fizemos várias vezes aqui, usando a função de nome integrada do Python.

02:12:08.680 --> 02:12:11.665
E agora, deixe-me usar uma string de formato em conjunto

02:12:11.665 --> 02:12:14.980
com esta biblioteca, interpolando o valor de name ali.

02:12:14.980 --> 02:12:18.460
E-- pelo menos, se meu nome for foneticamente pronunciável--

02:12:18.460 --> 02:12:23.587
vamos executar o python of speech.py, digitar meu nome e...

02:12:23.587 --> 02:12:24.670
INTÉRPRETE: Olá, David.

02:12:24.670 --> 02:12:25.445
DAVID MALAN: OK.

02:12:25.445 --> 02:12:27.640
É uma escolha estranha de inflexão, mas estamos

02:12:27.640 --> 02:12:30.475
começando a sintetizar a voz, não muito diferente da Siri ou do Google Assistant

02:12:30.475 --> 02:12:32.050
ou Alexa ou algo semelhante.

02:12:32.050 --> 02:12:36.130
Agora, podemos, talvez, fazer algo um pouco mais avançado também.

02:12:36.130 --> 02:12:39.310
Além de sintetizar a fala dessa maneira,

02:12:39.310 --> 02:12:43.270
poderíamos sintetizar, por exemplo, um gráfico real.

02:12:43.270 --> 02:12:45.740
Deixe-me ir em frente, agora, e fazer algo assim.

02:12:45.740 --> 02:12:48.760
Deixe-me criar um programa chamado qr.py.

02:12:48.760 --> 02:12:50.890
Vou prosseguir e importar uma biblioteca chamada

02:12:50.890 --> 02:12:54.860
OS, que fornece acesso à funcionalidade relacionada ao sistema operacional em Python.

02:12:54.860 --> 02:12:56.860
Vou importar uma biblioteca pré-instalada

02:12:56.860 --> 02:12:59.830
chamado qrcode, que é um código de barras bidimensional que você

02:12:59.830 --> 02:13:01.300
poderia ter visto no mundo real.

02:13:01.300 --> 02:13:03.715
Vou seguir em frente e criar uma variável de imagem usando

02:13:03.715 --> 02:13:08.260
função make desta biblioteca qrcode, que, de acordo com sua documentação,

02:13:08.260 --> 02:13:10.365
leva um URL, como um dos próprios vídeos do CS50.

02:13:10.365 --> 02:13:23.003
Então faremos isso com youtu.be/xvF2joSPgG0.

02:13:23.003 --> 02:13:24.670
Então, esperançosamente, essa é a palestra certa.

02:13:24.670 --> 02:13:27.160
E agora, temos img.save, que vai permitir

02:13:27.160 --> 02:13:30.130
me para criar um arquivo chamado qr.ping.

02:13:30.130 --> 02:13:33.460
Pense agora no conjunto de problemas 4 e em como era doloroso salvar arquivos.

02:13:33.460 --> 02:13:36.940
Vamos apenas usar a função salvar, agora, em Python e salvar isso como um arquivo PNG--

02:13:36.940 --> 02:13:38.260
Gráfico de rede portátil.

02:13:38.260 --> 02:13:43.420
E então, por último, vamos abrir com o comando open qr.png

02:13:43.420 --> 02:13:46.120
no meu Mac para que, com sorte, isso seja aberto automaticamente.

02:13:46.120 --> 02:13:46.660
Tudo bem.

02:13:46.660 --> 02:13:49.300
Vou seguir em frente e verificar novamente minha sintaxe aqui

02:13:49.300 --> 02:13:51.280
para que eu não tenha cometido nenhum erro.

02:13:51.280 --> 02:13:54.235
Vou seguir em frente e executar o python de qr.py.

02:13:54.235 --> 02:13:55.810
Digitar.

02:13:55.810 --> 02:13:57.223
Isso abre isso.

02:13:57.223 --> 02:13:58.390
Deixe-me ir em frente e aumentar o zoom.

02:13:58.390 --> 02:14:03.750
Se você tiver um telefone à mão e quiser escanear este código aqui,

02:14:03.750 --> 02:14:07.131
seja pessoalmente ou online--

02:14:07.131 --> 02:14:08.095
Peço desculpas.

02:14:08.095 --> 02:14:09.130
Você não vai gostar.

02:14:11.640 --> 02:14:12.140
Incrível!

02:14:12.140 --> 02:14:13.600
OK.

02:14:13.600 --> 02:14:17.230
E, por último, deixe-me voltar ao nosso exemplo de fala

02:14:17.230 --> 02:14:21.400
aqui, crie um final final aqui em nossos momentos finais.

02:14:21.400 --> 02:14:26.060
E que tal dizermos algo como "Isso foi CS50", assim.

02:14:26.060 --> 02:14:27.087
Vamos em frente, aqui.

02:14:27.087 --> 02:14:28.795
Conserte minha capitalização, apenas para limpeza.

02:14:28.795 --> 02:14:29.878
Vamos nos livrar do nome.

02:14:29.878 --> 02:14:33.840
E agora, com nosso floreio final e sua introdução ao Python equipada--

02:14:33.840 --> 02:14:35.230
aqui vamos nós--

02:14:35.230 --> 02:14:36.535
INTÉRPRETE: Isso foi CS50.

02:14:36.535 --> 02:14:37.000
DAVID MALAN: Tudo bem.

02:14:37.000 --> 02:14:38.000
Nos vemos na próxima vez.

02:14:38.000 --> 02:14:39.460
[APLAUSOS]

02:14:41.860 --> 02:14:45.210
[MÚSICA, TOCANDO]