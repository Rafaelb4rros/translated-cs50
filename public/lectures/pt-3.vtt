WEBVTT

00:00:00.000 --> 00:00:02.982
[ROLO DE FILME]

00:00:02.982 --> 00:00:06.461
[MÚSICA, TOCANDO]

00:01:12.660 --> 00:01:15.420
DAVID MALAN: Tudo bem, aqui é CS50.

00:01:15.420 --> 00:01:19.200
E esta é a semana 3, onde vamos dar uma olhada para trás, na verdade

00:01:19.200 --> 00:01:21.400
na semana 0, onde começamos.

00:01:21.400 --> 00:01:24.930
E na semana 0, lembre-se de que tudo foi muito intuitivo, de certa forma.

00:01:24.930 --> 00:01:28.000
Falamos não apenas sobre representação de informações, mas sobre algoritmos.

00:01:28.000 --> 00:01:30.450
E conversamos sobre rasgar uma lista telefônica repetidas vezes.

00:01:30.450 --> 00:01:32.860
E isso de alguma forma nos levou a uma solução melhor.

00:01:32.860 --> 00:01:35.888
Mas hoje tentaremos começar a formalizar algumas dessas ideias

00:01:35.888 --> 00:01:38.430
e capturando algumas dessas mesmas ideias não em pseudocódigo apenas

00:01:38.430 --> 00:01:41.650
ainda, mas no código real também.

00:01:41.650 --> 00:01:45.210
Mas também vamos considerar a eficiência desses algoritmos,

00:01:45.210 --> 00:01:48.372
como quão bons, quão bem projetados nossos algoritmos realmente são.

00:01:48.372 --> 00:01:50.580
E se você se lembra, quando fizemos o exemplo da lista telefônica

00:01:50.580 --> 00:01:53.940
em que primeiro tive um algoritmo pesquisando uma página por vez,

00:01:53.940 --> 00:01:56.460
e depois a segunda, duas páginas de cada vez, e a terceira,

00:01:56.460 --> 00:01:58.590
começou a rasgar a coisa ao meio, lembre-se

00:01:58.590 --> 00:02:01.900
que nós, com um aceno de mão, meio que analisamos da seguinte maneira.

00:02:01.900 --> 00:02:05.070
Propusemos que se o eixo x aqui é o tamanho do problema,

00:02:05.070 --> 00:02:09.120
como o número de páginas em uma lista telefônica, e o eixo y é o tempo necessário

00:02:09.120 --> 00:02:11.430
resolver o problema em segundos, minutos,

00:02:11.430 --> 00:02:13.363
lágrimas de página, seja qual for a sua unidade de medida,

00:02:13.363 --> 00:02:16.530
lembre-se que o primeiro algoritmo, que é a linha reta tal que se você

00:02:16.530 --> 00:02:19.620
tivesse n páginas na lista telefônica, poderia ter esta inclinação de n--

00:02:19.620 --> 00:02:23.280
e há essa relação de um para um entre páginas e lágrimas.

00:02:23.280 --> 00:02:27.000
Duas páginas por vez, é claro, era duas vezes mais rápido, mas ainda assim muito

00:02:27.000 --> 00:02:30.000
a mesma forma, a linha amarela aqui indicando que sim,

00:02:30.000 --> 00:02:33.570
é n sobre 2, talvez mais 1 se você tiver que dobrar de volta, como discutimos.

00:02:33.570 --> 00:02:36.840
Mas ainda é fundamentalmente o mesmo algoritmo um

00:02:36.840 --> 00:02:38.370
ou duas páginas de cada vez.

00:02:38.370 --> 00:02:41.760
Mas o terceiro algoritmo, lembre-se, era este aqui em verde,

00:02:41.760 --> 00:02:45.660
onde chamamos de logarítmico em termos de quão rápido ou lento era.

00:02:45.660 --> 00:02:48.235
E, de fato, a implicação desse algoritmo

00:02:48.235 --> 00:02:50.610
foi que poderíamos até dobrar o tamanho da lista telefônica,

00:02:50.610 --> 00:02:53.280
e não é grande coisa - um rasgo de página adicional,

00:02:53.280 --> 00:02:55.990
e damos mais uma mordida em 1.000 páginas da lista telefônica.

00:02:55.990 --> 00:02:58.890
Então, hoje, vamos revisitar algumas dessas ideias, formalizá-las um pouco,

00:02:58.890 --> 00:03:01.530
mas também traduzir alguns deles, em última análise, para o código.

00:03:01.530 --> 00:03:03.690
E tudo isso agora é possível porque nós

00:03:03.690 --> 00:03:06.060
ter essa compreensão de nível inferior, talvez, do que é

00:03:06.060 --> 00:03:07.600
realmente dentro do seu computador.

00:03:07.600 --> 00:03:10.170
Isso, é claro, é a RAM ou memória do seu computador.

00:03:10.170 --> 00:03:12.720
E lembre-se que se começarmos a abstrair isso,

00:03:12.720 --> 00:03:15.420
a memória do seu computador é realmente apenas uma grade de bytes.

00:03:15.420 --> 00:03:17.730
Na verdade, não precisamos mais olhar para o hardware.

00:03:17.730 --> 00:03:21.270
E olhamos para uma grade de bytes como esta, em que cada um desses bytes

00:03:21.270 --> 00:03:26.700
pode ser usado para armazenar um char, um int, um long ou até mesmo uma string inteira,

00:03:26.700 --> 00:03:27.460
em que.

00:03:27.460 --> 00:03:30.117
Mas vamos nos concentrar talvez apenas em um subconjunto disso

00:03:30.117 --> 00:03:31.950
porque na semana passada, é claro, enfatizamos,

00:03:31.950 --> 00:03:34.830
realmente, arrays, armazenando coisas em arrays.

00:03:34.830 --> 00:03:38.140
E isso nos permitiu começar a armazenar strings inteiras, sequências

00:03:38.140 --> 00:03:40.470
de caracteres e até matrizes de números inteiros

00:03:40.470 --> 00:03:44.770
se quiséssemos ter vários e não apenas variáveis ​​também.

00:03:44.770 --> 00:03:48.850
Mas o problema é que se você olhar dentro de um array na memória do computador--

00:03:48.850 --> 00:03:51.450
e, por exemplo, suponha que esses inteiros aqui sejam armazenados -

00:03:51.450 --> 00:03:53.850
é muito fácil para nós, humanos, dar uma olhada nisso

00:03:53.850 --> 00:03:55.698
e encontre imediatamente o número 50.

00:03:55.698 --> 00:03:57.990
Você meio que tem essa visão panorâmica de onde você está

00:03:57.990 --> 00:03:59.700
sentado de tudo na tela.

00:03:59.700 --> 00:04:02.500
E então é bastante óbvio como você chega ao número 50.

00:04:02.500 --> 00:04:04.710
Mas no mundo dos computadores, é claro,

00:04:04.710 --> 00:04:06.720
Acontece que isso é hardware.

00:04:06.720 --> 00:04:10.440
E os computadores, para os propósitos de hoje, só podem fazer uma coisa de cada vez.

00:04:10.440 --> 00:04:14.820
Eles não podem simplesmente pegar tudo e encontrar instantaneamente um número como 50.

00:04:14.820 --> 00:04:17.130
Então, talvez uma metáfora decente seja considerar

00:04:17.130 --> 00:04:20.010
a matriz de memória dentro do seu computador

00:04:20.010 --> 00:04:22.500
realmente é uma sequência de portas fechadas.

00:04:22.500 --> 00:04:25.860
E se o computador quiser encontrar algum valor em uma matriz,

00:04:25.860 --> 00:04:29.970
tem que fazer o equivalente digital de abrir cada uma dessas portas uma

00:04:29.970 --> 00:04:30.730
de uma vez.

00:04:30.730 --> 00:04:32.410
Agora, como o código pode fazer isso?

00:04:32.410 --> 00:04:35.610
Bem, é claro, introduzimos índices ou índices na semana passada,

00:04:35.610 --> 00:04:39.900
por meio do qual nós, por convenção, chamamos o primeiro elemento de um array de localização 0,

00:04:39.900 --> 00:04:44.490
o segundo local 1, o terceiro local 2 e assim por diante - o chamado 0

00:04:44.490 --> 00:04:45.150
indexado.

00:04:45.150 --> 00:04:48.300
E isso nos permitiu conectar esse mundo conceitual do que é

00:04:48.300 --> 00:04:51.510
acontecendo na memória com o código real, porque agora temos este colchete

00:04:51.510 --> 00:04:55.710
sintaxe através da qual poderíamos ir em busca de algo, se assim o quiséssemos.

00:04:55.710 --> 00:04:59.760
E acontece que, se eu agora pintar esses vermelhos em vez de amarelos,

00:04:59.760 --> 00:05:02.970
parece que temos uma boa metáfora física aqui

00:05:02.970 --> 00:05:07.170
substituindo o que seria a matriz de memória de um computador

00:05:07.170 --> 00:05:10.390
se, por exemplo, você estiver armazenando sete números assim.

00:05:10.390 --> 00:05:13.710
E assim, hoje começamos com uma olhada em um tipo específico de algoritmo.

00:05:13.710 --> 00:05:14.910
Isso é para pesquisar.

00:05:14.910 --> 00:05:16.270
A busca está em todo lugar.

00:05:16.270 --> 00:05:19.900
Todos nós provavelmente já acessamos o google.com ou algum equivalente

00:05:19.900 --> 00:05:21.090
várias vezes por dia.

00:05:21.090 --> 00:05:24.120
E obter respostas rapidamente é o que empresas como o Google

00:05:24.120 --> 00:05:25.110
são realmente bons.

00:05:25.110 --> 00:05:26.700
Então, como eles estão fazendo isso?

00:05:26.700 --> 00:05:29.882
Como eles estão armazenando informações na memória dos computadores?

00:05:29.882 --> 00:05:31.590
Bem, vamos considerar o que isso realmente é.

00:05:31.590 --> 00:05:34.500
É realmente apenas um problema, pois estava na semana 0.

00:05:34.500 --> 00:05:36.420
A entrada, porém, para o problema, por enquanto,

00:05:36.420 --> 00:05:38.253
pode ser este conjunto de sete armários.

00:05:38.253 --> 00:05:40.920
Essa é a entrada do problema, dentro da qual há um número.

00:05:40.920 --> 00:05:45.060
E talvez para simplificar agora, queremos apenas um sim/não, uma resposta verdadeiro/falso--

00:05:45.060 --> 00:05:46.860
um bool, isto é,

00:05:46.860 --> 00:05:51.250
de se algum número como 50 está ou não nessa matriz.

00:05:51.250 --> 00:05:52.680
Não é tão sofisticado quanto o Google.

00:05:52.680 --> 00:05:55.500
Isso não apenas diz que sim, temos resultados de pesquisa.

00:05:55.500 --> 00:05:57.300
Na verdade, fornece os resultados da pesquisa.

00:05:57.300 --> 00:05:59.520
Mas, agora vamos mantê-lo simples e apenas imprimir

00:05:59.520 --> 00:06:02.070
como parte deste problema sim ou não, verdadeiro ou falso,

00:06:02.070 --> 00:06:06.090
encontramos o número que estamos procurando, dado uma entrada como essa matriz.

00:06:06.090 --> 00:06:09.930
Mas acontece que dentro dessa caixa preta para a qual sempre voltamos,

00:06:09.930 --> 00:06:12.385
há todos os tipos de algoritmos possíveis.

00:06:12.385 --> 00:06:15.010
E conversamos sobre isso em alto nível conceitualmente na Semana 0

00:06:15.010 --> 00:06:15.860
com a lista telefónica.

00:06:15.860 --> 00:06:19.360
Mas hoje, vamos considerá-lo um pouco mais concretamente

00:06:19.360 --> 00:06:22.648
por meio de um jogo com o qual alguns de vocês podem ter crescido, ou seja, Banco Imobiliário.

00:06:22.648 --> 00:06:24.940
E assim por trás dessas portas, ao que parece, estará escondido

00:06:24.940 --> 00:06:26.800
algumas denominações de dinheiro de monopólio.

00:06:26.800 --> 00:06:28.690
Mas para isso, contamos agora com dois voluntários.

00:06:28.690 --> 00:06:30.483
Se você gostaria de cumprimentar o mundo?

00:06:30.483 --> 00:06:31.525
JACKSON: Oi, eu sou Jackson.

00:06:35.440 --> 00:06:37.220
STEPHANIE: Oi, meu nome é Stephanie.

00:06:37.220 --> 00:06:38.410
DAVID MALAN: E você quer dizer alguma coisinha

00:06:38.410 --> 00:06:40.570
sobre vocês mesmos - anos, casa, dormitório?

00:06:40.570 --> 00:06:43.030
STEPHANIE: Estou no primeiro ano morando em Matthews.

00:06:43.030 --> 00:06:43.780
DAVID MALAN: Legal.

00:06:43.780 --> 00:06:45.580
JACKSON: E estou no primeiro ano no Canadá.

00:06:45.580 --> 00:06:46.330
DAVID MALAN: Legal.

00:06:46.330 --> 00:06:48.670
Bem, bem-vindos aos nossos dois voluntários.

00:06:48.670 --> 00:06:50.710
Então, por que não fazemos isso?

00:06:50.710 --> 00:06:54.460
Um de vocês gostaria de oferecer o outro para ir primeiro?

00:06:54.460 --> 00:06:55.510
STEPHANIE: Eu vou.

00:06:55.510 --> 00:06:56.560
DAVID MALAN: OK.

00:06:56.560 --> 00:06:58.300
Tudo bem, então Stephanie acorda primeiro.

00:06:58.300 --> 00:07:02.560
E atrás de uma dessas portas aqui, escondemos o dinheiro do monopólio 50.

00:07:02.560 --> 00:07:04.180
E então gostaríamos que você encontrasse os 50.

00:07:04.180 --> 00:07:06.490
Não lhe diremos mais nada sobre os armários.

00:07:06.490 --> 00:07:08.900
Mas gostaríamos que você executasse um determinado algoritmo.

00:07:08.900 --> 00:07:11.020
Na verdade, vou dar a vocês um pseudocódigo para isso.

00:07:11.020 --> 00:07:12.770
E eu vou te dar o nome para isso.

00:07:12.770 --> 00:07:13.900
Chama-se pesquisa linear.

00:07:13.900 --> 00:07:15.855
E como o nome indica, você é praticamente

00:07:15.855 --> 00:07:17.980
vai acabar andando em uma espécie de linha reta.

00:07:17.980 --> 00:07:19.220
Mas como você vai fazer isso?

00:07:19.220 --> 00:07:21.520
Bem, deixe-me propor que em um momento, seu primeiro passo

00:07:21.520 --> 00:07:23.170
será pensar como um loop.

00:07:23.170 --> 00:07:27.280
Para cada porta da esquerda para a direita, o que queremos que você faça em cada iteração?

00:07:27.280 --> 00:07:31.528
Bem, se 50 está atrás daquela porta, então queremos

00:07:31.528 --> 00:07:33.070
para ir em frente e fazer com que você retorne true.

00:07:33.070 --> 00:07:35.860
E levante os 50 com orgulho, se quiser, para o grupo.

00:07:35.860 --> 00:07:38.500
Caso contrário, se você passar por todo esse loop

00:07:38.500 --> 00:07:40.690
e você não encontrou o número 50, você pode simplesmente

00:07:40.690 --> 00:07:42.640
jogue suas mãos para cima em desapontamento.

00:07:42.640 --> 00:07:45.190
Falso-- você não encontrou o número 50.

00:07:45.190 --> 00:07:50.293
Então, para ficar claro, o primeiro passo será para cada porta da esquerda para a direita.

00:07:50.293 --> 00:07:51.460
Como você gostaria de começar?

00:07:55.610 --> 00:07:56.495
Sim.

00:07:56.495 --> 00:07:57.840
Ah, e então-- sim.

00:07:57.840 --> 00:07:58.340
Aqui vamos nós.

00:07:58.340 --> 00:08:00.365
Sim.

00:08:00.365 --> 00:08:02.060
E se você gostaria de pelo menos dizer--

00:08:02.060 --> 00:08:04.040
bom, boa atuação aqui.

00:08:04.040 --> 00:08:06.140
O que você encontrou em vez disso?

00:08:06.140 --> 00:08:07.970
STEPHANIE: Não é 50, mas 20.

00:08:07.970 --> 00:08:08.900
DAVID MALAN: Ah, tudo bem.

00:08:08.900 --> 00:08:10.280
Portanto, o primeiro passo foi um fracasso.

00:08:10.280 --> 00:08:11.870
Então, vamos passar para a etapa dois.

00:08:11.870 --> 00:08:14.453
Dentro desse loop, o que você fará a seguir?

00:08:14.453 --> 00:08:16.370
STEPHANIE: Vou passar para a próxima porta.

00:08:16.370 --> 00:08:17.037
DAVID MALAN: OK.

00:08:20.790 --> 00:08:22.100
STEPHANIE: Quase.

00:08:22.100 --> 00:08:23.100
DAVID MALAN: OK, quase.

00:08:23.100 --> 00:08:23.790
Tipo de.

00:08:23.790 --> 00:08:25.110
Um 500 em vez disso.

00:08:25.110 --> 00:08:26.280
Próximo armário?

00:08:26.280 --> 00:08:30.200
STEPHANIE: Eu prefiro aceitar isso.

00:08:30.200 --> 00:08:30.700
Não.

00:08:33.840 --> 00:08:36.558
DAVID MALAN: OK, não estamos contando ao público?

00:08:36.558 --> 00:08:38.260
STEPHANIE: Foi um 10.

00:08:38.260 --> 00:08:39.789
DAVID MALAN: OK, então continue.

00:08:39.789 --> 00:08:40.974
Este é o passo três agora.

00:08:45.470 --> 00:08:46.310
STEPHANIE: Ah, cara.

00:08:49.850 --> 00:08:51.260
DAVID MALAN: Cinco, OK.

00:08:51.260 --> 00:08:52.670
Mais alguns armários para verificar.

00:08:57.296 --> 00:08:58.790
STEPHANIE: Um pouco triste, pessoal.

00:09:02.527 --> 00:09:04.360
DAVID MALAN: Tudo bem, penúltimo passo.

00:09:07.710 --> 00:09:09.070
STEPHANIE: É 1.

00:09:09.070 --> 00:09:10.022
Meio que perto.

00:09:10.022 --> 00:09:10.980
DAVID MALAN: Tudo bem.

00:09:10.980 --> 00:09:12.780
E, finalmente, o último passo.

00:09:12.780 --> 00:09:15.780
Claramente você foi, talvez, instalado aqui.

00:09:15.780 --> 00:09:17.340
STEPHANIE: Vamos!

00:09:17.340 --> 00:09:19.920
DAVID MALAN: Tudo bem, então o número 50.

00:09:23.500 --> 00:09:25.870
E Stephanie, se me permite, deixe-me fazer uma pergunta aqui.

00:09:25.870 --> 00:09:28.890
Então, na tela, este é o pseudocódigo que você acabou de executar.

00:09:28.890 --> 00:09:31.800
Suponha, porém, que eu tivesse feito o que muitos de nós

00:09:31.800 --> 00:09:34.770
adquiriram o hábito de fazer quando você tem uma condição if.

00:09:34.770 --> 00:09:36.730
Muitas vezes, você também tem uma ramificação else.

00:09:36.730 --> 00:09:38.760
Suponha que eu tivesse feito isso agora.

00:09:38.760 --> 00:09:41.680
E estou marcando em vermelho para deixar claro que isso está errado.

00:09:41.680 --> 00:09:45.750
Mas o que teria sido ruim sobre este código usando um if e um else,

00:09:45.750 --> 00:09:47.040
você poderia dizer?

00:09:47.040 --> 00:09:48.360
Algum instinto?

00:09:55.620 --> 00:09:58.740
STEPHANIE: Então você acabaria cancelando

00:09:58.740 --> 00:10:00.210
o código antes de encontrar o 50.

00:10:00.210 --> 00:10:01.020
DAVID MALAN: Sim, exatamente.

00:10:01.020 --> 00:10:02.070
STEPHANIE: Quer dizer, você ficaria eternamente triste.

00:10:02.070 --> 00:10:02.460
DAVID MALAN: De fato.

00:10:02.460 --> 00:10:05.127
Quando Stephanie abriu o primeiro armário, ela encontrou 20.

00:10:05.127 --> 00:10:06.630
20, claro, não é 50.

00:10:06.630 --> 00:10:07.838
Ela teria decretado falso.

00:10:07.838 --> 00:10:10.547
Mas é claro que ela não tinha verificado todos os outros armários.

00:10:10.547 --> 00:10:13.440
Então esse parece ser um detalhe chave que, com essa implementação

00:10:13.440 --> 00:10:16.440
do pseudocódigo, nós realmente passamos-- como fizemos--

00:10:16.440 --> 00:10:18.810
e apenas retornar false nem mesmo com um else,

00:10:18.810 --> 00:10:23.070
mas apenas no final do loop, de modo que só alcançamos essa linha se

00:10:23.070 --> 00:10:25.245
não retorne true antes disso.

00:10:25.245 --> 00:10:26.620
Bem, vamos em frente e fazer isso.

00:10:26.620 --> 00:10:27.360
Deixe-me pegar o microfone de você.

00:10:27.360 --> 00:10:28.930
Você gostaria de se sentar ao lado de Jackson?

00:10:28.930 --> 00:10:31.180
E Jackson, em apenas um momento, faremos você subir.

00:10:31.180 --> 00:10:34.170
Carter, se não se importa em reorganizar os armários para nós.

00:10:34.170 --> 00:10:36.630
Mas enquanto isso, deixe-me apontar como podemos agora

00:10:36.630 --> 00:10:38.010
traduzir essa mesma ideia para o código.

00:10:38.010 --> 00:10:41.050
Nível bastante alto, bastante orientado para o inglês com esse pseudocódigo -

00:10:41.050 --> 00:10:44.910
mas realmente agora, desde a semana passada, temos a sintaxe através da qual Stephanie

00:10:44.910 --> 00:10:48.810
e, em breve, Jackson poderia tratar este armário, este conjunto de armários, como realmente

00:10:48.810 --> 00:10:51.250
de fato, uma matriz usando a notação de colchetes.

00:10:51.250 --> 00:10:54.480
Portanto, agora podemos nos aproximar um pouco mais em nosso pseudocódigo do código real.

00:10:54.480 --> 00:10:56.670
E a maneira como um cientista da computação, por exemplo,

00:10:56.670 --> 00:10:59.850
traduziria pseudocódigo inglês de alto nível

00:10:59.850 --> 00:11:03.720
assim para algo um pouco mais próximo de C ou qualquer linguagem

00:11:03.720 --> 00:11:06.600
que suporta arrays seria um pouco mais cripticamente assim.

00:11:06.600 --> 00:11:09.060
Mas você verá mais dessa sintaxe nos próximos dias.

00:11:09.060 --> 00:11:13.260
Para i de 0 a n menos 1-- isso ainda é pseudocódigo.

00:11:13.260 --> 00:11:15.840
Mas essa é a maneira inglesa de expressar o que

00:11:15.840 --> 00:11:17.730
conhecemos como um loop for.

00:11:17.730 --> 00:11:22.260
Se 50 estiver atrás do colchete de portas i-- então estou assumindo para fins de discussão

00:11:22.260 --> 00:11:26.503
essa portas, agora, é o nome da minha variável, esse conjunto de sete portas.

00:11:26.503 --> 00:11:28.920
Mas então o resto da lógica, o resto do pseudocódigo

00:11:28.920 --> 00:11:30.370
realmente é da mesma forma.

00:11:30.370 --> 00:11:33.270
E assim você descobrirá com o tempo que programadores, cientistas da computação mais

00:11:33.270 --> 00:11:36.900
geralmente, quando você começa a expressar ideias, algoritmos para outra pessoa,

00:11:36.900 --> 00:11:40.170
em vez de talvez operar neste nível aqui,

00:11:40.170 --> 00:11:43.020
agora você tem um novo vocabulário, realmente uma nova sintaxe

00:11:43.020 --> 00:11:44.910
que você pode ser um pouco mais específico, não

00:11:44.910 --> 00:11:47.380
entrar tanto no mato de escrever código C real,

00:11:47.380 --> 00:11:50.910
mas pelo menos agora fazendo algo que está um pouco mais perto de manipular

00:11:50.910 --> 00:11:51.810
uma matriz como esta.

00:11:51.810 --> 00:11:55.140
Então, Jackson, você gostaria de ficar de pé?

00:11:55.140 --> 00:11:56.760
Tudo bem.

00:11:56.760 --> 00:11:57.360
Sim Sim.

00:11:57.360 --> 00:11:59.010
Apoio para Jackson aqui também.

00:11:59.010 --> 00:12:00.780
Legal.

00:12:00.780 --> 00:12:04.470
E aqui agora, vou permitir a você uma suposição que Stephanie não tinha.

00:12:04.470 --> 00:12:06.660
Stephanie claramente estava realmente fazendo o seu melhor

00:12:06.660 --> 00:12:10.050
pesquisando da esquerda para a direita usando a pesquisa linear, como a chamaremos agora.

00:12:10.050 --> 00:12:12.180
Mas eles estavam praticamente em uma ordem aleatória, certo?

00:12:12.180 --> 00:12:15.030
Havia um 20 ali, havia 1 ali e depois um 50.

00:12:15.030 --> 00:12:19.110
Então, deliberadamente, misturamos as coisas e não classificamos os números para ela.

00:12:19.110 --> 00:12:22.530
Mas Carter gentilmente acabou de lhe dar uma ajuda, Jackson,

00:12:22.530 --> 00:12:24.510
classificando os números com antecedência.

00:12:24.510 --> 00:12:27.630
E gostaríamos que desta vez, como na semana 0,

00:12:27.630 --> 00:12:30.060
fazer algo de novo e de novo, mas desta vez

00:12:30.060 --> 00:12:32.250
usando o que chamaremos agora de pesquisa binária.

00:12:32.250 --> 00:12:35.580
É exatamente o mesmo algoritmo conceitualmente que fizemos na Semana 0.

00:12:35.580 --> 00:12:38.310
Mas se traduzirmos para o contexto desta matriz,

00:12:38.310 --> 00:12:40.450
agora podemos dizer algo assim.

00:12:40.450 --> 00:12:42.960
O primeiro passo para Jackson pode ser fazer a pergunta -

00:12:42.960 --> 00:12:46.110
se 50 estiver atrás da porta do meio, onde presumivelmente ele está

00:12:46.110 --> 00:12:48.570
fiz algumas contas mentais para descobrir o que é o meio,

00:12:48.570 --> 00:12:50.610
então ele vai apenas retornar verdadeiro.

00:12:50.610 --> 00:12:53.070
E esperamos ter sorte e 50 estarão bem ali.

00:12:53.070 --> 00:12:56.400
Claro, há pelo menos duas outras possibilidades,

00:12:56.400 --> 00:12:58.290
qual seria o que?

00:12:58.290 --> 00:13:01.290
50 é, com relação a essas portas?

00:13:01.290 --> 00:13:03.930
Sim, então para a esquerda ou para a direita, alternativamente.

00:13:03.930 --> 00:13:07.722
Portanto, se 50 for menor que a porta do meio, presumivelmente,

00:13:07.722 --> 00:13:09.180
Jackson vai querer ir para a esquerda.

00:13:09.180 --> 00:13:11.310
Caso contrário, se 50 for maior que a porta do meio,

00:13:11.310 --> 00:13:13.380
ele vai querer dar certo, assim como eu

00:13:13.380 --> 00:13:16.170
fiz fisicamente na semana passada com a lista telefônica,

00:13:16.170 --> 00:13:17.910
dividindo e conquistando da esquerda para a direita.

00:13:17.910 --> 00:13:20.020
Mas na verdade há um quarto caso.

00:13:20.020 --> 00:13:21.540
Vamos colocá-lo no quadro primeiro.

00:13:21.540 --> 00:13:25.530
O que mais pode acontecer aqui que Jackson deveria considerar?

00:13:25.530 --> 00:13:26.170
Sim.

00:13:26.170 --> 00:13:28.590
Ah, não está lá.

00:13:28.590 --> 00:13:32.930
Então, deixe-me voltar e corrigir meu pseudocódigo aqui e apenas dizer Jackson,

00:13:32.930 --> 00:13:36.200
se não lhe dermos nenhuma porta, ou eventualmente,

00:13:36.200 --> 00:13:39.080
enquanto ele está dividindo e conquistando, se ele ficar sem mais portas,

00:13:39.080 --> 00:13:42.380
temos que lidar com essa situação para que o comportamento seja definido.

00:13:42.380 --> 00:13:44.210
Tudo bem, então com isso dito, Jackson, faça

00:13:44.210 --> 00:13:46.127
você quer ir em frente e encontrar-nos o número 50

00:13:46.127 --> 00:13:48.650
e explicar-nos verbalmente o que você está fazendo e encontrando?

00:13:48.650 --> 00:13:52.860
JACKSON: Tudo bem, então parece que esta é a porta do meio.

00:13:52.860 --> 00:13:55.290
Então eu vou abrir.

00:13:55.290 --> 00:13:57.030
Mas são 20, não 50.

00:13:57.030 --> 00:13:59.622
DAVID MALAN: Ah.

00:13:59.622 --> 00:14:01.080
O que está passando pela sua cabeça agora?

00:14:01.080 --> 00:14:02.670
JACKSON: Então agora estou procurando...

00:14:02.670 --> 00:14:06.490
como 50 é maior que 20, quero olhar para a direita.

00:14:06.490 --> 00:14:07.440
DAVID MALAN: Bom.

00:14:07.440 --> 00:14:10.270
JACKSON: E procure a nova porta do meio, que estaria aqui.

00:14:10.270 --> 00:14:11.700
DAVID MALAN: Legal.

00:14:11.700 --> 00:14:12.900
JACKSON: E é 100--

00:14:12.900 --> 00:14:13.740
ruim.

00:14:13.740 --> 00:14:16.560
Mas 50 é menor que 100.

00:14:16.560 --> 00:14:20.520
Então agora devemos olhar para a esquerda, que seria aqui.

00:14:20.520 --> 00:14:21.240
E ta-da.

00:14:21.240 --> 00:14:21.990
DAVID MALAN: Legal.

00:14:21.990 --> 00:14:25.680
Muito bem feito desta vez também.

00:14:25.680 --> 00:14:29.680
Então, obrigado, em primeiro lugar, aos nossos voluntários aqui.

00:14:29.680 --> 00:14:32.970
E, de fato, como você é um fã do Banco Imobiliário, como fomos informados,

00:14:32.970 --> 00:14:35.220
temos a edição de Cambridge do Banco Imobiliário

00:14:35.220 --> 00:14:36.743
com todos os seus favoritos de Harvard.

00:14:36.743 --> 00:14:37.410
JACKSON: De jeito nenhum.

00:14:37.410 --> 00:14:38.460
DAVID MALAN: Aqui está.

00:14:38.460 --> 00:14:38.970
STEPHANIE: Obrigada.

00:14:38.970 --> 00:14:40.095
JACKSON: Muito obrigado.

00:14:40.095 --> 00:14:42.570
DAVID MALAN: Obrigado aos nossos voluntários por nos encontrar 50.

00:14:42.570 --> 00:14:46.940
Isso foi mais popular do que esperávamos.

00:14:46.940 --> 00:14:50.470
Então, aqui, podemos traduzir isso mais uma vez em algo

00:14:50.470 --> 00:14:52.060
um pouco mais perto do código.

00:14:52.060 --> 00:14:54.730
E novamente, ainda pseudocódigo-- mas aqui, agora,

00:14:54.730 --> 00:14:57.460
pode ser outra formulação de exatamente o que Jackson acabou de fazer,

00:14:57.460 --> 00:14:59.380
apenas usando a nomenclatura agora de arrays,

00:14:59.380 --> 00:15:01.570
onde você pode ser um pouco mais preciso com suas instruções

00:15:01.570 --> 00:15:04.640
e ainda deixar para outra pessoa traduzir isso, finalmente, para o código.

00:15:04.640 --> 00:15:06.640
Mas aqui temos a mesma pergunta no começo.

00:15:06.640 --> 00:15:08.650
Se não houver mais portas, retorne false.

00:15:08.650 --> 00:15:11.500
Se 50 estiver atrás do suporte das portas no meio--

00:15:11.500 --> 00:15:13.810
então estou supondo aqui, porque isso é pseudocódigo--

00:15:13.810 --> 00:15:16.810
que em algum lugar eu fiz a matemática mental ou a matemática real

00:15:16.810 --> 00:15:19.480
para descobrir qual é o índice do meio.

00:15:19.480 --> 00:15:22.420
Por exemplo, se forem sete portas em uma matriz,

00:15:22.420 --> 00:15:27.310
este seria o local 0, 1, 2, 3, 4, 5, 6.

00:15:27.310 --> 00:15:31.120
Então, de alguma forma, peguei o número total de portas, 7,

00:15:31.120 --> 00:15:33.520
dividido por 2 para encontrar o meio.

00:15:33.520 --> 00:15:34.430
Isso é 3 e 1/2.

00:15:34.430 --> 00:15:35.680
Temos que lidar com arredondamentos.

00:15:35.680 --> 00:15:38.920
Mas basta dizer que existe uma fórmula bem definida para encontrar

00:15:38.920 --> 00:15:39.910
o índice médio.

00:15:39.910 --> 00:15:43.280
Dado o número total de armários, divida por 2 e arredonde de acordo.

00:15:43.280 --> 00:15:45.550
Então, presumivelmente, isso é o que Jackson fez apenas contando

00:15:45.550 --> 00:15:48.790
ou em sua cabeça para nos encontrar porta número 3.

00:15:48.790 --> 00:15:52.210
Não a terceira porta, a 4ª porta, mas o suporte da porta 3.

00:15:52.210 --> 00:15:56.200
Portanto, isso está apenas dizendo que se 50 estiver atrás do meio do colchete das portas, retorne verdadeiro.

00:15:56.200 --> 00:15:57.200
Esse não foi o caso.

00:15:57.200 --> 00:15:58.960
Em vez disso, ele encontrou uma nota de $ 20.

00:15:58.960 --> 00:16:03.670
Caso contrário, se 50 for menor que o meio do suporte das portas, vá em frente -

00:16:03.670 --> 00:16:10.660
e agora fica interessante - procure nas portas 0 pelas portas do meio menos 1.

00:16:10.660 --> 00:16:12.730
Então está ficando um pouco mais no mato agora.

00:16:12.730 --> 00:16:16.900
Mas se o meio é 3, este aqui, o que queremos agora

00:16:16.900 --> 00:16:19.300
faça Jackson procurar se 50 foram--

00:16:19.300 --> 00:16:22.360
se o número for menor, queremos começar no colchete 0

00:16:22.360 --> 00:16:24.340
e suba por este.

00:16:24.340 --> 00:16:26.380
E deliberadamente subtraímos 1 porque o que é

00:16:26.380 --> 00:16:28.297
a ponto de olhar no mesmo armário novamente?

00:16:28.297 --> 00:16:31.270
Podemos também fazer 0 até o meio menos 1.

00:16:31.270 --> 00:16:36.040
Caso contrário, se 50 for maior que o meio do suporte das portas, o que era,

00:16:36.040 --> 00:16:37.120
o que fizemos então?

00:16:37.120 --> 00:16:40.870
Então Jackson procurou intuitivamente por portas do meio mais 1

00:16:40.870 --> 00:16:43.295
através de portas n menos 1.

00:16:43.295 --> 00:16:46.420
E honestamente, fica um pouco chato ter os prós e contras aqui.

00:16:46.420 --> 00:16:47.780
Mas pense no que isso significa.

00:16:47.780 --> 00:16:49.090
Esta é a porta do meio.

00:16:49.090 --> 00:16:53.942
E Jackson então começou a procurar pelas portas do meio mais 1

00:16:53.942 --> 00:16:56.150
porque não adianta procurar esse de novo.

00:16:56.150 --> 00:17:00.130
E então o último elemento em qualquer array de tamanho n

00:17:00.130 --> 00:17:05.352
onde n é apenas o nosso número para o tamanho sempre será n menos 1.

00:17:05.352 --> 00:17:06.310
Não vai ser n.

00:17:06.310 --> 00:17:10.839
Será n menos 1 porque sempre começamos a contar arrays em 0.

00:17:10.839 --> 00:17:14.200
Então, aqui temos uma tradução em pseudocódigo que está um pouco mais próxima

00:17:14.200 --> 00:17:16.430
para C desta mesma ideia.

00:17:16.430 --> 00:17:18.490
E aqui, fechamos o círculo para a Semana 0.

00:17:18.490 --> 00:17:22.240
Na semana 0, foi bastante intuitivo imaginar dividir e conquistar

00:17:22.240 --> 00:17:23.420
um problema como este.

00:17:23.420 --> 00:17:26.770
Mas se você pensar agora em seu iPhone real, seu telefone Android,

00:17:26.770 --> 00:17:29.920
ou algo semelhante, quando você está fazendo preenchimento automático e pesquisando na lista,

00:17:29.920 --> 00:17:33.430
é possível, se você não tiver muitos amigos, familiares ou colegas

00:17:33.430 --> 00:17:34.840
no telefone, você sabe o quê?

00:17:34.840 --> 00:17:39.070
Pesquisa linear, apenas verificando cada nome da pessoa que você está procurando,

00:17:39.070 --> 00:17:40.720
pode estar perfeitamente bem.

00:17:40.720 --> 00:17:43.810
Mas é provável que seu telefone seja mais inteligente do que isso, especialmente se você

00:17:43.810 --> 00:17:47.140
comece a ter dezenas, centenas, milhares de pessoas em seus contatos

00:17:47.140 --> 00:17:47.770
ao longo dos anos.

00:17:47.770 --> 00:17:49.540
O que seria melhor do que a pesquisa linear?

00:17:49.540 --> 00:17:51.340
Bem, talvez busca binária.

00:17:51.340 --> 00:17:55.180
Mas, mas, mas-- há uma suposição, uma exigência, que é o quê?

00:17:55.180 --> 00:18:00.340
Por que Jackson finalmente conseguiu encontrar os 50 em apenas três etapas?

00:18:00.340 --> 00:18:04.830
em vez de um sete completo, como Stephanie?

00:18:04.830 --> 00:18:06.570
Porque a matriz foi classificada.

00:18:06.570 --> 00:18:09.990
E isso é uma espécie de teaser para o que teremos que voltar mais tarde hoje.

00:18:09.990 --> 00:18:12.780
Bem, quanto esforço era necessário para alguém como Carter?

00:18:12.780 --> 00:18:15.240
Quanto esforço seu telefone leva para classificar todas

00:18:15.240 --> 00:18:17.040
desses nomes e números com antecedência?

00:18:17.040 --> 00:18:19.650
Porque talvez não valha a pena tanto tempo.

00:18:19.650 --> 00:18:24.210
Agora, alguém como o Google provavelmente de alguma forma mantém o banco de dados de páginas da web classificado.

00:18:24.210 --> 00:18:28.110
Você pode imaginar que é super lento se, quando você digita gatos ou qualquer outra coisa

00:18:28.110 --> 00:18:32.280
em google.com, se pesquisassem linearmente em todo o conjunto de dados.

00:18:32.280 --> 00:18:35.430
Idealmente, eles estão fazendo algo um pouco mais inteligente do que isso.

00:18:35.430 --> 00:18:38.820
Então vamos formalizar, agora, exatamente esse tipo de análise.

00:18:38.820 --> 00:18:42.180
E não será tão matemático quanto intuitivo.

00:18:42.180 --> 00:18:45.480
Mas vamos apresentar-lhe alguns jargões, alguma terminologia

00:18:45.480 --> 00:18:48.180
que a maioria dos programadores ou cientistas da computação pode usar

00:18:48.180 --> 00:18:50.550
ao analisar seus próprios algoritmos.

00:18:50.550 --> 00:18:53.670
Vamos formalizar agora o que é esse tipo de análise.

00:18:53.670 --> 00:18:56.910
Então, agora, afirmo que a pesquisa binária é melhor do que a pesquisa linear.

00:18:56.910 --> 00:18:59.100
Mas quanto melhor e por que, exatamente?

00:18:59.100 --> 00:19:01.120
Bem, tudo se resume a esse tipo de gráfico.

00:19:01.120 --> 00:19:04.830
Portanto, lembre-se, foi assim que analisamos a lista telefônica na Semana 0.

00:19:04.830 --> 00:19:08.880
E lembre-se que, de fato, tínhamos essas fórmulas, fórmulas grosseiras que

00:19:08.880 --> 00:19:11.370
descreveu o tempo de execução desses três algoritmos--

00:19:11.370 --> 00:19:13.740
uma página de cada vez, duas páginas de cada vez e, em seguida,

00:19:13.740 --> 00:19:15.720
rasgando a coisa de novo e de novo ao meio.

00:19:15.720 --> 00:19:19.830
E precisamente, se você contasse o número de páginas que eu tocava

00:19:19.830 --> 00:19:22.020
ou o número de páginas que eu estava rasgando, é

00:19:22.020 --> 00:19:24.600
justo dizer que o primeiro algoritmo, no pior caso,

00:19:24.600 --> 00:19:26.700
pode ter levado n páginas no total.

00:19:26.700 --> 00:19:29.010
Não porque eu estava procurando por John Harvard

00:19:29.010 --> 00:19:31.260
na época, que é um pouco cedo no alfabeto.

00:19:31.260 --> 00:19:34.340
Mas se eu estivesse procurando alguém com o sobrenome Z,

00:19:34.340 --> 00:19:36.840
Eu teria que continuar indo e indo, no pior dos casos,

00:19:36.840 --> 00:19:38.430
através de todas as n páginas.

00:19:38.430 --> 00:19:41.940
Não tão ruim para o segundo algoritmo, e é por isso que n dividimos por 2.

00:19:41.940 --> 00:19:43.920
E mesmo isso é uma mentira inocente.

00:19:43.920 --> 00:19:48.270
Provavelmente é n dividido por 2 mais 1 caso eu tenha que dobrar de volta.

00:19:48.270 --> 00:19:50.405
Mas, novamente, estou fazendo isso de forma mais geral

00:19:50.405 --> 00:19:52.030
para capturar a essência dessas coisas.

00:19:52.030 --> 00:19:54.363
E então nós realmente entramos no mato com uma base de toras

00:19:54.363 --> 00:19:56.940
2 para esse terceiro e último algoritmo.

00:19:56.940 --> 00:20:00.690
E na época, alegávamos que sempre que você estava dividindo algo pela metade,

00:20:00.690 --> 00:20:04.200
ao meio, ao meio, é provável que haja algum tipo de logaritmo envolvido.

00:20:04.200 --> 00:20:05.340
E veremos isso hoje.

00:20:05.340 --> 00:20:09.010
Mas hoje, vamos realmente começar a usar a terminologia da ciência da computação.

00:20:09.010 --> 00:20:13.590
E vamos formalizar essa imprecisão, se você quiser.

00:20:13.590 --> 00:20:17.670
Não vamos nos importar, geralmente, sobre exatamente quantos passos

00:20:17.670 --> 00:20:20.820
algum algoritmo leva porque isso não vai ser tão esclarecedor,

00:20:20.820 --> 00:20:24.630
especialmente se talvez você tenha um computador mais rápido amanhã do que hoje.

00:20:24.630 --> 00:20:27.510
Não seria realmente justo comparar números com muita precisão.

00:20:27.510 --> 00:20:31.590
Nós realmente queremos, com um aceno de mão, apenas ter uma noção de aproximadamente

00:20:31.590 --> 00:20:33.930
quão lento ou quão rápido é um algoritmo.

00:20:33.930 --> 00:20:36.000
Portanto, a notação aqui é deliberada.

00:20:36.000 --> 00:20:40.620
Isso é literalmente um O maiúsculo, muitas vezes em itálico, conhecido como O grande.

00:20:40.620 --> 00:20:43.920
E assim o primeiro algoritmo está em grande O de n.

00:20:43.920 --> 00:20:47.760
O segundo algoritmo está em grande O de n dividido por 2.

00:20:47.760 --> 00:20:51.480
O terceiro algoritmo está em grande O de log base 2 de n.

00:20:51.480 --> 00:20:54.690
Mas mesmo isso é um detalhe desnecessário.

00:20:54.690 --> 00:20:58.830
Ao usar a notação O grande, você realmente não se importa, veremos,

00:20:58.830 --> 00:21:01.230
os termos de menor ordem.

00:21:01.230 --> 00:21:04.500
Não vamos nos importar com a divisão por 2 porque sabe de uma coisa?

00:21:04.500 --> 00:21:07.720
A forma desses algoritmos é quase a mesma.

00:21:07.720 --> 00:21:10.800
E realmente, a ideia-- o algoritmo em si é meio que fundamentalmente

00:21:10.800 --> 00:21:11.340
o mesmo.

00:21:11.340 --> 00:21:13.620
Em vez de uma página de cada vez, estou fazendo duas.

00:21:13.620 --> 00:21:17.280
Mas se você jogar milhões de páginas, bilhões de páginas em mim,

00:21:17.280 --> 00:21:20.460
esses algoritmos vão realmente ter o mesmo desempenho que n obtém

00:21:20.460 --> 00:21:22.085
realmente grande, vai em direção ao infinito.

00:21:22.085 --> 00:21:23.585
E o mesmo vale para logaritmos.

00:21:23.585 --> 00:21:25.560
Mesmo se você estiver um pouco enferrujado, acontece

00:21:25.560 --> 00:21:29.560
que se você fizer a matemática com log base 2, log base 3, log base 10,

00:21:29.560 --> 00:21:33.040
você pode simplesmente multiplicar um pelo outro para realmente obter a mesma fórmula.

00:21:33.040 --> 00:21:35.700
Portanto, isso é apenas para dizer que um cientista da computação geralmente

00:21:35.700 --> 00:21:39.270
digamos que os dois primeiros algoritmos são da ordem de n passos.

00:21:39.270 --> 00:21:42.690
O terceiro algoritmo é da ordem de log n passos.

00:21:42.690 --> 00:21:46.350
E não nos importamos exatamente com o que queremos dizer além disso.

00:21:46.350 --> 00:21:49.770
E esta grande notação O, como veremos -- e, na verdade, deixe-me diminuir o zoom.

00:21:49.770 --> 00:21:53.500
Se você pode imaginar de repente tornando o eixo x muito mais longo -

00:21:53.500 --> 00:21:55.770
mais páginas na tela ao mesmo tempo--

00:21:55.770 --> 00:21:58.320
de fato, serão as formas dessas curvas

00:21:58.320 --> 00:22:01.480
isso importa, porque imagine em sua mente enquanto você diminui o zoom,

00:22:01.480 --> 00:22:04.950
diminuir o zoom, diminuir o zoom, diminuir o zoom, e como n fica muito, muito, muito maior

00:22:04.950 --> 00:22:07.470
no eixo x, a linha vermelha e a linha amarela

00:22:07.470 --> 00:22:11.400
essencialmente terão a mesma aparência quando n for suficientemente grande.

00:22:11.400 --> 00:22:14.378
Mas a linha verde nunca terá a mesma aparência.

00:22:14.378 --> 00:22:16.420
Vai ser uma forma fundamentalmente diferente.

00:22:16.420 --> 00:22:18.570
E essa é a intuição do grande O, obter

00:22:18.570 --> 00:22:23.200
uma noção dessas taxas de desempenho como esta.

00:22:23.200 --> 00:22:25.410
Então, aqui está o grande O. Aqui está, talvez,

00:22:25.410 --> 00:22:29.160
uma folha de dicas das fórmulas comuns que um cientista da computação, certamente

00:22:29.160 --> 00:22:32.490
em um contexto introdutório, pode usar ao analisar algoritmos.

00:22:32.490 --> 00:22:36.060
E vamos considerar por um momento qual dos nossos dois primeiros algoritmos--

00:22:36.060 --> 00:22:39.040
pesquisa linear e pesquisa binária-- se enquadram nessas categorias.

00:22:39.040 --> 00:22:44.318
Então eu os ordenei do mais lento para o mais rápido, então ordem de n ao quadrado.

00:22:44.318 --> 00:22:46.110
Não é algo que realmente vimos ainda,

00:22:46.110 --> 00:22:48.392
mas tende a ser lento porque é quadrático.

00:22:48.392 --> 00:22:49.350
Você está fazendo n vezes n.

00:22:49.350 --> 00:22:51.090
Isso deve incluir muitas etapas.

00:22:51.090 --> 00:22:53.190
Melhor hoje vai ser n log n.

00:22:53.190 --> 00:22:54.630
Ainda melhor vai ser n.

00:22:54.630 --> 00:22:56.190
Ainda melhor do que isso é log n.

00:22:56.190 --> 00:23:00.150
E o melhor é a chamada ordem de 1, como um passo

00:23:00.150 --> 00:23:02.520
ou talvez dois passos, talvez até 1.000 passos,

00:23:02.520 --> 00:23:08.200
mas um número fixo e finito de etapas que nunca muda, não importa quão grande n seja.

00:23:08.200 --> 00:23:11.920
Então, dado este gráfico, só para ficar claro, pesquisa linear -

00:23:11.920 --> 00:23:13.570
vamos considerar o pior caso.

00:23:13.570 --> 00:23:18.040
Na pior das hipóteses, quantos passos foram necessários para alguém como Stephanie

00:23:18.040 --> 00:23:23.500
encontrar a solução para o problema, assumindo não sete portas, mas n portas?

00:23:23.500 --> 00:23:25.160
Sim?

00:23:25.160 --> 00:23:26.540
Então, na ordem de n.

00:23:26.540 --> 00:23:28.280
E neste caso, é exatamente n.

00:23:28.280 --> 00:23:32.660
Mas quer saber, talvez seja indiscutivelmente 2n porque levou Stephanie

00:23:32.660 --> 00:23:33.530
alguns passos.

00:23:33.530 --> 00:23:34.460
Ela teve que levantar o trinco.

00:23:34.460 --> 00:23:35.360
Ela teve que abrir a porta.

00:23:35.360 --> 00:23:36.318
Talvez sejam três passos.

00:23:36.318 --> 00:23:37.530
Ela teve que mostrar o dinheiro.

00:23:37.530 --> 00:23:39.170
Então agora é 3n, 2n.

00:23:39.170 --> 00:23:41.990
Mas realmente não nos importamos com esse nível de precisão.

00:23:41.990 --> 00:23:45.660
Nós realmente nos preocupamos apenas com o número fundamental de operações.

00:23:45.660 --> 00:23:47.540
Então vamos dizer sim, na ordem de n.

00:23:47.540 --> 00:23:51.320
Isso pode ser um limite superior, vamos chamá-lo de pesquisa linear.

00:23:51.320 --> 00:23:53.030
E quanto à pesquisa binária?

00:23:53.030 --> 00:23:57.140
No caso de Jackson, ou em geral, eu na semana 0, se houver n portas,

00:23:57.140 --> 00:24:02.910
quantos passos Jackson ou eu levamos usando a pesquisa binária?

00:24:02.910 --> 00:24:04.860
Neste caso, foram literalmente três.

00:24:04.860 --> 00:24:07.200
Mas isso não é uma fórmula.

00:24:07.200 --> 00:24:09.690
Sim, então é da ordem do log n.

00:24:09.690 --> 00:24:11.970
E, de fato, se houver sete portas, bem, isso é

00:24:11.970 --> 00:24:14.250
quase oito, se você apenas arredondar um pouco.

00:24:14.250 --> 00:24:18.480
E, de fato, se você pegar log base 2 de 8, isso nos dá 3.

00:24:18.480 --> 00:24:19.813
Então a matemática realmente confere.

00:24:19.813 --> 00:24:22.272
E se você não se sentir confortável com logaritmos, não é grande coisa.

00:24:22.272 --> 00:24:23.670
Basta pensar sobre isso intuitivamente.

00:24:23.670 --> 00:24:27.010
Logaritmo de base 2 é apenas dividir algo de novo e de novo.

00:24:27.010 --> 00:24:31.110
Então, neste gráfico, quando consideramos o grande O, que fica claro,

00:24:31.110 --> 00:24:35.100
permite que você descreva a ordem do tempo de execução de um algoritmo--

00:24:35.100 --> 00:24:38.610
como a magnitude disso - mas também descreve, mais especificamente,

00:24:38.610 --> 00:24:40.090
um limite superior.

00:24:40.090 --> 00:24:42.990
Então, no pior caso, por exemplo, esses

00:24:42.990 --> 00:24:45.480
são medidas muito boas de quão bom--

00:24:45.480 --> 00:24:47.310
ou melhor, de quão ruim--

00:24:47.310 --> 00:24:49.270
pesquisa linear e pesquisa binária podem ser.

00:24:49.270 --> 00:24:49.770
Por que?

00:24:49.770 --> 00:24:52.122
Bem, suponha que você esteja pesquisando em uma lista telefônica de 1.000 páginas

00:24:52.122 --> 00:24:55.080
e o nome da pessoa começa com Z. O algoritmo ainda será

00:24:55.080 --> 00:24:56.320
na ordem de n passos.

00:24:56.320 --> 00:24:56.820
Por que?

00:24:56.820 --> 00:25:01.080
Porque pode levar até n etapas para encontrá-lo.

00:25:01.080 --> 00:25:05.250
Agora, isso não será necessariamente o caso na prática.

00:25:05.250 --> 00:25:08.370
Se eu usar o grande O como um limite superior, bem,

00:25:08.370 --> 00:25:11.160
seria bom se houvesse um limite inferior correspondente,

00:25:11.160 --> 00:25:16.180
especialmente se você quiser considerar não apenas os piores casos, mas talvez os melhores casos.

00:25:16.180 --> 00:25:18.040
Então, o que podemos usar aqui?

00:25:18.040 --> 00:25:20.200
Bem, este é um símbolo ômega grego maiúsculo.

00:25:20.200 --> 00:25:23.550
Então ômega é o símbolo que um cientista da computação geralmente usa

00:25:23.550 --> 00:25:25.920
para descrever um limite inferior em um algoritmo,

00:25:25.920 --> 00:25:28.710
muitas vezes no contexto do melhor caso, embora não necessariamente.

00:25:28.710 --> 00:25:32.490
Portanto, um limite inferior significa quantos passos um algoritmo pode levar?

00:25:32.490 --> 00:25:33.990
E aqui, também, as mesmas fórmulas.

00:25:33.990 --> 00:25:36.270
E vamos preencher esses espaços em branco ao longo do tempo.

00:25:36.270 --> 00:25:40.140
Alguns algoritmos podem sempre levar um mínimo de n passos ao quadrado,

00:25:40.140 --> 00:25:41.370
ou na ordem de n passos.

00:25:41.370 --> 00:25:45.660
Alguns podem levar apenas n log n, ou n, ou log n, ou 1.

00:25:45.660 --> 00:25:49.170
Algo como uma pesquisa linear--

00:25:49.170 --> 00:25:51.240
quando Stephanie começou com a pesquisa linear,

00:25:51.240 --> 00:25:52.980
ela não teve sorte desta vez no palco.

00:25:52.980 --> 00:25:57.720
Mas e se ela tivesse, e a primeira porta que ela abrisse fosse 50?

00:25:57.720 --> 00:26:01.260
Como você poderia então descrever o limite inferior em linear

00:26:01.260 --> 00:26:08.290
pesquisar neste chamado melhor caso, usando esta lista de respostas possíveis?

00:26:08.290 --> 00:26:09.530
Sim?

00:26:09.530 --> 00:26:11.060
Sim, então ômega de 1.

00:26:11.060 --> 00:26:14.900
Então, no melhor caso, o limite inferior de quantos passos

00:26:14.900 --> 00:26:18.990
pode ser necessária uma pesquisa linear para encontrar algo pode ser apenas uma etapa.

00:26:18.990 --> 00:26:19.490
Por que?

00:26:19.490 --> 00:26:21.500
Porque talvez se Stephanie tivesse tido sorte

00:26:21.500 --> 00:26:25.960
e tínhamos preenchido esses armários com os números em alguma outra ordem

00:26:25.960 --> 00:26:28.460
tal que ela poderia ter aberto o primeiro armário, e voila,

00:26:28.460 --> 00:26:31.280
o número 50 poderia estar lá, então um limite inferior sem dúvida

00:26:31.280 --> 00:26:34.610
poderia de fato ser ômega de 1 para pesquisa linear.

00:26:34.610 --> 00:26:35.990
E que tal agora para Jackson?

00:26:35.990 --> 00:26:37.440
Ele usou a busca binária.

00:26:37.440 --> 00:26:40.940
Então ele mergulhou bem no meio do problema.

00:26:40.940 --> 00:26:45.020
Mas o que seria um limite inferior na busca binária usando essa lógica?

00:26:45.020 --> 00:26:45.980
Sim?

00:26:45.980 --> 00:26:47.460
Sim, novamente, ômega de 1.

00:26:47.460 --> 00:26:47.960
Por que?

00:26:47.960 --> 00:26:49.580
Porque talvez ele apenas tenha sorte.

00:26:49.580 --> 00:26:53.300
E, de fato, bem no meio dos armários poderia estar o número 50.

00:26:53.300 --> 00:26:54.060
Não foi.

00:26:54.060 --> 00:26:57.770
E tão mais pertinente na prática real de Jackson

00:26:57.770 --> 00:27:00.050
teria sido a grande discussão O.

00:27:00.050 --> 00:27:03.350
Mas grande O e ômega, limite superior e limite inferior,

00:27:03.350 --> 00:27:05.450
apenas permita que um cientista da computação meio que lute

00:27:05.450 --> 00:27:06.980
com o que poderia acontecer talvez no pior

00:27:06.980 --> 00:27:08.670
caso, o que pode acontecer na melhor das hipóteses?

00:27:08.670 --> 00:27:12.267
E você pode até obter ainda mais precisão como o caso médio ou algo semelhante.

00:27:12.267 --> 00:27:15.350
E isso é, de fato, o que os engenheiros podem fazer em um quadro branco em uma empresa,

00:27:15.350 --> 00:27:17.600
em uma universidade ao projetar um algoritmo

00:27:17.600 --> 00:27:21.380
e tentando argumentar por que seu algoritmo é melhor do que alguém

00:27:21.380 --> 00:27:24.080
de outra pessoa, por meio desses tipos de análises.

00:27:24.080 --> 00:27:29.180
E só para você ver, acontece que se algum algoritmo acontecer

00:27:29.180 --> 00:27:32.990
ter um limite superior e um limite inferior idênticos,

00:27:32.990 --> 00:27:35.880
você também pode usar um teta grego maiúsculo.

00:27:35.880 --> 00:27:38.210
E este é o último dos símbolos gregos hoje.

00:27:38.210 --> 00:27:41.900
Mas um theta grego indica uma coincidência de ambos os

00:27:41.900 --> 00:27:43.130
limite e limite inferior.

00:27:43.130 --> 00:27:44.702
Ou seja, eles são um e o mesmo.

00:27:44.702 --> 00:27:47.660
Esse não foi o caso da nossa discussão um segundo atrás sobre busca linear,

00:27:47.660 --> 00:27:49.220
não é o caso da pesquisa binária.

00:27:49.220 --> 00:27:52.970
Mas você pode usar os mesmos tipos de fórmulas

00:27:52.970 --> 00:27:56.970
se descobrir que seu limite superior e inferior são os mesmos.

00:27:56.970 --> 00:28:00.440
Então, por exemplo, se eu contasse literalmente todos nesta sala-- um,

00:28:00.440 --> 00:28:03.870
dois, três, quatro, cinco, seis e assim por diante -

00:28:03.870 --> 00:28:09.080
você poderia realmente dizer que contar dessa maneira está em theta de n

00:28:09.080 --> 00:28:11.150
porque na melhor das hipóteses, vai demorar

00:28:11.150 --> 00:28:13.468
me n pontos, pessoas na platéia.

00:28:13.468 --> 00:28:15.260
Na pior das hipóteses, vai me levar n.

00:28:15.260 --> 00:28:18.380
Sempre vou precisar de n passos se quiser contar todos na sala.

00:28:18.380 --> 00:28:20.930
Você realmente não pode fazer melhor do que isso, a menos que pule as pessoas.

00:28:20.930 --> 00:28:23.510
Então, isso seria um exemplo do manguito de algo

00:28:23.510 --> 00:28:26.150
onde theta é, em vez disso, pertinente.

00:28:26.150 --> 00:28:31.530
Alguma dúvida agora sobre O grande, ômega ou teta,

00:28:31.530 --> 00:28:34.040
que agora são apenas ferramentas mais formais no kit de ferramentas

00:28:34.040 --> 00:28:38.730
por falar sobre o design de nossos algoritmos?

00:28:38.730 --> 00:28:42.050
Alguma pergunta?

00:28:42.050 --> 00:28:42.860
Não?

00:28:42.860 --> 00:28:44.720
Vendo nenhum.

00:28:44.720 --> 00:28:45.560
Oh, isso é-- sim?

00:28:45.560 --> 00:28:46.840
Não?

00:28:46.840 --> 00:28:48.250
OK, então estamos bem.

00:28:48.250 --> 00:28:52.000
Então vamos em frente e traduzir isso, talvez, para algum código real.

00:28:52.000 --> 00:28:53.900
Deixe-me passar para o VS Code aqui.

00:28:53.900 --> 00:28:57.100
E vamos ver se agora não podemos traduzir algumas dessas ideias

00:28:57.100 --> 00:29:00.280
para algum código real, não tanto usando a nova sintaxe ainda.

00:29:00.280 --> 00:29:03.320
Ainda vamos operar neste mundo de matrizes como na semana passada.

00:29:03.320 --> 00:29:05.237
Então deixe-me ir em frente e criar um programa chamado

00:29:05.237 --> 00:29:09.280
search.c executando o espaço de código search.c no meu terminal.

00:29:09.280 --> 00:29:11.800
E aqui em cima, vamos em frente e incluímos nosso usual,

00:29:11.800 --> 00:29:14.740
então inclua cs50.h para que eu possa obter algumas informações.

00:29:14.740 --> 00:29:18.370
Inclua io.h padrão para que eu possa imprimir alguma saída.

00:29:18.370 --> 00:29:21.910
Faremos int main void, cujo significado iniciamos

00:29:21.910 --> 00:29:23.140
para separar na semana passada.

00:29:23.140 --> 00:29:26.650
O fato de estar nulo novamente hoje significa apenas que não há argumentos de linha de comando.

00:29:26.650 --> 00:29:28.580
E deixe-me ir em frente e fazer isso.

00:29:28.580 --> 00:29:33.130
Deixe-me prosseguir e declarar, apenas para fins de discussão, um array estático,

00:29:33.130 --> 00:29:34.840
como uma matriz que nunca muda.

00:29:34.840 --> 00:29:39.280
E a sintaxe para isso será dar-me uma matriz chamada números

00:29:39.280 --> 00:29:41.290
usando a notação de colchetes.

00:29:41.290 --> 00:29:43.390
E eu vou inicializá-lo imediatamente

00:29:43.390 --> 00:29:49.300
a 20, 500, 10, 5, 100, 1 e 50, reminiscente dessas mesmas denominações

00:29:49.300 --> 00:29:50.060
como antes.

00:29:50.060 --> 00:29:54.080
Portanto, esta é uma sintaxe ligeiramente nova que talvez não tenhamos visto.

00:29:54.080 --> 00:29:57.130
E as chaves aqui, que são diferentes dos loops for

00:29:57.130 --> 00:30:00.820
e while loops e funções, apenas diga ao compilador, por favor, me dê

00:30:00.820 --> 00:30:05.380
uma matriz de qualquer tamanho que contenha esses números da esquerda para a direita.

00:30:05.380 --> 00:30:10.220
Eu poderia, alternativamente, usar a sintaxe da semana passada para dizer algo assim.

00:30:10.220 --> 00:30:13.090
Vejamos, 1, 2, 3, 4, 5, 6, 7 denominações.

00:30:13.090 --> 00:30:15.250
Eu poderia alternativamente fazer isso.

00:30:15.250 --> 00:30:21.910
E então eu poderia dizer que os números entre colchetes 0 são iguais

00:30:21.910 --> 00:30:25.570
20, o colchete de números 1 é igual a 500.

00:30:25.570 --> 00:30:27.572
E eu poderia fazer isso mais cinco vezes.

00:30:27.572 --> 00:30:28.780
Isso é um pouco tedioso.

00:30:28.780 --> 00:30:30.580
Se você conhece os números com antecedência, não

00:30:30.580 --> 00:30:32.530
tem que dizer ao compilador quantos existem.

00:30:32.530 --> 00:30:37.420
Você pode apenas deixá-lo descobrir que seus números serão 10, 500, 10, 5,

00:30:37.420 --> 00:30:39.430
100, 1 e 50.

00:30:39.430 --> 00:30:42.550
Então é assim que você define estaticamente um array.

00:30:42.550 --> 00:30:45.380
Tudo bem, deixe-me ir em frente e pedir ao usuário agora um número.

00:30:45.380 --> 00:30:48.920
Vamos chamá-lo de n usando get_int e solicitando um número--

00:30:48.920 --> 00:30:50.020
então nada de novo aí.

00:30:50.020 --> 00:30:53.680
E agora deixe-me implementar a pesquisa linear.

00:30:53.680 --> 00:30:57.520
E o pseudocódigo que tínhamos para isso antes usava alguma notação semelhante a um array.

00:30:57.520 --> 00:30:59.620
Deixe-me ir em frente, então, e começar da mesma forma.

00:30:59.620 --> 00:31:04.270
Para int i-- e você quase sempre começa a contar em i por convenção.

00:31:04.270 --> 00:31:06.490
Talvez seja um bom ponto de partida.

00:31:06.490 --> 00:31:09.790
Eu vou fazer isso enquanto eu for menor que 7.

00:31:09.790 --> 00:31:12.138
Não é o melhor design para codificar o 7, mas isso é apenas

00:31:12.138 --> 00:31:13.930
para fins de demonstração por agora, porque eu

00:31:13.930 --> 00:31:15.560
sabe quantos números eu coloquei lá.

00:31:15.560 --> 00:31:16.992
E então eu vou para i++.

00:31:16.992 --> 00:31:19.450
Então agora eu tenho o começo de um loop que permitirá

00:31:19.450 --> 00:31:21.550
me para iterar sobre toda a matriz.

00:31:21.550 --> 00:31:22.760
E deixe-me perguntar isso.

00:31:22.760 --> 00:31:27.370
Se o número atual no local i for igual a

00:31:27.370 --> 00:31:30.650
é igual a n, que é o número que o humano digitou,

00:31:30.650 --> 00:31:33.400
então vamos em frente e fazer algo simples como printf,

00:31:33.400 --> 00:31:36.190
aspas sem aspas, encontrado, barra invertida n.

00:31:36.190 --> 00:31:40.240
E então, de acordo com nossa discussão na semana passada, para indicar que isso é bem-sucedido,

00:31:40.240 --> 00:31:42.610
Vou retornar 0 se o encontrei.

00:31:42.610 --> 00:31:45.940
E se eu não encontrar, vou descer aqui e, por padrão,

00:31:45.940 --> 00:31:48.640
diga não encontrado, barra invertida n.

00:31:48.640 --> 00:31:52.610
E apenas por convenção-- opa, apenas por uma boa medida, por convenção,

00:31:52.610 --> 00:31:55.630
Vou retornar 1 ou, na verdade, qualquer valor diferente de 0.

00:31:55.630 --> 00:31:57.130
0, lembre-se, significa sucesso.

00:31:57.130 --> 00:32:00.670
E qualquer outro número inteiro tende a significar algum tipo de erro,

00:32:00.670 --> 00:32:02.690
independentemente do número que estou procurando.

00:32:02.690 --> 00:32:06.670
Então, só para revisitar, a única coisa nova aqui é a sintaxe.

00:32:06.670 --> 00:32:09.980
Estamos criando uma matriz de sete números, esses números.

00:32:09.980 --> 00:32:13.540
E então, depois disso, realmente destacamos aqui

00:32:13.540 --> 00:32:16.090
uma implementação de busca linear.

00:32:16.090 --> 00:32:19.390
Quero dizer, esta é a versão C, ouso dizer, do que Stephanie fez no quadro,

00:32:19.390 --> 00:32:22.540
considerando que agora a matriz é chamada de números em vez de portas.

00:32:22.540 --> 00:32:25.460
Mas acho que é quase a mesma coisa.

00:32:25.460 --> 00:32:30.380
Deixe-me ir em frente e abrir a janela do meu terminal e executar a pesquisa.

00:32:30.380 --> 00:32:32.518
Parece compilar, ./search.

00:32:32.518 --> 00:32:34.310
E vamos em frente e procurar um número.

00:32:34.310 --> 00:32:36.230
Vamos começar com o que fizemos antes, 50.

00:32:36.230 --> 00:32:37.340
E foi encontrado.

00:32:37.340 --> 00:32:39.770
Vamos executá-lo novamente, ./search.

00:32:39.770 --> 00:32:42.500
Vamos procurar por talvez 20 no começo.

00:32:42.500 --> 00:32:43.670
Esse também foi encontrado.

00:32:43.670 --> 00:32:47.150
Vamos executá-lo mais uma vez procurando por 1.000,

00:32:47.150 --> 00:32:50.720
que não está entre as denominações.

00:32:50.720 --> 00:32:52.980
E esse, de fato, não foi encontrado.

00:32:52.980 --> 00:32:56.210
Pegamos uma ideia da Semana 0, agora formalizada na Semana 3,

00:32:56.210 --> 00:32:59.300
e acabei de traduzi-lo agora para o código.

00:32:59.300 --> 00:33:05.500
Dúvidas sobre esta implementação de busca linear?

00:33:05.500 --> 00:33:07.570
Pesquisa linear.

00:33:07.570 --> 00:33:08.680
Nada.

00:33:08.680 --> 00:33:11.810
Oh, tão bem sucedido até agora hoje.

00:33:11.810 --> 00:33:15.820
Então, vamos ver se não podemos tornar isso um pouco mais interessante

00:33:15.820 --> 00:33:19.270
e ver se não podemos tropeçar em um detalhe que vai ser importante em C.

00:33:19.270 --> 00:33:23.330
E em vez de fazer números, deixe-me ir em frente e fazer isso.

00:33:23.330 --> 00:33:25.030
Continuaremos no tema com Banco Imobiliário.

00:33:25.030 --> 00:33:26.830
E eu caí na toca do coelho lendo a Wikipédia

00:33:26.830 --> 00:33:27.730
artigo sobre Monopólio.

00:33:27.730 --> 00:33:32.170
E as peças originais ou fichas que vieram com o Banco Imobiliário-- e acontece

00:33:32.170 --> 00:33:33.740
podemos representar aqueles com strings.

00:33:33.740 --> 00:33:37.690
Vou criar um array chamado strings, plural, de qualquer coisa

00:33:37.690 --> 00:33:39.170
tamanho que defini aqui.

00:33:39.170 --> 00:33:42.340
E as primeiras peças de monopólio naquela época

00:33:42.340 --> 00:33:44.920
fosse um navio de guerra com o qual você poderia brincar,

00:33:44.920 --> 00:33:53.320
uma bota, um canhão, um ferro, um dedal e uma cartola, alguns dos quais

00:33:53.320 --> 00:33:54.700
você pode do jogo hoje em dia.

00:33:54.700 --> 00:33:56.410
Acontece que eles estão mudando isso--

00:33:56.410 --> 00:33:57.890
não tinha ideia - ao longo dos anos.

00:33:57.890 --> 00:34:00.170
Então aqui está, agora, um array de strings.

00:34:00.170 --> 00:34:03.940
Deixe-me prosseguir e solicitar ao usuário que não seja mais um número inteiro.

00:34:03.940 --> 00:34:07.970
Agora, quero procurar uma dessas strings ainda usando a pesquisa linear.

00:34:07.970 --> 00:34:11.020
Então, deixe-me criar uma string s, defini-la igual a get_string,

00:34:11.020 --> 00:34:13.840
solicitar ao usuário uma string para pesquisar.

00:34:13.840 --> 00:34:19.540
E então acho que meu código aqui é quase o mesmo, exceto por um detalhe.

00:34:19.540 --> 00:34:21.850
Agora tenho um array chamado strings.

00:34:21.850 --> 00:34:24.040
Agora tenho uma variável chamada s.

00:34:24.040 --> 00:34:27.790
Mas acontece que, por motivos que exploraremos com mais detalhes na próxima semana,

00:34:27.790 --> 00:34:31.030
esta linha de código não vai funcionar.

00:34:31.030 --> 00:34:34.900
E acontece que o motivo tem a ver com o que discutimos

00:34:34.900 --> 00:34:36.880
última semana sobre o que realmente é uma string.

00:34:36.880 --> 00:34:39.355
E o que é uma string, de novo?

00:34:39.355 --> 00:34:41.000
Uma string é uma matriz.

00:34:41.000 --> 00:34:44.929
E acontece, porém, que igual a igual não é

00:34:44.929 --> 00:34:49.760
vai comparar generosamente todos os caracteres em uma matriz para você

00:34:49.760 --> 00:34:51.949
só porque você usa igual igual.

00:34:51.949 --> 00:34:54.650
Acontece que não vai comparar todas as letras.

00:34:54.650 --> 00:35:00.260
E, felizmente, existe, na biblioteca de strings

00:35:00.260 --> 00:35:03.058
que apresentamos na semana passada, uma solução para este problema.

00:35:03.058 --> 00:35:05.850
A razão do problema, vamos explorar com mais detalhes na próxima semana.

00:35:05.850 --> 00:35:09.860
Mas, por enquanto, saiba que quando você quiser comparar strings em C--

00:35:09.860 --> 00:35:13.220
especialmente se você entrou na classe sabendo um pouco de Java ou Python ou algum

00:35:13.220 --> 00:35:15.680
outro idioma-- você não pode usar equals equals.

00:35:15.680 --> 00:35:18.500
Mesmo que você pudesse no Scratch, você não pode em C.

00:35:18.500 --> 00:35:21.620
Então, o que eu realmente tenho que fazer aqui é isso.

00:35:21.620 --> 00:35:26.330
Eu tenho que fazer a pergunta, o valor de retorno de uma função chamada str

00:35:26.330 --> 00:35:33.160
compare, ou strcomp, igual a 0 quando passado na string atual

00:35:33.160 --> 00:35:36.050
e isso é entrada do usuário?

00:35:36.050 --> 00:35:39.790
Então, se você ler a documentação para esta função chamada str compare,

00:35:39.790 --> 00:35:44.500
você verá que são necessárias duas strings como entrada, a primeira e a segunda.

00:35:44.500 --> 00:35:47.140
Então... alguém décadas atrás escreveu o código

00:35:47.140 --> 00:35:49.060
que provavelmente usa um loop for ou um loop while

00:35:49.060 --> 00:35:51.910
para comparar cada caractere em cada uma dessas strings.

00:35:51.910 --> 00:35:56.290
E acontece que retorna 0 se eles forem, de fato, iguais.

00:35:56.290 --> 00:36:00.640
Acontece que também retornará um número positivo ou um número negativo

00:36:00.640 --> 00:36:02.440
em outras situações.

00:36:02.440 --> 00:36:04.990
Qualquer intuição de por que isso pode realmente ser

00:36:04.990 --> 00:36:10.810
útil ter uma função que permite verificar se duas strings são iguais?

00:36:10.810 --> 00:36:13.480
Se eles não são iguais, o que mais pode ser interessante saber

00:36:13.480 --> 00:36:14.830
ao comparar duas strings?

00:36:18.474 --> 00:36:19.391
Se certos valores são?

00:36:19.391 --> 00:36:23.347
ALUNO: [INAUDÍVEL]

00:36:23.347 --> 00:36:24.430
DAVID MALAN: OK, possivelmente.

00:36:24.430 --> 00:36:26.950
Talvez você queira saber o quão semelhantes eles são.

00:36:26.950 --> 00:36:28.810
E isso é de fato um algoritmo em si.

00:36:28.810 --> 00:36:31.410
Mas str compare é um pouco mais simples do que isso.

00:36:31.410 --> 00:36:33.040
ALUNO: [INAUDÍVEL]

00:36:35.850 --> 00:36:39.100
DAVID MALAN: Exatamente, se você está tentando colocar em ordem alfabética toda uma lista de strings,

00:36:39.100 --> 00:36:41.950
assim como seu telefone provavelmente é para seus contatos ou catálogo de endereços.

00:36:41.950 --> 00:36:44.320
Acontece que a comparação str irá realmente

00:36:44.320 --> 00:36:48.220
retornar um número positivo ou um número negativo ou um 0

00:36:48.220 --> 00:36:52.120
com base em se, talvez vem em ordem alfabética primeiro ou depois,

00:36:52.120 --> 00:36:53.800
ou de fato, igual.

00:36:53.800 --> 00:36:55.130
Então isso pode ser uma coisa útil.

00:36:55.130 --> 00:36:57.838
E isso é apenas um teaser para uma explicação de nível inferior

00:36:57.838 --> 00:36:58.880
que veremos na próxima semana.

00:36:58.880 --> 00:37:01.750
Então agora, deixe-me cruzar os dedos e ver se acertei.

00:37:01.750 --> 00:37:05.410
Deixe-me ir em frente e fazer uma pesquisa.

00:37:05.410 --> 00:37:08.590
Compilou, embora lentamente.

00:37:08.590 --> 00:37:11.920
Pesquisa de ponto e barra, e vamos procurar algo como o dedal.

00:37:11.920 --> 00:37:14.048
E vemos que isso é, de fato, encontrado.

00:37:14.048 --> 00:37:16.090
Caso contrário, vamos procurar algo que eu saiba

00:37:16.090 --> 00:37:19.060
não está lá, como um carro de corrida, que estava lá quando eu cresci.

00:37:19.060 --> 00:37:23.227
Mas hein, falha de segmentação, núcleo despejado.

00:37:23.227 --> 00:37:25.810
E, na verdade, alguns de vocês já tropeçaram nesse erro antes.

00:37:25.810 --> 00:37:27.220
Alguém quer admitir ter visto isso?

00:37:27.220 --> 00:37:29.350
Então, sim, não é algo sobre o qual conversamos,

00:37:29.350 --> 00:37:32.170
e honestamente, não é algo que eu pretendia agora.

00:37:32.170 --> 00:37:34.450
Mas isso também, veremos na próxima semana.

00:37:34.450 --> 00:37:39.920
Qualquer intuição de por que meu programa acabou de quebrar.

00:37:39.920 --> 00:37:41.900
Eu realmente não mudei a lógica.

00:37:41.900 --> 00:37:43.550
Ainda é uma pesquisa linear.

00:37:43.550 --> 00:37:46.280
Deixe-me ocultar o terminal para que você possa ver todo o código de uma vez.

00:37:46.280 --> 00:37:49.850
A única coisa que fiz foi mudar de números inteiros para strings.

00:37:49.850 --> 00:37:52.310
E eu mudei para comparar str aqui.

00:37:52.310 --> 00:37:54.205
Mas a falha de segmentação aconteceu.

00:37:54.205 --> 00:37:57.080
E o teaser é que de alguma forma se relaciona com a memória do computador.

00:37:57.080 --> 00:37:57.996
Sim.

00:37:57.996 --> 00:38:00.690
ALUNO: [INAUDÍVEL]

00:38:01.470 --> 00:38:03.670
DAVID MALAN: Sim, e isso é sutil, mas preciso.

00:38:03.670 --> 00:38:06.510
Então um, dois, três, quatro, cinco, seis elementos

00:38:06.510 --> 00:38:11.880
total nesta matriz, contra os sete números de denominações de monopólio

00:38:11.880 --> 00:38:12.810
que tínhamos anteriormente.

00:38:12.810 --> 00:38:13.888
E é aqui, viu?

00:38:13.888 --> 00:38:15.930
Tipo de caso em questão, isso voltou para me morder.

00:38:15.930 --> 00:38:19.860
O fato de ter codificado esse valor em vez de talvez separá-lo

00:38:19.860 --> 00:38:22.260
como uma constante ou declarando-o mais alto, meio que

00:38:22.260 --> 00:38:26.610
me mordeu aqui, porque agora estou iterando em uma matriz de tamanho 6.

00:38:26.610 --> 00:38:29.820
Mas claramente, estou indo longe demais, porque estou literalmente

00:38:29.820 --> 00:38:32.250
vai iterar sete vezes, não seis.

00:38:32.250 --> 00:38:35.580
Então é como se eu estivesse olhando para a memória que está aqui.

00:38:35.580 --> 00:38:37.530
E, de fato, na próxima semana, vamos nos concentrar na memória.

00:38:37.530 --> 00:38:38.860
E isso é apenas uma coisa ruim.

00:38:38.860 --> 00:38:42.270
Portanto, é provável que nem mesmo veja seu código da semana passada, se algum de vocês

00:38:42.270 --> 00:38:46.020
teve falhas de segmentação, provavelmente você tocou na memória

00:38:46.020 --> 00:38:47.280
que você não deveria ter.

00:38:47.280 --> 00:38:49.290
Você talvez tenha repetido muitas vezes.

00:38:49.290 --> 00:38:52.770
Você pode ter usado um número negativo para entrar em sua matriz.

00:38:52.770 --> 00:38:55.220
Em geral, você tocou na memória que não deveria.

00:38:55.220 --> 00:38:57.720
E você tocou em um segmento de memória que não deveria.

00:38:57.720 --> 00:39:00.060
A solução, porém, pelo menos no meu caso, é simples.

00:39:00.060 --> 00:39:01.300
Apenas não faça isso.

00:39:01.300 --> 00:39:03.210
Então deixe-me ir em frente e recompilar isso.

00:39:03.210 --> 00:39:06.870
Faça pesquisa de barra de ponto de pesquisa.

00:39:06.870 --> 00:39:10.320
E vou procurar novamente por carro de corrida, Enter.

00:39:10.320 --> 00:39:11.850
E agora não trava.

00:39:11.850 --> 00:39:13.630
Mas ele me diz que não foi encontrado.

00:39:13.630 --> 00:39:17.040
Tão sutil, mas algo em que você mesmo já deve ter tropeçado.

00:39:17.040 --> 00:39:23.190
Perguntas então, sobre o que acabei de fazer, intencionalmente ou não.

00:39:23.190 --> 00:39:24.423
Sim, na frente.

00:39:24.423 --> 00:39:29.060
ALUNO: Uma coisa é que o programa ainda funciona se você voltar...

00:39:29.060 --> 00:39:31.275
se você não fizer, retorne 0, retorne 1.

00:39:31.275 --> 00:39:33.220
Então, qual é o propósito de fazer [INAUDÍVEL]??

00:39:33.220 --> 00:39:34.720
DAVID MALAN: Uma pergunta muito boa.

00:39:34.720 --> 00:39:38.920
Portanto, o programa ainda funcionará mesmo que eu não retorne 0 ou retorne 1.

00:39:38.920 --> 00:39:43.120
Na verdade, deixe-me fazer isso e apenas ocultar minha janela de terminal

00:39:43.120 --> 00:39:43.930
por um segundo.

00:39:43.930 --> 00:39:46.210
Vamos nos livrar do retorno aqui.

00:39:46.210 --> 00:39:48.040
Vamos nos livrar do retorno aqui.

00:39:48.040 --> 00:39:50.810
No entanto, observe o que acontece aqui.

00:39:50.810 --> 00:39:53.710
Deixe-me ir em frente e recompilar isso, fazer uma pesquisa.

00:39:53.710 --> 00:39:55.610
Deixe-me rolar para cima no meu código aqui.

00:39:55.610 --> 00:39:57.560
Deixe-me ir em frente e fazer pesquisa de barra de ponto.

00:39:57.560 --> 00:40:00.280
E deixe-me ir em frente e procurar a primeira coisa na lista,

00:40:00.280 --> 00:40:02.800
navio de guerra, então eu sei que isso deve ser encontrado.

00:40:02.800 --> 00:40:04.690
Eu apertei Enter.

00:40:04.690 --> 00:40:05.858
Ei, interessante.

00:40:05.858 --> 00:40:07.150
Então está dizendo encontrado não encontrado.

00:40:07.150 --> 00:40:11.496
Mas você vê por que, logicamente, neste caso?

00:40:11.496 --> 00:40:12.980
ALUNO: O loop ainda está funcionando?

00:40:12.980 --> 00:40:13.910
DAVID MALAN: Exatamente.

00:40:13.910 --> 00:40:15.302
Portanto, o loop ainda está em execução.

00:40:15.302 --> 00:40:17.010
Portanto, há algumas soluções para isso.

00:40:17.010 --> 00:40:21.080
Eu poderia, por exemplo, de alguma forma quebrar o código aqui.

00:40:21.080 --> 00:40:24.200
Mas isso ainda resultará na execução da linha 18.

00:40:24.200 --> 00:40:26.600
Eu poderia então apenas voltar aqui.

00:40:26.600 --> 00:40:29.390
Eu não preciso estritamente retornar 1 para baixo na parte inferior.

00:40:29.390 --> 00:40:31.580
Mas eu fiz esta afirmação na semana passada que tende

00:40:31.580 --> 00:40:35.600
ser útil à medida que seus programas se tornam mais sofisticados, pelo menos significar,

00:40:35.600 --> 00:40:39.300
assim como um programador do mundo real, códigos de erro quando algo dá errado.

00:40:39.300 --> 00:40:44.090
Portanto, retornar 0 em main é a maneira mais fácil de indicar que meu código está pronto.

00:40:44.090 --> 00:40:46.340
Estou pronto para sair com sucesso, é isso.

00:40:46.340 --> 00:40:48.988
Mas aqui, eu ainda poderia retornar 0,

00:40:48.988 --> 00:40:50.280
porque isso não é grande coisa.

00:40:50.280 --> 00:40:53.870
Não é bem um erro que mereça incomodar o usuário com algum tipo de pop

00:40:53.870 --> 00:40:55.200
que algo deu errado.

00:40:55.200 --> 00:40:57.830
Mas o retorno 1 é apenas uma forma de sinalização de nível inferior,

00:40:57.830 --> 00:41:00.330
eh, realmente não encontrou o que eu estava procurando.

00:41:00.330 --> 00:41:03.510
E lembre-se da semana passada, você pode ver isso da seguinte maneira.

00:41:03.510 --> 00:41:08.060
Se eu recompilar isso novamente, agora que reverti essas alterações, faça uma pesquisa.

00:41:08.060 --> 00:41:13.100
E se eu fizer uma pesquisa de ponto e barra e procurar navio de guerra,

00:41:13.100 --> 00:41:16.700
que é realmente encontrado, lembre-se de que posso executar este comando mágico,

00:41:16.700 --> 00:41:19.790
echo cifrão ponto de interrogação, que você não vai executar com frequência.

00:41:19.790 --> 00:41:22.790
Mas mostra o que main retornou.

00:41:22.790 --> 00:41:27.770
Se eu executar a pesquisa novamente e procurar por carro de corrida, que não foi encontrado,

00:41:27.770 --> 00:41:30.530
Vejo não encontrado, mas também posso executar este comando novamente

00:41:30.530 --> 00:41:32.150
e veja que, oh, ele retornou 1.

00:41:32.150 --> 00:41:35.300
Agora, se você avançar alguns meses, alguns anos, quando estiver realmente

00:41:35.300 --> 00:41:37.850
escrever código em uma empresa ou para projetos maiores,

00:41:37.850 --> 00:41:40.100
você pode querer automatizar o software.

00:41:40.100 --> 00:41:43.100
Você pode não querer que o humano necessariamente o execute manualmente.

00:41:43.100 --> 00:41:47.240
Você pode querer que o código seja automatizado por algum processo noturno

00:41:47.240 --> 00:41:48.360
ou algo assim.

00:41:48.360 --> 00:41:53.030
Usando esses códigos de saída, um programa pode determinar sim ou não

00:41:53.030 --> 00:41:55.910
esse outro código foi bem-sucedido ou falhou.

00:41:55.910 --> 00:42:01.850
Outras questões sobre pesquisa linear desta forma.

00:42:01.850 --> 00:42:02.350
Não?

00:42:02.350 --> 00:42:07.570
Tudo bem, bem, vamos traduzir isso para outro recurso de C

00:42:07.570 --> 00:42:11.590
aqui incorporando essas duas idéias agora em um outro programa.

00:42:11.590 --> 00:42:16.605
Vou criar um catálogo telefônico em C fazendo code space phonebook dot C.

00:42:16.605 --> 00:42:18.730
E vamos combinar algumas dessas ideias e implementar

00:42:18.730 --> 00:42:21.700
essa noção de procurar um nome real em uma lista telefônica

00:42:21.700 --> 00:42:23.030
e recebendo de volta um número.

00:42:23.030 --> 00:42:26.500
Vou seguir em frente e incluir rapidamente algumas das mesmas coisas, cs50.h

00:42:26.500 --> 00:42:28.060
para que possamos obter entrada.

00:42:28.060 --> 00:42:30.860
padrão io dot h para que possamos imprimir a saída.

00:42:30.860 --> 00:42:33.310
E vou incluir preventivamente string.h

00:42:33.310 --> 00:42:35.320
caso precisemos dele também.

00:42:35.320 --> 00:42:39.010
int main void, não há necessidade de argumentos de linha de comando hoje.

00:42:39.010 --> 00:42:42.650
E deixe-me dar a mim mesmo, agora, uma série de nomes para esta lista telefônica.

00:42:42.650 --> 00:42:45.040
Portanto, os nomes das strings são iguais.

00:42:45.040 --> 00:42:47.620
E então entre chaves, que tal Carter

00:42:47.620 --> 00:42:50.840
será uma pessoa na lista telefônica, e David, eu, será a outra.

00:42:50.840 --> 00:42:53.465
Portanto, vamos mantê-lo curto para não termos que digitar muitos nomes.

00:42:53.465 --> 00:42:55.840
Mas esta é uma lista telefônica com duas pessoas até agora.

00:42:55.840 --> 00:42:59.628
Suponha, agora, que também queiramos armazenar o número de telefone de Carter em mente.

00:42:59.628 --> 00:43:01.420
Portanto, não é apenas dizer encontrado ou não encontrado.

00:43:01.420 --> 00:43:05.320
É literalmente procurar nossos números de telefone como uma lista telefônica adequada.

00:43:05.320 --> 00:43:09.440
Bem, no momento, realmente não há como fazer isso.

00:43:09.440 --> 00:43:15.460
Eu poderia fazer algo hackeado como colocar um número como 617-495-1000

00:43:15.460 --> 00:43:16.510
depois de Carter.

00:43:16.510 --> 00:43:22.460
Talvez eu pudesse fazer algo como 949-468-2750 depois de mim.

00:43:22.460 --> 00:43:25.300
Mas agora você está meio que fazendo a coisa toda de maçãs e laranjas.

00:43:25.300 --> 00:43:26.470
Agora, não são cordas.

00:43:26.470 --> 00:43:28.420
É uma string int, string int.

00:43:28.420 --> 00:43:31.240
Tudo bem, então talvez eu possa fazer todas essas cordas.

00:43:31.240 --> 00:43:34.600
Mas agora é apenas uma mistura conceitual de maçãs e laranjas.

00:43:34.600 --> 00:43:36.425
Como sim, é uma matriz de quatro strings.

00:43:36.425 --> 00:43:39.550
Mas agora você está no sistema de honra para saber que a primeira string é um nome,

00:43:39.550 --> 00:43:42.160
a segunda string é um número, a terceira string é--

00:43:42.160 --> 00:43:43.100
Você consegue.

00:43:43.100 --> 00:43:45.110
Mas é meio que um hack, por assim dizer.

00:43:45.110 --> 00:43:47.300
Então, o que pode ser mais limpo do que isso?

00:43:47.300 --> 00:43:51.070
Em vez de combinar nossos números de telefone na mesma matriz de nossos nomes,

00:43:51.070 --> 00:43:55.480
o que mais podemos fazer que talvez seja um pouco melhor?

00:43:55.480 --> 00:43:56.440
Diga um pouco mais alto.

00:43:58.960 --> 00:44:01.197
Uma matriz 2D, possivelmente algo que poderíamos fazer.

00:44:01.197 --> 00:44:04.030
Vou simplificar ainda mais agora, porque não usamos esses

00:44:04.030 --> 00:44:07.823
pelo nome, mesmo que seja, vimos na semana passada, tecnicamente o que é argv.

00:44:07.823 --> 00:44:10.240
O que mais posso fazer se quiser armazenar nomes e números?

00:44:10.240 --> 00:44:11.147
Sim.

00:44:11.147 --> 00:44:12.220
ALUNO: [INAUDÍVEL]

00:44:12.220 --> 00:44:13.690
DAVID MALAN: Sim, deixe-me ir com esta sugestão.

00:44:13.690 --> 00:44:14.607
É um pouco mais simples.

00:44:14.607 --> 00:44:17.440
Em vez de complicar as coisas em dimensões literalmente diferentes,

00:44:17.440 --> 00:44:18.970
deixe-me ir em frente e fazer string.

00:44:18.970 --> 00:44:21.730
Bem, eu poderia fazer números inteiros.

00:44:21.730 --> 00:44:22.690
Mas você sabe o que?

00:44:22.690 --> 00:44:27.700
Para que possamos suportar pontuação como travessões ou até mesmo parênteses ou país

00:44:27.700 --> 00:44:29.200
códigos, eu vou fazer isso em seu lugar.

00:44:29.200 --> 00:44:33.760
Vou fazer números de string para que eu possa representar o número de Carter como citação

00:44:33.760 --> 00:44:39.040
sem aspas mais 1 para os EUA, 617-495-1000, completo com hifens,

00:44:39.040 --> 00:44:40.390
como é a convenção dos EUA.

00:44:40.390 --> 00:44:47.930
E então, para o meu, vou em frente e faço +1-949-468-2750 ponto e vírgula.

00:44:47.930 --> 00:44:51.610
E agora abaixo, vamos permitir que o usuário pesquise este telefone

00:44:51.610 --> 00:44:53.860
livro, assim como na semana 0 fizemos.

00:44:53.860 --> 00:44:55.960
O nome da string é igual a get string.

00:44:55.960 --> 00:44:58.960
E vamos pedir um nome ao usuário, presumivelmente David ou Carter

00:44:58.960 --> 00:44:59.990
ou outra pessoa.

00:44:59.990 --> 00:45:01.850
E agora vamos reimplementar a pesquisa linear.

00:45:01.850 --> 00:45:05.920
Então 4, int eu obtenho 0. i é menor que 2.

00:45:05.920 --> 00:45:07.510
E faça o que eu digo, não o que eu faço.

00:45:07.510 --> 00:45:09.700
Acho que devemos tomar cuidado com essa codificação rígida,

00:45:09.700 --> 00:45:12.010
mas vamos simplificar por enquanto.

00:45:12.010 --> 00:45:13.220
i++.

00:45:13.220 --> 00:45:16.390
E então, neste loop for, acho que temos todos os ingredientes

00:45:16.390 --> 00:45:17.150
para resolver isso.

00:45:17.150 --> 00:45:23.440
Portanto, se o valor de retorno de str comparar todos os nomes entre colchetes

00:45:23.440 --> 00:45:28.810
eu comparando com o nome que o humano digitou, se tudo isso for igual

00:45:28.810 --> 00:45:33.380
igual a 0, ou seja, todos os caracteres nessas duas strings são iguais,

00:45:33.380 --> 00:45:36.770
então acho que podemos ir em frente e dizer encontrado, como da última vez.

00:45:36.770 --> 00:45:37.520
Mas você sabe o que?

00:45:37.520 --> 00:45:40.130
Vamos imprimir o número do Carter ou o meu.

00:45:40.130 --> 00:45:44.770
Então encontramos a porcentagem s, e vamos inserir os números, parênteses i.

00:45:44.770 --> 00:45:47.800
E então, apenas para consistência, retornarei 0 aqui.

00:45:47.800 --> 00:45:52.210
E aqui embaixo, que tal eu dizer algo como printf not

00:45:52.210 --> 00:45:53.600
encontrado, só para ficar claro.

00:45:53.600 --> 00:45:56.240
E então eu vou retornar 1 também.

00:45:56.240 --> 00:45:58.120
Então, só para recapitular, aqui está todo o código.

00:45:58.120 --> 00:46:01.610
É quase o mesmo de antes, exceto que agora é útil.

00:46:01.610 --> 00:46:03.460
Não estou apenas dizendo encontrado ou não encontrado.

00:46:03.460 --> 00:46:07.180
Encontrei um número no monopólio ou encontrei uma peça no monopólio.

00:46:07.180 --> 00:46:09.880
Estou procurando em um array, uma das strings.

00:46:09.880 --> 00:46:12.730
E então estou imprimindo da outra matriz, a resposta.

00:46:12.730 --> 00:46:19.480
Então deixe-me ir em frente aqui e executar o compilador, fazer lista telefônica, Enter.

00:46:19.480 --> 00:46:21.070
OK, isso é promissor, sem erros.

00:46:21.070 --> 00:46:22.720
Ponto barra agenda telefônica agora.

00:46:22.720 --> 00:46:26.350
E vamos pesquisar, por exemplo, Carter Enter.

00:46:26.350 --> 00:46:28.060
Certo, encontramos o número do Carter.

00:46:28.060 --> 00:46:29.393
Tudo bem, deixe-me fazer isso de novo.

00:46:29.393 --> 00:46:30.960
Lista telefónica, vamos procurar o David.

00:46:30.960 --> 00:46:32.960
Certo, parece que encontramos o número de David.

00:46:32.960 --> 00:46:34.502
Tudo bem, vamos fazer isso uma última vez.

00:46:34.502 --> 00:46:35.410
Lista telefónica, Enter.

00:46:35.410 --> 00:46:37.360
E agora vamos procurar por John Harvard.

00:46:37.360 --> 00:46:40.060
Digite, não encontrado.

00:46:40.060 --> 00:46:45.520
Tudo bem, então eu ouso dizer, embora com testes mínimos, este código está correto.

00:46:45.520 --> 00:46:48.190
Alguém agora gostaria de criticar o design?

00:46:48.190 --> 00:46:51.910
Algo o incomoda, talvez, sobre essa abordagem aqui?

00:46:55.120 --> 00:46:58.180
E como sempre, pense em como, se o programa talvez

00:46:58.180 --> 00:47:01.510
fica mais longo, mais complicado, como decisões como essa podem se desenrolar.

00:47:01.510 --> 00:47:02.448
Sim.

00:47:02.448 --> 00:47:04.400
ALUNO: Se i for menor que 2.

00:47:04.400 --> 00:47:07.820
DAVID MALAN: OK, então se i for menor que 2, tecnicamente,

00:47:07.820 --> 00:47:10.080
se eu alterar o número de pessoas nesta lista telefônica,

00:47:10.080 --> 00:47:11.330
vou ter que atualizar o i.

00:47:11.330 --> 00:47:13.290
E já vimos que me meto em problemas.

00:47:13.290 --> 00:47:14.165
Então isso é um design ruim.

00:47:14.165 --> 00:47:15.005
Bom.

00:47:15.005 --> 00:47:17.795
ALUNO: Digamos que você adicione o nome de alguém à lista telefônica,

00:47:17.795 --> 00:47:20.710
mas você não tem o número correspondente.

00:47:20.710 --> 00:47:23.380
Então, quando você vai puxar o número deles,

00:47:23.380 --> 00:47:24.730
é [INAUDÍVEL] o número de alguém.

00:47:24.730 --> 00:47:25.480
DAVID MALAN: Sim.

00:47:25.480 --> 00:47:28.180
Então, novamente, estou confiando em mim mesmo para não estragar tudo.

00:47:28.180 --> 00:47:30.850
Se eu adicionar John ou qualquer outra pessoa ao primeiro array

00:47:30.850 --> 00:47:34.180
mas eu esqueço de adicionar o número deles à segunda matriz,

00:47:34.180 --> 00:47:36.640
eventualmente, as coisas vão se desviar e ser inconsistentes.

00:47:36.640 --> 00:47:39.010
E então o código estará incorreto nesse ponto.

00:47:39.010 --> 00:47:43.420
Então, um design ruim me preparando para um fracasso futuro, se você quiser.

00:47:43.420 --> 00:47:44.860
Outros pensamentos?

00:47:44.860 --> 00:47:45.460
Sim.

00:47:45.460 --> 00:47:49.816
ALUNO: [INAUDÍVEL] então se você trocasse a ordem dos números

00:47:49.816 --> 00:47:52.848
mas não o principal [INAUDÍVEL]

00:47:52.848 --> 00:47:54.140
DAVID MALAN: Sim, muito bom.

00:47:54.140 --> 00:47:55.550
Estamos assumindo a mesma ordem.

00:47:55.550 --> 00:47:59.452
Da esquerda para a direita, vão os nomes, e da esquerda para a direita, vão os números.

00:47:59.452 --> 00:48:01.160
Mas isso é apenas o sistema de honra.

00:48:01.160 --> 00:48:03.440
Tipo, não há literalmente nada no código me impedindo

00:48:03.440 --> 00:48:07.047
de inverter a ordem por qualquer motivo, ou talvez classificar os nomes.

00:48:07.047 --> 00:48:10.130
Tipo, eles estão classificados agora, e talvez isso seja deliberado, mas talvez não seja.

00:48:10.130 --> 00:48:12.920
Portanto, este sistema de honra aqui também não é bom.

00:48:12.920 --> 00:48:17.180
Eu poderia colocar um comentário aqui para me lembrar, uma nota para mim mesmo,

00:48:17.180 --> 00:48:19.490
sempre atualize os arrays da mesma maneira.

00:48:19.490 --> 00:48:21.600
Mas tipo, algo vai acontecer eventualmente,

00:48:21.600 --> 00:48:26.090
especialmente quando não temos dois, mas três, mas 30, 300 nomes e números.

00:48:26.090 --> 00:48:29.670
Seria bom manter todos os dados relacionados juntos.

00:48:29.670 --> 00:48:32.810
E, de fato, o novo recurso de C que apresentaremos hoje

00:48:32.810 --> 00:48:37.970
é aquele que realmente nos permite implementar nossas próprias estruturas de dados.

00:48:37.970 --> 00:48:41.870
Você pode pensar em arrays como um conjunto de dados muito leve

00:48:41.870 --> 00:48:44.870
estrutura, na medida em que permite agrupar dados relacionados de volta

00:48:44.870 --> 00:48:45.930
para trás para trás para trás.

00:48:45.930 --> 00:48:48.170
E é assim que as strings são implementadas.

00:48:48.170 --> 00:48:51.560
Eles são uma estrutura de dados efetivamente implementada com uma matriz.

00:48:51.560 --> 00:48:54.290
Mas com C e com outras linguagens, acontece

00:48:54.290 --> 00:48:56.600
você pode inventar seus próprios tipos de dados, sejam eles

00:48:56.600 --> 00:48:59.870
unidimensional, bidimensional mesmo, ou além.

00:48:59.870 --> 00:49:05.960
E com C, você pode criar especificamente seus próprios tipos

00:49:05.960 --> 00:49:07.200
que têm seus próprios nomes?

00:49:07.200 --> 00:49:10.670
Então, por exemplo, não teria sido bom se C viesse com,

00:49:10.670 --> 00:49:16.380
não apenas char e int e floats e long e outros.

00:49:16.380 --> 00:49:19.970
Não seria bom se C viesse com um tipo de dado chamado pessoa?

00:49:19.970 --> 00:49:22.790
E, idealmente, uma pessoa teria um nome e um número.

00:49:22.790 --> 00:49:24.860
Agora, isso é um pouco ingênuo e irreal.

00:49:24.860 --> 00:49:28.460
Tipo, por que eles definiriam uma pessoa para ter apenas esses dois campos.

00:49:28.460 --> 00:49:30.950
Certamente, as pessoas poderiam ter discordado sobre o que é uma pessoa.

00:49:30.950 --> 00:49:32.300
Então eles deixam isso para nós.

00:49:32.300 --> 00:49:35.900
Os autores de C nos deram todos esses primitivos, ints e floats e strings

00:49:35.900 --> 00:49:36.810
e assim por diante.

00:49:36.810 --> 00:49:39.810
Mas cabe a nós agora usá-los de uma maneira mais interessante

00:49:39.810 --> 00:49:44.940
para que possamos criar uma matriz de variáveis ​​pessoais, se preferir,

00:49:44.940 --> 00:49:48.150
dentro de um array chamado pessoas, só para pluralizar aqui.

00:49:48.150 --> 00:49:49.740
Então, como vamos fazer isso?

00:49:49.740 --> 00:49:54.140
Bem, por enquanto, vamos apenas estipular que uma pessoa no mundo

00:49:54.140 --> 00:49:57.260
terá um nome e um número que poderíamos discutir o dia todo o que mais

00:49:57.260 --> 00:49:58.010
uma pessoa deveria ter.

00:49:58.010 --> 00:49:58.677
E tudo bem.

00:49:58.677 --> 00:50:01.790
Você pode inventar sua própria pessoa eventualmente.

00:50:01.790 --> 00:50:04.610
No momento, estou usando apenas duas variáveis

00:50:04.610 --> 00:50:06.500
para definir o nome e o número de uma pessoa.

00:50:06.500 --> 00:50:10.490
Mas não seria bom encapsular, ou seja, combinar esses dois dados

00:50:10.490 --> 00:50:14.660
tipos, em um tipo de dados novo e aprimorado chamado pessoa.

00:50:14.660 --> 00:50:17.360
E a sintaxe para isso será esta.

00:50:17.360 --> 00:50:18.800
Então é um pouco de boca cheia.

00:50:18.800 --> 00:50:21.960
Mas você pode, talvez, inferir o que parte disso está fazendo aqui.

00:50:21.960 --> 00:50:24.500
Acontece que C tem uma palavra-chave chamada typedef.

00:50:24.500 --> 00:50:28.310
Como o nome sugere, isso permite que você defina seu próprio tipo.

00:50:28.310 --> 00:50:31.550
Struct é uma indicação de que é uma estrutura.

00:50:31.550 --> 00:50:35.060
É como uma estrutura que tem vários valores dentro dela

00:50:35.060 --> 00:50:36.710
que você está tentando definir.

00:50:36.710 --> 00:50:39.440
E então bem no fundo aqui fora das chaves,

00:50:39.440 --> 00:50:42.270
é o nome do tipo que você deseja criar.

00:50:42.270 --> 00:50:45.790
Portanto, você não tem critério sobre o uso de typedef ou struct

00:50:45.790 --> 00:50:46.790
neste caso específico.

00:50:46.790 --> 00:50:48.665
Mas você pode nomear a coisa como quiser.

00:50:48.665 --> 00:50:52.590
E você também pode colocar o que quiser na estrutura.

00:50:52.590 --> 00:50:56.510
E assim que o ponto e vírgula for executado na parte inferior do código,

00:50:56.510 --> 00:50:59.180
cada linha depois disso agora pode ter acesso

00:50:59.180 --> 00:51:05.760
a um tipo de dados de pessoa, seja como uma única variável ou como uma matriz inteira.

00:51:05.760 --> 00:51:10.260
Então, se eu quiser construir sobre isso, deixe-me ir em frente e fazer isso.

00:51:10.260 --> 00:51:12.230
Deixe-me voltar ao meu código C aqui.

00:51:12.230 --> 00:51:17.610
E vou seguir em frente e mudar apenas algumas coisas.

00:51:17.610 --> 00:51:19.110
Vamos em frente e fazer isso.

00:51:19.110 --> 00:51:23.240
Vou seguir em frente e, primeiro, me livrar desses dois arrays codificados.

00:51:23.240 --> 00:51:27.180
E deixe-me ir em frente e, no topo do meu arquivo,

00:51:27.180 --> 00:51:30.180
invente esse tipo, então typedef struct.

00:51:30.180 --> 00:51:34.470
Dentro dele haverá um nome de string e, em seguida, um número de string.

00:51:34.470 --> 00:51:36.780
E então o nome da estrutura será pessoa.

00:51:36.780 --> 00:51:40.025
E as melhores práticas me fariam defini-lo bem no topo do meu arquivo

00:51:40.025 --> 00:51:42.150
para que qualquer uma das minhas funções, de fato, pudesse usá-lo,

00:51:42.150 --> 00:51:44.530
mesmo que eu só tenha main neste caso.

00:51:44.530 --> 00:51:47.100
Agora, se eu quisesse, eu poderia fazer isso.

00:51:47.100 --> 00:51:50.370
Pessoa P1 e pessoa P2.

00:51:50.370 --> 00:51:53.040
Mas sabemos desde a semana passada que já é um design ruim.

00:51:53.040 --> 00:51:57.400
Se você quiser ter várias instâncias do mesmo tipo de variável,

00:51:57.400 --> 00:52:00.044
provavelmente devemos usar o que em vez disso?

00:52:00.044 --> 00:52:01.046
ALUNO: [INAUDÍVEL]

00:52:01.046 --> 00:52:01.796
DAVID MALAN: E...

00:52:01.796 --> 00:52:02.470
ALUNO: Uma matriz.

00:52:02.470 --> 00:52:03.637
DAVID MALAN: Sim, uma matriz.

00:52:03.637 --> 00:52:05.230
Então, deixe-me nem mesmo ir por esse caminho.

00:52:05.230 --> 00:52:06.700
Em vez disso, deixe-me fazer isso.

00:52:06.700 --> 00:52:09.727
Person será o tipo do array.

00:52:09.727 --> 00:52:10.810
Mas vou chamá-lo...

00:52:10.810 --> 00:52:11.980
Eu poderia chamá-lo de pessoas.

00:52:11.980 --> 00:52:13.720
Mas em inglês, normalmente dizemos pessoas.

00:52:13.720 --> 00:52:15.190
Então eu vou chamar o pessoal da matriz.

00:52:15.190 --> 00:52:18.110
E eu quero que existam duas pessoas neste array,

00:52:18.110 --> 00:52:20.920
embora eu certamente pudesse mudar esse número para qualquer coisa que eu quisesse.

00:52:20.920 --> 00:52:24.820
Como, agora, você coloca um nome dentro de uma pessoa

00:52:24.820 --> 00:52:27.190
e depois colocar o número dentro dessa mesma pessoa?

00:52:27.190 --> 00:52:28.990
Bem, uma sintaxe ligeiramente nova hoje.

00:52:28.990 --> 00:52:30.520
Eu vou seguir em frente e dizer isso.

00:52:30.520 --> 00:52:34.420
Pessoas colchete 0 apenas me dá a primeira pessoa na matriz.

00:52:34.420 --> 00:52:35.570
Isso não é novo.

00:52:35.570 --> 00:52:40.840
Mas se você quiser entrar na memória dessa pessoa, use um ponto.

00:52:40.840 --> 00:52:44.870
E então você apenas especifica o nome do atributo nele.

00:52:44.870 --> 00:52:47.410
Então, se eu quiser definir o nome da primeira pessoa como Carter,

00:52:47.410 --> 00:52:49.480
Eu apenas uso a chamada notação de ponto.

00:52:49.480 --> 00:52:52.780
E então, se eu quiser definir o número de Carter usando a notação de ponto,

00:52:52.780 --> 00:52:56.680
Eu faria isso, +1-617-495-1000.

00:52:56.680 --> 00:52:58.880
E então, se eu quiser fazer o mesmo por mim,

00:52:58.880 --> 00:53:03.730
Eu agora colocaria as pessoas entre colchetes 1 ponto nome igual aspas sem aspas David.

00:53:03.730 --> 00:53:08.440
E então as pessoas colchetes 1 ainda número de pontos é igual a aspas fecha aspas

00:53:08.440 --> 00:53:13.030
+1-949-468-2750.

00:53:13.030 --> 00:53:15.970
E agora, no final do meu arquivo, acho

00:53:15.970 --> 00:53:18.610
minha lógica pode ficar praticamente a mesma.

00:53:18.610 --> 00:53:22.180
Ainda posso, nesta linha aqui, solicitar ao usuário

00:53:22.180 --> 00:53:24.370
para o nome da pessoa que eles querem procurar.

00:53:24.370 --> 00:53:26.620
Por enquanto, embora eu admita que não é o melhor design,

00:53:26.620 --> 00:53:28.495
Estou fazendo isso apenas para fins de demonstração,

00:53:28.495 --> 00:53:31.360
Vou deixar os dois aí, porque sei que tenho duas pessoas.

00:53:31.360 --> 00:53:34.100
Mas aqui embaixo, isso vai ter que mudar.

00:53:34.100 --> 00:53:37.000
Não quero mais comparar os nomes entre colchetes i.

00:53:37.000 --> 00:53:42.190
O que eu quero digitar aqui como o primeiro argumento para comparar str?

00:53:42.190 --> 00:53:43.900
O que eu quero fazer aqui?

00:53:43.900 --> 00:53:44.960
Sim.

00:53:44.960 --> 00:53:46.800
ALUNO: Nome de pessoas que eu pontuo.

00:53:46.800 --> 00:53:49.140
DAVID MALAN: Então, as pessoas que eu menciono, sim.

00:53:49.140 --> 00:53:52.938
Então eu quero ir para o array de pessoas no i-ésimo local,

00:53:52.938 --> 00:53:54.480
porque é isso que meu loop está fazendo.

00:53:54.480 --> 00:53:55.890
Ele está atualizando i novamente e novamente.

00:53:55.890 --> 00:53:58.087
E então olhe para o nome, e isso é bom.

00:53:58.087 --> 00:53:59.670
Acho que agora preciso mudar isso também.

00:53:59.670 --> 00:54:01.890
O que eu quero imprimir se a pessoa for encontrada?

00:54:01.890 --> 00:54:02.445
Alguém?

00:54:05.070 --> 00:54:08.850
O que eu quero imprimir aqui, se eu encontrar o nome da pessoa?

00:54:08.850 --> 00:54:09.360
Sim.

00:54:09.360 --> 00:54:10.890
ALUNO: [INAUDÍVEL]

00:54:10.890 --> 00:54:12.390
DAVID MALAN: Diga um pouco mais alto.

00:54:12.390 --> 00:54:13.795
ALUNO: Pessoas que eu pontuo.

00:54:13.795 --> 00:54:14.670
DAVID MALAN: Perfeito.

00:54:14.670 --> 00:54:17.460
Então, as pessoas colchetes i número de ponto, se de fato eu

00:54:17.460 --> 00:54:20.310
deseja imprimir o número correspondente a esta pessoa.

00:54:20.310 --> 00:54:22.930
E então acho que o resto do meu código pode permanecer o mesmo.

00:54:22.930 --> 00:54:27.150
Então, deixe-me ir em frente e executar novamente o catálogo telefônico para recompilar esta versão.

00:54:27.150 --> 00:54:28.170
Até agora tudo bem.

00:54:28.170 --> 00:54:29.400
Lista telefônica ponto barra.

00:54:29.400 --> 00:54:31.598
Vamos digitar o nome de Carter, encontrado.

00:54:31.598 --> 00:54:33.390
Tudo bem, vamos em frente e executá-lo novamente.

00:54:33.390 --> 00:54:35.273
Nome de David, encontrado.

00:54:35.273 --> 00:54:36.940
Vamos em frente e executá-lo mais uma vez.

00:54:36.940 --> 00:54:40.260
Digite John Harvard, por exemplo, não encontrado, neste caso.

00:54:40.260 --> 00:54:43.710
Então, fundamentalmente, o código não é tão diferente.

00:54:43.710 --> 00:54:46.090
A busca linear ainda está se comportando da mesma maneira.

00:54:46.090 --> 00:54:48.690
E eu admito, isso é meio feio.

00:54:48.690 --> 00:54:52.350
Nós meio que fizemos uma solução de duas linhas com cinco linhas de código agora.

00:54:52.350 --> 00:54:56.640
Mas se avançarmos uma ou duas semanas quando começarmos a salvar informações

00:54:56.640 --> 00:55:01.500
a arquivos, apresentaremos a você arquivos como arquivos csv,

00:55:01.500 --> 00:55:03.892
valores separados por vírgula ou arquivos de planilha, que

00:55:03.892 --> 00:55:06.600
você certamente abriu em seu Mac ou PC em algum momento no passado.

00:55:06.600 --> 00:55:09.840
Basta dizer que em breve aprenderemos técnicas para armazenar informações,

00:55:09.840 --> 00:55:11.790
como nomes e números, em arquivos.

00:55:11.790 --> 00:55:13.680
E nesse ponto, não vamos fazer nenhum

00:55:13.680 --> 00:55:15.990
deste tipo hackish de codificação do número 2

00:55:15.990 --> 00:55:19.080
e digitando manualmente meu nome e o nome e número de Carter em nosso programa.

00:55:19.080 --> 00:55:21.750
Vamos ler as informações dinamicamente de um arquivo.

00:55:21.750 --> 00:55:25.180
E em algumas semanas, vamos lê-lo dinamicamente de um banco de dados.

00:55:25.180 --> 00:55:30.240
Mas isso é, por enquanto, apenas sintaticamente como podemos criar um array de tamanho 2

00:55:30.240 --> 00:55:32.190
contendo uma pessoa cada.

00:55:32.190 --> 00:55:34.643
Podemos atualizar o nome e o número da primeira pessoa,

00:55:34.643 --> 00:55:36.810
atualize o nome e o número da segunda pessoa,

00:55:36.810 --> 00:55:40.500
e depois pesquisar esses nomes e imprimir

00:55:40.500 --> 00:55:41.610
os números correspondentes.

00:55:41.610 --> 00:55:44.220
E, nesse sentido, esse é um design melhor.

00:55:44.220 --> 00:55:44.730
Por que?

00:55:44.730 --> 00:55:48.690
Como o tipo de dados da minha pessoa encapsula,

00:55:48.690 --> 00:55:53.400
agora, tudo o que significa ser uma pessoa, pelo menos neste mundo estreito.

00:55:53.400 --> 00:55:57.580
E se eu quiser acrescentar algo à noção de pessoa, por exemplo,

00:55:57.580 --> 00:55:59.640
Eu poderia ir para a minha definição de tipo, e amanhã,

00:55:59.640 --> 00:56:03.743
adicione um endereço para cada pessoa e comece a lê-lo também.

00:56:03.743 --> 00:56:05.160
E agora não é o sistema de honra.

00:56:05.160 --> 00:56:10.260
Não é uma matriz de nomes, uma matriz de números, uma matriz de endereços e tudo mais

00:56:10.260 --> 00:56:12.210
você pode imaginar relacionado a uma pessoa.

00:56:12.210 --> 00:56:17.223
É tudo encapsulado, que é um termo de arte dentro do mesmo tipo.

00:56:17.223 --> 00:56:19.890
Reminiscente, se alguns de vocês já programaram antes, de algo

00:56:19.890 --> 00:56:21.660
chamada programação orientada a objetos.

00:56:21.660 --> 00:56:23.190
Mas ainda não chegamos lá.

00:56:23.190 --> 00:56:24.690
C não é isso.

00:56:24.690 --> 00:56:29.280
Dúvidas sobre esse uso de struct ou essa nova sintaxe,

00:56:29.280 --> 00:56:35.037
o operador ponto sendo realmente a parte interessante aqui.

00:56:35.037 --> 00:56:35.620
Alguma pergunta?

00:56:35.620 --> 00:56:36.522
Sim.

00:56:36.522 --> 00:56:39.414
ALUNO: [INAUDÍVEL]

00:56:42.800 --> 00:56:44.420
DAVID MALAN: Em que número de linha?

00:56:44.420 --> 00:56:46.063
ALUNO: 16.

00:56:46.063 --> 00:56:46.730
DAVID MALAN: 16?

00:56:46.730 --> 00:56:51.230
Então, sim, sintaticamente, introduzimos os colchetes na semana passada.

00:56:51.230 --> 00:56:55.310
Portanto, fazer pessoas colchetes 0 significa apenas ir para a primeira pessoa na matriz.

00:56:55.310 --> 00:56:58.400
Foi como quando Stephanie literalmente abriu esta porta.

00:56:58.400 --> 00:56:59.990
Esse é o suporte de portas 0.

00:56:59.990 --> 00:57:02.330
Mas isso é, é claro, colchete de pessoas 0 em vez disso.

00:57:02.330 --> 00:57:04.580
Hoje, o ponto é uma nova peça de sintaxe.

00:57:04.580 --> 00:57:11.000
Significa entrar na memória dessa pessoa e olhar o nome que ela tem

00:57:11.000 --> 00:57:13.297
e defina-o igual a Carter e faça o mesmo para o número.

00:57:13.297 --> 00:57:13.880
Então isso é tudo.

00:57:13.880 --> 00:57:16.340
É como, abra a porta do armário, entre nele,

00:57:16.340 --> 00:57:18.410
e verifique ou defina o nome e o número.

00:57:18.410 --> 00:57:19.040
Sim.

00:57:19.040 --> 00:57:29.280
ALUNO: [INAUDÍVEL] você pode definir valores padrão para cada um dos [INAUDÍVEL]??

00:57:29.280 --> 00:57:30.840
DAVID MALAN: Atributos é bom.

00:57:30.840 --> 00:57:31.530
Boa pergunta.

00:57:31.530 --> 00:57:34.050
Na estrutura, você pode definir valores padrão?

00:57:34.050 --> 00:57:35.100
Resposta curta, não.

00:57:35.100 --> 00:57:39.000
E é aqui que o C se torna menos funcional do que as linguagens mais modernas

00:57:39.000 --> 00:57:42.580
como Python e Java e outros, onde você pode, de fato, fazer isso.

00:57:42.580 --> 00:57:44.890
Então, quando fizermos a transição para o Python em algumas semanas,

00:57:44.890 --> 00:57:47.140
veremos como podemos começar a resolver problemas como esse.

00:57:47.140 --> 00:57:50.100
Mas, por enquanto, cabe a você inicializar nome e número

00:57:50.100 --> 00:57:51.450
para algo.

00:57:51.450 --> 00:57:52.832
Sim.

00:57:52.832 --> 00:57:55.540
ALUNO: [INAUDÍVEL]

00:58:04.123 --> 00:58:05.540
DAVID MALAN: Realmente boa pergunta.

00:58:05.540 --> 00:58:08.470
Como podemos ajustar ou criticar o design do que estou fazendo?

00:58:08.470 --> 00:58:12.190
Esta é uma das poucas situações em que eu diria, hipocritamente,

00:58:12.190 --> 00:58:13.780
faça o que eu digo, não o que eu faço.

00:58:13.780 --> 00:58:17.710
Estou usando linhas bem feias como esta, apenas para introduzir a sintaxe.

00:58:17.710 --> 00:58:20.428
Mas minha reivindicação, pedagogicamente hoje, é que eventualmente,

00:58:20.428 --> 00:58:22.720
quando começamos a armazenar nomes e números ou outras coisas

00:58:22.720 --> 00:58:26.230
em arquivos ou em bancos de dados, você não terá essa redundância.

00:58:26.230 --> 00:58:29.080
Você terá uma linha de código ou duas linhas de código que

00:58:29.080 --> 00:58:31.660
ler as informações do arquivo ou banco de dados

00:58:31.660 --> 00:58:34.630
e, em seguida, preencha toda a matriz com esses dados.

00:58:34.630 --> 00:58:37.330
Por enquanto, estou apenas fazendo manualmente para manter nosso foco apenas

00:58:37.330 --> 00:58:39.400
na nova sintaxe, mas é isso.

00:58:39.400 --> 00:58:42.640
Portanto, perdoe o mau design por design hoje.

00:58:42.640 --> 00:58:45.740
Outras perguntas sobre isso?

00:58:45.740 --> 00:58:47.595
Tudo bem, isso já foi muito.

00:58:47.595 --> 00:58:50.470
Por que não vamos em frente e fazemos uma pausa de 10 minutos com lanches primeiro?

00:58:50.470 --> 00:58:53.020
Temos brownies deliciosos no saguão.

00:58:53.020 --> 00:58:55.900
Tudo bem, estamos de volta.

00:58:55.900 --> 00:58:59.890
E até agora, parece claramente bom se seus dados forem classificados,

00:58:59.890 --> 00:59:02.350
porque você pode usar a pesquisa binária.

00:59:02.350 --> 00:59:05.540
Você sabe um pouco mais sobre os dados.

00:59:05.540 --> 00:59:07.570
Mas acontece que a classificação em si

00:59:07.570 --> 00:59:10.420
é um tipo de problema para resolver também.

00:59:10.420 --> 00:59:14.830
E você pode pensar, bem, se a classificação está indo

00:59:14.830 --> 00:59:18.070
para ser bem rápido, devemos fazer isso antes de começar a pesquisar,

00:59:18.070 --> 00:59:20.237
porque isso apenas acelerará todas as nossas pesquisas.

00:59:20.237 --> 00:59:22.960
Mas se a classificação for lenta, isso nos leva à pergunta, bem,

00:59:22.960 --> 00:59:25.420
devemos nos preocupar em classificar nossos dados se estivermos apenas

00:59:25.420 --> 00:59:28.090
vai pesquisar os dados talvez uma vez, talvez duas?

00:59:28.090 --> 00:59:30.550
E então aqui vai ser, potencialmente, uma troca.

00:59:30.550 --> 00:59:33.250
Portanto, vamos considerar o que realmente significa classificar dados.

00:59:33.250 --> 00:59:35.950
No nosso caso, será simples e usará números.

00:59:35.950 --> 00:59:38.230
Mas pode, no caso dos Googles do mundo,

00:59:38.230 --> 00:59:40.880
ser páginas da web reais ou pessoas ou similares.

00:59:40.880 --> 00:59:46.090
Então, aqui está nossa imagem típica para classificar, para resolver qualquer problema.

00:59:46.090 --> 00:59:48.190
Entrada à esquerda e saída à direita.

00:59:48.190 --> 00:59:54.340
A entrada para nosso problema de classificação será um conjunto não classificado de valores.

00:59:54.340 --> 00:59:57.940
E a saída, idealmente, será o mesmo conjunto de valores classificados.

00:59:57.940 --> 01:00:00.550
E se fizermos isso concretamente, vamos supor

01:00:00.550 --> 01:00:04.786
que queremos classificar esta lista de números, 7, 2, 5, 4, 1, 6, 0,

01:00:04.786 --> 01:00:05.860
3.

01:00:05.860 --> 01:00:07.810
Então são todos os números de 0 a 7.

01:00:07.810 --> 01:00:09.757
Mas eles estão de alguma forma misturados aleatoriamente.

01:00:09.757 --> 01:00:11.590
Essa será a entrada para o problema.

01:00:11.590 --> 01:00:13.840
E o objetivo agora é classificá-los para que você, de fato,

01:00:13.840 --> 01:00:17.990
saia 0, 1, 2, 3, 4, 5, 6, 7 em vez disso.

01:00:17.990 --> 01:00:20.440
Acontece que há muitas maneiras diferentes

01:00:20.440 --> 01:00:23.900
podemos classificar números como estes aqui.

01:00:23.900 --> 01:00:27.430
E, de fato, apenas para complementar nosso exemplo de pesquisa anterior,

01:00:27.430 --> 01:00:29.952
poderíamos talvez obter rapidamente cerca de oito voluntários

01:00:29.952 --> 01:00:32.410
para aparecer se você se sentir confortável em aparecer na internet?

01:00:32.410 --> 01:00:39.100
Se você quiser fazer 1, 2, 3, 4, 5, 6, 7, 8, que tal?

01:00:39.100 --> 01:00:40.255
Tudo bem, desça.

01:00:45.040 --> 01:00:47.970
Tudo bem.

01:00:47.970 --> 01:00:50.560
Venha aqui, e eu darei a cada um de vocês um número.

01:00:50.560 --> 01:00:54.240
E se quiserem começar a se organizar na mesma ordem

01:00:54.240 --> 01:00:58.390
você vê os números no quadro.

01:00:58.390 --> 01:01:01.530
Então, olhe para cima e organize-se da esquerda

01:01:01.530 --> 01:01:04.460
para a direita nessa mesma ordem.

01:01:04.460 --> 01:01:06.210
E vamos falar primeiro de vocês-- perfeito.

01:01:06.210 --> 01:01:10.420
Se você quiser vir bem aqui, que tal estar alinhado com isso?

01:01:10.420 --> 01:01:13.990
Tudo bem, e mais alguns números.

01:01:13.990 --> 01:01:14.980
Tudo bem.

01:01:14.980 --> 01:01:19.810
Número 2, 6 e perfeito.

01:01:19.810 --> 01:01:21.625
Apenas o número certo, tudo bem.

01:01:21.625 --> 01:01:22.858
oi.

01:01:22.858 --> 01:01:24.400
Certo, lá vamos nós, número três.

01:01:24.400 --> 01:01:24.968
Tudo bem.

01:01:24.968 --> 01:01:26.260
Então, vamos fazer uma verificação rápida.

01:01:26.260 --> 01:01:30.867
Temos 7, 2, 5, 4, 1, 6, 0, 3, muito bom até agora.

01:01:30.867 --> 01:01:32.950
Você quer apenas deslizar um pouco desta maneira apenas

01:01:32.950 --> 01:01:34.510
para fazer um pouco mais de espaço?

01:01:34.510 --> 01:01:38.090
Tudo bem, e vamos considerar agora quem temos aqui no palco.

01:01:38.090 --> 01:01:40.780
Você quer que cada um diga um olá rápido para o público?

01:01:40.780 --> 01:01:42.070
RYAN: Oi, meu nome é Ryan.

01:01:42.070 --> 01:01:45.597
Eu sou um primeiro ano de Pennypacker.

01:01:45.597 --> 01:01:46.930
ITSELLE: Oi, meu nome é Itselle.

01:01:46.930 --> 01:01:49.177
Estou no primeiro ano na Strauss.

01:01:49.177 --> 01:01:50.260
LUCY: Oi, meu nome é Lucy.

01:01:50.260 --> 01:01:52.400
E eu sou um primeiro ano de Greenough.

01:01:52.400 --> 01:01:53.650
SHILOH: Oi, meu nome é Shiloh.

01:01:53.650 --> 01:01:55.927
Estou no primeiro ano em Wigglesworth.

01:01:55.927 --> 01:01:57.010
JACK: Oi, meu nome é Jack.

01:01:57.010 --> 01:01:59.877
E eu sou um primeiro ano em Strauss.

01:01:59.877 --> 01:02:01.210
KATHRYN: Oi, meu nome é Kathryn.

01:02:01.210 --> 01:02:02.787
Estou no primeiro ano na Strauss.

01:02:02.787 --> 01:02:04.120
MICHAEL: Oi, meu nome é Michael.

01:02:04.120 --> 01:02:06.063
Estou no primeiro ano na Pennypacker.

01:02:06.063 --> 01:02:07.480
MUHAMMAD: Olá, meu nome é Muhammad.

01:02:07.480 --> 01:02:09.047
Eu sou um primeiro ano em Matthews.

01:02:09.047 --> 01:02:10.630
DAVID MALAN: Oi, bom, bem-vindo a bordo.

01:02:10.630 --> 01:02:11.240
Tudo bem.

01:02:11.240 --> 01:02:16.510
Então, vamos considerar, agora, como podemos classificar nossos gentis voluntários aqui,

01:02:16.510 --> 01:02:21.160
o objetivo é colocá-los em ordem do menor para o maior, de modo que,

01:02:21.160 --> 01:02:24.160
presumivelmente, podemos usar algo mais inteligente do que apenas a pesquisa linear.

01:02:24.160 --> 01:02:26.350
Na verdade, podemos usar a pesquisa binária, assumindo

01:02:26.350 --> 01:02:27.878
que eles já estão classificados.

01:02:27.878 --> 01:02:30.670
Então, deixe-me propor que primeiro consideremos um algoritmo que realmente

01:02:30.670 --> 01:02:32.600
tem um nome chamado classificação de seleção.

01:02:32.600 --> 01:02:36.220
E a classificação por seleção vai ser aquela que literalmente me tem,

01:02:36.220 --> 01:02:40.060
ou realmente você, como programador, selecionando o menor elemento novamente

01:02:40.060 --> 01:02:43.610
e novamente, e então colocando-os no lugar apropriado.

01:02:43.610 --> 01:02:47.115
Então deixe-me ir em frente e começar aqui, começando com o número 7.

01:02:47.115 --> 01:02:49.240
No momento, 7 é o menor número que encontrei.

01:02:49.240 --> 01:02:52.610
Vou anotar isso mentalmente com uma variável mental, se preferir.

01:02:52.610 --> 01:02:53.710
Eu vou seguir em frente agora.

01:02:53.710 --> 01:02:55.460
O número 2 é obviamente menor, então estou apenas

01:02:55.460 --> 01:02:58.360
vou atualizar meu lembrete mental de que 2 agora é o menor,

01:02:58.360 --> 01:03:01.555
esquecendo efetivamente, por enquanto, o número 7.

01:03:01.555 --> 01:03:02.440
5, não menor.

01:03:02.440 --> 01:03:03.370
4, não menor.

01:03:03.370 --> 01:03:04.170
1, menor.

01:03:04.170 --> 01:03:05.920
E vou fazer uma anotação mental disso.

01:03:05.920 --> 01:03:07.030
6, não menor.

01:03:07.030 --> 01:03:08.200
0, ainda menor.

01:03:08.200 --> 01:03:11.140
Vou anotar isso mentalmente, tendo esquecido agora todo o resto.

01:03:11.140 --> 01:03:13.180
E agora o número 3 não é menor.

01:03:13.180 --> 01:03:14.290
Então, qual é o seu nome mesmo?

01:03:14.290 --> 01:03:14.630
MICHAEL: Miguel.

01:03:14.630 --> 01:03:16.240
DAVID MALAN: Então Michael é o número 0.

01:03:16.240 --> 01:03:18.310
Ele pertence, é claro, lá embaixo.

01:03:18.310 --> 01:03:20.740
Mas infelizmente-- você é--

01:03:20.740 --> 01:03:21.550
RYAN: Ryan.

01:03:21.550 --> 01:03:23.360
DAVID MALAN: Ryan está no caminho.

01:03:23.360 --> 01:03:24.580
Então o que deveríamos fazer?

01:03:24.580 --> 01:03:27.570
Como devemos começar a classificar essa lista?

01:03:27.570 --> 01:03:30.510
Onde deve ir o número 0?

01:03:30.510 --> 01:03:31.012
Sim.

01:03:31.012 --> 01:03:32.220
Quer dizer mais alto?

01:03:32.220 --> 01:03:34.545
ALUNO: Vou trocar, eu acho.

01:03:34.545 --> 01:03:36.670
DAVID MALAN: Sim, então vamos em frente e trocar.

01:03:36.670 --> 01:03:39.190
Então, se você quiser ir em frente e 0, vá onde 7 está.

01:03:39.190 --> 01:03:41.170
Precisamos abrir espaço para o número 7.

01:03:41.170 --> 01:03:44.350
Seria uma espécie de trapaça se talvez todos educadamente

01:03:44.350 --> 01:03:45.530
passou para o lado.

01:03:45.530 --> 01:03:46.030
Por que?

01:03:46.030 --> 01:03:49.000
Porque se imaginarmos todos os nossos voluntários aqui como uma matriz, tipo,

01:03:49.000 --> 01:03:52.390
é uma quantidade absurda de trabalho ter todos os elementos no array

01:03:52.390 --> 01:03:54.190
desloque-se para a esquerda apenas para abrir espaço.

01:03:54.190 --> 01:03:57.340
Então, vamos simplificar e expulsar quem estiver lá agora.

01:03:57.340 --> 01:04:00.880
Agora, talvez tenhamos sorte e o número 7 esteja realmente mais perto de seu destino.

01:04:00.880 --> 01:04:03.250
Talvez tenhamos azar e vá mais longe.

01:04:03.250 --> 01:04:05.260
Mas pelo menos resolvemos um problema.

01:04:05.260 --> 01:04:08.140
Se antes tínhamos n problemas, agora temos n menos 1,

01:04:08.140 --> 01:04:10.280
porque o número 0 está de fato no lugar certo.

01:04:10.280 --> 01:04:14.588
Então, se eu continuar a representar isso, deixe-me ir em frente e dizer 2, atualmente

01:04:14.588 --> 01:04:15.130
o menor.

01:04:15.130 --> 01:04:18.040
5, não, 4, não, 1 atualmente o menor.

01:04:18.040 --> 01:04:19.000
Vou fazer uma anotação mental.

01:04:19.000 --> 01:04:22.690
6, 7, 3, e agora deixe-me fazer uma pausa.

01:04:22.690 --> 01:04:26.000
1 é obviamente o menor elemento agora.

01:04:26.000 --> 01:04:27.760
Então eu precisava continuar?

01:04:27.760 --> 01:04:30.550
Bem, pelo menos conforme defini a classificação por seleção,

01:04:30.550 --> 01:04:33.130
Eu preciso continuar, porque eu só reivindico

01:04:33.130 --> 01:04:36.550
que estou usando uma variável em minha mente para lembrar o então menor elemento.

01:04:36.550 --> 01:04:39.970
Não sou inteligente o suficiente como nós, humanos, para lembrar, espere um minuto,

01:04:39.970 --> 01:04:41.590
1 é definitivamente o menor agora.

01:04:41.590 --> 01:04:43.190
Eu não tenho toda essa lembrança.

01:04:43.190 --> 01:04:45.590
Então, estou apenas acompanhando o agora menor.

01:04:45.590 --> 01:04:46.910
Então número 1, seu nome era?

01:04:46.910 --> 01:04:47.410
JACK: Jack.

01:04:47.410 --> 01:04:49.300
DAVID MALAN: Jack, para onde Jack deve ir?

01:04:49.300 --> 01:04:50.380
Provavelmente lá.

01:04:50.380 --> 01:04:51.670
E qual é o seu nome?

01:04:51.670 --> 01:04:51.880
PARA SI: Para mim.

01:04:51.880 --> 01:04:54.588
DAVID MALAN: OK, então Jack e Itselle, se você quiser trocar de lugar,

01:04:54.588 --> 01:04:57.430
agora resolvemos dois dos n problemas totais.

01:04:57.430 --> 01:04:58.990
E agora faremos isso um pouco mais rápido.

01:04:58.990 --> 01:05:03.880
Se cada um de vocês quiser começar a trocar conforme eu encontrar a pessoa certa, então 5 menores,

01:05:03.880 --> 01:05:06.340
4 menor, 2 é menor.

01:05:06.340 --> 01:05:07.750
Tenho que continuar verificando.

01:05:07.750 --> 01:05:09.572
OK, 2 era menor.

01:05:09.572 --> 01:05:11.780
Tudo bem, agora eu vou voltar para o começo.

01:05:11.780 --> 01:05:13.090
Tudo bem, 4 é pequeno.

01:05:13.090 --> 01:05:14.050
5 não é.

01:05:14.050 --> 01:05:14.740
6 não é.

01:05:14.740 --> 01:05:16.120
7-- oh, 3 é pequeno.

01:05:16.120 --> 01:05:17.770
Onde você quer ir?

01:05:17.770 --> 01:05:18.670
OK bom.

01:05:18.670 --> 01:05:19.810
Eu vou voltar aqui.

01:05:19.810 --> 01:05:21.060
E eu posso ser um pouco inteligente.

01:05:21.060 --> 01:05:22.810
Eu não tenho que ir até o fim,

01:05:22.810 --> 01:05:24.950
porque eu sei que essas pessoas já estão classificadas.

01:05:24.950 --> 01:05:26.630
Então eu posso pelo menos otimizar um pouco.

01:05:26.630 --> 01:05:27.970
Então agora 5 é pequeno.

01:05:27.970 --> 01:05:28.720
6 é pequeno.

01:05:28.720 --> 01:05:30.160
7 é 4, 4 é menor.

01:05:30.160 --> 01:05:33.080
Se você quiser ir no lugar lá.

01:05:33.080 --> 01:05:34.810
E agora, aqui as coisas ficam interessantes.

01:05:34.810 --> 01:05:37.180
Posso otimizar não olhando para essas pessoas

01:05:37.180 --> 01:05:39.340
mais, porque eles obviamente têm problemas resolvidos.

01:05:39.340 --> 01:05:42.970
Mas agora 5 é pequeno, 6 não é, 7 não é.

01:05:42.970 --> 01:05:45.010
OK, 5, você pode ficar onde está.

01:05:45.010 --> 01:05:46.870
Agora, um humano na sala obviamente vai

01:05:46.870 --> 01:05:49.420
para questionar por que estou perdendo mais tempo.

01:05:49.420 --> 01:05:52.090
Mas com a classificação por seleção, como defini até agora,

01:05:52.090 --> 01:05:55.840
Ainda tenho que, agora, verificar se 6 é o menor, não 7.

01:05:55.840 --> 01:05:58.520
E agora meu passo final, OK, eles estão todos no lugar.

01:05:58.520 --> 01:06:00.760
Então aqui também está essa dicotomia entre o que todos nós

01:06:00.760 --> 01:06:03.730
temos essa visão panorâmica de todo o problema, onde é óbvio

01:06:03.730 --> 01:06:05.060
onde todos precisam ir.

01:06:05.060 --> 01:06:09.137
Mas um computador implementando isso com uma matriz realmente precisa ser mais metódico.

01:06:09.137 --> 01:06:10.720
E, na verdade, estamos economizando uma etapa aqui.

01:06:10.720 --> 01:06:13.780
Se estivéssemos realmente fazendo isso, nenhum desses números seria visível.

01:06:13.780 --> 01:06:16.840
Todos os oito de nossos voluntários estariam dentro de uma porta trancada.

01:06:16.840 --> 01:06:19.220
E só então poderíamos vê-los um de cada vez.

01:06:19.220 --> 01:06:21.670
Mas estamos nos concentrando agora apenas no aspecto de classificação.

01:06:21.670 --> 01:06:24.640
Então deixe-me apenas, antes de fazermos outra demonstração aqui,

01:06:24.640 --> 01:06:29.620
proponho que o que acabei de fazer aqui em pseudocódigo foi algo assim.

01:06:29.620 --> 01:06:33.430
Para i de 0 a n menos 1, tendo em mente

01:06:33.430 --> 01:06:35.590
que 0 é sempre a esquerda da matriz.

01:06:35.590 --> 01:06:38.110
n menos 1 é sempre a extremidade direita da matriz.

01:06:38.110 --> 01:06:43.000
Para i de 0 a n menos 1, encontrei o menor número entre colchetes de números

01:06:43.000 --> 01:06:45.730
i e colchetes de números n menos 1.

01:06:45.730 --> 01:06:48.610
E essa é a maneira muito nerd de expressar essa otimização.

01:06:48.610 --> 01:06:51.490
Estou sempre começando do colchete de números i onde quer que eu esteja.

01:06:51.490 --> 01:06:53.200
E então tudo o mais para a direita.

01:06:53.200 --> 01:06:56.890
E era isso que estava me permitindo ignorar os voluntários já classificados.

01:06:56.890 --> 01:07:01.220
Se, porém, minha última linha disser troque o menor número pelos números i,

01:07:01.220 --> 01:07:03.220
acho que implementa o que nossos humanos estavam fazendo

01:07:03.220 --> 01:07:05.470
caminhando fisicamente para outro local.

01:07:05.470 --> 01:07:09.220
Tudo bem, então isso seria o que chamaremos de ordenação por seleção.

01:07:09.220 --> 01:07:11.620
Vamos seguir em frente e fazer uma segunda abordagem aqui

01:07:11.620 --> 01:07:13.360
usando um algoritmo que chamarei de classificação por bolhas.

01:07:13.360 --> 01:07:16.090
Mas para fazer isso, precisamos que todos voltem aos seus locais originais.

01:07:16.090 --> 01:07:17.320
Temos uma pequena folha de dicas no quadro

01:07:17.320 --> 01:07:19.750
se você gostaria de voltar a esta posição aqui.

01:07:19.750 --> 01:07:22.600
E deixe-me adotar uma abordagem fundamentalmente diferente, porque não sou

01:07:22.600 --> 01:07:24.850
realmente gostando da classificação de seleção como está, porque é gentil

01:07:24.850 --> 01:07:26.780
de muita caminhada para frente e para trás.

01:07:26.780 --> 01:07:30.620
E a caminhada sugere muitos, muitos passos de novo e de novo.

01:07:30.620 --> 01:07:32.090
Então, o que posso fazer em vez disso?

01:07:32.090 --> 01:07:34.840
Bem, o tipo de bolha vai me focar um pouco mais

01:07:34.840 --> 01:07:36.730
intuitivamente apenas em problemas menores.

01:07:36.730 --> 01:07:38.605
E vamos ver se isso me leva a outro lugar.

01:07:38.605 --> 01:07:42.430
Então, se eu apenas olhar para esta lista sem olhar para todos os outros, 7 e 2,

01:07:42.430 --> 01:07:43.670
isso obviamente é um problema.

01:07:43.670 --> 01:07:44.170
Por que?

01:07:44.170 --> 01:07:45.500
Porque você está fora de ordem.

01:07:45.500 --> 01:07:47.810
Então, vamos resolver um pequeno problema primeiro.

01:07:47.810 --> 01:07:49.570
Então 7 e 2, por que você não troca?

01:07:49.570 --> 01:07:54.160
Eu sei que 2 está em um lugar melhor agora, porque ela definitivamente tem menos de 7.

01:07:54.160 --> 01:07:55.540
Então acho que agora posso seguir em frente.

01:07:55.540 --> 01:07:57.350
7 e 5, problema.

01:07:57.350 --> 01:07:58.390
Então vamos resolver isso.

01:07:58.390 --> 01:07:59.830
7 e 4, problema.

01:07:59.830 --> 01:08:02.380
Vamos resolver isso, 7 e 1, vamos resolver isso.

01:08:02.380 --> 01:08:03.970
7 e 6, vamos resolver isso.

01:08:03.970 --> 01:08:05.080
7 e 0, resolva isso.

01:08:05.080 --> 01:08:06.550
7 e 3, resolva isso.

01:08:06.550 --> 01:08:07.330
Feito.

01:08:07.330 --> 01:08:09.130
Ordenado, certo?

01:08:09.130 --> 01:08:11.780
Ou obviamente não, se você apenas olhar para esses números aqui.

01:08:11.780 --> 01:08:14.530
Mas, fundamentalmente, demos uma mordida no problema.

01:08:14.530 --> 01:08:17.020
7 está de fato no lugar certo.

01:08:17.020 --> 01:08:21.170
Portanto, temos no máximo n menos 1 outros problemas para resolver.

01:08:21.170 --> 01:08:23.660
Então, como faço isso?

01:08:23.660 --> 01:08:25.700
Acho que posso repetir a mesma lógica.

01:08:25.700 --> 01:08:26.770
Deixa eu passar aqui.

01:08:26.770 --> 01:08:28.210
2 e 5, bom.

01:08:28.210 --> 01:08:29.800
5 e 4, n.

01:08:29.800 --> 01:08:31.330
5 e 1, n.

01:08:31.330 --> 01:08:32.590
5 e 6, sim.

01:08:32.590 --> 01:08:34.660
6 e 0, não.

01:08:34.660 --> 01:08:36.760
6 e 3, n.

01:08:36.760 --> 01:08:39.191
Portanto, agora resolvemos dois dos problemas.

01:08:39.191 --> 01:08:41.649
E o que há de bom no tipo de bolha, pelo menos neste olhar,

01:08:41.649 --> 01:08:42.707
é legal e simples.

01:08:42.707 --> 01:08:43.540
É bom e local.

01:08:43.540 --> 01:08:46.510
E você continua resolvendo gradualmente mais e mais problemas.

01:08:46.510 --> 01:08:48.010
Então, vamos em frente e fazer isso de novo.

01:08:48.010 --> 01:08:50.080
E eu farei isso-- podemos fazer isso mais rápido.

01:08:50.080 --> 01:08:51.760
2 e 4, sabemos que são bons.

01:08:51.760 --> 01:08:59.200
4 e 1, 4 e 5, 5 e 0, 5 e 3, 5 e 6, 6 e 7, bom.

01:08:59.200 --> 01:09:01.390
Então voltamos, 2 e 1.

01:09:01.390 --> 01:09:03.340
Ah, agora outro problema resolvido.

01:09:03.340 --> 01:09:09.939
2 e 4, 4 e 0, 4 e 3, 4 e 5, 5 e 6, 6 e 7.

01:09:09.939 --> 01:09:13.270
E então observe 2, conforme o nome, os maiores elementos

01:09:13.270 --> 01:09:14.895
borbulharam até o topo.

01:09:14.895 --> 01:09:17.020
E é isso que parece estar acontecendo exatamente quando estamos

01:09:17.020 --> 01:09:18.340
corrigindo alguns problemas remanescentes.

01:09:18.340 --> 01:09:19.120
Tão quase pronto.

01:09:19.120 --> 01:09:27.550
1 e 2, 2 e 0, 2 e 3, 3 e 4, 4 e 5, 5 e 6, 6 e 7, quase pronto.

01:09:27.550 --> 01:09:29.830
Obviamente, para nós, humanos, parece feito.

01:09:29.830 --> 01:09:32.529
Como eu sei como o computador com certeza?

01:09:32.529 --> 01:09:36.370
Qual seria o caminho mais certo para eu ir agora, não está feito, desculpe.

01:09:36.370 --> 01:09:38.080
Isso é um erro.

01:09:38.080 --> 01:09:43.390
OK, 1 e 0, 1 e 2, 2 e 3, 3 e 4, 4 e 5, 5 e 6, 6 e 7.

01:09:43.390 --> 01:09:47.899
OK, então agora está obviamente resolvido para o resto de nós no palco.

01:09:47.899 --> 01:09:50.290
Como eu poderia confirmar tanto quanto o código?

01:09:50.290 --> 01:09:52.670
Você está fazendo isso com sua mente, apenas olhando para isso.

01:09:52.670 --> 01:09:56.080
Como o computador, o código, saberia com certeza que esta lista agora está ordenada?

01:09:56.080 --> 01:09:57.000
Sim.

01:09:57.000 --> 01:09:58.500
ALUNO: [INAUDÍVEL] mais uma vez.

01:09:58.500 --> 01:10:00.000
DAVID MALAN: Vamos fazer mais uma vez.

01:10:00.000 --> 01:10:03.512
E olha, tira que conclusão?

01:10:03.512 --> 01:10:05.490
ALUNO: Que nada tem que mudar.

01:10:05.490 --> 01:10:07.365
DAVID MALAN: Sim, vamos fazer isso mais uma vez,

01:10:07.365 --> 01:10:08.860
mesmo que seja um pouco inútil.

01:10:08.860 --> 01:10:13.320
Mas logicamente, se eu passar por toda a lista comparando pares de novo, de novo,

01:10:13.320 --> 01:10:15.810
e novamente, e eu não faço nenhum trabalho dessa vez,

01:10:15.810 --> 01:10:19.133
agora é obviamente logicamente seguro simplesmente parar, porque caso contrário, estou

01:10:19.133 --> 01:10:21.300
perdendo meu tempo fazendo a mesma coisa de novo e de novo

01:10:21.300 --> 01:10:22.933
se ninguém estiver realmente se movendo.

01:10:22.933 --> 01:10:25.350
Infelizmente não temos jogos de monopólio para todos vocês.

01:10:25.350 --> 01:10:26.767
Mas temos oito bolas de estresse.

01:10:26.767 --> 01:10:30.090
E uma salva de palmas, se pudéssemos, para os nossos voluntários.

01:10:30.090 --> 01:10:33.910
Se você quiser colocar seus números na prateleira lá.

01:10:33.910 --> 01:10:36.220
Então, se considerarmos por um momento -

01:10:36.220 --> 01:10:36.720
obrigado.

01:10:36.720 --> 01:10:39.340
Muito obrigado.

01:10:39.340 --> 01:10:42.150
Claro.

01:10:42.150 --> 01:10:43.170
Obrigado.

01:10:43.170 --> 01:10:44.230
Obrigado.

01:10:44.230 --> 01:10:44.730
Claro.

01:10:44.730 --> 01:10:48.870
Então, se considerarmos agora esses dois algoritmos, qual é o melhor?

01:10:48.870 --> 01:10:51.990
Qualquer intuição sobre se a seleção classifica o primeiro

01:10:51.990 --> 01:10:55.950
é melhor ou pior do que o Bubble Sort no segundo?

01:10:55.950 --> 01:10:58.020
Alguma ideia?

01:10:58.020 --> 01:10:58.860
Sim.

01:10:58.860 --> 01:11:03.620
ALUNO: O Bubble sort é ainda melhor porque dá menos trabalho [INAUDÍVEL].

01:11:03.620 --> 01:11:06.110
DAVID MALAN: Portanto, o tipo de bolha parece menos trabalhoso,

01:11:06.110 --> 01:11:08.930
especialmente porque eu estava focando naqueles problemas localizados.

01:11:08.930 --> 01:11:11.460
Outra intuição?

01:11:11.460 --> 01:11:14.580
Classificação por seleção versus classificação por bolha.

01:11:14.580 --> 01:11:18.000
Bem, deixe-me propor que tentemos quantificar isso para que possamos realmente

01:11:18.000 --> 01:11:19.420
analisá-lo de alguma forma.

01:11:19.420 --> 01:11:22.590
E este não é um exercício que faremos constantemente para muitos algoritmos.

01:11:22.590 --> 01:11:24.940
Mas estes são bastante representativos de algoritmos.

01:11:24.940 --> 01:11:27.690
Para que possamos entender, de fato, o desempenho

01:11:27.690 --> 01:11:28.960
ou o design dessas coisas.

01:11:28.960 --> 01:11:34.350
Então, aqui está meu pseudocódigo para classificação de seleção, segundo o nome,

01:11:34.350 --> 01:11:38.500
Eu apenas seleciono iterativamente o próximo menor elemento repetidamente.

01:11:38.500 --> 01:11:41.890
Então, como podemos analisar algo assim?

01:11:41.890 --> 01:11:43.920
Bem, poderíamos apenas fazê-lo em lápis de papel

01:11:43.920 --> 01:11:46.260
e conte o número de passos que parecem

01:11:46.260 --> 01:11:48.030
ser implícito logicamente pelo código.

01:11:48.030 --> 01:11:52.260
Poderíamos literalmente contar o número de passos que eu estava dando repetidamente,

01:11:52.260 --> 01:11:52.890
da esquerda para direita.

01:11:52.890 --> 01:11:55.830
Também poderíamos apenas contar o número de comparações

01:11:55.830 --> 01:11:58.302
Eu estava fazendo com cada uma das pessoas envolvidas.

01:11:58.302 --> 01:12:00.510
E eu estava fazendo isso rapidamente no tipo de seleção.

01:12:00.510 --> 01:12:03.033
Mas toda vez que eu estava olhando para uma pessoa tentando decidir,

01:12:03.033 --> 01:12:04.950
eu quero lembrar que o número é o menor?

01:12:04.950 --> 01:12:08.580
Esse número, eu estava comparando dois valores com igual igual ou menor

01:12:08.580 --> 01:12:11.700
sinal de maior ou maior que, pelo menos se tivéssemos feito isso no código.

01:12:11.700 --> 01:12:13.110
Então essa tende a ser a norma.

01:12:13.110 --> 01:12:16.680
Ao analisar algoritmos como esses, contando o número de comparações,

01:12:16.680 --> 01:12:21.090
porque é uma espécie de unidade de medida global

01:12:21.090 --> 01:12:23.490
podemos usar para comparar inteiramente diferentes algoritmos.

01:12:23.490 --> 01:12:27.780
Portanto, pense também que, no caso geral, quando

01:12:27.780 --> 01:12:30.390
temos mais de oito voluntários, mais de sete portas,

01:12:30.390 --> 01:12:33.510
podemos generalizar nossa matriz em geral, pois isso

01:12:33.510 --> 01:12:35.220
é o primeiro elemento no colchete 0.

01:12:35.220 --> 01:12:37.770
E o final é sempre n menos 1.

01:12:37.770 --> 01:12:41.550
Portanto, matrizes ou portas, neste caso, ou voluntários,

01:12:41.550 --> 01:12:45.720
são sempre indexados numericamente de 0 em até n menos 1,

01:12:45.720 --> 01:12:47.200
se houver n deles no total.

01:12:47.200 --> 01:12:50.940
Então, como analisamos o código de classificação de seleção?

01:12:50.940 --> 01:12:56.370
Bem, quantos passos demorei para encontrar o primeiro menor elemento?

01:12:56.370 --> 01:12:58.835
Ou mais precisamente, quantas comparações eu

01:12:58.835 --> 01:13:00.960
preciso fazer quando eu andei para a esquerda para a direita para encontrar

01:13:00.960 --> 01:13:06.100
nossa primeira pessoa menor, que acabou sendo 0?

01:13:06.100 --> 01:13:09.310
Quantas comparações eu fiz ao andar da esquerda para a direita?

01:13:09.310 --> 01:13:15.850
Se houvesse oito pessoas no palco, quantas comparações totais eu faria?

01:13:15.850 --> 01:13:18.280
Como se houvesse oito pessoas, eu comparei essas pessoas.

01:13:18.280 --> 01:13:22.210
Então essa pessoa, essa pessoa, sim.

01:13:22.210 --> 01:13:23.412
Sim, então sete no total, certo?

01:13:23.412 --> 01:13:25.120
Porque se houver oito pessoas no palco,

01:13:25.120 --> 01:13:28.420
você só pode fazer sete comparações no total, porque senão você

01:13:28.420 --> 01:13:29.960
estar comparando um número a si mesmo.

01:13:29.960 --> 01:13:31.960
Parece que, no caso geral, se você

01:13:31.960 --> 01:13:34.600
tem n números que você está tentando classificar,

01:13:34.600 --> 01:13:38.560
encontrar o menor elemento primeiro leva n menos 1 comparações.

01:13:38.560 --> 01:13:41.275
Talvez n passos totais da esquerda para a direita.

01:13:41.275 --> 01:13:43.150
Mas o número de comparações, que afirmo,

01:13:43.150 --> 01:13:46.030
é apenas uma unidade de medida útil, é n menos 1.

01:13:46.030 --> 01:13:48.490
Que tal encontrar a próxima pessoa menor?

01:13:48.490 --> 01:13:51.970
Quantos passos demorei para encontrar o próximo menor número, que

01:13:51.970 --> 01:13:53.200
acabou sendo o número 1?

01:13:55.790 --> 01:13:56.855
Sim.

01:13:56.855 --> 01:13:58.340
ALUNO: [INAUDÍVEL] n menos 2.

01:13:58.340 --> 01:13:59.600
DAVID MALAN: Sim, então apenas n menos 2.

01:13:59.600 --> 01:13:59.870
Por que?

01:13:59.870 --> 01:14:01.610
Porque eu já tinha resolvido um problema.

01:14:01.610 --> 01:14:03.210
Alguém já estava na posição certa.

01:14:03.210 --> 01:14:05.490
Seria tolo continuar contando-os de novo e de novo.

01:14:05.490 --> 01:14:08.157
Assim, posso reduzir meu número de comparações para a próxima passagem

01:14:08.157 --> 01:14:09.200
para n menos 2.

01:14:09.200 --> 01:14:12.350
A terceira passagem para encontrar o terceiro menor número seria n menos 3.

01:14:12.350 --> 01:14:15.770
E então ponto, ponto, ponto, presumivelmente esta história, esta fórmula,

01:14:15.770 --> 01:14:19.620
termina quando você tem apenas um par final, as pessoas no final, para comparar.

01:14:19.620 --> 01:14:22.820
Então, se isso parece um pouco reminiscente de algum tipo de recorrência

01:14:22.820 --> 01:14:25.520
do ensino médio ou matemática ou física do ensino médio ou similares,

01:14:25.520 --> 01:14:28.220
deixe-me apenas estipular que, se você realmente fizer essa matemática

01:14:28.220 --> 01:14:32.840
e generalize, é a mesma coisa que n vezes n menos 1

01:14:32.840 --> 01:14:33.392
dividido por 2.

01:14:33.392 --> 01:14:35.100
E se você está enferrujado nisso, não é grande coisa.

01:14:35.100 --> 01:14:37.070
Apenas me comprometa com a memória a qualquer momento

01:14:37.070 --> 01:14:40.010
você soma esse tipo de série, algo mais algo ligeiramente

01:14:40.010 --> 01:14:42.302
menor, mais algo um pouco menor, cada um dos quais

01:14:42.302 --> 01:14:46.520
difere em 1, você obterá esta fórmula. n vezes n menos 1 sobre 2.

01:14:46.520 --> 01:14:50.630
Se nós, é claro, multiplicarmos isso, isso é realmente n ao quadrado menos n,

01:14:50.630 --> 01:14:51.680
tudo dividido por 2.

01:14:51.680 --> 01:14:56.540
Se continuarmos multiplicando, isso é n ao quadrado dividido por 2 menos n sobre 2.

01:14:56.540 --> 01:14:59.660
E agora, temos uma espécie de vocabulário com o qual

01:14:59.660 --> 01:15:03.140
pode falar sobre a eficiência, o design desse algoritmo.

01:15:03.140 --> 01:15:06.380
Mas, honestamente, não me importo com esse nível de precisão,

01:15:06.380 --> 01:15:09.560
como n ao quadrado dividido por 2 menos n dividido por 2.

01:15:09.560 --> 01:15:14.240
À medida que n fica muito grande, qual desses símbolos, quais desses termos

01:15:14.240 --> 01:15:17.480
realmente vai dominar, se tornar o maior influenciador

01:15:17.480 --> 01:15:20.190
sobre o valor total das etapas?

01:15:20.190 --> 01:15:20.690
Certo?

01:15:20.690 --> 01:15:21.890
É a praça, certo?

01:15:21.890 --> 01:15:23.382
Definitivamente não é n dividido por 2.

01:15:23.382 --> 01:15:24.590
Isso é economizar algum tempo.

01:15:24.590 --> 01:15:27.800
Mas n ao quadrado, conforme n fica grande, vai ficar muito grande.

01:15:27.800 --> 01:15:29.990
Se n for 100, então n ao quadrado é maior.

01:15:29.990 --> 01:15:32.570
Se n é um milhão, n ao quadrado é realmente maior.

01:15:32.570 --> 01:15:35.390
E assim, no final do dia, quando estamos apenas conversando

01:15:35.390 --> 01:15:39.140
sobre uma onda da análise da mão e limite superior, se preferir,

01:15:39.140 --> 01:15:43.130
digamos apenas que o tipo de seleção, conforme analisado aqui,

01:15:43.130 --> 01:15:45.860
é da ordem de n passos ao quadrado.

01:15:45.860 --> 01:15:47.690
Não são precisamente n passos ao quadrado.

01:15:47.690 --> 01:15:52.830
Mas você sabe o que? n ao quadrado dividido por 2, a intuição aqui pode ser que,

01:15:52.830 --> 01:15:55.250
bem, é metade disso.

01:15:55.250 --> 01:15:58.570
n ao quadrado é o que realmente importa quando n fica muito, muito grande.

01:15:58.570 --> 01:16:01.070
E é aí que você começa a pensar e tentar resolver

01:16:01.070 --> 01:16:02.445
os problemas do Google no mundo.

01:16:02.445 --> 01:16:04.670
Quando n fica grande, é quando você tem que ser mais inteligente

01:16:04.670 --> 01:16:07.490
do que apenas implementações ingênuas de qualquer algoritmo.

01:16:07.490 --> 01:16:12.480
Então, onde esse algoritmo se enquadra nessa categorização aqui?

01:16:12.480 --> 01:16:14.870
Bem, n ao quadrado, ao que parece, está na ordem

01:16:14.870 --> 01:16:19.610
de n passos quadrados, no pior caso, seja classificado ou não.

01:16:19.610 --> 01:16:23.990
Acontece, porém, limite inferior, se considerarmos esse mesmo código,

01:16:23.990 --> 01:16:28.670
suponha que o melhor cenário, como nossos oito voluntários subissem no palco.

01:16:28.670 --> 01:16:32.240
E só porque eles já se classificaram, então de 0 a 7.

01:16:32.240 --> 01:16:34.490
Suponha que eles simplesmente estivessem naquele estado.

01:16:34.490 --> 01:16:37.550
Quantos passos a loja de seleção levaria

01:16:37.550 --> 01:16:42.670
classificar uma lista já classificada de voluntários?

01:16:42.670 --> 01:16:43.420
Alguma intuição?

01:16:43.420 --> 01:16:44.318
Sim.

01:16:44.318 --> 01:16:47.186
ALUNO: Ainda seria [INAUDÍVEL]?

01:16:47.186 --> 01:16:49.717
DAVID MALAN: Ainda seria n--

01:16:49.717 --> 01:16:51.180
ALUNO: Ainda ser 7 [INAUDÍVEL].

01:16:51.180 --> 01:16:53.263
DAVID MALAN: Então, para a primeira passagem, ainda seria

01:16:53.263 --> 01:16:55.710
ser 7 para a primeira passagem pelos humanos.

01:16:55.710 --> 01:16:58.530
Porque embora, sim, eu esteja afirmando que 0 está aqui,

01:16:58.530 --> 01:17:01.920
Eu não sei que 0 é o menor até que eu perco todo o caminho

01:17:01.920 --> 01:17:03.990
ali fazendo todas as sete comparações.

01:17:03.990 --> 01:17:08.220
OK, tudo bem, a primeira passagem levou sete ou mais geralmente n menos 1 passos.

01:17:08.220 --> 01:17:11.940
E se eu procurar o próximo menor elemento, e os humanos nesta história

01:17:11.940 --> 01:17:14.370
já estão classificados de 0 a 7?

01:17:14.370 --> 01:17:17.580
Bem, sim, o número 1 está aqui, e eu os vejo primeiro.

01:17:17.580 --> 01:17:21.405
Mas eu não sei se eles são os menores até comparar com todos os outros

01:17:21.405 --> 01:17:22.530
chegar ao final da lista.

01:17:22.530 --> 01:17:24.238
E nós pensamos, oh, bem, isso foi estúpido.

01:17:24.238 --> 01:17:26.550
Eu já tinha a menor pessoa na mão então.

01:17:26.550 --> 01:17:29.820
E então este pseudocódigo, esta implementação de classificação por seleção,

01:17:29.820 --> 01:17:31.650
é meio que fixo assim.

01:17:31.650 --> 01:17:35.490
Não há nenhum caso especial que diga, se já resolvido, saia mais cedo.

01:17:35.490 --> 01:17:37.860
Sempre levará n passos ao quadrado.

01:17:37.860 --> 01:17:42.090
E assim, neste caso, se pegarmos emprestado nosso jargão de

01:17:42.090 --> 01:17:46.080
usando notação ômega, só para ficar claro, classificação de seleção

01:17:46.080 --> 01:17:50.790
também vai estar nesta encarnação em ômega de n ao quadrado,

01:17:50.790 --> 01:17:53.190
porque mesmo no melhor caso, onde a lista já está

01:17:53.190 --> 01:17:56.100
resolvido, você vai perder muito tempo

01:17:56.100 --> 01:17:59.040
essencialmente verificando o máximo ou descobrindo o máximo,

01:17:59.040 --> 01:18:01.750
embora nós, humanos, é claro, pudéssemos ver isso imediatamente.

01:18:01.750 --> 01:18:06.270
Portanto, a classificação por seleção parece levar n passos ao quadrado no pior

01:18:06.270 --> 01:18:08.425
caso, n passos ao quadrado no melhor caso.

01:18:08.425 --> 01:18:09.300
E então você sabe o quê?

01:18:09.300 --> 01:18:11.280
Podemos usar nossa terminologia theta para isso.

01:18:11.280 --> 01:18:13.770
Aqui seria um algoritmo, assim como a contagem anterior,

01:18:13.770 --> 01:18:17.880
que sempre leva n passos quadrados, não importa se a matriz é classificada

01:18:17.880 --> 01:18:19.652
ou não desde o início.

01:18:19.652 --> 01:18:21.360
Tudo bem, então espero que possamos fazer melhor.

01:18:21.360 --> 01:18:23.550
E alguém propôs anteriormente esse tipo de bolha

01:18:23.550 --> 01:18:25.618
parecia que estava usando menos etapas.

01:18:25.618 --> 01:18:26.910
Bem, vamos considerar isso a seguir.

01:18:26.910 --> 01:18:30.630
Com o tipo de bolha, tínhamos esse pseudocódigo, eu afirmo.

01:18:30.630 --> 01:18:33.780
Por meio disso, vamos nos concentrar primeiro no interior do código.

01:18:33.780 --> 01:18:36.120
Aqui embaixo, o que eu estava fazendo?

01:18:36.120 --> 01:18:39.960
Para i de 0 a n menos 2.

01:18:39.960 --> 01:18:40.740
Isso é curioso.

01:18:40.740 --> 01:18:42.360
Nunca vimos n menos 2 antes.

01:18:42.360 --> 01:18:44.040
Mas eu fiz esta pergunta.

01:18:44.040 --> 01:18:50.160
Se os números colchete i e os números colchete i mais 1 estiverem fora de ordem, troque-os.

01:18:50.160 --> 01:18:53.610
Então foi quando eu estava apontando para nossos dois primeiros voluntários aqui.

01:18:53.610 --> 01:18:57.090
Eu vi que eles estavam fora de ordem, então eu os troquei.

01:18:57.090 --> 01:19:01.830
Como é que eu estou fazendo isso de novo e de novo até n menos 2, no entanto,

01:19:01.830 --> 01:19:05.610
em vez de n menos 1, que sempre usamos

01:19:05.610 --> 01:19:09.670
até agora como nosso limite mais à direita?

01:19:09.670 --> 01:19:14.170
Alguma intuição de por que estou fazendo isso de 0 a n menos 2?

01:19:14.170 --> 01:19:14.700
Sim.

01:19:14.700 --> 01:19:18.540
ALUNO: [INAUDÍVEL] número, você não pode se livrar do i-ésimo número.

01:19:18.540 --> 01:19:21.005
Não há nenhum personagem benigno com o qual você possa trocar.

01:19:21.005 --> 01:19:21.880
DAVID MALAN: Exatamente.

01:19:21.880 --> 01:19:26.050
Porque estou olhando para a i-ésima pessoa por este pseudocódigo aqui

01:19:26.050 --> 01:19:29.740
e a i-ésima mais 1 pessoa, é melhor eu não pisar

01:19:29.740 --> 01:19:31.550
além dos limites da minha matriz.

01:19:31.550 --> 01:19:33.010
Então, se você pensar na minha mão esquerda.

01:19:33.010 --> 01:19:36.250
Quando eu estava de costas para você aqui, apontando para a pessoa atual

01:19:36.250 --> 01:19:39.225
na primeira posição, minha mão direita para este condicionador if

01:19:39.225 --> 01:19:41.350
está essencialmente apontando para a pessoa ao lado deles.

01:19:41.350 --> 01:19:44.740
E você quer iterar com a mão esquerda por todas essas pessoas.

01:19:44.740 --> 01:19:47.620
Mas você não quer que sua mão esquerda aponte para a última pessoa.

01:19:47.620 --> 01:19:50.000
Você quer que aponte para a penúltima pessoa.

01:19:50.000 --> 01:19:54.220
Mas sabemos que a última pessoa está sempre em n menos 1.

01:19:54.220 --> 01:19:57.820
Portanto, a penúltima pessoa, matematicamente, está em n menos 2.

01:19:57.820 --> 01:19:58.780
Então é uma sutileza.

01:19:58.780 --> 01:20:00.880
Mas esta é uma falha de segmentação esperando para acontecer.

01:20:00.880 --> 01:20:03.760
Se você implementou a classificação de bolhas usando n menos 1,

01:20:03.760 --> 01:20:07.340
você vai, minha mão direita iria além dos limites da matriz,

01:20:07.340 --> 01:20:08.170
tão ruim.

01:20:08.170 --> 01:20:10.490
Tudo bem, então por que estou dizendo isso n vezes?

01:20:10.490 --> 01:20:13.070
Bem, nós fizemos isso muito organicamente com humanos.

01:20:13.070 --> 01:20:15.940
Mas cada vez que alguém--

01:20:15.940 --> 01:20:18.370
cada passagem que eu fazia pelo array, alguém

01:20:18.370 --> 01:20:19.840
borbulhou até o fim.

01:20:19.840 --> 01:20:22.870
Número 7, depois número 6, depois número 5.

01:20:22.870 --> 01:20:26.600
Então, se em cada passagem pela matriz de voluntários,

01:20:26.600 --> 01:20:31.360
Eu estava resolvendo pelo menos um problema, parece que o tipo de bolha pode simplesmente

01:20:31.360 --> 01:20:34.315
execute n vezes o total para resolver todos os n problemas,

01:20:34.315 --> 01:20:36.940
porque a primeira passagem colocará pelo menos um número no lugar.

01:20:36.940 --> 01:20:38.470
Segunda passagem, segundo número no lugar.

01:20:38.470 --> 01:20:39.970
Você pode ter sorte, e faria mais.

01:20:39.970 --> 01:20:41.740
Mas, na pior das hipóteses, isso parece suficiente.

01:20:41.740 --> 01:20:46.240
Basta fazer isso cegamente n vezes e todos eles se alinharão.

01:20:46.240 --> 01:20:49.780
Bem, tecnicamente-- tudo bem, agora estamos entrando no mato.

01:20:49.780 --> 01:20:52.060
Tecnicamente, você pode apenas repetir em menos 1 vezes,

01:20:52.060 --> 01:20:54.520
porque se você resolver todos os n menos 1 outros problemas,

01:20:54.520 --> 01:20:58.120
e você fica com 1, literalmente essa pessoa está onde ela precisa estar,

01:20:58.120 --> 01:20:58.900
apenas logicamente.

01:20:58.900 --> 01:21:01.390
Se você já organizou todo o resto e só tem 1 sobrando,

01:21:01.390 --> 01:21:02.540
já está borbulhando.

01:21:02.540 --> 01:21:03.980
Então, como analisamos isso?

01:21:03.980 --> 01:21:06.670
Bem, no tipo de bolha, podemos fazer algo assim.

01:21:06.670 --> 01:21:11.015
Estou essencialmente fazendo n menos 1 coisas n menos 1 vezes.

01:21:11.015 --> 01:21:13.390
Agora, deixe-me voltar ao pseudocódigo, porque este é

01:21:13.390 --> 01:21:14.980
um pouco menos óbvio.

01:21:14.980 --> 01:21:19.270
É aqui que você pode inferir matematicamente do seu loop

01:21:19.270 --> 01:21:21.110
quantos passos você está dando.

01:21:21.110 --> 01:21:24.585
Portanto, esta primeira linha diz literalmente, repita o seguinte n menos 1 vezes.

01:21:24.585 --> 01:21:26.710
Então isso vai traduzir muito diretamente

01:21:26.710 --> 01:21:28.240
à nossa fórmula matemática.

01:21:28.240 --> 01:21:30.190
Faça algo n menos 1 vezes.

01:21:30.190 --> 01:21:33.970
Este loop, só porque estou usando a terminologia de loop for,

01:21:33.970 --> 01:21:35.840
é enquadrado de forma um pouco diferente.

01:21:35.840 --> 01:21:39.910
Mas se você estiver iterando de 0 a n menos 2,

01:21:39.910 --> 01:21:43.258
você está iterando um total de n menos 1 vezes.

01:21:43.258 --> 01:21:45.550
E, novamente, a aritmética está ficando um pouco chata.

01:21:45.550 --> 01:21:48.470
Mas isso significa apenas fazer o seguinte n menos 1 vezes.

01:21:48.470 --> 01:21:51.670
Então faça n menos 1 coisas n menos 1 vezes.

01:21:51.670 --> 01:21:54.440
Agora podemos executar a matemática da seguinte maneira.

01:21:54.440 --> 01:21:57.940
Temos a fórmula n menos 1 vezes n menos 1.

01:21:57.940 --> 01:22:01.210
Fazemos nosso pequeno método FOIL aqui, n ao quadrado menos 1 vezes n,

01:22:01.210 --> 01:22:03.100
menos 1 vezes n, mais 1.

01:22:03.100 --> 01:22:06.550
Podemos combinar termos semelhantes. n ao quadrado menos 2n mais 1.

01:22:06.550 --> 01:22:09.025
Mas neste ponto, quando n fica muito grande,

01:22:09.025 --> 01:22:10.900
com qual termo realmente vamos nos importar?

01:22:10.900 --> 01:22:13.390
Isso é da ordem de?

01:22:13.390 --> 01:22:14.870
Sim, n ao quadrado.

01:22:14.870 --> 01:22:16.780
Então, pelo menos assintoticamente.

01:22:16.780 --> 01:22:20.830
Assintoticamente significa que, conforme n se aproxima do infinito, fica muito grande.

01:22:20.830 --> 01:22:24.070
Acontece que o limite superior na classificação por seleção e classificação por bolha

01:22:24.070 --> 01:22:25.430
são essencialmente os mesmos.

01:22:25.430 --> 01:22:28.540
Agora, se realmente analisarmos e compararmos o número total de comparações,

01:22:28.540 --> 01:22:29.680
eles podem diferir ligeiramente.

01:22:29.680 --> 01:22:31.870
Mas conforme n fica grande, honestamente, você mal

01:22:31.870 --> 01:22:36.350
vai notar a diferença, ao que parece, entre esses dois algoritmos.

01:22:36.350 --> 01:22:39.550
Mas e o limite inferior?

01:22:39.550 --> 01:22:44.620
Se o limite superior no tipo de bolha também for grande O de n, e quanto ao limite inferior

01:22:44.620 --> 01:22:45.470
ligado aqui?

01:22:45.470 --> 01:22:50.170
Bem, com este pseudocódigo, qual seria o limite inferior no tipo de bolha?

01:22:50.170 --> 01:22:53.890
Mesmo no melhor caso, quando todos os voluntários são classificados.

01:22:53.890 --> 01:22:56.830
Alguma intuição?

01:22:56.830 --> 01:22:57.670
Neste pseudocódigo.

01:22:57.670 --> 01:22:58.538
Sim, no meio.

01:22:58.538 --> 01:22:59.830
ALUNO: Desculpe, pergunta rápida.

01:22:59.830 --> 01:23:02.360
O tipo de bolha não é estruturado de forma que você

01:23:02.360 --> 01:23:05.955
não precisaria comparar números que já surgiram?

01:23:05.955 --> 01:23:07.080
DAVID MALAN: Boa pergunta.

01:23:07.080 --> 01:23:09.122
O tipo de bolha não foi projetado de forma que você não

01:23:09.122 --> 01:23:12.860
precisa comparar números que já surgiram?

01:23:12.860 --> 01:23:17.000
Isso é o que está acontecendo aqui no meio, implicitamente.

01:23:17.000 --> 01:23:19.220
Estou sempre indo da esquerda para a direita.

01:23:19.220 --> 01:23:21.650
Mas lembre-se que mesmo quando eu estraguei tudo no final

01:23:21.650 --> 01:23:23.900
e as duas últimas pessoas estavam fora de ordem, eu sempre

01:23:23.900 --> 01:23:27.140
precisa reiniciar do início, pois os números grandes são

01:23:27.140 --> 01:23:29.691
indo para lá, e os pequenos números estão vindo para cá.

01:23:29.691 --> 01:23:32.892
ALUNO: [INAUDÍVEL]

01:23:32.892 --> 01:23:34.100
DAVID MALAN: Então isso é verdade.

01:23:34.100 --> 01:23:37.460
Existem algumas pequenas otimizações que estou passando por cima aqui.

01:23:37.460 --> 01:23:40.700
Deixe-me estipular que ainda acabaria sendo da ordem de n ao quadrado.

01:23:40.700 --> 01:23:43.910
Mas isso definitivamente reduziria algum tempo real de execução aqui.

01:23:43.910 --> 01:23:46.340
Mas e se a lista já estiver classificada?

01:23:46.340 --> 01:23:48.410
Nosso pseudocódigo, no momento, não tem permissão

01:23:48.410 --> 01:23:51.020
pois se a lista já estiver classificada, saia antes.

01:23:51.020 --> 01:23:53.840
Então, vamos cegamente fazer n menos 1 coisas

01:23:53.840 --> 01:23:58.850
e menos 1 vezes, a menos que modifiquemos nosso pseudocódigo, como fiz verbalmente antes,

01:23:58.850 --> 01:23:59.960
Eu propus isso.

01:23:59.960 --> 01:24:04.520
Dentro desse loop externo, se você passar por todos os voluntários,

01:24:04.520 --> 01:24:06.907
e seu contador mental não fez trocas,

01:24:06.907 --> 01:24:08.990
você tem que acompanhar com algum tipo de variável,

01:24:08.990 --> 01:24:10.518
bem, então você pode muito bem parar.

01:24:10.518 --> 01:24:12.560
Porque se você fizer um passe inteiro e não fizer nenhuma troca,

01:24:12.560 --> 01:24:17.550
por que você perderia tempo fazendo isso de novo esperando um comportamento diferente?

01:24:17.550 --> 01:24:23.480
Então, para ajudar a visualizá-los, agora a classificação por bolhas pode ser vantajosa

01:24:23.480 --> 01:24:26.640
se os dados já estiverem classificados ou quase todos classificados.

01:24:26.640 --> 01:24:27.140
Por que?

01:24:27.140 --> 01:24:29.510
Porque ele tem esse detalhe de curto-circuito.

01:24:29.510 --> 01:24:31.790
Pelo menos se implementarmos assim, como

01:24:31.790 --> 01:24:36.263
podemos visualizar essas coisas um pouco mais claramente?

01:24:36.263 --> 01:24:37.680
Bem, deixe-me ir em frente e fazer isso.

01:24:37.680 --> 01:24:41.870
Deixe-me mostrar, aqui, uma visualização exatamente desses algoritmos,

01:24:41.870 --> 01:24:45.320
graças a uma ferramenta de terceiros aqui que vai nos ajudar a visualizar

01:24:45.320 --> 01:24:46.850
esses algoritmos de classificação da seguinte maneira.

01:24:46.850 --> 01:24:48.740
Barras pequenas representam números pequenos.

01:24:48.740 --> 01:24:50.480
Barras grandes representam números grandes.

01:24:50.480 --> 01:24:53.720
E então a ideia, agora, é quando eu apertar um botão aqui

01:24:53.720 --> 01:24:56.843
para obter todas as barras pequenas desta forma, todas as barras grandes desta forma.

01:24:56.843 --> 01:24:58.010
Assim como nossos voluntários.

01:24:58.010 --> 01:25:02.370
Mas, em vez de conter números iluminados, são barras que representam sua magnitude.

01:25:02.370 --> 01:25:07.190
Então, vamos começar com, por exemplo, classificação por seleção.

01:25:07.190 --> 01:25:09.920
E você verá em rosa, está sendo destacado

01:25:09.920 --> 01:25:12.980
o número atual que está sendo selecionado

01:25:12.980 --> 01:25:14.820
e, em seguida, puxou todo o caminho para a esquerda.

01:25:14.820 --> 01:25:16.220
Portanto, este é o tipo de seleção.

01:25:16.220 --> 01:25:20.420
E, novamente, está selecionando o próximo menor elemento.

01:25:20.420 --> 01:25:25.850
Mas você pode ver aqui, ainda mais visivelmente, que assim como meus pés humanos,

01:25:25.850 --> 01:25:27.450
estamos dando muitos passos.

01:25:27.450 --> 01:25:32.430
Assim, este algoritmo está tocando esses elementos, de novo e de novo e de novo.

01:25:32.430 --> 01:25:34.970
E é por isso que o n ao quadrado é realmente uma coisa.

01:25:34.970 --> 01:25:37.322
Deve haver alguma redundância inerente aqui.

01:25:37.322 --> 01:25:40.280
Tipo, por que continuamos olhando para os mesmos elementos malditos de novo e de novo?

01:25:40.280 --> 01:25:43.070
Nós, em termos de nosso pseudocódigo, precisamos fazê-lo.

01:25:43.070 --> 01:25:46.670
Mas são essas comparações redundantes que meio que explicam

01:25:46.670 --> 01:25:48.782
por que n ao quadrado é de fato o caso.

01:25:48.782 --> 01:25:49.490
Então agora está feito.

01:25:49.490 --> 01:25:50.977
Bares pequenos aqui, bares grandes ali.

01:25:50.977 --> 01:25:53.060
E eu tinha que continuar falando lá para matar o tempo,

01:25:53.060 --> 01:25:54.650
porque é relativamente lento.

01:25:54.650 --> 01:25:57.182
Bem, deixe-me randomizar novamente a matriz, apenas

01:25:57.182 --> 01:25:58.640
então começamos com uma ordem diferente.

01:25:58.640 --> 01:26:00.380
E agora deixe-me clicar no tipo de bolha.

01:26:00.380 --> 01:26:03.240
E você verá uma ideia semelhante, mas um algoritmo diferente.

01:26:03.240 --> 01:26:06.620
Agora, as duas barras em rosa são as duas que

01:26:06.620 --> 01:26:09.995
estão sendo comparados e corrigidos, potencialmente, se estiverem fora de ordem.

01:26:09.995 --> 01:26:11.870
E você já pode ver que os maiores bares

01:26:11.870 --> 01:26:14.420
estão borbulhando até o topo.

01:26:14.420 --> 01:26:17.510
Mas agora, você também pode ver essa redundância,

01:26:17.510 --> 01:26:20.450
como se estivéssemos percorrendo a lista de novo e de novo, apenas

01:26:20.450 --> 01:26:22.740
como se eu continuasse andando para frente e para trás.

01:26:22.740 --> 01:26:23.795
E isso é n ao quadrado.

01:26:23.795 --> 01:26:24.920
Isso não é muitos bares.

01:26:24.920 --> 01:26:25.420
O que?

01:26:25.420 --> 01:26:27.830
10, 20, há cerca de 40 ou algo assim, eu acho.

01:26:27.830 --> 01:26:31.560
Isso já é muito lento apenas para classificar 40 números.

01:26:31.560 --> 01:26:34.310
E acho que vai ficar entediante se eu continuar falando sobre isso.

01:26:34.310 --> 01:26:37.590
Então, vamos supor que isso também seja relativamente lento.

01:26:37.590 --> 01:26:41.390
Se eu tivesse tido sorte e a lista já estivesse quase ordenada,

01:26:41.390 --> 01:26:43.310
O tipo de bolha teria sido muito rápido.

01:26:43.310 --> 01:26:46.040
Mas esta foi uma matriz verdadeiramente aleatória, então não tivemos sorte.

01:26:46.040 --> 01:26:50.010
Então, de fato, o pior caso pode ser o que está acontecendo aqui.

01:26:50.010 --> 01:26:54.470
Então eu sinto que vai ser anticlimático, como segurar um espirro, se eu

01:26:54.470 --> 01:26:55.980
não deixe você ver o fim disso.

01:26:55.980 --> 01:26:57.890
Aqui vamos nos.

01:26:57.890 --> 01:27:00.110
Nada de interessante está prestes a acontecer.

01:27:00.110 --> 01:27:02.330
Quase pronto.

01:27:02.330 --> 01:27:03.080
Feito.

01:27:03.080 --> 01:27:05.890
Tudo bem, então obrigado.

01:27:05.890 --> 01:27:06.710
[APLAUSOS]

01:27:06.710 --> 01:27:09.110
Obrigado.

01:27:09.110 --> 01:27:12.500
Então, ainda um pouco lento.

01:27:12.500 --> 01:27:15.800
Como podemos, talvez, fazer um pouco melhor fundamentalmente?

01:27:15.800 --> 01:27:19.070
Assim, podemos fazê-lo se introduzirmos ainda outra técnica.

01:27:19.070 --> 01:27:22.130
E este não é tanto uma função de código quanto um conceito.

01:27:22.130 --> 01:27:25.290
E é algo que você pode ter visto no mundo real,

01:27:25.290 --> 01:27:27.500
mas talvez não tão obviamente assim.

01:27:27.500 --> 01:27:31.490
Acontece que, na programação, a recursão

01:27:31.490 --> 01:27:34.970
refere-se à capacidade de uma função chamar a si mesma.

01:27:34.970 --> 01:27:37.460
No mundo da matemática, se você tem uma função f,

01:27:37.460 --> 01:27:41.450
se f aparece tanto no lado esquerdo quanto no lado direito de uma fórmula,

01:27:41.450 --> 01:27:43.850
isso também seria uma função recursiva no mundo da matemática.

01:27:43.850 --> 01:27:46.490
Sempre que f é definido em termos de si mesmo, ou no nosso caso,

01:27:46.490 --> 01:27:51.800
em computação-- em programação, sempre que uma função chama a si mesma,

01:27:51.800 --> 01:27:53.660
essa função é chamada de recursiva.

01:27:53.660 --> 01:27:55.790
E isso é realmente algo que já vimos em sala de aula,

01:27:55.790 --> 01:27:57.373
mesmo que não o chamássemos tanto.

01:27:57.373 --> 01:28:00.350
Então, por exemplo, considere este pseudocódigo

01:28:00.350 --> 01:28:03.590
de antes, em que este era o pseudocódigo

01:28:03.590 --> 01:28:07.760
para pesquisar por meio de pesquisa binária, um monte de portas.

01:28:07.760 --> 01:28:10.040
Se nenhuma porta for deixada retornar falso, isso

01:28:10.040 --> 01:28:12.600
foi a condicional adicional que adicionamos.

01:28:12.600 --> 01:28:14.930
Mas então, se o número atrás da porta do meio retornar verdadeiro,

01:28:14.930 --> 01:28:18.980
e aqui está a parte interessante, se o número for menor que a porta do meio,

01:28:18.980 --> 01:28:20.780
procure a metade esquerda.

01:28:20.780 --> 01:28:24.020
Caso contrário, se o número for maior que a porta do meio, procure na metade direita.

01:28:24.020 --> 01:28:27.800
Esse pseudocódigo anterior era, ele próprio, recursivo.

01:28:27.800 --> 01:28:28.340
Por que?

01:28:28.340 --> 01:28:30.590
Porque aqui está um algoritmo para pesquisar.

01:28:30.590 --> 01:28:32.650
Mas o que o algoritmo está nos dizendo?

01:28:32.650 --> 01:28:37.280
Bem, nesta linha e nesta linha, está nos dizendo para procurar outra coisa.

01:28:37.280 --> 01:28:40.720
Mesmo que não seja explicitamente definido no código como tendo um nome,

01:28:40.720 --> 01:28:44.410
se este for um algoritmo de pesquisa e, ainda assim, o algoritmo de pesquisa estiver usando uma pesquisa

01:28:44.410 --> 01:28:47.650
algoritmo, este pseudocódigo é recursivo.

01:28:47.650 --> 01:28:50.380
Agora, isso pode causar problemas rapidamente se uma função apenas

01:28:50.380 --> 01:28:53.410
chama-se de novo e de novo e de novo.

01:28:53.410 --> 01:28:57.130
Mas por que, intuitivamente, não é problemático

01:28:57.130 --> 01:29:01.840
que esse código, esse pseudocódigo, chama a si mesmo?

01:29:01.840 --> 01:29:03.460
Por que o algoritmo ainda vai parar?

01:29:03.460 --> 01:29:03.970
Sim.

01:29:03.970 --> 01:29:07.525
ALUNO: Tem uma condição de saída, como se não houvesse mais portas, [INAUDÍVEL].

01:29:07.525 --> 01:29:08.400
DAVID MALAN: Exatamente.

01:29:08.400 --> 01:29:10.860
Tem alguma condição de saída, como se não houvesse mais portas.

01:29:10.860 --> 01:29:14.700
E mais importante, sempre que você pesquisar na metade esquerda,

01:29:14.700 --> 01:29:17.120
você está procurando uma versão menor do problema.

01:29:17.120 --> 01:29:18.870
Sempre que você procurar a metade certa, você

01:29:18.870 --> 01:29:22.330
procurando uma versão menor do problema, literalmente metade do tamanho.

01:29:22.330 --> 01:29:24.270
Então é por isso que, na lista telefônica, obviamente

01:29:24.270 --> 01:29:27.210
Eu não poderia rasgar a lista telefônica ao meio infinitas vezes,

01:29:27.210 --> 01:29:29.560
porque estava literalmente ficando menor a cada vez.

01:29:29.560 --> 01:29:33.580
Portanto, a recursão é essa capacidade de chamar a si mesmo, se quiser.

01:29:33.580 --> 01:29:36.850
Mas o importante é que você faça isso em um problema cada vez menor,

01:29:36.850 --> 01:29:39.750
para que, eventualmente, você não tenha mais problemas para resolver

01:29:39.750 --> 01:29:42.010
ou sem mais dados, sem mais portas.

01:29:42.010 --> 01:29:46.210
Essas duas linhas aqui seriam os elementos recursivos aqui.

01:29:46.210 --> 01:29:49.690
Mas se voltarmos à semana 0, poderíamos ter usado a recursão de alguma outra maneira.

01:29:49.690 --> 01:29:53.040
Portanto, este era o nosso pseudocódigo para a lista telefônica na semana 0.

01:29:53.040 --> 01:29:55.350
E lembre-se que descrevemos essas linhas amarelas

01:29:55.350 --> 01:29:59.050
como realmente representando um loop, algum tipo de ciclo de novo e de novo.

01:29:59.050 --> 01:30:01.080
Mas houve uma oportunidade perdida aqui.

01:30:01.080 --> 01:30:05.670
E se eu tivesse reimplementado esse código para fazer isso?

01:30:05.670 --> 01:30:09.120
Em vez de dizer aberto no meio da metade esquerda do livro

01:30:09.120 --> 01:30:12.450
e então volte para a linha 3, literalmente induzindo um loop,

01:30:12.450 --> 01:30:14.610
ou abra metade de um livro no meio da direita e volte

01:30:14.610 --> 01:30:17.400
para a linha 3 induzindo outro loop, por que não

01:30:17.400 --> 01:30:19.590
apenas reconheça que o que estou olhando agora

01:30:19.590 --> 01:30:23.730
que é um algoritmo para pesquisar uma lista telefônica?

01:30:23.730 --> 01:30:27.480
E se você quiser pesquisar uma lista telefônica menor, como A a M ou N

01:30:27.480 --> 01:30:30.750
através de Z, vamos apenas usar este mesmo algoritmo.

01:30:30.750 --> 01:30:35.100
Posso substituir essas linhas amarelas por apenas isso, falando casualmente.

01:30:35.100 --> 01:30:37.282
Procure na metade esquerda do livro, procure na metade direita do livro.

01:30:37.282 --> 01:30:39.240
Isso seria implicitamente, e agora posso encurtar

01:30:39.240 --> 01:30:42.360
a coisa toda, uma implementação recursiva da lista telefônica

01:30:42.360 --> 01:30:43.633
pseudocódigo da semana 0.

01:30:43.633 --> 01:30:46.050
E é recursivo, porque se for um algoritmo de busca,

01:30:46.050 --> 01:30:48.900
e você está dizendo para procurar outra coisa, tudo bem.

01:30:48.900 --> 01:30:49.890
Isso é recursivo.

01:30:49.890 --> 01:30:52.440
Mas como você está pesquisando metade da lista telefônica,

01:30:52.440 --> 01:30:55.710
realmente vai ficar cada vez menor.

01:30:55.710 --> 01:30:59.400
Mesmo no mundo real ou no mundo virtual real real,

01:30:59.400 --> 01:31:01.903
você pode ver estruturas de dados recursivas em estado selvagem,

01:31:01.903 --> 01:31:03.820
ou pelo menos em Super Mario Brothers assim.

01:31:03.820 --> 01:31:05.612
Deixe-me me livrar de todas as distrações aqui

01:31:05.612 --> 01:31:08.790
e concentre-se nesta pirâmide, onde você tem um bloco,

01:31:08.790 --> 01:31:10.860
depois dois, depois três, depois quatro.

01:31:10.860 --> 01:31:14.710
Bem, isso em si é tecnicamente definido recursivamente no sentido de que,

01:31:14.710 --> 01:31:16.590
bem, para que serve uma pirâmide de altura?

01:31:16.590 --> 01:31:18.420
Bem, é realmente, o quê?

01:31:18.420 --> 01:31:21.090
Como você descreveria uma pirâmide de altura 4

01:31:21.090 --> 01:31:25.743
é na verdade a mesma coisa que uma pirâmide de--

01:31:25.743 --> 01:31:28.200
ALUNO: Altura 3.

01:31:28.200 --> 01:31:30.750
DAVID MALAN: --de altura 3, mais 1 camada adicional.

01:31:30.750 --> 01:31:32.370
Bem, o que é uma pirâmide de altura 3?

01:31:32.370 --> 01:31:36.250
Bem, é tecnicamente uma pirâmide de altura 2 mais 1 camada adicional.

01:31:36.250 --> 01:31:38.670
E assim mesmo as estruturas físicas podem ser recursivas

01:31:38.670 --> 01:31:40.630
se você pode defini-los em termos de si mesmo.

01:31:40.630 --> 01:31:44.280
Agora, em algum momento, você tem que dizer que se a pirâmide tem altura 1,

01:31:44.280 --> 01:31:46.090
há apenas um bloco.

01:31:46.090 --> 01:31:49.020
Você não pode dizer para sempre que é definido em termos de altura negativa 1,

01:31:49.020 --> 01:31:50.440
2 negativo, você nunca iria parar.

01:31:50.440 --> 01:31:52.752
Então você tem que ter um caso especial lá.

01:31:52.752 --> 01:31:55.710
Mas vamos em frente e traduzir algo assim, de fato, para o código.

01:31:55.710 --> 01:32:00.390
Deixe-me voltar ao código VS aqui e deixe-me implementar um programa chamado iteração

01:32:00.390 --> 01:32:03.090
que se refere a uma iteração de loop.

01:32:03.090 --> 01:32:05.620
E deixe-me implementar uma pirâmide muito simples como essa.

01:32:05.620 --> 01:32:08.370
Então deixe-me prosseguir e incluir a biblioteca CS50.

01:32:08.370 --> 01:32:14.918
Incluirei nosso padrão io.h int main void, sem argumentos de linha de comando hoje.

01:32:14.918 --> 01:32:16.210
E vamos em frente e fazer isso.

01:32:16.210 --> 01:32:18.900
Vamos declarar uma variável chamada altura, pergunte ao humano

01:32:18.900 --> 01:32:21.150
para a altura desta pirâmide.

01:32:21.150 --> 01:32:25.300
E então vamos em frente e desenhar uma pirâmide dessa altura.

01:32:25.300 --> 01:32:27.580
Agora, é claro, desenhar ainda não existe.

01:32:27.580 --> 01:32:30.090
Vou precisar inventar a função draw.

01:32:30.090 --> 01:32:33.180
Deixe-me prosseguir e definir uma função que não tenha um valor de retorno.

01:32:33.180 --> 01:32:34.722
Só vai ter efeitos colaterais.

01:32:34.722 --> 01:32:37.230
É só imprimir tijolos na tela, chamados de desenhar.

01:32:37.230 --> 01:32:40.240
E recebe um inteiro, n, como sua entrada.

01:32:40.240 --> 01:32:41.950
E como vou implementar isso?

01:32:41.950 --> 01:32:46.530
Bem, novamente, quero imprimir um bloco, depois dois, depois três, depois quatro.

01:32:46.530 --> 01:32:49.680
Isso é bem direto, pelo menos quando você se sentir confortável com os loops.

01:32:49.680 --> 01:32:51.370
Deixe-me voltar ao código aqui.

01:32:51.370 --> 01:32:55.170
Deixe-me ir em frente e dizer 4, int i, obter 0.

01:32:55.170 --> 01:32:56.880
i é menor que n.

01:32:56.880 --> 01:32:58.260
eu mais mais.

01:32:58.260 --> 01:33:01.170
E isso vai iterar, essencialmente linha por linha.

01:33:01.170 --> 01:33:05.370
E em cada linha, quero imprimir um, depois dois, depois três, depois

01:33:05.370 --> 01:33:06.060
quatro tijolos.

01:33:06.060 --> 01:33:08.815
Mas estou iterando de 0 para 1 para 2 para 3.

01:33:08.815 --> 01:33:09.690
Então eu acho que está tudo bem.

01:33:09.690 --> 01:33:13.020
Posso apenas dizer algo como 4 int j get 0.

01:33:13.020 --> 01:33:17.160
j, vamos ser espertos sobre isso, é menor que i.

01:33:17.160 --> 01:33:19.380
j++.

01:33:19.380 --> 01:33:22.560
E agora, deixe-me ir em frente e, dentro deste loop,

01:33:22.560 --> 01:33:27.130
Acho que posso me safar apenas imprimindo um único sinal de hash.

01:33:27.130 --> 01:33:30.270
Mas fora desse loop, semelhante à semana passada,

01:33:30.270 --> 01:33:32.920
Vou imprimir minha nova linha separadamente.

01:33:32.920 --> 01:33:34.470
Então, um pouco não óbvio no começo.

01:33:34.470 --> 01:33:38.790
Mas esse loop externo itera linha por linha, linha por linha, se você preferir.

01:33:38.790 --> 01:33:46.890
E então o loop interno apenas garante que quando i for igual a zero, vamos ver.

01:33:46.890 --> 01:33:48.960
Oh não, há um bug.

01:33:48.960 --> 01:33:52.170
Preciso ter certeza de que j é menor que i mais 1.

01:33:52.170 --> 01:33:55.500
Então, quando i é 0 na minha primeira linha de saída,

01:33:55.500 --> 01:33:57.600
Vou imprimir um tijolo.

01:33:57.600 --> 01:34:02.350
Quando eu tiver 1, vou imprimir dois tijolos e assim por diante.

01:34:02.350 --> 01:34:05.460
Então deixe-me ir em frente e executar make iteration.

01:34:05.460 --> 01:34:09.090
Tudo bem, e agora, parece compilar.

01:34:09.090 --> 01:34:10.770
Ué, é.

01:34:10.770 --> 01:34:12.900
Declaração implícita da função draw.

01:34:12.900 --> 01:34:16.100
Então, estou cometendo erros na primeira semana novamente.

01:34:16.100 --> 01:34:16.660
O que?

01:34:16.660 --> 01:34:17.570
Diga novamente.

01:34:17.570 --> 01:34:18.450
ALUNO: [INAUDÍVEL]

01:34:18.450 --> 01:34:19.200
DAVID MALAN: Sim.

01:34:19.200 --> 01:34:20.320
Falta o protótipo.

01:34:20.320 --> 01:34:21.300
Eu não declarei no topo.

01:34:21.300 --> 01:34:23.550
Essa é uma solução fácil, e a única vez, realmente, é

01:34:23.550 --> 01:34:25.530
OK e necessário copiar e colar.

01:34:25.530 --> 01:34:29.050
Deixe-me copiar a declaração de funções lá e com um ponto e vírgula.

01:34:29.050 --> 01:34:32.370
Então aquele clang agora sabe que o sorteio vai existir.

01:34:32.370 --> 01:34:33.240
Faça iteração.

01:34:33.240 --> 01:34:33.930
Agora funciona.

01:34:33.930 --> 01:34:36.090
Obrigado. iteração ponto barra.

01:34:36.090 --> 01:34:37.830
Vamos digitar algo como 4.

01:34:37.830 --> 01:34:40.860
E aí temos, nossa pirâmide de altura um, dois, três, quatro,

01:34:40.860 --> 01:34:43.340
que se parece muito com isso, embora usando hashes.

01:34:43.340 --> 01:34:46.590
Então é assim que teríamos implementado isso, tipo, duas semanas atrás na primeira semana,

01:34:46.590 --> 01:34:49.110
talvez na semana passada, mas apenas usando arrays.

01:34:49.110 --> 01:34:53.640
Mas deixe-me propor que poderíamos fazer algo recursivamente.

01:34:53.640 --> 01:34:55.480
Deixe-me fechar esta versão do código.

01:34:55.480 --> 01:34:59.730
E deixe-me voltar ao VS Code e abrir recursion.c,

01:34:59.730 --> 01:35:01.800
apenas para demonstrar algo recursivamente.

01:35:01.800 --> 01:35:04.420
E farei isso incorretamente deliberadamente na primeira vez.

01:35:04.420 --> 01:35:06.630
Deixe-me incluir cs50.h.

01:35:06.630 --> 01:35:08.850
Deixe-me incluir padrão io.h.

01:35:08.850 --> 01:35:12.000
Deixe-me fazer int main void.

01:35:12.000 --> 01:35:17.910
E deixe-me desenhar cegamente uma pirâmide inicialmente de altura 1.

01:35:17.910 --> 01:35:21.910
Mas agora na minha função de desenho, deixe-me reimplementá-la de maneira um pouco diferente.

01:35:21.910 --> 01:35:24.840
Então, minha função de desenho desta vez ainda vai pegar um número n.

01:35:24.840 --> 01:35:26.860
Mas é quantos hashes ele imprimirá.

01:35:26.860 --> 01:35:30.030
Então vamos fazer 4, int eu obtenho 0.

01:35:30.030 --> 01:35:32.220
i é menor que n.

01:35:32.220 --> 01:35:34.050
i++.

01:35:34.050 --> 01:35:38.440
Então, vamos imprimir uma única marca de hash aqui.

01:35:38.440 --> 01:35:44.290
Depois disso, vamos imprimir o final da linha, como antes.

01:35:44.290 --> 01:35:49.770
Mas agora isso, é claro, só vai desenhar uma única linha.

01:35:49.770 --> 01:35:53.790
Vai imprimir um hash ou dois hashes ou três hashes, mas apenas

01:35:53.790 --> 01:35:54.750
em uma linha.

01:35:54.750 --> 01:35:58.560
Deixe-me agora, incorretamente, mas apenas curiosamente dizer, tudo bem.

01:35:58.560 --> 01:36:01.230
Bem, se isso desenha uma pirâmide de altura 1,

01:36:01.230 --> 01:36:04.860
vamos nos usar para desenhar uma pirâmide de altura n mais 1.

01:36:04.860 --> 01:36:08.370
Então, na primeira vez que chamo draw, ele imprime um hash.

01:36:08.370 --> 01:36:12.870
Então, na segunda vez que eu chamar draw, ele imprimirá dois hashes, depois três,

01:36:12.870 --> 01:36:13.770
então quatro.

01:36:13.770 --> 01:36:18.000
Então, estamos colocando esses tijolos de cima para baixo.

01:36:18.000 --> 01:36:20.670
Faça recursão.

01:36:20.670 --> 01:36:22.420
Opa, errei de novo.

01:36:22.420 --> 01:36:24.630
Então, vamos copiar o protótipo aqui.

01:36:24.630 --> 01:36:27.260
Vamos colocar isso aqui, ponto e vírgula.

01:36:27.260 --> 01:36:28.600
Vamos fazer isso de novo.

01:36:28.600 --> 01:36:30.010
Faça recursão.

01:36:30.010 --> 01:36:32.410
Tudo bem, tudo bem, recursão de ponto e barra.

01:36:32.410 --> 01:36:34.930
E agora deixe-me aumentar o tamanho da janela do meu terminal,

01:36:34.930 --> 01:36:37.310
apenas para que você possa ver mais da saída.

01:36:37.310 --> 01:36:39.490
E aqui temos.

01:36:39.490 --> 01:36:41.480
OK, ruim, mas obrigado.

01:36:41.480 --> 01:36:43.525
Portanto, temos uma pirâmide infinitamente alta.

01:36:43.525 --> 01:36:45.400
E está voando pela tela, o que

01:36:45.400 --> 01:36:47.020
é por isso que parece uma bagunça.

01:36:47.020 --> 01:36:51.670
Mas imprimi uma pirâmide de altura 1, depois 2, depois 3 e depois 4.

01:36:51.670 --> 01:36:55.210
E, infelizmente, o que me falta em qualquer tipo de condição rápida,

01:36:55.210 --> 01:36:58.270
qualquer tipo de condição que diga, espere um minuto, quando estiver muito alto,

01:36:58.270 --> 01:36:59.353
parar completamente.

01:36:59.353 --> 01:37:00.520
Portanto, este é um loop infinito.

01:37:00.520 --> 01:37:01.570
Mas não é um loop.

01:37:01.570 --> 01:37:03.250
É uma chamada recursiva.

01:37:03.250 --> 01:37:05.780
E na verdade, fazer isso em geral, é muito ruim.

01:37:05.780 --> 01:37:08.410
Veremos na próxima semana que, se você chamar uma função muitas vezes,

01:37:08.410 --> 01:37:11.967
você pode acionar mais uma dessas falhas de segmentação,

01:37:11.967 --> 01:37:14.050
porque você está usando muita memória, essencialmente.

01:37:14.050 --> 01:37:16.300
Mas, por enquanto, ainda não acionei isso.

01:37:16.300 --> 01:37:17.927
O controle C é seu amigo para cancelar.

01:37:17.927 --> 01:37:21.010
E como um aparte, se você estiver jogando em casa ou jogando com este código

01:37:21.010 --> 01:37:22.750
mais tarde, eu realmente trapaceei aqui.

01:37:22.750 --> 01:37:25.360
Temos um recurso especial de configuração clang

01:37:25.360 --> 01:37:28.392
que o impede de chamar uma função como essa

01:37:28.392 --> 01:37:29.350
e criando um problema.

01:37:29.350 --> 01:37:31.598
Eu o anulei apenas para fins de demonstração.

01:37:31.598 --> 01:37:34.640
Mas as probabilidades estão em casa, você não seria capaz de compilar esse código sozinho.

01:37:34.640 --> 01:37:39.050
Mas deixe-me fazer uma versão adequada recursivamente deste código da seguinte forma.

01:37:39.050 --> 01:37:41.870
Deixe-me voltar para o código aqui.

01:37:41.870 --> 01:37:45.130
Deixe-me ir em frente e, não apenas começar cegamente a desenhar um, depois dois,

01:37:45.130 --> 01:37:46.540
depois três camadas de tijolos.

01:37:46.540 --> 01:37:50.380
Deixe-me solicitar ao humano como antes a altura da pirâmide

01:37:50.380 --> 01:37:53.350
eles querem usar nossa função get int.

01:37:53.350 --> 01:37:55.670
E agora deixe-me chamar de desenho de altura novamente.

01:37:55.670 --> 01:37:58.330
Então agora estou voltando para a versão em loop.

01:37:58.330 --> 01:38:03.250
Mas, em vez de usar um loop agora, é aqui que a recursão fica bastante elegante,

01:38:03.250 --> 01:38:04.120
Se você for.

01:38:04.120 --> 01:38:10.690
Deixe-me prosseguir e executar e codificar a função de desenho da seguinte maneira.

01:38:10.690 --> 01:38:14.050
Pela sua definição, se uma pirâmide de altura 4

01:38:14.050 --> 01:38:17.437
é realmente apenas uma pirâmide de altura 3 mais outra linha, bem,

01:38:17.437 --> 01:38:18.520
vamos levar isso literalmente.

01:38:18.520 --> 01:38:19.990
Deixe-me voltar ao meu código.

01:38:19.990 --> 01:38:24.340
E se você quiser desenhar uma pirâmide de altura 4, vá em frente

01:38:24.340 --> 01:38:29.380
e desenhe uma pirâmide de altura 3 primeiro, ou mais geralmente, n menos 1.

01:38:29.380 --> 01:38:30.640
Mas qual é o segundo passo?

01:38:30.640 --> 01:38:34.510
Bem, depois de desenhar uma pirâmide de altura 3, desenhe uma linha extra.

01:38:34.510 --> 01:38:37.190
Então eu pelo menos tenho que morder essa parte do problema sozinho.

01:38:37.190 --> 01:38:39.310
Então deixe-me fazer para int eu recebo 0.

01:38:39.310 --> 01:38:41.530
i é menor que n i++.

01:38:41.530 --> 01:38:46.010
E deixe-me, o programador desta função, imprimir meus hashes.

01:38:46.010 --> 01:38:48.340
E então, na parte inferior, imprima uma nova linha

01:38:48.340 --> 01:38:50.350
então o cursor se move para a próxima linha.

01:38:50.350 --> 01:38:55.660
Mas isso é meio elegante agora, ouso dizer, em que o desenho é recursivo,

01:38:55.660 --> 01:38:58.570
porque estou literalmente traduzindo do inglês para o código C,

01:38:58.570 --> 01:39:02.050
essa ideia de que uma pirâmide de altura 4 é na verdade apenas uma pirâmide de altura 3.

01:39:02.050 --> 01:39:03.640
Então eu faço isso primeiro.

01:39:03.640 --> 01:39:06.560
E estou meio que confiante de que isso vai funcionar.

01:39:06.560 --> 01:39:09.800
Depois é só colocar mais uma camada de tijolos, quatro deles.

01:39:09.800 --> 01:39:13.030
Portanto, se n é 4, este é apenas um loop for simples, à la semana 1,

01:39:13.030 --> 01:39:15.520
que irá imprimir uma camada adicional.

01:39:15.520 --> 01:39:18.610
Mas isso, é claro, será problemático eventualmente.

01:39:18.610 --> 01:39:20.030
Por que?

01:39:20.030 --> 01:39:22.670
Ainda não está pronto, este programa.

01:39:22.670 --> 01:39:27.644
Quantas vezes o desenho se chamará neste modelo?

01:39:27.644 --> 01:39:28.640
ALUNO: É infinito.

01:39:28.640 --> 01:39:30.098
DAVID MALAN: Infinitas vezes.

01:39:30.098 --> 01:39:30.814
Por que?

01:39:30.814 --> 01:39:34.170
ALUNO: Porque não há função de sair.

01:39:34.170 --> 01:39:36.450
DAVID MALAN: Sim, não há equivalente a desistir.

01:39:36.450 --> 01:39:39.810
Tipo, se você já imprimiu o suficiente, então saia, bem,

01:39:39.810 --> 01:39:41.050
como captamos isso?

01:39:41.050 --> 01:39:43.320
Bem, acho que não queremos que isso fique negativo.

01:39:43.320 --> 01:39:46.570
Não faria sentido desenhar uma pirâmide de altura negativa.

01:39:46.570 --> 01:39:51.270
Então, acho que podemos pegar, como programador, um caso fácil,

01:39:51.270 --> 01:39:53.650
uma resposta fácil, o chamado caso básico.

01:39:53.650 --> 01:39:54.900
E eu só vou fazer isso.

01:39:54.900 --> 01:40:00.030
No topo da minha função de desenho, deixe-me apenas dizer, se n for menor que

01:40:00.030 --> 01:40:02.830
ou, diabos, menor ou igual a 0, é isso.

01:40:02.830 --> 01:40:04.530
Vá em frente e apenas volte.

01:40:04.530 --> 01:40:06.030
Não há mais nada a fazer.

01:40:06.030 --> 01:40:10.680
E essa condição simples, tecnicamente conhecida como caso base,

01:40:10.680 --> 01:40:13.290
garantirá que o código não seja executado para sempre.

01:40:13.290 --> 01:40:13.860
Por que?

01:40:13.860 --> 01:40:17.730
Bem, suponha que draw seja chamado com um argumento de 4.

01:40:17.730 --> 01:40:20.580
4 é, claro, não menor que 0, então não retornamos.

01:40:20.580 --> 01:40:22.590
Mas desenhamos uma pirâmide de altura 3.

01:40:22.590 --> 01:40:24.870
E é aqui que as coisas ficam um pouco complicadas mentalmente.

01:40:24.870 --> 01:40:28.320
Você não avança para a linha 20 até que o empate seja chamado.

01:40:28.320 --> 01:40:31.080
Então, quando draw é chamado com um argumento de 3,

01:40:31.080 --> 01:40:34.230
é como se você estivesse executando a partir do início desta função novamente.

01:40:34.230 --> 01:40:35.520
3 não é menor que 0.

01:40:35.520 --> 01:40:36.330
Então, o que você faz?

01:40:36.330 --> 01:40:38.490
Você desenha 2.

01:40:38.490 --> 01:40:39.540
Como você desenha 2?

01:40:39.540 --> 01:40:41.950
Bem, 2 não é menor que 0, então você não retorna.

01:40:41.950 --> 01:40:43.050
Então você desenha 1.

01:40:43.050 --> 01:40:44.370
Tem que ter cuidado aqui.

01:40:44.370 --> 01:40:45.240
Desenhe 1.

01:40:45.240 --> 01:40:47.340
E agora, vamos voltar ao início.

01:40:47.340 --> 01:40:48.090
Como você desenha 1?

01:40:48.090 --> 01:40:50.430
Bem, 1 não é menor que 0, então você não retorna.

01:40:50.430 --> 01:40:53.400
Você desenha altura 0.

01:40:53.400 --> 01:40:54.510
Como você desenha altura 0?

01:40:54.510 --> 01:40:55.110
Espere um minuto.

01:40:55.110 --> 01:40:57.660
0 é menor ou igual a 0.

01:40:57.660 --> 01:40:58.980
E você volta.

01:40:58.980 --> 01:41:02.100
E então é como esta pilha mental, esta lista de tarefas.

01:41:02.100 --> 01:41:05.190
Você continua adiando, executando essas linhas de código inferiores,

01:41:05.190 --> 01:41:08.700
porque você continua reiniciando, reiniciando, reiniciando a função de desenho

01:41:08.700 --> 01:41:12.840
até que, finalmente, uma dessas chamadas de função diga que não há nada a fazer,

01:41:12.840 --> 01:41:13.530
retornar.

01:41:13.530 --> 01:41:16.530
E agora a coisa toda começa a se desenrolar, se você quiser.

01:41:16.530 --> 01:41:18.330
E você retoma de onde parou.

01:41:18.330 --> 01:41:20.300
E este é, talvez, o melhor cenário.

01:41:20.300 --> 01:41:21.300
Não faremos isso em sala de aula.

01:41:21.300 --> 01:41:23.508
Mas se você gostaria de lutar por isso sozinho

01:41:23.508 --> 01:41:27.780
usando debug50 para continuar entrando, entrando, entrando, cada

01:41:27.780 --> 01:41:31.480
dessas linhas, logicamente, você verá exatamente o que está realmente acontecendo.

01:41:31.480 --> 01:41:34.330
Então deixe-me ir ao meu terminal e fazer recursão,

01:41:34.330 --> 01:41:37.740
que agora é esta versão correta do código, recursão de ponto e barra.

01:41:37.740 --> 01:41:39.240
Vamos digitar uma altura de 4.

01:41:39.240 --> 01:41:44.730
E pronto, agora temos a mesma pirâmide, não usando a iteração per se,

01:41:44.730 --> 01:41:47.910
embora reconheçamos que estamos usando iteração para imprimir a camada adicional.

01:41:47.910 --> 01:41:53.340
Agora estamos usando draw recursivamente para imprimir todas as pirâmides menores

01:41:53.340 --> 01:41:55.120
essa necessidade vem antes dela.

01:41:55.120 --> 01:41:57.370
ALUNO: Você só pode usar recursão para a função void?

01:41:57.370 --> 01:41:58.123
[INAUDÍVEL]

01:41:58.123 --> 01:41:58.790
DAVID MALAN: Não.

01:41:58.790 --> 01:42:01.070
A pergunta é: você só pode usar recursão com uma função void?

01:42:01.070 --> 01:42:01.920
Não, de jeito nenhum.

01:42:01.920 --> 01:42:05.120
Na verdade, é muito comum ter um valor de retorno como um número inteiro

01:42:05.120 --> 01:42:09.350
ou outra coisa para que você possa realmente fazer algo de forma construtiva

01:42:09.350 --> 01:42:11.360
com esse valor real.

01:42:11.360 --> 01:42:13.190
Outras perguntas sobre isso.

01:42:13.190 --> 01:42:15.290
ALUNO: Quando a linha 21 está sendo executada?

01:42:15.290 --> 01:42:16.790
DAVID MALAN: Diga um pouco mais alto.

01:42:16.790 --> 01:42:18.770
ALUNO: Quando a linha 21 está sendo executada?

01:42:18.770 --> 01:42:20.850
DAVID MALAN: Quando a linha 21 está sendo executada?

01:42:20.850 --> 01:42:23.720
Então, se você continuar a--

01:42:23.720 --> 01:42:26.600
deixe-me rolar um pouco mais para baixo para que você possa ver a parte superior do código.

01:42:26.600 --> 01:42:35.310
Portanto, a linha 21 será executada assim que a linha 19 terminar de se executar.

01:42:35.310 --> 01:42:40.790
Agora, na história que contei, continuamos chamando empate de novo, de novo, de novo.

01:42:40.790 --> 01:42:43.400
Mas assim que uma dessas chamadas de função

01:42:43.400 --> 01:42:46.490
onde n é igual a 0 retorna imediatamente, então nós

01:42:46.490 --> 01:42:48.510
não fique desenhando de novo e de novo.

01:42:48.510 --> 01:42:51.110
Agora, se você pensar no processo como reverso,

01:42:51.110 --> 01:42:57.530
então você continua na linha 21, depois na linha 21 novamente, depois na linha 21 novamente,

01:42:57.530 --> 01:42:59.303
e como o tipo de lógica se desenrola.

01:42:59.303 --> 01:43:01.970
E na próxima semana, vamos pintar um quadro do que é realmente

01:43:01.970 --> 01:43:03.530
acontecendo na memória do computador.

01:43:03.530 --> 01:43:07.450
Mas, por enquanto, é apenas muito semelhante ao pseudocódigo do telefone

01:43:07.450 --> 01:43:07.950
livro.

01:43:07.950 --> 01:43:09.680
Você está apenas procurando de novo e de novo.

01:43:09.680 --> 01:43:14.408
Mas você está esperando até o final para obter o resultado final.

01:43:14.408 --> 01:43:16.700
Google agora, que continuo mencionando por coincidência hoje,

01:43:16.700 --> 01:43:18.830
está cheio de programadores, é claro.

01:43:18.830 --> 01:43:20.600
Aqui está um exercício divertido.

01:43:20.600 --> 01:43:23.432
Deixe-me voltar para um navegador.

01:43:23.432 --> 01:43:26.390
Vou procurar recursão, porque quero aprender

01:43:26.390 --> 01:43:27.980
um pouco sobre recursão.

01:43:27.980 --> 01:43:30.230
Aqui está uma espécie de meme ou piada da internet.

01:43:30.230 --> 01:43:35.360
Se eu aumentar o zoom aqui, os engenheiros do Google são engraçados.

01:43:35.360 --> 01:43:37.902
Veja porque?

01:43:37.902 --> 01:43:38.798
ALUNO: Ah.

01:43:38.798 --> 01:43:40.540
DAVID MALAN: Ah, aí está.

01:43:40.540 --> 01:43:41.740
Sim.

01:43:41.740 --> 01:43:43.030
Sim, isso é recursão.

01:43:43.030 --> 01:43:45.822
E haverá tantos memes que você encontrará agora, onde

01:43:45.822 --> 01:43:48.490
recursão, como se você já apontasse uma câmera para a TV

01:43:48.490 --> 01:43:51.190
mostrando a câmera, e você meio que vê a si mesmo ou a imagem de novo e de novo,

01:43:51.190 --> 01:43:52.660
isso é realmente recursão.

01:43:52.660 --> 01:43:56.320
E, nesse caso, ele só para quando você atinge o caso básico de um único pixel.

01:43:56.320 --> 01:43:59.350
Mas esta é uma piada muito engraçada em alguns círculos

01:43:59.350 --> 01:44:01.880
quando se trata de recursão e Google.

01:44:01.880 --> 01:44:04.570
Então, como podemos realmente usar o Google, ou melhor,

01:44:04.570 --> 01:44:08.050
como podemos realmente usar a recursão de forma construtiva?

01:44:08.050 --> 01:44:11.320
Bem, deixe-me propor que nós realmente apresentamos

01:44:11.320 --> 01:44:14.950
um terceiro e último algoritmo para classificação que, com sorte, faz melhor

01:44:14.950 --> 01:44:16.870
do que os dois tipos até agora.

01:44:16.870 --> 01:44:19.480
Fizemos classificação por seleção e classificação por bolha.

01:44:19.480 --> 01:44:22.845
Tipo de bolha, gostamos um pouco melhor, pelo menos na melhor das hipóteses

01:44:22.845 --> 01:44:24.220
onde a lista já está ordenada.

01:44:24.220 --> 01:44:26.387
O Bubble sort é pelo menos mais inteligente e, na verdade,

01:44:26.387 --> 01:44:28.840
terminar mais cedo, dando-nos um limite inferior melhor,

01:44:28.840 --> 01:44:30.490
em termos de nossa notação ômega.

01:44:30.490 --> 01:44:33.100
Mas acontece que a recursão, e isso não é

01:44:33.100 --> 01:44:36.250
necessariamente um recurso de recursão, mas algo que agora podemos aproveitar.

01:44:36.250 --> 01:44:39.460
Acontece que, usando recursão, podemos adotar uma abordagem fundamentalmente diferente

01:44:39.460 --> 01:44:43.090
para classificar um monte de números de tal maneira

01:44:43.090 --> 01:44:47.560
que podemos fazer muito menos comparações e, idealmente, acelerar

01:44:47.560 --> 01:44:49.010
nossos resultados finais.

01:44:49.010 --> 01:44:51.970
Então aqui está o pseudocódigo para o que estamos prestes a ver

01:44:51.970 --> 01:44:54.010
para algo chamado merge sort.

01:44:54.010 --> 01:44:56.230
E é realmente tão conciso.

01:44:56.230 --> 01:44:58.330
Classifique a metade esquerda dos números.

01:44:58.330 --> 01:45:00.550
Classifique a metade direita dos números.

01:45:00.550 --> 01:45:02.950
Mesclar as metades classificadas.

01:45:02.950 --> 01:45:06.310
Isso é quase sem sentido, porque se você

01:45:06.310 --> 01:45:09.880
pediu um algoritmo para classificar, e você respondeu com, bem, classifique a metade esquerda,

01:45:09.880 --> 01:45:10.960
classificar a metade direita.

01:45:10.960 --> 01:45:14.230
Isso está sendo difícil, porque bem, estou pedindo um algoritmo de classificação.

01:45:14.230 --> 01:45:16.897
Você está apenas me dizendo para classificar a metade esquerda e a metade direita.

01:45:16.897 --> 01:45:21.130
Mas implícito na última linha, a fusão é um recurso bastante poderoso

01:45:21.130 --> 01:45:21.760
deste tipo.

01:45:21.760 --> 01:45:23.908
Agora, precisamos de outro caso base no topo.

01:45:23.908 --> 01:45:24.700
Então deixe-me adicionar isso.

01:45:24.700 --> 01:45:27.850
Se nos encontrarmos com uma lista, um array, de tamanho 1,

01:45:27.850 --> 01:45:29.807
bem, esse array está obviamente classificado.

01:45:29.807 --> 01:45:32.390
Se houver apenas um elemento nele, não há trabalho a ser feito.

01:45:32.390 --> 01:45:33.890
Então esse será o nosso caso base.

01:45:33.890 --> 01:45:38.770
Mas permitindo-nos agora, apenas nestes, o que, quatro, seis linhas de pseudocódigo,

01:45:38.770 --> 01:45:40.900
para realmente classificar alguns elementos.

01:45:40.900 --> 01:45:43.652
Mas vamos nos concentrar primeiro em apenas um subconjunto disso.

01:45:43.652 --> 01:45:46.360
Vamos considerar por um momento o que significa mesclar metades classificadas.

01:45:46.360 --> 01:45:48.760
Então Carter veio maravilhosamente para ser voluntário aqui

01:45:48.760 --> 01:45:50.170
para nos ajudar a redefinir esses números.

01:45:50.170 --> 01:45:54.080
Suponha que no meio da história que estamos prestes a contar,

01:45:54.080 --> 01:45:56.020
temos duas metades classificadas.

01:45:56.020 --> 01:45:58.300
Eu já classifiquei a metade esquerda desses números,

01:45:58.300 --> 01:46:01.630
e, de fato, 2, 4, 5, 7 é classificado do menor para o maior.

01:46:01.630 --> 01:46:06.100
E a metade direita parece já estar classificada, 0, 1, 3, 6, já classificada.

01:46:06.100 --> 01:46:09.370
Então, no meu pseudocódigo, já terminamos de classificar a metade esquerda

01:46:09.370 --> 01:46:10.630
e a metade direita de alguma forma.

01:46:10.630 --> 01:46:12.160
Mas veremos como daqui a pouco.

01:46:12.160 --> 01:46:14.980
Bem, como faço para mesclar essas duas metades?

01:46:14.980 --> 01:46:18.490
Bem, como eles já estão classificados e você deseja mesclá-los em ordem,

01:46:18.490 --> 01:46:20.110
Acho que podemos virar para baixo.

01:46:20.110 --> 01:46:25.030
Podemos ocultar todos, exceto os primeiros números, em cada uma dessas sublistas.

01:46:25.030 --> 01:46:28.125
Então, aqui, temos uma metade que começa com 2.

01:46:28.125 --> 01:46:30.250
E eu realmente não me importo com quais são os outros números,

01:46:30.250 --> 01:46:32.060
porque eles são claramente maiores que 2.

01:46:32.060 --> 01:46:35.043
Posso me concentrar apenas em 2 e 0 também, 0 também.

01:46:35.043 --> 01:46:37.960
Sabemos que 0 é o menor ali, então vamos ignorar os números

01:46:37.960 --> 01:46:39.293
que Carter gentilmente derrubou.

01:46:39.293 --> 01:46:44.360
Então, como faço para mesclar essas duas listas em uma nova lista maior classificada?

01:46:44.360 --> 01:46:47.590
Bem, eu comparo os dois à minha esquerda com o 0

01:46:47.590 --> 01:46:50.470
à minha direita, obviamente, o que vem primeiro, o 0.

01:46:50.470 --> 01:46:51.963
Então deixe-me colocar isso aqui.

01:46:51.963 --> 01:46:54.130
E Carter, se você quiser nos dar o próximo elemento.

01:46:54.130 --> 01:46:55.960
Agora eu tenho duas metades classificadas.

01:46:55.960 --> 01:46:57.650
Mas já tirei um.

01:46:57.650 --> 01:47:00.010
Então agora eu comparo os dois contra o 1.

01:47:00.010 --> 01:47:01.580
1 obviamente vem a seguir.

01:47:01.580 --> 01:47:04.843
Vou tirar o 1 e colocar aqui.

01:47:04.843 --> 01:47:06.760
Agora vou comparar as duas metades novamente.

01:47:06.760 --> 01:47:08.830
2 e 3, qual devo mesclar primeiro?

01:47:08.830 --> 01:47:10.660
Obviamente, o 2 vem a seguir.

01:47:10.660 --> 01:47:14.170
E agora, observe, cada vez que faço isso, minhas mãos estão teoricamente

01:47:14.170 --> 01:47:15.220
avançando.

01:47:15.220 --> 01:47:18.580
Não estou dobrando de volta como sempre fiz com o tipo de seleção ou bolha

01:47:18.580 --> 01:47:20.290
classificar, para frente e para trás, para frente e para trás.

01:47:20.290 --> 01:47:22.810
Meus dedos estão constantemente avançando,

01:47:22.810 --> 01:47:24.310
e isso vai ser um detalhe chave.

01:47:24.310 --> 01:47:27.340
Então eu comparo 4 e 3, 3 obviamente.

01:47:27.340 --> 01:47:32.560
Eu comparo 4 e 6, 4 obviamente.

01:47:32.560 --> 01:47:36.520
Eu comparo 5 e 6, 5 obviamente.

01:47:36.520 --> 01:47:40.810
E então eu comparo 7 e 6, 6 é claro.

01:47:40.810 --> 01:47:43.000
E, finalmente, temos apenas um elemento restante.

01:47:43.000 --> 01:47:45.460
E mesmo que eu esteja me movendo desajeitadamente como humano,

01:47:45.460 --> 01:47:48.160
minhas mãos tecnicamente só estavam se movendo para a direita.

01:47:48.160 --> 01:47:51.130
Eu nunca estava voltando a fazer algo de novo e de novo.

01:47:51.130 --> 01:47:54.430
E isso é, talvez, a intuição e espaço suficiente para o 7.

01:47:54.430 --> 01:47:58.210
Então, é assim que você mesclaria duas metades classificadas.

01:47:58.210 --> 01:48:00.610
Começamos com a metade esquerda classificada e a metade direita classificada.

01:48:00.610 --> 01:48:02.860
E a fusão é exatamente como o que você faria como humano.

01:48:02.860 --> 01:48:04.568
E Carter apenas virou os números para baixo,

01:48:04.568 --> 01:48:08.620
então nosso foco estava apenas nos menores elementos de cada um.

01:48:08.620 --> 01:48:13.030
Qualquer dúvida antes de prosseguirmos com o que isso significa, então,

01:48:13.030 --> 01:48:17.120
para ser mesclado desta forma?

01:48:17.120 --> 01:48:18.777
Então agora, aqui está uma lista original.

01:48:18.777 --> 01:48:20.860
Nós o colocamos deliberadamente no topo, porque há

01:48:20.860 --> 01:48:22.480
um detalhe do merge sort que é a chave.

01:48:22.480 --> 01:48:25.490
O Merge sort tecnicamente vai usar um pouco mais de espaço.

01:48:25.490 --> 01:48:28.270
E assim, enquanto anteriormente, apenas continuávamos movendo nossos humanos

01:48:28.270 --> 01:48:30.790
e trocar pessoas e garantir que elas ficassem no final

01:48:30.790 --> 01:48:32.110
nas posições originais.

01:48:32.110 --> 01:48:36.700
Com classificação por mesclagem, finge que aqui está nossa matriz original de memória.

01:48:36.700 --> 01:48:38.970
Vou precisar de pelo menos um outro array de memória.

01:48:38.970 --> 01:48:41.160
E vou trapacear e vou usar ainda mais memória.

01:48:41.160 --> 01:48:43.440
Mas, tecnicamente, eu poderia realmente ir e voltar

01:48:43.440 --> 01:48:45.540
entre 1 array e um array secundário.

01:48:45.540 --> 01:48:48.370
Mas vai me ocupar mais espaço.

01:48:48.370 --> 01:48:53.130
Então, como faço para implementar o merge sort neste código?

01:48:53.130 --> 01:48:54.930
Bem, vamos considerar isso.

01:48:54.930 --> 01:48:57.060
Aqui está uma matriz de tamanho 8.

01:48:57.060 --> 01:48:59.590
Se apenas um número sair, obviamente não aplicável.

01:48:59.590 --> 01:49:01.230
Então vamos focar na parte suculenta aí.

01:49:01.230 --> 01:49:02.880
Classifique a metade esquerda dos números.

01:49:02.880 --> 01:49:05.130
Certo, como classifico a metade esquerda dos números?

01:49:05.130 --> 01:49:09.240
Vou apenas empurrá-los para ficar claro, que é a metade esquerda.

01:49:09.240 --> 01:49:11.850
Aqui está agora uma sublista de tamanho 4.

01:49:11.850 --> 01:49:14.860
Como faço para classificar a metade esquerda?

01:49:14.860 --> 01:49:17.380
Bem, eu tenho um algoritmo para classificação?

01:49:17.380 --> 01:49:18.430
Sim, o que eu faço?

01:49:18.430 --> 01:49:19.492
Aqui está uma lista de tamanho 4.

01:49:19.492 --> 01:49:20.200
Como faço para classificar isso?

01:49:20.200 --> 01:49:22.000
Qual é o primeiro passo?

01:49:22.000 --> 01:49:23.330
Classifique a metade esquerda.

01:49:23.330 --> 01:49:28.060
Agora, conceitualmente em minha mente, pego essa sublista de tamanho 4.

01:49:28.060 --> 01:49:32.740
E eu classifico primeiro classificando a metade esquerda, focando agora no 7 e no 2.

01:49:32.740 --> 01:49:34.330
Tudo bem, aqui está uma lista de tamanho 2.

01:49:34.330 --> 01:49:37.060
Como faço para classificar uma lista de tamanho 2?

01:49:37.060 --> 01:49:38.740
ALUNO: [INAUDÍVEL]

01:49:38.740 --> 01:49:40.170
DAVID MALAN: Desculpe?

01:49:40.170 --> 01:49:42.360
Acho que continuamos seguindo nossas instruções.

01:49:42.360 --> 01:49:43.650
Classifique a metade esquerda.

01:49:43.650 --> 01:49:45.630
Tudo bem, aqui está uma lista de tamanho 1.

01:49:45.630 --> 01:49:48.417
Como faço para classificar uma lista de tamanho 1?

01:49:48.417 --> 01:49:49.803
ALUNO: [INAUDÍVEL]

01:49:49.803 --> 01:49:50.720
DAVID MALAN: Acabei.

01:49:50.720 --> 01:49:51.360
Está feito.

01:49:51.360 --> 01:49:52.740
Então eu deixo isso sozinho.

01:49:52.740 --> 01:49:54.740
Qual foi o próximo passo na história?

01:49:54.740 --> 01:49:58.160
Acabei de classificar a metade esquerda da metade esquerda da metade esquerda.

01:49:58.160 --> 01:49:59.580
O que vem depois?

01:49:59.580 --> 01:50:03.260
Eu classifico a metade direita da metade esquerda da metade esquerda,

01:50:03.260 --> 01:50:06.260
e pronto, porque é apenas uma lista de tamanho 1.

01:50:06.260 --> 01:50:09.280
O que vem depois disso?

01:50:09.280 --> 01:50:09.972
Mesclar.

01:50:09.972 --> 01:50:11.680
Então é aqui que fica um pouco estranho,

01:50:11.680 --> 01:50:14.770
porque você tem que lembrar onde estamos pausando a história para fazer as coisas

01:50:14.770 --> 01:50:16.187
recursivamente de novo e de novo.

01:50:16.187 --> 01:50:19.270
Mas se eu apenas classifiquei a metade esquerda e a metade direita,

01:50:19.270 --> 01:50:20.890
agora eu os fundi.

01:50:20.890 --> 01:50:25.040
Esta é uma lista super curta, então não precisamos da ajuda de Carter aqui como antes.

01:50:25.040 --> 01:50:27.640
Mas acho que o primeiro número que tomo aqui é o 2.

01:50:27.640 --> 01:50:31.660
E então o segundo número que eu pego, porque é a única opção, é o 7.

01:50:31.660 --> 01:50:35.260
Mas o que é bom agora é que, observe, a metade esquerda da metade esquerda

01:50:35.260 --> 01:50:39.228
está de fato classificado, porque classifiquei trivialmente a metade esquerda dele

01:50:39.228 --> 01:50:40.270
e a metade direita dela.

01:50:40.270 --> 01:50:42.760
Mas a fusão é realmente onde a mágica acontece.

01:50:42.760 --> 01:50:45.670
Tudo bem, novamente, se você retroceder agora em sua mente,

01:50:45.670 --> 01:50:51.300
se acabei de classificar a metade esquerda da metade esquerda, o que acontece a seguir?

01:50:51.300 --> 01:50:55.000
Classifique a metade direita da metade esquerda.

01:50:55.000 --> 01:50:56.980
Então, novamente, você meio que retrocede no tempo.

01:50:56.980 --> 01:50:58.290
Então, como faço isso?

01:50:58.290 --> 01:50:59.520
Tenho uma lista de tamanho 2.

01:50:59.520 --> 01:51:01.920
Eu classifico a metade esquerda, apenas o 5, pronto.

01:51:01.920 --> 01:51:04.200
Ordene a metade direita, 4, pronto.

01:51:04.200 --> 01:51:08.910
Agora a parte interessante, eu mesclo a metade esquerda e a metade direita

01:51:08.910 --> 01:51:11.380
da metade direita da metade esquerda.

01:51:11.380 --> 01:51:12.450
Então o que eu faço?

01:51:12.450 --> 01:51:14.280
4 vem aqui.

01:51:14.280 --> 01:51:16.260
5 desce aqui.

01:51:16.260 --> 01:51:19.860
E agora, observe o que eu tenho.

01:51:19.860 --> 01:51:21.600
A metade esquerda está classificada.

01:51:21.600 --> 01:51:23.130
A metade direita está classificada.

01:51:23.130 --> 01:51:26.610
Se você voltar no tempo, onde está meu próximo passo, 3?

01:51:26.610 --> 01:51:27.742
Junte as duas metades.

01:51:27.742 --> 01:51:29.700
E foi isso que Carter me ajudou a fazer antes.

01:51:29.700 --> 01:51:31.290
Vamos nos concentrar apenas nos menores elementos,

01:51:31.290 --> 01:51:32.665
apenas para que haja menos distração.

01:51:32.665 --> 01:51:34.020
Comparo o 2 e o 4.

01:51:34.020 --> 01:51:36.520
2 vem primeiro, então vamos obviamente colocar isso aqui.

01:51:36.520 --> 01:51:39.570
Agora, eu comparo o novo começo desta lista

01:51:39.570 --> 01:51:41.280
e o antigo começo desta lista.

01:51:41.280 --> 01:51:43.050
4 obviamente vem a seguir.

01:51:43.050 --> 01:51:45.940
E agora, comparo o 7 com o 5.

01:51:45.940 --> 01:51:47.430
5 obviamente vem a seguir.

01:51:47.430 --> 01:51:49.240
E agora, por último, fico com um número.

01:51:49.240 --> 01:51:50.970
Então agora estou no 7.

01:51:50.970 --> 01:51:53.490
Portanto, mesmo que você tenha perdido a noção de algumas das nuances

01:51:53.490 --> 01:51:55.510
aqui, se você apenas der um passo para trás,

01:51:55.510 --> 01:51:58.260
temos a metade direita original aqui ainda intocada.

01:51:58.260 --> 01:52:03.210
Mas a metade esquerda da entrada original agora está, de fato, classificada,

01:52:03.210 --> 01:52:07.140
tudo por meio da classificação metade esquerda, metade direita, metade esquerda, metade direita,

01:52:07.140 --> 01:52:08.940
mas com essas fusões intermediárias.

01:52:08.940 --> 01:52:11.965
Tudo bem, se acabamos de classificar a metade esquerda,

01:52:11.965 --> 01:52:13.590
rebobinamos todo o caminho até o começo.

01:52:13.590 --> 01:52:15.590
O que eu faço agora?

01:52:15.590 --> 01:52:17.120
Tudo bem, então classifique a metade certa.

01:52:17.120 --> 01:52:18.410
Então classifique a metade direita.

01:52:18.410 --> 01:52:20.180
Como faço para classificar uma lista de tamanho 4?

01:52:20.180 --> 01:52:22.550
Bem, primeiro classifico a metade esquerda, o 1 e o 6.

01:52:22.550 --> 01:52:24.560
Como faço para classificar uma lista de tamanho 2?

01:52:24.560 --> 01:52:26.757
Você classifica a metade esquerda, apenas o número 1.

01:52:26.757 --> 01:52:28.340
Obviamente, não há trabalho a ser feito.

01:52:28.340 --> 01:52:30.620
Feito, classificando a metade esquerda.

01:52:30.620 --> 01:52:33.080
6, feito, classificando a metade direita.

01:52:33.080 --> 01:52:34.280
Agora o que eu faço?

01:52:34.280 --> 01:52:40.610
Eu fundi a metade esquerda aqui com a metade direita aqui.

01:52:40.610 --> 01:52:42.240
E esse é bem direto.

01:52:42.240 --> 01:52:43.050
Agora o que eu faço?

01:52:43.050 --> 01:52:43.910
Acabei de mesclar.

01:52:43.910 --> 01:52:45.048
Então agora eu classifico.

01:52:45.048 --> 01:52:47.090
Acabei de classificar a metade esquerda da metade direita.

01:52:47.090 --> 01:52:49.550
Então agora eu classifico a metade direita da metade direita.

01:52:49.550 --> 01:52:51.590
Então eu considero o 0, feito.

01:52:51.590 --> 01:52:53.270
Eu considero o 3, feito.

01:52:53.270 --> 01:52:55.040
Eu agora fundir esses dois juntos.

01:52:55.040 --> 01:52:56.640
0, é claro, vem primeiro.

01:52:56.640 --> 01:52:58.100
Depois vem o 3.

01:52:58.100 --> 01:53:00.680
E agora estou no ponto da história onde

01:53:00.680 --> 01:53:02.930
Eu classifiquei a metade esquerda da metade direita

01:53:02.930 --> 01:53:04.910
e a metade direita da metade direita.

01:53:04.910 --> 01:53:07.535
Portanto, o passo 3 é mesclar.

01:53:07.535 --> 01:53:09.410
E farei de novo como fizemos com Carter.

01:53:09.410 --> 01:53:12.320
Tudo bem, 1 e 0, obviamente o 0 vem primeiro.

01:53:12.320 --> 01:53:14.390
Agora, compare o 1 e o 3.

01:53:14.390 --> 01:53:16.130
Obviamente, o 1 vem primeiro.

01:53:16.130 --> 01:53:18.590
Compare o 6 e o ​​3, obviamente o 3.

01:53:18.590 --> 01:53:20.300
E por último, o 6.

01:53:20.300 --> 01:53:21.890
Então agora, onde estamos?

01:53:21.890 --> 01:53:26.840
Pegamos a metade esquerda de tudo e a classificamos.

01:53:26.840 --> 01:53:29.990
Em seguida, pegamos a metade certa de tudo e a classificamos.

01:53:29.990 --> 01:53:33.560
Então agora estamos, finalmente, no passo 3 pela última vez.

01:53:33.560 --> 01:53:35.120
O que nós fazemos?

01:53:35.120 --> 01:53:35.780
Mesclar.

01:53:35.780 --> 01:53:40.220
E então, só para ser consistente, deixe-me empurrá-los para baixo e vamos comparar.

01:53:40.220 --> 01:53:43.310
Mão esquerda ou mão direita, percebendo que só avançam,

01:53:43.310 --> 01:53:45.230
nada dessas comparações de ida e volta.

01:53:45.230 --> 01:53:47.270
2 e 0, claro, o 0.

01:53:47.270 --> 01:53:48.860
Então vamos colocar isso no lugar.

01:53:48.860 --> 01:53:51.140
2 e 1, claro, o 1.

01:53:51.140 --> 01:53:52.880
Então nós colocamos isso no lugar.

01:53:52.880 --> 01:53:56.930
2 e 3, nós nos fundimos, é claro, no 2 neste caso.

01:53:56.930 --> 01:54:00.770
4 e 3, agora fundimos no 3 neste caso.

01:54:00.770 --> 01:54:05.630
4 e 6, agora juntamos, é claro, o 4 no lugar.

01:54:05.630 --> 01:54:07.760
E agora, comparamos 5 e 6.

01:54:07.760 --> 01:54:08.615
Mantemos o 5.

01:54:12.590 --> 01:54:15.226
Erro.

01:54:15.226 --> 01:54:17.295
OK, vamos fingir que o 5 está ligado.

01:54:20.040 --> 01:54:21.450
Ah, é por isso.

01:54:21.450 --> 01:54:24.240
Tudo bem, agora comparamos o 7 e o 6.

01:54:24.240 --> 01:54:26.430
6º se foi.

01:54:26.430 --> 01:54:29.520
E por último, 7 é o último no lugar.

01:54:29.520 --> 01:54:32.140
E mesmo que eu conceda isso de todos os algoritmos,

01:54:32.140 --> 01:54:34.320
este é provavelmente o mais difícil de se manter atualizado,

01:54:34.320 --> 01:54:36.210
especialmente quando estou fazendo isso como locução.

01:54:36.210 --> 01:54:41.010
Perceba que o que acabamos de fazer são apenas essas três etapas, recursivamente.

01:54:41.010 --> 01:54:42.510
Começamos com uma lista de tamanho 8.

01:54:42.510 --> 01:54:43.650
Nós classificamos a metade esquerda.

01:54:43.650 --> 01:54:44.790
Nós classificamos a metade direita.

01:54:44.790 --> 01:54:46.450
E então juntamos os dois.

01:54:46.450 --> 01:54:48.960
Mas se você descer cada uma dessas tocas de coelho, por assim dizer,

01:54:48.960 --> 01:54:52.410
classificar a metade esquerda envolve classificar a metade esquerda da metade esquerda

01:54:52.410 --> 01:54:54.970
e a metade direita da metade esquerda, e assim por diante.

01:54:54.970 --> 01:54:59.250
Mas esse germe de ideia de realmente dividir e vencer o problema,

01:54:59.250 --> 01:55:02.520
não que você esteja tendo o problema e lidando apenas com a metade.

01:55:02.520 --> 01:55:05.700
Claramente, estamos classificando uma metade e a outra metade

01:55:05.700 --> 01:55:07.780
e fundi-los, em última instância.

01:55:07.780 --> 01:55:10.810
Isso ainda nos leva à mesma solução.

01:55:10.810 --> 01:55:14.550
E se visualizarmos os restos disso agora, se eu descrever isso da seguinte forma,

01:55:14.550 --> 01:55:18.390
onde na tela aqui, você vê onde os números começaram originalmente

01:55:18.390 --> 01:55:20.310
na linha superior da esquerda para a direita.

01:55:20.310 --> 01:55:23.470
Essencialmente, embora isso esteja em uma ordem diferente,

01:55:23.470 --> 01:55:28.708
Dividi essa lista de tamanho 8, por fim, em oito listas de tamanho 1.

01:55:28.708 --> 01:55:31.000
E foi aí que o caso base entrou em ação e disse:

01:55:31.000 --> 01:55:32.580
OK, terminamos de classificar isso.

01:55:32.580 --> 01:55:37.680
E depois disso, logicamente, juntei duas listas de tamanho 1

01:55:37.680 --> 01:55:41.580
em muitas listas de tamanho 2 e essas listas de tamanho 2 em listas de tamanho 4.

01:55:41.580 --> 01:55:47.250
E, finalmente, a lista de tamanho 4 em uma grande lista classificada de tamanho 8.

01:55:47.250 --> 01:55:50.610
E então eu coloquei esta imagem com os pequenos indicadores de linha

01:55:50.610 --> 01:55:55.620
aqui, porque quantas vezes eu dividi, dividi, dividi ao meio?

01:55:55.620 --> 01:55:57.360
Ou realmente duplo, duplo, duplo.

01:55:57.360 --> 01:55:59.280
Então o expoente é o oposto--

01:55:59.280 --> 01:56:00.600
spoiler.

01:56:00.600 --> 01:56:02.610
Quantas vezes eu dividi?

01:56:02.610 --> 01:56:04.320
Então três, concretamente.

01:56:04.320 --> 01:56:08.070
Mas se houver oito elementos no total, e houver n de forma mais geral,

01:56:08.070 --> 01:56:12.300
é realmente uma questão de dividir e conquistar log n vezes.

01:56:12.300 --> 01:56:15.360
Você começa isso e pode dividir uma, duas, três vezes, log n vezes.

01:56:15.360 --> 01:56:18.930
Ou, inversamente, você pode começar aqui e dobrar exponencialmente, dobrar,

01:56:18.930 --> 01:56:21.060
dobrar três vezes, que é log n.

01:56:21.060 --> 01:56:24.510
Mas em cada fileira, cada prateleira, literalmente, eu

01:56:24.510 --> 01:56:28.350
fiz um barulho sobre apontar minhas mãos apenas da esquerda para a direita,

01:56:28.350 --> 01:56:31.380
avançando-os constantemente, de modo que toda vez que eu fazia essas fusões,

01:56:31.380 --> 01:56:34.500
Toquei cada elemento uma vez e apenas uma vez.

01:56:34.500 --> 01:56:37.470
Não havia nada disso indo e voltando, indo e vindo no palco.

01:56:37.470 --> 01:56:42.750
Então, se estou fazendo algo log n vezes, ou se estou fazendo,

01:56:42.750 --> 01:56:49.410
em vez disso, n coisas registram n vezes, qual seria nossa grande fórmula O, talvez?

01:56:49.410 --> 01:56:51.057
n coisas registram n vezes?

01:56:51.057 --> 01:56:52.140
ALUNO: Oh, é n log n.

01:56:52.140 --> 01:56:53.490
DAVID MALAN: Sim, então n log n.

01:56:53.490 --> 01:56:56.430
A ordem de n log n é, de fato, como descreveríamos

01:56:56.430 --> 01:56:58.560
o tempo de execução do merge sort.

01:56:58.560 --> 01:57:03.270
E de todos os tipos até agora, vimos esse tipo de mesclagem aqui,

01:57:03.270 --> 01:57:07.120
na verdade, é n log n, que é estritamente melhor que n ao quadrado,

01:57:07.120 --> 01:57:10.650
que é onde a classificação por seleção e a classificação por bolha foram parar.

01:57:10.650 --> 01:57:14.015
Mas também é mais lento que a pesquisa linear, por exemplo.

01:57:14.015 --> 01:57:15.390
Mas você prefere esperar isso.

01:57:15.390 --> 01:57:17.880
Se você tiver que fazer muito trabalho na classificação inicial

01:57:17.880 --> 01:57:19.878
alguns elementos em vez de apenas pesquisá-los,

01:57:19.878 --> 01:57:21.670
você vai ter que se esforçar mais.

01:57:21.670 --> 01:57:24.150
E então a questão de saber se você deve ou não apenas pesquisar algo

01:57:24.150 --> 01:57:26.670
cegamente com pesquisa linear e não se preocupar em classificá-la,

01:57:26.670 --> 01:57:30.327
realmente se resume a, você pode gastar tanto tempo?

01:57:30.327 --> 01:57:32.160
E se você é o Google do mundo, as probabilidades

01:57:32.160 --> 01:57:35.170
você não quer pesquisar o banco de dados linearmente todas as vezes.

01:57:35.170 --> 01:57:35.670
Por que?

01:57:35.670 --> 01:57:40.380
Porque você pode resolver isso uma vez e então beneficiar milhões, bilhões de pessoas,

01:57:40.380 --> 01:57:43.560
subseqüentemente usando algo como busca binária ou, francamente, na prática,

01:57:43.560 --> 01:57:46.443
algo ainda mais sofisticado e rápido do que a pesquisa binária.

01:57:46.443 --> 01:57:48.360
Mas sempre haverá essa troca.

01:57:48.360 --> 01:57:52.140
Você pode obter a pesquisa binária somente se os elementos estiverem classificados.

01:57:52.140 --> 01:57:53.940
Quanto custa para você classificá-los?

01:57:53.940 --> 01:57:56.940
Bem, talvez n ao quadrado, se você usou alguns dos algoritmos anteriores.

01:57:56.940 --> 01:58:00.850
Mas acontece que o login também é muito rápido.

01:58:00.850 --> 01:58:06.180
Portanto, no final das contas, esses tempos de execução envolvem compensações.

01:58:06.180 --> 01:58:09.600
E, de fato, no merge sort 2, devo observar que o limite inferior no merge

01:58:09.600 --> 01:58:12.090
sort também será ômega de n log n.

01:58:12.090 --> 01:58:14.640
Como tal, podemos descrevê-lo em termos de nossa notação theta,

01:58:14.640 --> 01:58:18.030
dizendo que merge sort é, de fato, em theta de n log n.

01:58:18.030 --> 01:58:21.780
Então, de um modo geral, provavelmente é melhor usar algo como merge sort

01:58:21.780 --> 01:58:24.030
ou algum outro algoritmo que seja n log n.

01:58:24.030 --> 01:58:27.660
Na prática, a maioria dos programadores não está implementando esses algoritmos de classificação

01:58:27.660 --> 01:58:28.200
eles mesmos.

01:58:28.200 --> 01:58:30.390
As probabilidades são, eles estão usando uma biblioteca da prateleira

01:58:30.390 --> 01:58:34.200
que eles próprios tomaram a decisão sobre qual desses algoritmos fazer.

01:58:34.200 --> 01:58:37.140
Mas de um modo geral, e estamos vendo isso pela primeira vez,

01:58:37.140 --> 01:58:41.430
se você quiser melhorar o tempo, como usar menos tempo, escrever código mais rápido,

01:58:41.430 --> 01:58:42.750
você tem que pagar um preço.

01:58:42.750 --> 01:58:45.120
E esse pode ser o seu tempo humano, apenas leva você

01:58:45.120 --> 01:58:47.400
mais tempo para codificar algo mais sofisticado,

01:58:47.400 --> 01:58:49.080
mais difícil de implementar.

01:58:49.080 --> 01:58:51.840
Ou você precisa gastar algo como espaço.

01:58:51.840 --> 01:58:54.060
E como essas prateleiras sugerem, isso também é

01:58:54.060 --> 01:58:55.740
um dos principais detalhes do merge sort.

01:58:55.740 --> 01:58:58.500
Você não pode simplesmente ter os elementos trocando de lugar.

01:58:58.500 --> 01:59:02.520
Você precisa de pelo menos uma matriz auxiliar, para que, ao fazer a mesclagem,

01:59:02.520 --> 01:59:03.960
você tem um lugar para colocá-los.

01:59:03.960 --> 01:59:05.988
E isso é excessivo, essa quantidade de memória.

01:59:05.988 --> 01:59:09.030
Eu poderia simplesmente ir e voltar entre a prateleira de cima e a prateleira de baixo.

01:59:09.030 --> 01:59:11.113
Mas é um pouco mais interessante ir de cima para baixo.

01:59:11.113 --> 01:59:12.870
Mas você precisa de mais espaço.

01:59:12.870 --> 01:59:15.605
Antigamente, décadas atrás, o espaço era muito caro.

01:59:15.605 --> 01:59:16.480
E então você sabe o quê?

01:59:16.480 --> 01:59:19.450
Poderia ter sido melhor não usar o merge sort, use o bubble sort

01:59:19.450 --> 01:59:23.230
ou classificação de seleção mesmo, ou algum outro algoritmo completamente.

01:59:23.230 --> 01:59:25.300
Hoje em dia, o espaço é relativamente barato.

01:59:25.300 --> 01:59:27.160
E, portanto, essas são compensações mais aceitáveis.

01:59:27.160 --> 01:59:29.650
Mas depende totalmente da aplicação.

01:59:29.650 --> 01:59:32.950
A última coisa que pensamos em fazer é mostrar uma comparação real

01:59:32.950 --> 01:59:34.450
de alguns desses algoritmos de ordenação.

01:59:34.450 --> 01:59:35.800
Tem cerca de 60 segundos de duração.

01:59:35.800 --> 01:59:39.790
E irá comparar para você, classificação de seleção, classificação de bolha,

01:59:39.790 --> 01:59:44.350
e mesclar classificação em paralelo simultaneamente com alguma classificação divertida

01:59:44.350 --> 01:59:46.570
música, mostrando a você o que realmente

01:59:46.570 --> 01:59:52.750
significa ser um O de n ao quadrado, ou melhor ainda, grande O de n log n.

01:59:52.750 --> 01:59:54.850
Seleção no topo.

01:59:54.850 --> 01:59:58.050
Bolha no fundo.

01:59:58.050 --> 01:59:59.400
Junte no meio.

01:59:59.400 --> 02:00:01.885
[MÚSICA, TOCANDO]

02:00:53.660 --> 02:00:55.700
Tudo bem, é isso para CS50.

02:00:55.700 --> 02:00:57.910
Nos vemos na próxima vez.